<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hx&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/32690cfd58b9093251b720ee371b49ad</icon>
  <subtitle>aha</subtitle>
  <link href="https://huangxinhere.github.io/atom.xml" rel="self"/>
  
  <link href="https://huangxinhere.github.io/"/>
  <updated>2024-03-13T08:16:02.501Z</updated>
  <id>https://huangxinhere.github.io/</id>
  
  <author>
    <name>(●ˇ∀ˇ●)</name>
    <email>1159390360@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity-UI（2）</title>
    <link href="https://huangxinhere.github.io/2024/03/13/2024313-Unity-UI%EF%BC%882%EF%BC%89/"/>
    <id>https://huangxinhere.github.io/2024/03/13/2024313-Unity-UI%EF%BC%882%EF%BC%89/</id>
    <published>2024-03-12T16:00:00.000Z</published>
    <updated>2024-03-13T08:16:02.501Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>图集的使用，降低dc的实践（尝试提高性能</p></li><li><p>rectTransform的scale具体原理是什么，如何做到缩放但不改变节点。</p></li><li><p>解决图片tile模式的警告问题</p></li><li><p>把实习的笔记补充</p></li><li><p>画布渲染次序解决：一个按照逻辑归类好的画布，对另一个画布产生了三明治影响：夹着另一个画布。解决办法是在前面的物体添加canvas组件作为了子canvas，能够改变渲染顺序。</p></li><li><p>画布点击事件过滤</p></li><li><p>协程频繁触发时及时销毁，第一个方法不可用，为啥？stop后coro不为空，为什么</p></li></ul>]]></content>
    
    
    <summary type="html">UI的应用</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity-性能优化</title>
    <link href="https://huangxinhere.github.io/2023/09/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://huangxinhere.github.io/2023/09/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2023-09-13T16:00:00.000Z</published>
    <updated>2023-10-13T01:05:38.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建物体"><a href="#创建物体" class="headerlink" title="创建物体"></a>创建物体</h1><h2 id="new-GameObject"><a href="#new-GameObject" class="headerlink" title="new GameObject()"></a>new GameObject()</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject <span class="built_in">object</span>=<span class="keyword">new</span> GameObject(“物体名”);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建物体，物体名为New Game Object，位置为（0,0,0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建物体，物体名为设定的name，位置为（0,0,0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建物体，物体名为设定的name且添加指定组件，位置为（0,0,0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">string</span> name, <span class="keyword">params</span> Type[] components</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="Object-Instantiate-prefab"><a href="#Object-Instantiate-prefab" class="headerlink" title="Object.Instantiate(prefab);"></a>Object.Instantiate(prefab);</h2><p>利用prefab来创建。</p><p>常用于创建指定物体，可将物体提前预设好，根据情景应用快速创建所需的物体。</p><h2 id="CreatePrimitive"><a href="#CreatePrimitive" class="headerlink" title="CreatePrimitive"></a>CreatePrimitive</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject.CreatePrimitive(PrimitiveType.Cube);</span><br></pre></td></tr></table></figure><p>此方法可创建系统预设的几种常用简单三维模型；</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p><a href="https://blog.uwa4d.com/archives/allinone.html">Unity性能优化大合集，All In One !（更新至8.18） - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com)</a></p><ul><li><strong>内存</strong>问题（GC、频繁申请与释放）；</li><li><strong>IO</strong>（资源加载、频繁读写文件，网络包发送频率过大，频繁读取数据库）；</li><li><strong>逻辑</strong>问题（大量遍历循环、无意义的Tick、过多的锁、高频率Log）；</li><li><strong>AI</strong>（寻路耗时）；</li><li><strong>物理</strong>问题（复杂模拟、碰撞检测）；</li><li><strong>语言</strong>特性等；</li><li>客户端还有各种复杂的<strong>渲染</strong>问题（Draw Call太多，半透明，动态阴影）</li></ul><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p><a href="https://blog.uwa4d.com/archives/optimzation_cpu.html">性能优化，永无止境—CPU篇 - UWA问答 | 博客 | 游戏及VR应用性能优化记录分享 | 侑虎科技 (uwa4d.com)</a></p><p>就目前的Unity移动游戏而言，CPU方面的性能开销主要可归结为两大类：<strong>引擎模块性能开销和自身代码性能开销</strong>。</p><p>其中，引擎模块中又可细致划分为渲染模块、动画模块、物理模块、UI模块、粒子系统、加载模块和GC调用等等。</p><p>通过大量的性能测评数据，我们发现<strong>渲染模块、UI模块和加载模块</strong>，往往占据了游戏CPU性能开销的Top3。</p><p>游戏类型的不同、设计的不同，其他模块仍然会有较大的CPU占用。比如，ARPG游戏中的动画系统和物理系统，音乐休闲类游戏中的音频系统和粒子系统等。</p><h2 id="渲染模块【引擎】"><a href="#渲染模块【引擎】" class="headerlink" title="渲染模块【引擎】"></a>渲染模块【引擎】</h2><p>渲染模块可以说是任何游戏中<strong>最为消耗CPU性能的引擎模块</strong>，因为几乎所有的游戏都离不开场景、物体和特效的渲染。对于渲染模块的优化，主要从以下两个方面入手：</p><h3 id="降低DrawCall"><a href="#降低DrawCall" class="headerlink" title="降低DrawCall"></a>降低DrawCall</h3><p>Draw Call是渲染模块优化方面的重中之重，一般来说，Draw Call越高，则渲染模块的CPU开销越大。</p><p>降低Draw Call的方法则主要是<strong>减少所渲染物体的材质种类，并通过Draw Call Batching来减少其数量</strong>。Unity文档对于Draw Call Batching的原理和注意事项有非常详细的讲解，感兴趣的朋友可以直接查看 <a href="http://docs.unity3d.com/Manual/DrawCallBatching.html">Unity官方文档</a>。</p><p>但是需要注意的是，游戏性能并非Draw Call越小越好。这是因为，**<u>决定渲染模块性能的除了Draw Call之外，还有用于传输渲染数据的总线带宽</u>**。当我们使用Draw Call Batching将同种材质的网格模型拼合在一起时，可能会造成同一时间需要传输的数据（Texture、VB/IB等）大大增加，以至于造成带宽“堵塞”，在资源无法及时传输过去的情况下，GPU只能等待，从而反倒降低了游戏的运行帧率。</p><p>Draw Call和总线带宽是天平的两端，我们需要做的是尽可能维持天平的平衡，任何一边过高或过低，对性能来说都是无益的。</p><h3 id="简化资源"><a href="#简化资源" class="headerlink" title="简化资源"></a>简化资源</h3><p>在大量的移动游戏中，其渲染资源其实是“过量”的，过量的网格资源、不合规的纹理资源等等。</p><h2 id="UI模块【引擎】"><a href="#UI模块【引擎】" class="headerlink" title="UI模块【引擎】"></a>UI模块【引擎】</h2><p>一个性能优异的UI模块可以将游戏的用户体验再抬高一个档次。在目前国内的大量项目中，NGUI作为UI解决方案的占比仍然非常高。</p><p>在NGUI的优化方面，UIPanel.LateUpdate为性能优化的重中之重，它是NGUI中CPU开销最大的函数，没有之一。</p><p>UI模块制作的难点并不在于其表现上，因为UI界面的表现力是由设计师来决定的，但两套表现完全一致的UI系统，<u>其底层的性能开销</u>则可能千差万别。如何让UI系统使用尽可能小的CPU开销来达到设计师所设计的表现力，则足以考验每一位UI开发人员的制作功底。</p><blockquote><p>具体分析和优化详见Unity-UI。</p></blockquote><h2 id="加载模块【引擎】"><a href="#加载模块【引擎】" class="headerlink" title="加载模块【引擎】"></a>加载模块【引擎】</h2><p>加载模块同样也是任何游戏项目中所不可缺少的组成成分。与之前两个模块不同的是，加载模块的性能开销比较集中，<strong>主要出现于场景切换处</strong>，且CPU占用峰值均较高。</p><p>这里，我们先来说说场景切换时，其性能开销的主要体现形式。对于目前的Unity版本而言，场景切换时的主要性能开销主要体现在两个方面，<u>前一场景的场景卸载和下一场景的场景加载</u>。下面，我们就具体来说说这两个方面的性能瓶颈：</p><h3 id="场景卸载"><a href="#场景卸载" class="headerlink" title="场景卸载"></a>场景卸载</h3><p>对于Unity引擎而言，场景卸载一般是由引擎自动完成的，即当我们调用类似Application.LoadLevel的API时，引擎即会开始对上一场景进行处理，其性能开销主要被以下几个部分占据：</p><blockquote><p><strong>Destroy</strong></p><p>引擎在切换场景时会收集未标识成“DontDestoryOnLoad”的GameObject及其Component，然后进行Destroy。</p><p>同时，代码中的OnDestory被触发执行，这里的性能开销主要取决于OnDestroy回调函数中的代码逻辑。</p></blockquote><blockquote><p><strong>Resources.UnloadUnusedAssets</strong></p><p>一般情况下，场景切换过程中，该API会被调用两次，一次为引擎在切换场景时自动调用，另一次则为用户手动调用（一般出现在场景加载后，用户调用它来确保上一场景的资源被卸载干净）。</p><p>在我们测评过的大量项目中，该API的CPU开销主要集中在500ms~3000ms之间。其耗时开销主要取决于场景中Asset和Object的数量，数量越多，则耗时越慢。</p></blockquote><h3 id="场景加载"><a href="#场景加载" class="headerlink" title="场景加载"></a>场景加载</h3><blockquote><p><strong>资源加载</strong></p><p>资源加载几乎占据了整个加载过程的90%时间以上，其加载效率主要取决于资源的<strong>加载方式</strong>（Resource.Load或AssetBundle加载）、<strong>加载量</strong>（纹理、网格、材质等资源数据的大小）和<strong>资源格式</strong>（纹理格式、音频格式等）等等。</p><p>不同的加载方式、不同的资源格式，其加载效率可谓千差万别。</p></blockquote><blockquote><p><strong>Instantiate实例化</strong></p><p>在场景加载过程中，往往伴随着大量的Instantiate实例化操作，比如UI界面实例化、角色/怪物实例化、场景建筑实例化等等。</p><p>在Instantiate实例化时，<u>引擎底层会查看其相关的资源是否已经被加载，如果没有，则会先加载其相关资源，再进行实例化</u>，这其实是大家遇到的大多数“Instantiate耗时问题”的根本原因，这也是为什么我们在之前的AssetBundle文章中所提倡的资源依赖关系打包并进行预加载，从而来缓解Instantiate实例化时的压力。</p></blockquote><h2 id="代码效率"><a href="#代码效率" class="headerlink" title="代码效率"></a>代码效率</h2><p>逻辑代码在一个较为复杂的游戏项目中往往占据较大的性能开销。这种情况在MOBA、ARPG、MMORPG等游戏类型中非常常见。</p><p>在项目优化过程中，我们经常会想知道，到底是哪些函数占据了大量的CPU开销。同时，绝大多数的项目中其性能开销都遵循着“二八原则”，即80%的性能开销都集中在20%的函数上。</p><h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><p>在渲染上，GPU、CPU两者的性能瓶颈往往是CPU；GPU的性能瓶颈往往是像素点填充率（Overdraw导致）。</p><h2 id="OverDraw"><a href="#OverDraw" class="headerlink" title="OverDraw"></a>OverDraw</h2><p><a href="https://blog.csdn.net/qq_33808037/article/details/129427267?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-129427267-blog-129636294.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-129427267-blog-129636294.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=1">Unity性能优化 - Overdraw篇_unity 查看overdraw_后知后觉℘的博客-CSDN博客</a></p><blockquote><p>Overdraw是指屏幕上的某个像素在<strong>同一帧的时间</strong>内被<strong>绘制了多次</strong>。当多个UI元素重叠时，每个像素都需要被多次绘制。这种绘制超出了渲染所需的最小像素数，因此被称为Overdraw。</p></blockquote><h3 id="导致overdraw的原因-以及对应解决方法"><a href="#导致overdraw的原因-以及对应解决方法" class="headerlink" title="导致overdraw的原因 以及对应解决方法"></a>导致overdraw的原因 以及对应解决方法</h3><ul><li><p>UI元素：UI元素叠加在一起。</p></li><li><p>半透明：</p><blockquote><p>控制透明度：规定透明度的使用和控制；</p></blockquote></li><li><p>Shader：某些shader可能需要绘制多次。</p><blockquote><p>优化Shader：规定Shader的使用和优化，以避免过多的Overdraw。（？</p></blockquote></li><li><p>模型：模型的面数很高。</p><blockquote><p>合并网格：规定是否需要合并多个网格为一个大网格</p></blockquote></li><li><p>粒子系统：粒子的数量过多或者设置不当。</p></li><li><p>地形系统：地形细节设置过高。</p></li><li><p>镜头后处理：在镜头后处理中使用了过多的效果（例如bloom、全屏模糊等）。</p></li><li><p>其他高耗性能的特效：例如实时阴影、全局光照等特效。</p><blockquote><p>合理使用特效</p></blockquote></li></ul><h3 id="可以制定哪些规范控制Overdraw"><a href="#可以制定哪些规范控制Overdraw" class="headerlink" title="可以制定哪些规范控制Overdraw"></a>可以制定哪些规范控制Overdraw</h3><ul><li><p>批处理数量：规定每个批次的三角形数量的上限，以控制批处理的数量和渲染次数。（？</p></li><li><p>合并材质：规定是否需要将多个物体使用相同材质的合并为一个批次，以减少Overdraw。（？</p></li><li><p>剔除不可见面：规定是否需要使用背面剔除（Backface Culling）技术来剔除不可见的面，以减少Overdraw。</p></li></ul><h3 id="针对不同元素的一些具体优化方法"><a href="#针对不同元素的一些具体优化方法" class="headerlink" title="针对不同元素的一些具体优化方法"></a>针对不同元素的一些具体优化方法</h3><h4 id="UI元素"><a href="#UI元素" class="headerlink" title="UI元素"></a>UI元素</h4><p>【合并】</p><ol><li><p>合并UI元素：将多个UI元素合并成一个较大的UI元素，可以减少绘制次数，从而减少overdraw。可以使用Unity的Canvas Group组件来将多个UI元素合并到同一个Canvas上。（具体是如何合并的？合并成什么效果？</p><blockquote><p><strong>Canvas Group</strong>：控制画布的显隐比setActive效率更好。<a href="https://zhuanlan.zhihu.com/p/264833204">Unity UGUI显隐效率对比 - 知乎 (zhihu.com)</a></p></blockquote></li><li><p>使用UI组件的优化选项：Unity的UI组件中提供了一些优化选项，如使用静态batching、动态batching、合并材质等，可以减少overdraw。</p></li></ol><p>【减少】</p><ol><li>减少透明度：如果UI元素具有透明度，可以尝试减少透明度或使用不透明的材质来减少overdraw。</li><li>减少UI元素数量：尽可能减少UI元素的数量，只使用必要的UI元素。</li><li>调整UI元素的层级：将UI元素的层级设置得尽可能低。</li></ol><p>【避免】</p><ol><li>使用UI画布裁剪（？：UI画布裁剪可以避免不必要的绘制。</li><li>使用遮罩：使用遮罩来隐藏不必要的部分，减少绘制次数。</li></ol><p>总之，优化UI元素overdraw的关键是<strong>尽可能减少绘制次数</strong>，<strong>合并绘制操作</strong>以及<strong>避免不必要的绘制</strong>。</p><h4 id="Shader"><a href="#Shader" class="headerlink" title="Shader"></a>Shader</h4><p>Shader的overdraw指的是在屏幕上绘制过程中，同一区域内<strong>多次执行相同的着色器</strong>代码造成的性能浪费。</p><p>【合并】</p><ol><li>合并Mesh：将多个Mesh合并成一个大的Mesh，可以减少绘制次数和Shader overdraw。</li></ol><p>【减少】</p><ol><li><p>减少透明度：如果物体具有透明度，可以尝试减少透明度或使用不透明的材质来减少overdraw。</p></li><li><p>调整渲染顺序：将最先绘制的物体放在最前面，可以减少overdraw。</p><blockquote><p>不透明的物体是从前往后，透明的物体是从后往前。</p></blockquote></li><li><p>使用Substance材质：Substance材质可以动态生成纹理，可以减少overdraw。（？？</p></li><li><p>使用GPU instancing：GPU instancing可以复制和绘制一个Mesh的多个实例，可以减少绘制次数和Shader overdraw。（？？</p></li><li><p>调整渲染距离：在远距离处，可以使用简单的材质代替复杂的材质，减少Shader overdraw。（？？</p></li></ol><p>【避免】</p><ol><li>使用级联遮挡剔除（Occlusion Culling）：使用级联遮挡剔除可以在绘制之前剔除不可见的物体，减少overdraw。</li></ol><p>总之，优化Shader overdraw的关键是尽可能<strong>减少着色器执行次数</strong>，减少绘制次数，<strong>合并绘制操作</strong>以及<strong>避免不必要的绘制</strong>。</p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><h4 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h4><h4 id="地形系统"><a href="#地形系统" class="headerlink" title="地形系统"></a>地形系统</h4><h4 id="镜头后处理"><a href="#镜头后处理" class="headerlink" title="镜头后处理"></a>镜头后处理</h4><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="内存占用组成"><a href="#内存占用组成" class="headerlink" title="内存占用组成"></a>内存占用组成</h2><ol><li>Unity（基本所有的Unity的使用的内存，Native）</li><li>Mono（C#代码，可以被GC回收）</li><li>GfxDriver（显卡驱动，渲染时的纹理，渲染目标，shader，Mesh（顶点、法线等）等）</li><li>FMOD（声音资源）</li><li>Profiler（自身，把采样的数据的缓存下来）</li></ol><p>就目前基于Unity引擎开发的移动游戏和移动VR游戏而言，内存的开销无外乎以下三大部分：<strong>1.资源内存占用；2.引擎模块自身内存占用；3.托管堆内存占用。</strong></p><h2 id="资源占用"><a href="#资源占用" class="headerlink" title="资源占用"></a>资源占用</h2><p><a href="https://zhuanlan.zhihu.com/p/21913770">Unity内存优化总结（上） - 知乎 (zhihu.com)</a></p><p>在一个较为复杂的大中型项目中，资源的内存占用往往占据了总体内存的70%以上。因此，资源使用是否恰当直接决定了项目的内存占用情况。</p><p>一般来说，一款游戏项目的资源主要可分为如下几种：</p><ul><li>纹理（Texture）</li><li>网格（Mesh）</li><li>动画片段（AnimationClip）</li><li>音频片段（AudioClip）</li><li>材质（Material）</li><li>着色器（Shader）</li><li>字体资源（Font）</li><li>文本资源（Text Asset）等等。</li></ul><p>其中，<strong>纹理、网格、动画片段和音频片段</strong>则是最容易造成较大内存开销的资源。</p><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>纹理资源可以说是几乎所有游戏项目中占据最大内存开销的资源。</p><p>一个6万面片的场景，网格资源最大才不过10MB，但一个2048x2048的纹理，可能直接就达到16MB。因此，项目中纹理资源的使用是否得当会极大地影响项目的内存占用。</p><h4 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h4><p>纹理格式是研发团队<u>最需要关注的纹理属性</u>。因为它不仅影响着<strong>纹理的内存占用</strong>，同时还决定了<strong>纹理的加载效率</strong>。</p><blockquote><p>详情见unity-图形-纹理。</p></blockquote><h4 id="纹理尺寸"><a href="#纹理尺寸" class="headerlink" title="纹理尺寸"></a>纹理尺寸</h4><p>一般来说，纹理尺寸越大，则内存占用越大。所以，尽可能降低纹理尺寸，如果512x512的纹理对于显示效果已经够用，那么就不要使用1024x1024的纹理，因为后者的内存占用是前者的四倍。</p><h4 id="Mipmap功能"><a href="#Mipmap功能" class="headerlink" title="Mipmap功能"></a>Mipmap功能</h4><p>Mipmap旨在<u>有效降低渲染带宽的压力</u>，提升游戏的渲染效率。但是，开启Mipmap会将纹理内存提升1.33倍。</p><p>对于具有较大纵深感的3D游戏来说，3D场景模型和角色我们一般是建议开启Mipmap功能的，</p><p>但经常会发现部分UI纹理也开启了Mipmap功能。这其实是没有必要的，绝大多数UI均是渲染在屏幕最上层，开启Mipmap并不会提升渲染效率，反倒会增加无谓的内存占用。</p><h4 id="Read-amp-Write"><a href="#Read-amp-Write" class="headerlink" title="Read &amp; Write"></a>Read &amp; Write</h4><p><img src="https://pic3.zhimg.com/80/246edb7d264e11da994f92f245bed35e_720w.webp" alt="img"></p><p> 开启该选项将会使纹理内存增大一倍。</p><h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>网格资源在<u>较为复杂的游戏</u>中，往往占据较高的内存。对于网格资源来说，它在使用时应该注意哪些方面呢？</p><h4 id="Normal、Color和Tangent"><a href="#Normal、Color和Tangent" class="headerlink" title="Normal、Color和Tangent"></a>Normal、Color和Tangent</h4><p>在深度优化过的大量项目中，Mesh资源的数据中经常会含有大量的Color数据、Normal数据和Tangent数据。这些数据的存在将大幅度增加Mesh资源的文件体积和内存占用。其中，Color数据和Normal数据主要为3DMax、Maya等建模软件导出时设置所生成，而Tangent一般为导入引擎时生成。</p><p>更为麻烦的是，如果项目对Mesh进行Draw Call Batching操作的话，那么将很有可能进一步增大总体内存的占用。比如，100个Mesh进行拼合，其中99个Mesh均没有Color、Tangent等属性，剩下一个则包含有Color、Normal和Tangent属性，那么Mesh拼合后，CombinedMesh中将为每个Mesh来添加上此三个顶点属性，进而造成很大的内存开销.</p><h2 id="引擎模块自身占用"><a href="#引擎模块自身占用" class="headerlink" title="引擎模块自身占用"></a><strong>引擎模块自身占用</strong></h2><p>引擎自身中存在内存开销的部分纷繁复杂，可以说是由巨量的“微小”内存所累积起来的，比如GameObject及其各种Component（最大量的Component应该算是Transform了）、ParticleSystem、MonoScript以及各种各样的模块Manager（SceneManager、CanvasManager、PersistentManager等)…</p><p>一般情况下，上面所指出的引擎各组成部分的内存开销均比较小，真正占据较大内存开销的是这两处：<strong>WebStream</strong> 和 <strong>SerializedFile</strong>。其绝大部分的内存分配则是由AssetBundle加载资源所致。</p><p>简单言之，当您使用new WWW或CreateFromMemory来加载AssetBundle时，Unity引擎会<strong>加载原始数据到内存中并对其进行解压</strong>，而WebStream的大小则是AssetBundle原始文件大小 + 解压后的数据大小 + DecompressionBuffer(0.5MB)。</p><p>因此，当项目中存在通过new WWW加载多个AssetBundle文件，且AssetBundle又无法及时释放时，WebStream的内存可能会很大，这是研发团队需要时刻关注的。</p><h2 id="托管堆内存占用"><a href="#托管堆内存占用" class="headerlink" title="托管堆内存占用"></a>托管堆内存占用</h2><p>对于目前绝大多数基于Unity引擎开发的项目而言，其托管堆内存是由Mono分配和管理的。“托管” 的本意是<strong>Mono</strong>可以<u>自动地改变堆的大小来适应你所需要的内存，并且适时地调用垃圾回收</u>（Garbage Collection）操作来释放已经不需要的内存，从而降低开发人员在代码内存管理方面的门槛。</p><p>但是这并不意味着研发团队可以在代码中肆无忌惮地开辟托管堆内存，因为目前Unity所使用的Mono版本存在一个很严重的问题，即：<strong>Mono的堆内存一旦分配，就不会返还给系统。</strong>这意味着Mono的堆内存是只升不降的。</p><p>举个例子，项目运行时，在场景A中开辟了60MB的托管堆内存，而到下一场景B时，只需要使用20MB的托管堆内存，那么Mono中将会存在40MB空闲的堆内存，且不会返还给系统。这是我们非常不愿意看到的现象，因为对于游戏（特别是移动游戏）来说，内存的占用可谓是寸土寸金的，让Mono毫无必要地锁住大量的内存，是一件非常浪费的事情。</p><ul><li>用户不必要的堆内存分配主要来自于以下几个方面：</li></ul><ol><li>高频率地 New Class/Container/Array等。切记不要在Update、FixUpdate或较高调用频率的函数中开辟堆内存，这会对你的项目内存和性能均造成非常大的伤害。</li><li>Log输出。仅保留关键Log，以避免不必要的堆内存分配。</li><li>UIPanel.LateUpdate。这是NGUI中CPU和堆内存开销最大的函数。它本身只是一个函数，但NGUI的大量使用使它逐渐成为了一个不可忽视规则。该函数的堆内存分配和自身CPU开销，其根源上是一致的，即是由UI网格的重建造成。</li><li><strong>字符串</strong>拼接，减少频繁扩容；尽量用结构体取代类（值类型不占用堆，不需要GC）。</li></ol><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p><strong>内存泄漏</strong>：<u>向系统申请分配内存</u>进行使用（new/malloc），然后系统在堆内存中给这个对象申请一块内存空间，但当我们<u>使用完了却没有归系统</u>（delete），导致这个不使用的对象一直占据内存单元，造成系统将不能再把它分配给需要的程序。 </p><p>一次内存泄漏的危害可以忽略不计，但是内存泄漏堆积则后果很严重，无论多少内存，迟早会被占完，造成内存泄漏。</p><p>一般来说，<strong>推荐的判断内存是否泄漏的方法</strong>如下：</p><ul><li>检查<strong>资源的使用情况</strong>，特别是纹理、网格等资源的使用</li></ul><p><strong>资源泄漏</strong>是内存泄露的主要表现形式，其具体原因是用户对加载后的资源进行了储存（比如放到Container中），但在场景切换时并没有将其Remove或Clear，从而无论是引擎本身还是手动调用Resources.UnloadUnusedAssets等相关API均无法对其进行卸载，进而造成了资源泄露。</p><blockquote><p><u>同种场景或同一场景</u>的资源使用比较：</p><p>比较<strong>不同时刻</strong>同一场景的资源信息，可以快速帮你找到其资源使用的差异情况；</p><p><u>不同类型</u>场景进行比较：</p><p>通过比较两种不同类型的场景，你可以直接查看比较结果中的“<strong>共同资源</strong>”，并判断其是否确实为预先设定好的常驻资源。</p></blockquote><ul><li>通过Profiler来检测WebStream或SerializedFile的使用情况</li></ul><p><strong>AssetBundle的管理不当</strong>也会造成一定的内存泄露，即上一场景中使用的AssetBundle在场景切换时没有被卸载掉，而被带入到了下一场场景中。</p><h2 id="无效的Mono堆内存开销"><a href="#无效的Mono堆内存开销" class="headerlink" title="无效的Mono堆内存开销"></a>无效的Mono堆内存开销</h2><p>目前，Unity所使用的Mono版本中存在一个较大的问题，即内存一旦分配，则不会再返回给系统。这就衍生出另外一个问题—— <strong>无效的Mono堆内存</strong>。它是Mono所分配的堆内存，但却没有被真正利用上，因此称之为“无效”。</p><ul><li><strong>避免一次性堆内存的过大分配</strong>。Mono的堆内存也是“按需”逐步进行分配的。但如果一次性开辟过大堆内存，比如New一个较大Container、加载一个过大配置文件等，则势必会造成Mono的堆内存直接冲高，所以研发团队对堆内存的分配需要时刻注意</li><li><strong>避免不必要的堆内存开销</strong>。</li></ul><h2 id="资源冗余"><a href="#资源冗余" class="headerlink" title="资源冗余"></a>资源冗余</h2><p>所谓“资源冗余”，是指在某一时刻内存中存在两份甚至多份同样的资源。导致这种情况的出现主要有两种原因：</p><ul><li>AssetBundle打包机制出现问题</li></ul><p><strong>同一份资源被打入到多份AssetBundle文件中</strong>。</p><p>举个例子，同一张纹理被不同的NPC所使用，同时每个NPC被制作成独立的AssetBundle文件，那么在没有针对纹理进行依赖打包的前提下，就会出现该张纹理出现在不同的NPC AssetBundle文件中。</p><p>当这些AssetBundle先后被加载到内存后，内存中即会出现纹理资源冗余的情况。</p><blockquote><p>Unity-热更新-AB打包也有提到这个问题。</p></blockquote><ul><li>资源的实例化所致</li></ul><p>在Unity引擎中，当我们修改了一些<strong>特定GameObject的资源属性</strong>时，引擎会为该GameObject自动实例化一份资源供其使用，比如Material、Mesh等。</p><p>以Material为例，我们在研发时经常会有这样的做法：在角色被攻击时，改变其Material中的属性来得到特定的受击效果。这种做法则会导致引擎为特定的GameObject重新实例化一个Material，后缀会加上（instance）字样。</p><p>其本身没有特别大的问题，但是当有改变Material属性需求的GameObject越来越多时（比如ARPG、MMORPG、MOBA等游戏类型），其内存中的冗余数量则会大量增长。虽然Material的内存占用不大，但是过多的冗余资源却为Resources.UnloadUnusedAssets API的调用效率增加了相当大的压力。</p><h1 id="DrawCall【渲染】"><a href="#DrawCall【渲染】" class="headerlink" title="DrawCall【渲染】"></a>DrawCall【渲染】</h1><p>CPU准备好需要绘制的元素，对底层图形程序接口进行调用的过程。</p><p>也可以理解为：CPU向GPU发布一条渲染指令，就是一次DrawCall的过程。简称DC；</p><h2 id="降低DrawCall-1"><a href="#降低DrawCall-1" class="headerlink" title="降低DrawCall"></a>降低DrawCall</h2><ol><li>动态合批</li><li>静态合批</li><li>降低shader的等级特性</li><li>场景优化策略——遮挡技术。</li><li>rectMask2D替代Mask</li></ol><h3 id="静态合批"><a href="#静态合批" class="headerlink" title="静态合批"></a>静态合批</h3><p>将static的静态物体（永远不会移动、旋转和缩放） ，如果相同材质球，面数在一定范围之内。unity会自动合并成一个batch送往GPU处理。</p><ul><li><p>把要进行静态批处理的GameObject在Inspector面板右上角的Static勾选(实际上只需要勾选Batching Static即可)</p></li><li><p>优点：因为只需要进行一次，所以性能会比动态批处理要好。</p></li><li><p>缺点：</p><p><strong>使用静态合批需要额外的内存开销来存储合并后的几何数据。</strong></p><p>因为需要额外维护多一份数据，所以包体会变大，占用的内存也会变多（不能有超级大量的相同模型（如：森林里的树））</p><p><strong>无法移动</strong></p><p>进行了静态批处理之后的GameObject不能在游戏运行时改变位置或者是跟渲染有关的属性；</p><p>并且因为把所有要静态批处理的GameObject都合并成一个大网格保存起来，所以这实际上相当于即使是同一个GameObject，也需要复制一份网格数据一起保存在这个大网格的顶点数据里面去，这样就导致了占用的内存变多了。</p><p>​    静态合批就是<u>多渲染一套合并后的网格</u> ，提前存在内存里，内存当然就大了。</p></li><li><p><strong>原理</strong></p></li></ul><p>​    在开始阶段把需要静态批处理的GameObject进行一次网格合并操作，然后把这个合并之后的大网格保存起来，<u>后续都是用这个网格而不需要再进行合并</u>。</p><p>​    在预处理阶段，把一些材质相同的模型的顶点统一变换到世界空间坐标下，并且新构建一个大的VB把数据保存下来，在绘制时，就会把这个大的VB提交上去，<strong>只需要设置一次渲染状态</strong>，<strong>再进行多次drawcall绘画出每个子模型</strong>。 <u>所以Static Batching是不会减少drawcall的，但由于只修改了一次渲染状态依然可以减少CPU的消耗。</u>而且在渲染前，也可以进行视锥体剔除，减少顶点着色器对不可见的顶点的处理次数，提交GPU的效率。</p><h3 id="动态合批"><a href="#动态合批" class="headerlink" title="动态合批"></a>动态合批</h3><p>如果动态物体<u>共用着相同的材质</u>，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。</p><ul><li><p>优点：不用自己做任何事情，Unity会在游戏中自动进行动态批处理，只要满足下述条件。 （？）</p><blockquote><ol><li>顶点属性要小于900。例如，如果shader中需要使用顶点位置、法线和纹理坐标这三个顶点属性，那么要想让模型能够被动态批处理，它的顶点数目不能超过300。因此，优化策略就是<u>shader的优化，少使用顶点属性，或者模型顶点数要尽可能少。</u>（这个是《UnityShader入门精要》这本书上说到的，同时书上也说了不一定是900，可能不同版本的Unity会有所区别，这个可以自己在Unity中去手动验证得出）</li><li>多Pass的shader会中断批处理。</li><li>使用LightingMap的物体需要小心处理。为了让这些物体可以被动态批处理，需要保证它们指向LightingMap中的同一位置。</li></ol></blockquote></li><li><p>原理：</p><p>​    Unity会检测哪些GameObject使用了同一个共享材质，然后去合并这些使用了同一个共享材质的网格顶点数据，形成一个新的大网格，然后传给显存，直接渲染这个大网格就相当于渲染了所有的被合并的小网格，而这<strong>只需要一次DrawCall</strong>。</p><p>​    在每一帧运行时，计算相同材质的模型，把他合并批次进行渲染。动态合批<strong>只需要设置一次渲染状态，且能减少drawcall次数</strong>。</p></li></ul><h3 id="UI合批"><a href="#UI合批" class="headerlink" title="UI合批"></a>UI合批</h3><p>详情见Unity-UI。</p><h3 id="场景性能优化"><a href="#场景性能优化" class="headerlink" title="场景性能优化"></a>场景性能优化</h3><p><a href="https://blog.csdn.net/Z_hongli/article/details/124442236">Unity3D场景性能优化/渲染/卡顿/搭建优化 遮挡剔除/层消距离技术/LOD（多层次细节）_unity 场景太大模型移动有马赛克-CSDN博客</a></p><h4 id="遮挡剔除"><a href="#遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除</h4><p>摄像机<strong>看不到的物体</strong>场景中不会渲染显示。</p><ul><li>将场景中的物体设置成遮挡静态（Occluder Static）；</li><li>做场景烘焙（Window-Rendering-Occlusion Culling-Bake）</li></ul><h4 id="层消隐距离技术"><a href="#层消隐距离技术" class="headerlink" title="层消隐距离技术"></a>层消隐距离技术</h4><p>简单理解：因<strong>距离太远太小</strong>而看不见的物体将其<strong>隐藏</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LayerBlankingDistance</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Distance = <span class="number">10</span>;  <span class="comment">//定义显示距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Layer = <span class="number">9</span>; <span class="comment">//定义被剔除的层级</span></span><br><span class="line">    <span class="comment">//定义大小为32的一维数组，用来储存所有层的剔除信息 </span></span><br><span class="line">    <span class="built_in">float</span>[] distance = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//经过测试 只能够在Start函数中使用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Layer层显示的距离在Distance内 超过这个距离就不会显示</span></span><br><span class="line">        distance[Layer] = Distance;</span><br><span class="line">        <span class="comment">//将数组赋给摄像机的LayerCullDistance</span></span><br><span class="line">        Camera.main.layerCullDistances = distance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LOD技术（多细节层次）"><a href="#LOD技术（多细节层次）" class="headerlink" title="LOD技术（多细节层次）"></a><strong>LOD技术（多细节层次）</strong></h4><p>LOD：Level Of Detail。</p><p>根据摄像机与模型的距离来决定显示哪一个模型，一般距离近的时候显示高精度多细节模型，距离远的时候显示低精度低细节模型，以内存做消耗来优化GPU</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;创建物体&quot;&gt;&lt;a href=&quot;#创建物体&quot; class=&quot;headerlink&quot; title=&quot;创建物体&quot;&gt;&lt;/a&gt;创建物体&lt;/h1&gt;&lt;h2 id=&quot;new-GameObject&quot;&gt;&lt;a href=&quot;#new-GameObject&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity-图形</title>
    <link href="https://huangxinhere.github.io/2023/09/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E5%9B%BE%E5%BD%A2/"/>
    <id>https://huangxinhere.github.io/2023/09/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E5%9B%BE%E5%BD%A2/</id>
    <published>2023-09-12T16:00:00.000Z</published>
    <updated>2023-09-24T12:42:49.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><p><a href="https://docs.unity.cn/cn/2023.2/Manual/Lightmappers.html">光照贴图 - Unity 手册</a></p><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><p>光照贴图过程将预先计算场景中表面的亮度，并将结果存储在称为“光照贴图”的纹理中供以后使用。</p><p><img src="https://docs.unity.cn/cn/2023.2/uploads/GlobalIllumination/Lightmap.png" alt="左：一个简单的光照贴图场景。右：Unity 生成的光照贴图纹理。请注意捕获阴影和光照信息的方式。"></p><p>光照贴图可以包含直射光和间接光。该光照纹理可与颜色（反照率）和浮雕（法线）之类的对象表面信息材质相关联的着色器一起使用。</p><h1 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h1><p><a href="https://docs.unity.cn/cn/2023.2/Manual/texture-compression-formats.html">Texture formats - Unity 手册</a></p><h2 id="纹理格式"><a href="#纹理格式" class="headerlink" title="纹理格式"></a>纹理格式</h2><p>可以在纹理资源导入设置中为其配置纹理压缩格式。当您向项目添加纹理资源时，Unity 编辑器会自动为每个构建目标选择合适的压缩格式；但是，大多数平台都支持多种纹理压缩格式。</p><p>纹理压缩格式会影响<u>加载时间、GPU 帧时间、内存使用、视觉质量、构建大小和压缩时间</u>。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>每像素位数（bpp）</p><p>每像素位数 (bpp) 表示<strong>单个纹理像素所需的存储量</strong>。</p><p>Bpp 值<u>越低的纹理在磁盘和内存中也越小</u>。较低的 bpp 值也意味着 GPU 使用较少的内存带宽来读取纹理像素。GPU 内存带宽通常是帧率的瓶颈，因此纹理压缩有助于避免这一问题。</p><p>纹理资源的<u>视觉质量越高，每像素的位数就越高</u>；因此，这会增大构建大小、加载时间和运行时内存使用。在某种程度上，所有纹理压缩格式都是有损的。未压缩的纹理提供最高的质量，但它们的每像素位数也最高。不同的纹理压缩格式提供不同的折衷。</p></li></ul><p>通常，为了获得最佳运行时性能和磁盘占用空间，对于大多数纹理资源，您应该选择<u>目标设备支持的纹理压缩格式</u>，并且实现<u>所需的视觉质量的最小每像素位数</u>。</p><ul><li><p>选择目标平台和设备支持的格式</p><p>当 Unity 加载的纹理具有设备不支持的压缩格式时，它会将纹理解压缩为该平台的默认未压缩格式，并将<u>未压缩副本与原始压缩纹理一起存储在内存中</u>。这会增加纹理加载时间并使用额外的内存。当 Unity 加载的纹理具有设备支持的压缩格式时，<u>GPU 可以使用该数据而无需任何转换</u>。</p></li></ul><h3 id="不同的纹理格式以及对应质量"><a href="#不同的纹理格式以及对应质量" class="headerlink" title="不同的纹理格式以及对应质量"></a>不同的纹理格式以及对应质量</h3><p><a href="https://zhuanlan.zhihu.com/p/398328765">Unity3D 纹理格式 - 知乎 (zhihu.com)</a></p><table><thead><tr><th align="center"><strong>Texture format</strong></th><th><strong>描述</strong></th><th><strong>通道</strong></th><th align="center"><strong>Quality</strong></th><th><strong>每像素位数</strong></th><th><strong>1024x1024 纹理的大小，以 MB 为单位</strong></th></tr></thead><tbody><tr><td align="center">RGB(A) Compressed BC7</td><td>压缩 RGB 或 RGBA</td><td>RGB 或 RGBA。</td><td align="center">高</td><td>8</td><td>1</td></tr><tr><td align="center">RGBA Crunched DXT5</td><td>Compressed RGBA，采用额外的磁盘上 Crunch 压缩。</td><td>RGBA</td><td align="center">低到中</td><td>可变</td><td>可变</td></tr><tr><td align="center">RGB Compressed DXT1</td><td>压缩 RGB（也称为 BC1）</td><td>RGB</td><td align="center">中</td><td>4</td><td>0.5</td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td></td><td></td></tr><tr><td align="center"></td><td></td><td></td><td align="center"></td><td></td><td></td></tr></tbody></table><h3 id="Crunch压缩"><a href="#Crunch压缩" class="headerlink" title="Crunch压缩"></a>Crunch压缩</h3><p>Crunch 是一种压缩格式，基于 DXT 或 ETC 压缩，通过提供额外的可变比特率压缩。</p><p>当 Unity 加载一个经过 Crunch 压缩的纹理时，它会在 CPU 上将该纹理解压缩为 DXT 或 ETC，然后将 DXT 或 ETC 压缩纹理数据上传至 GPU。</p><p>Crunch 压缩有助于纹理<u>在磁盘上使用尽可能少的空间</u>，但<u>对于运行时内存使用量没有影响</u>。</p><p>Crunch 纹理可能需要很长时间进行压缩，但在<strong>运行时的解压缩速度非常快</strong>。您可以调整 Crunch 压缩的有损程度，以在文件大小和质量之间取得平衡。</p><h3 id="纹理格式设置"><a href="#纹理格式设置" class="headerlink" title="纹理格式设置"></a>纹理格式设置</h3><p><img src="https://docs.unity.cn/cn/2023.2/uploads/Main/PlatformSpecificOverrides.png" alt="特定于平台的覆盖面板"></p><table><thead><tr><th align="left"><strong>属性：</strong></th><th align="left"><strong>功能：</strong></th><th></th></tr></thead><tbody><tr><td align="left"><strong>Max Size</strong></td><td align="left">设置导入的纹理的最大尺寸（以像素为单位）。美术师通常喜欢使用尺寸较大的纹理，但您可以将纹理缩小到合适的尺寸大小。</td><td></td></tr><tr><td align="left"><strong>Resize Algorithm</strong></td><td align="left">当纹理尺寸大于指定的 <strong>Max Size</strong> 时，选择一种算法来缩小纹理尺寸。</td><td></td></tr><tr><td align="left"></td><td align="left"><strong>Mitchell</strong></td><td>使用 Mitchell 算法调整纹理的大小。这是默认的大小调整算法。</td></tr><tr><td align="left"></td><td align="left"><strong>Bilinear</strong></td><td>使用双线性插值来调整纹理的大小。如果小而锐利的细节在图像中很重要，此设置可以<strong>保留比 Mitchell 更多这些细节</strong>。</td></tr><tr><td align="left"><strong>Format</strong></td><td align="left">绕过自动系统来指定用于纹理的内部表示。可用格式的列表取决于平台和纹理类型。有关更多信息，请参阅<a href="https://docs.unity.cn/cn/2023.2/Manual/class-TextureImporterOverride.html">特定于平台的覆盖的纹理格式</a>。  <strong>注意：</strong>即使不覆盖平台，此选项也会显示自动系统选择的格式。此属性仅在覆盖特定平台时可用，而不是作为默认设置。</td><td></td></tr><tr><td align="left"><strong>Compression</strong></td><td align="left">选择<u>纹理的压缩类型</u>。这有助于 Unity 为纹理选择正确的压缩格式。根据平台和压缩格式的可用性，不同的设置可能最终会获得相同的内部格式。例如，<strong>Low Quality Compression</strong> 会影响移动平台，但不会影响桌面平台。</td><td></td></tr><tr><td align="left"></td><td align="left"><strong>None</strong></td><td>不压缩纹理。</td></tr><tr><td align="left"></td><td align="left"><strong>Low Quality</strong></td><td>以低质量格式压缩纹理。这种质量比 <strong>Normal Quality</strong> 使用更少的内存。</td></tr><tr><td align="left"></td><td align="left"><strong>Normal Quality</strong></td><td>以标准格式压缩纹理。</td></tr><tr><td align="left"></td><td align="left"><strong>High Quality</strong></td><td>以高质量格式压缩纹理。这种质量比 <strong>Normal Quality</strong> 使用更多的内存。</td></tr><tr><td align="left"><strong>Use Crunch Compression</strong></td><td align="left">如果适用，使用 Crunch 压缩。Crunch 是一种基于 DXT 或 ETC 纹理压缩的有损压缩格式。Unity 在 CPU 上将纹理解压缩为 DXT 或 ETC，然后在运行时将其上传到 GPU。Crunch 压缩有助于纹理在磁盘上使用尽可能少的空间并方便下载。Crunch 纹理可能需要很长时间进行压缩，但在运行时的解压缩速度非常快。</td><td></td></tr><tr><td align="left"><strong>Compressor Quality</strong></td><td align="left">使用 Crunch 纹理压缩时，可使用滑动条调整质量。压缩质量越高意味着纹理越大，压缩时间越长。  <strong>注意：</strong>对于 Android 平台，Compressor Quality 值提供的选项略有不同。有关更多信息，请参阅<a href="https://docs.unity.cn/cn/2023.2/Manual/class-TextureImporterOverride.html">特定于平台的覆盖的纹理格式</a>。</td><td></td></tr></tbody></table><h1 id="Graphics-performance-and-profiling"><a href="#Graphics-performance-and-profiling" class="headerlink" title="Graphics performance and profiling"></a>Graphics performance and profiling</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;光照&quot;&gt;&lt;a href=&quot;#光照&quot; class=&quot;headerlink&quot; title=&quot;光照&quot;&gt;&lt;/a&gt;光照&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.unity.cn/cn/2023.2/Manual/Lightmappers.html&quot;&gt;光照贴</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity-热更新</title>
    <link href="https://huangxinhere.github.io/2023/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://huangxinhere.github.io/2023/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%83%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2023-09-09T16:00:00.000Z</published>
    <updated>2023-10-16T01:49:29.965Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/612235756">Unity热更新入门最全教程（一） - 知乎 (zhihu.com)</a></p><p><a href="https://cloud.tencent.com/developer/article/2239496">Unity 热更新技术 | （一） 热更新的基本概念原理及主流热更新方案介绍-腾讯云开发者社区-腾讯云 (tencent.com)</a>【最详细】</p><h1 id="什么是更新"><a href="#什么是更新" class="headerlink" title="什么是更新"></a>什么是更新</h1><p>游戏更新 简单点说，分为两类，一种是<strong>冷更新</strong>（换包），一种是<strong>热更新</strong>（不换包，通过网络下载，动态更新资源等）。</p><p>1、冷更新（Cold Update）是指在需要更新时，需要<u>用户手动到应用商店或官方网站下载新版本安装包并重新安装</u>的一种更新方式，以解决一些热更新无法覆盖的问题，如需要进行版本升级、打包、发布等工作，需要耗费一定的时间和人力物力成本。</p><p>2、热更新（Hotfix）是指在不需要重新发布应用程序或游戏的情况下，<u>通过远程更新服务器向客户端推送程序代码、资源文件等数据</u>的一种技术手段，以修复程序漏洞、优化游戏性能、更新游戏内容等</p><blockquote><ul><li><p>热更新相对于冷更新的优点在于：</p><p>可以快速地修复程序漏洞、更新游戏内容和添加新功能；</p><p>同时减少了用户下载和安装的操作流程，降低了用户对游戏的耐心和耐受度。</p><p>因此，在一些紧急情况下，如修复重大漏洞、提供重要新内容等，热更新是比较合适的选择。</p></li><li><p>冷更新相对于热更新的优点在于：</p><p>更新的内容<u>更加稳定、全面和完整</u>，可以解决一些热更新无法覆盖的问题。</p><p>冷更新通常需要进行版本升级、打包、发布等工作，需要耗费一定的时间和人力物力成本，但也可以在更新中进行更多的优化和改进。</p></li></ul></blockquote><h1 id="热更新内容"><a href="#热更新内容" class="headerlink" title="热更新内容"></a>热更新内容</h1><p>我们需要更新的内容，一般 包含代码和资源两部分。</p><p><strong>代码部分</strong>指的是应用程序的逻辑代码，包括 C# 脚本、插件等。开发者可以将需要更新的代码打包成 <strong>DLL 或插件</strong>，然后通过 Unity 程序动态加载和替换旧的代码，实现应用程序的热更新。</p><p><strong>资源部分</strong>指的是应用程序使用的图像、音频、视频、场景等资源。开发者可以将需要更新的资源打包成 <strong>AssetBundle 文件</strong>，然后通过 Unity 程序动态加载和替换旧的资源，实现应用程序的热更新。</p><h1 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h1><p>热更新，是需要通过 <strong>网络下载</strong><u>资源或者代码</u> 下载到本地包。</p><p>利用<strong>动态加载</strong>技术，将新的代码或资源<u>加载到应用程序</u>中，以替换旧的代码或资源。这通常涉及到一个热更新引擎或框架，该引擎会在运行时检测到代码或资源的更改，并自动将其加载到应用程序中。</p><ul><li><strong>C#热更原理</strong>：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，<u>只有作为业务（逻辑）模块的DLL部分需要修改</u>。游戏运行时通过反射机制加载这些DLL就实现了热更新。</li><li><strong>lua热更原理</strong>：逻辑代码转化为<strong>脚本</strong>，脚本转化为<strong>文本资源</strong>，以<strong>更新资源的形式</strong>更新程序。</li></ul><blockquote><p><strong>为什么实现热更新一般都是用Lua，而不是C#?</strong></p><p>热更新本身对于资源热更新是非常容易的，Unity自带的AB包就可以轻松解决，难的是代码热更新，因为Unity中的C#是<strong>编译型语言</strong>，Unity在打包后，会将C#编译成一种中间代码，再由Mono虚拟机编译成汇编代码供各个平台执行，它打包以后就变成了二进制了，会跟着程序同时启动，就无法进行任何修改了。</p><p>所以直接使用C#进行热更新显然是不可行的，但是也不是说一点办法也没有。在安卓上可以通过C#的语言特性-反射机制实现动态代码加载从而实现热更新。</p><p>C#的编译流程：写好的代码-&gt;编译成.dll扩展程序（UnityEditor完成）-&gt;运行于Unity <strong>C#热更具体做法</strong>：将需要频繁更改的逻辑部分独立出来做成DLL，在主模块调用这些DLL，主模块代码是不修改的，只有作为业务（逻辑）模块的DLL部分需要修改。游戏运行时<u>通过反射机制加载这些DLL</u>就实现了热更新。</p><p>但苹果对反射机制有限制，不能实现这样的热更。为了安全起见，不能给程序太强的能力，因为反射机制实在太过强大，会给系统带来安全隐患。</p><p>而 <code>LUA</code> 则是<strong>解释型语言</strong>，并不需要事先编译成块，而是<u>运行时动态解释执行</u>的。这样LUA就和普通的游戏资源如图片，文本没有区别，因此可以在运行时直接从WEB服务器上下载到持久化目录并被其它LUA文件调用。</p></blockquote><h1 id="热更新流程"><a href="#热更新流程" class="headerlink" title="热更新流程"></a>热更新流程</h1><p><img src="https://developer.qcloudimg.com/http-save/yehe-8681253/5a98381a3ef9d2908bf4e3deddeef9c0.png" alt="在这里插入图片描述"></p><p><strong>第一步、【开发者】导出热更新所需资源</strong></p><ol><li>打包热更资源的对应的<u>md5信息</u>（涉及到增量打包）</li><li>上传热更对应的ab包到<u>热更服务器</u></li><li>上传<u>版本信息</u>到版本服务器</li></ol><p><strong>第二步、游戏运行后的热更新流程</strong></p><ol><li>启动游戏</li><li>根据当前版本号，和平台号去版本服务器上检查<strong>是否有热更</strong></li><li>从热更服务器上下载md5文件，比对<strong>需要热更的具体文件列表</strong></li><li>从热更服务器上<strong>下载</strong>需要热更的资源，<strong>解压</strong>到热更资源目录；</li><li>游戏运行加载资源，<u>优先到热更目录中加载，再到母包资源目录加载</u></li></ol><blockquote><p>更新注意：</p><p>要有下载失败重试几次机制；</p><p>要进行超时检测； </p><p>要记录更新日志，例如哪几个资源时整个更新流程失败。</p></blockquote><h1 id="主流热更新方案"><a href="#主流热更新方案" class="headerlink" title="主流热更新方案"></a>主流热更新方案</h1><h2 id="LUA热更-XLua-ToLua-（LUA与C-绑定，方案成熟）"><a href="#LUA热更-XLua-ToLua-（LUA与C-绑定，方案成熟）" class="headerlink" title="LUA热更(XLua/ToLua)（LUA与C#绑定，方案成熟）"></a>LUA热更(XLua/ToLua)（LUA与C#绑定，方案成熟）</h2><ul><li>原理：逻辑代码转化为脚本，脚本转化为文本资源，以更新资源的形式更新程序；</li><li>Lua系解决方案: 内置一个Lua虚拟机,做好UnityEngine与C#框架的Lua导出。典型的框架有xLua, uLua,大体都差不多。</li></ul><p>Lua热更新解决方案是通过一个<strong>Lua热更新插件</strong>（如ulua、slua、tolua、xlua等）来提供一个<u>Lua的运行环境以及和C#进行交互</u>。xLua是腾讯开源的热更新插件，有大厂背书和专职人员维护，插件的稳定性和可持续性较强。</p><p>由于Lua不需要编译，因此Lua代码<u>可以直接在Lua虚拟机里运行</u>，Python和JavaScript等脚本语言也是同理。而xLua热更新插件就是为Unity、.Net、Mono等C#环境提供一个Lua虚拟机，使这些环境里也可以运行Lua代码，从而为它们增加Lua脚本编程的能力。</p><p>借助xLua，这些Lua代码就可以方便的和C#相互调用。这样平时开发时使用C#，等需要热更新时再使用Lua，等下次版本更新时再把之前的Lua代码转换成C#代码，从而保证游戏正常运营。</p><h2 id="ILRuntime热更"><a href="#ILRuntime热更" class="headerlink" title="ILRuntime热更"></a>ILRuntime热更</h2><p>项目是掌趣科技开源的热更新项目，它为基于C#的平台（例如Unity）<u>提供了一个纯C#、快速、方便和可靠的IL运行环境</u>，使得能够在不支持JIT的硬件环境（如iOS）能够实现代码热更新。</p><p>ILRuntime项目的原理实际上就是先用VS把需要热更新的C#代码<strong>封装成DLL</strong>（动态链接库）文件，然后通过Mono.Cecil库读取DLL信息并<strong>得到对应的IL中间代码</strong>（IL是.NET平台上的C#、F#等高级语言编译后产生的中间代码，IL的具体形式为.NET平台编译后得到的.dll动态链接库文件或.exe可执行文件），最后再用<strong>内置的IL解译执行虚拟机来执行DLL文件中的IL代码</strong></p><p>由于IsLRuntime项目是使用C#来完成热更新，因此很多时候会用到反射来实现某些功能【为什么？】。而反射是.NET平台在运行时获取类型（包括类、接口、结构体、委托和枚举等类型）信息的重要机制，即<u>从对象外部获取内部的信息</u>，包括字段、属性、方法、构造函数和特性等。我们可以使用反射动态获取类型的信息，并利用这些信息动态创建对应类型的对象。</p><p>ILRuntime中的反射有两种：</p><ul><li>一种是在热更新DLL中直接使用C#反射获取到System.Type类对象；</li><li>另一种是在Unity主工程中通过appdomain.LoadedTypes来获取继承自System.Type类的IType类对象，因为在Unity主工程中无法直接通过System.Type类来获取热更新DLL中的类。</li></ul><h1 id="AssetBundle"><a href="#AssetBundle" class="headerlink" title="AssetBundle"></a>AssetBundle</h1><p><a href="https://blog.csdn.net/qq_28299311/article/details/104870024">Unity - AssetBundle和XLua热更新教程（简单详细）_unity assetbundle hotfix_长生但酒狂的博客-CSDN博客</a>【初识热更新的基本流程】</p><p><a href="https://blog.csdn.net/Terie/article/details/106591022">Unity热更新技术学习——AssetsBundle详解-CSDN博客</a>【针对AB更详细的介绍】</p><h2 id="和Resources的比较"><a href="#和Resources的比较" class="headerlink" title="和Resources的比较"></a>和Resources的比较</h2><p><code>Resources</code>是Unity最早提出的资源动态加载的方案。当你需要动态加载某个资源的时候，你需要把对应的资源，比如预置体，材质等放入<code>Resources目录</code>下，然后用Unity提供的API（<code>Resources.Load()</code>）去动态加载。</p><p>这个目录在以前游戏不是很大的情况下很方便很好用。但在项目做大的时候，它的缺点就暴露得很明显了（缺点来自官方文档）：</p><ul><li>难以进行细粒度的内存管理；</li><li>无论你用不用，Resources目录下的资源都<strong>会打包进游戏包</strong>（编译好放进游戏包）里。这不仅会导致游戏<u>构建时长</u>增大，游戏<u>包体大小激增</u>，资源还难以管理；</li><li><strong>没法使用Resources进行热更新</strong>。在你构建的时候，Unity会自动帮你打包好资源，而之后游戏也只会使用这些打包好的资源。</li><li>主线程加载。这意味着，如果你需要动态加载的资源多了，你的游戏会假死。</li></ul><p>为了解决这些问题，AssetsBundle诞生了。</p><p><strong>AssetsBundle</strong></p><p>AssetsBundle是Unity另一套资源管理的方式。它和Resources的相同之处，也是他们最主要的用途就是<u>允许工程动态加载里面的资源</u>。不同之处在于：</p><ul><li>AssetsBundle是<strong>和应用程序分开存储</strong>的</li><li>允许用户<strong>下载新的AssetBundle</strong>并使用里面的资源【资源热更的核心】</li><li>需要用户在Unity编辑器模式下，<u>手动编写代码构建</u>AssetsBundle</li></ul><p>而手动构建虽然显得更加繁琐，但也给你更多的选择。你可以选择构建AssetsBundle的路径，<u>选择它的名称和更细分的变体</u>（Variants），你还可以构建好AssetsBundle之后，将其<u>存储到服务器</u>上，让用户在需要资源更新的时候下载新的AssetsBundle。</p><h2 id="存储目录"><a href="#存储目录" class="headerlink" title="存储目录"></a>存储目录</h2><p>两个重要的目录：<strong>StreamingAssetsPath</strong> 和 <strong>PersistentDataPath</strong>。</p><ul><li>AssetBundle存放<code>StreamingAssetsPath</code>目录下且不会参与编译，但因为是只读的所以无法更新</li></ul><p><strong>StreamingAssetsPath</strong> 可以通过<code>Application.streamingAssetsPath</code>获取路径。在Unity编辑器模式下，它是Assets目录下的StreamingAssets目录。在Android平台里，它就是assets目录。</p><p>和Android一样，Unity也不会对这个目录下的文件做任何事情，包括C#脚本，Shader和材质也<strong>不会参与编译</strong>。</p><p>所以应该使用这个目录去存储Unity的资源。在PC上，你可以<u>直接使用文件系统访问</u><code>Application.streamingAssetsPath</code>获取里面的资源。</p><blockquote><p>而在Android和WebGL平台上无法通过文件系统直接访问。Android提供了AssetsManager这个API去访问，反映到Unity层面，就是WWW（过时）或者UnityWebRequest。</p></blockquote><p>一般来说，在Editor下打包出来需要直接进入游戏包体的AssetsBundle都会放入这个目录下。但是这个目录在Android上是<strong>只读</strong>的，所以你无法将新下载的AssetsBundle放入这个目录。如果要更新的AssetsBundle，还需要另一个目录——</p><ul><li>存放在 <strong>PersistentDataPath</strong></li></ul><p>PersistentDataPath 可以通过<code>Application.persistentDataPath</code>获取路径。</p><p>Unity编辑器：<code>/User/AppData/Local/Packages/&lt;productname&gt;/LocalState</code><br>Android：<code>/sdcard/Android/data/&lt;packagename&gt;/files</code></p><p>这个目录是<strong>可读可写</strong>的。新下载的AssetsBundle就会放入这个地方。</p><h2 id="构建AssetsBundle"><a href="#构建AssetsBundle" class="headerlink" title="构建AssetsBundle"></a>构建AssetsBundle</h2><h3 id="构建代码"><a href="#构建代码" class="headerlink" title="构建代码"></a>构建代码</h3><p>因为是编辑器手动构建，所以<strong>构建代码需要放到Editor目录</strong>下。随意建一个Editor目录，然后新建一个脚本放到Editor目录下，内容为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateAssetsBundle</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MenuItem(<span class="meta-string">&quot;Assets/Build AssetBundles&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAllAssetBundles</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> dir = Application.streamingAssetsPath; <span class="comment">// AB包将放到StreamingAssetsPath下</span></span><br><span class="line">        <span class="keyword">if</span> (!Directory.Exists(dir))</span><br><span class="line">        &#123;</span><br><span class="line">            Directory.CreateDirectory(dir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始打包</span></span><br><span class="line">        <span class="comment">// 1.输出路径</span></span><br><span class="line">        <span class="comment">// 2.压缩方式（None为默认算法）</span></span><br><span class="line">        <span class="comment">// 3.对应平台</span></span><br><span class="line">        BuildPipeline.BuildAssetBundles(dir, BuildAssetBundleOptions.None, EditorUserBuildSettings.activeBuildTarget);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>手动导出（要手动标记AB资源）</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210413230253901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MDA1Nzk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>自动导出（代码搜索文件并打包）</p></blockquote><h3 id="资源标记"><a href="#资源标记" class="headerlink" title="资源标记"></a>资源标记</h3><p>（标记的地方和标记名称参考：）</p><p><img src="https://img-blog.csdnimg.cn/202104132344378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MDA1Nzk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><table><thead><tr><th align="center">物体</th><th align="center">AssetBundle Name</th></tr></thead><tbody><tr><td align="center">Red（材质）</td><td align="center">ab_mat</td></tr><tr><td align="center">RedShader（着色器）</td><td align="center">ab_mat</td></tr><tr><td align="center">Cube（预置体）</td><td align="center">ab_prefab</td></tr><tr><td align="center">Sphere（预置体）</td><td align="center">ab_prefab</td></tr><tr><td align="center">SampleScene（场景文件）</td><td align="center">ab_scene</td></tr><tr><td align="center">file（贴图 png）</td><td align="center">ab_tex</td></tr><tr><td align="center">folder（贴图 png）</td><td align="center">ab_tex</td></tr></tbody></table><h3 id="打包效果"><a href="#打包效果" class="headerlink" title="打包效果"></a>打包效果</h3><p>然后点击 Assets -&gt; Build AssetBundles 开始打包。打完包之后就会出现上图中的StreamingAssets目录。打开它你会发现这些东西：</p><p><img src="https://img-blog.csdnimg.cn/20200607235213759.png" alt="在这里插入图片描述"></p><p>可以发现，里面有两种文件，每种文件分别有一个<code>AssetBundle文件</code>，一个<code>manifest清单文件</code>（忽略meta文件）</p><h3 id="manifest清单文件"><a href="#manifest清单文件" class="headerlink" title="manifest清单文件"></a>manifest清单文件</h3><p>manifest清单文件是文本文件，我们打开来看看其中预置体对应的AB包的清单文件的内容：</p><p><img src="https://img-blog.csdnimg.cn/20200608000046172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rlcmll,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>CRC：CRC校验码；</li><li>Hashes：资源文件和TypeTree的Hash值，可能是用来做完整性验证的；</li><li>Assets：描述了这个AB包里包含了什么资源；</li><li><strong>Dependencies</strong>：顾名思义，就是这个AB包的依赖。上面我把材质球赋予了这两个预置体，所以包含这两个预置体的AB包自然就要依赖该材质球所在的AB包——ab_mat。</li></ul><h3 id="AssetBundle文件"><a href="#AssetBundle文件" class="headerlink" title="AssetBundle文件"></a>AssetBundle文件</h3><p>清单文件只是描述AB包的基础信息，而真正的资源都包含在AB包里。</p><p><img src="https://img-blog.csdnimg.cn/20200608002756731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1Rlcmll,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>以External References开头，这个Header描述了当前AB包中的资源都需要引入哪些外部的AB包。由于是<strong>被依赖的资源</strong>，这些AB包都会在当前AB包加载之前事先被加载进来。如果你有引用Unity内置的一些资源，比如Shader或者贴图，也会在这里被列出来。</p></li><li><p>每个数据块都有一个ID，一个Class ID，和一个名称。他们代表<strong>当前AB包中包含的资源</strong>。在上述的例子中，AB包中包含了构成两个Prefab的所有组件，以及一个固定ID为1的AssetBundle类型的数据。</p></li><li><p>每个数据都描述了各自的属性，以及他们的外部依赖。</p><blockquote><p>对于每个数据详细的属性描述，请看参考博客。</p></blockquote></li></ul><p><strong>【AB的类型】</strong></p><p>分成由场景文件Scene打包而来的<strong>场景AB包</strong>，以及普通资源打成的<strong>松散AB包</strong>。</p><ul><li><p>在松散AB包中，每一个包中都包含一个<u>固定ID为1</u>的，名字叫AssetBundle的资源。</p><p>除了这个以外，其余所有的资源的ID都是一个绝对值很大的看起来很像是Hash的ID，这个ID一般来说是全局唯一的，如果两个AB包中包含同一个PathID的资源，就表示资源冗余了。</p></li><li><p>在场景AB包中，ID从1开始依次给场景中的资源计数，所以不同场景包中的资源的ID有重复自然就不奇怪了。</p></li></ul><p><strong>【AssetBundle依赖】</strong></p><p>假设两个预置体被分别打进了两个AssetBundle。他们依赖同一个材质，材质使用一个贴图，然而材质和贴图都没有打AssetBundle。我们看看打出来的文件大小：</p><p><img src="https://img-blog.csdnimg.cn/20200608114407214.png" alt="在这里插入图片描述"></p><p>然后第二种方案是将材质也指定一个AssetBundle，再看看文件大小：</p><p><img src="https://img-blog.csdnimg.cn/20200608114512628.png" alt="在这里插入图片描述"></p><p>材质没有打AssetBundle之前，两个预置体的AssetBundle大小都达到了87KB。材质打了AssetBundle之后，多了一个大小87KB的AssetBundle，但是两个预置体的大小都降低到了2KB。</p><p>为了<strong>内存的细粒度管理</strong>，项目喜欢把单个预置体打成一个AssetBundle。在这种情况下，上面第一种方案的内存会按照O(n)的复杂度增长，而第二种方案的内存增长的复杂度则是O(1)。</p><p>实际上，如果一个AssetBundle内的资源所依赖的另一个资源没有打AssetBundle，Unity会将其拷贝进AssetBundle里面。</p><p>如果多个不同的AssetBundle的资源都依赖同一个没有打AssetBundle的资源，那么打包后该资源会在多个AssetBundle各存在一份拷贝。</p><p>相反，如果将这个资源打包，那么那些<u>依赖该资源的AssetBundle只会保存该资源所在的AssetBundle的引用。</u></p><h3 id="检查导出包的完整性【MD5格式打包】"><a href="#检查导出包的完整性【MD5格式打包】" class="headerlink" title="检查导出包的完整性【MD5格式打包】"></a>检查导出包的完整性【MD5格式打包】</h3><p><a href="https://blog.csdn.net/qq_46005796/article/details/115643808?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-115643808-blog-106591022.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-6-115643808-blog-106591022.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=7">AssetsBundle学习（看一遍不懂不要紧，赶紧收藏！！！）_asset bundle_WeQKing的博客-CSDN博客</a></p><ul><li>为什么使用MD5</li></ul><p>只要使用了该方法，转出来的格式密码就是唯一的，<u>不管是对导出包数据，还是对导出包名字，都是唯一的</u>。</p><p>如果其他人想要通过<u>更改数据包文件数据，或者是更改数据包文件名称</u>，那么这个数据转成MD5格式数据之后，就会<u>和原来的MD5格式数据不一样</u>，这样子就能起到判断导出包数据是否完整的作用。</p><p>而在Unity中，有一个自己内置的MD5格式转换的方法，只需要<strong>把导出包的所有数据都单独转成MD5格式数据</strong>，<strong>并加上该MD5格式的导出包名称</strong>，就可以起到一个判断导出包数据完整性的作用。</p><blockquote><p>如果在一个txt文件上存放<strong>所有</strong>导出包的名称和MD5格式数据，在想要使用该包的时候，检查一下这个txt文件所附的目录下数据包是否一一对应，我们就能够实现使用包或者是更新资源的一种判断。</p><p>一般我们称存放所有数据包名称和MD5数据的文件为<strong>Config文件</strong>！</p></blockquote><ul><li>MD5转换逻辑</li></ul><p>我们要知道，我们要转换成MD5格式的东西是什么，那就是导出AssetsBundle包的包路径【不是数据包文件数据+文件名称么？】。我们把该路径转为MD5格式，这样再返回出去，这就是MD5在这里的用途，其他用途也会用到，但这里只展示这些。</p><p><img src="https://img-blog.csdnimg.cn/2021041323050885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MDA1Nzk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>其中遍历二进制数组的过程中，用字符串拼接的方式把二进制拼接起来，并转换为二位十六进制的数据【？一边转化一边拼接？】</p></blockquote><ul><li>检查文件完整性</li></ul><p>把导出来的AssetsBundle包的<u>包名和包路径位置</u>都存储到一个config文件内，</p><p>并把该config文件存放到<u>AssetsBundle的父级目录下</u>，与该父级目录同级，</p><p>这样，在检查<strong>整个</strong>assetsbundle文件完整性时，只需要检查<u>config文件内数据</u>是否和<u>父级目录内的assetsbundle文件</u>一一对应，就能够知道资源是否完整</p><ul><li>Config文件</li></ul><p>该文件存储有两种数据：</p><ol><li><p>AssetsBundle数据包名</p></li><li><p>AssetsBundle数据包路径</p></li></ol><p><img src="https://img-blog.csdnimg.cn/20210413230633975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MDA1Nzk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>Config文件创建</li></ul><p>用MD5把文件路径转格式之后，再存进Config文件数据之中，对应文件之后。</p><p>一个文件一个文件的放，最终所有的导出包文件文件名和MD5格式加密字符都有了，这个Config文件就算成功</p><p><img src="https://img-blog.csdnimg.cn/20210413230153375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ2MDA1Nzk2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="导入ab资源包"><a href="#导入ab资源包" class="headerlink" title="导入ab资源包"></a>导入ab资源包</h2><p>首先在项目中定义asset bundle类型的变量，用来存放加载之后的ab资源包；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AssetBundle totalAssetBundle;</span><br></pre></td></tr></table></figure><p>之后通过AssetBundle.LoadFromFile（ab资源路径+ab资源名）；(ab资源名记住不是路径的那个，类似我所做的data文件，那个加载是不行的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">totalAssetBundle = AssetBundle.LoadFromFile(Common.Path + <span class="string">&quot;FileName&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>或者是通过服务器下载</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">UnityWebRequest www = UnityWebRequestAssetBundle.GetAssetBundle(path);</span><br><span class="line">www.SendWebRequest();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!www.isDone)</span><br><span class="line">&#123;</span><br><span class="line"> Debug.Log(www.downloadProgress);</span><br><span class="line">    slider.<span class="keyword">value</span> = www.downloadProgress;<span class="comment">//下载进度</span></span><br><span class="line">    progressText.text = Math.Floor(www.downloadProgress * <span class="number">100</span>) + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下载完成</span></span><br><span class="line"><span class="keyword">if</span> (www.isDone)</span><br><span class="line">&#123;</span><br><span class="line">    progressText.text = <span class="number">100</span> + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    slider.<span class="keyword">value</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 隐藏UI(等待1s)</span></span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">1</span></span>)</span>;</span><br><span class="line">    GameObject.Find(<span class="string">&quot;Canvas&quot;</span>).SetActive(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (www.isNetworkError || www.isHttpError)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;DownLoad Err: &quot;</span> + www.error);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    assetBundle = DownloadHandlerAssetBundle.GetContent(www);</span><br><span class="line">    TextAsset hot = assetBundle.LoadAsset&lt;TextAsset&gt;(<span class="string">&quot;luaScript.lua.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> newPath = Application.persistentDataPath + <span class="string">@&quot;/luaScript.lua.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!File.Exists(newPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Create后如果不主动释放资源就会被占用,下次打开会报错，所以一定要加上 .Dispose()</span></span><br><span class="line">        File.Create(newPath).Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    File.WriteAllText(newPath, hot.text);</span><br><span class="line"></span><br><span class="line">    Debug.Log(<span class="string">&quot;下载资源成功！new Path : &quot;</span> + newPath);</span><br><span class="line">    <span class="comment">// 下载成功后 读取执行lua脚本</span></span><br><span class="line">    callBack();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用ab资源包"><a href="#使用ab资源包" class="headerlink" title="使用ab资源包"></a>使用ab资源包</h2><p>上述方法其实已经加载完ab资源包，等需要用的时候，只要用<u>存放加载完的ab类型的变量</u>.LoadAsset&lt;资源类型&gt;(资源名称)方法，即可实现使用对应ab资源。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GameObject memoryObj = totalAssetBundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;ccc&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/612235756&quot;&gt;Unity热更新入门最全教程（一） - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/develop</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity-算法</title>
    <link href="https://huangxinhere.github.io/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/"/>
    <id>https://huangxinhere.github.io/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-05T16:00:00.000Z</published>
    <updated>2023-09-07T06:42:36.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="敏感词匹配"><a href="#敏感词匹配" class="headerlink" title="敏感词匹配"></a>敏感词匹配</h1><ol><li><p>如果不考虑性能的话，建立一个“敏感词”语句库，利用constains和replace操作直接替换，不过时间复杂度比较高。</p></li><li><p>AC自动机</p><p><a href="https://www.bilibili.com/video/BV1Ag41117YU/?spm_id_from=333.337.search-card.all.click&vd_source=a0e1a6c98f31da08ec684b90c3d4c2cc">【全程干货】程序员必备算法！AC自动机算法敏感词匹配算法！动画演示讲解，看完轻松掌握，面试官都被你唬住！！_哔哩哔哩_bilibili</a></p><ul><li>构建Trie树（字典树，前缀树）</li></ul><p>从根节点出发，可以向后无限延伸，每个节点都有多个子节点，将敏感词的每一个字拆分开，作为一个节点，以特定的顺序排列，来构建成一个Tire树。</p><p>当每个敏感词构建完成后，在最后的节点记录敏感词长度，这样就能知道整个敏感词是什么了（在被匹配的字符串上“回溯”？）。</p><p><img src="https://img-blog.csdnimg.cn/84ddfba19d8d46b59bb7869440a08b92.png" alt="img"></p><ul><li>构建Fail指针（失配指针）</li></ul><p> 在检索Trie树的时候，在某个分支的节点上匹配失败，可以重新指向关联的其他分支上，避免了从头开始冗余检索。</p><ol><li>构建fail指针的遍历为<strong>层次遍历</strong>。</li><li><strong>root节点</strong>的fail指针指向自己本身。</li><li>如果当前节点父节点、的fail指针、指向的节点下、存在与当前节点一样的子节点，则当前节点的fail指针指向该子节点。否则、指向root节点。</li></ol><p><img src="https://img-blog.csdnimg.cn/6add1f5a95ec468e8c79ce06d0b0d567.png" alt="img"></p></li></ol><ul><li>遍历过程</li></ul><p>若遍历语句的时候，到达“结束节点”时，根据当前结束节点标记的“length”来进行回溯，找到包含的敏感词；</p><p>当语句没有结束时，但已经到了“结束节点”，就根据Fail指针，指向另一个节点继续遍历。直到将语句中所有的字遍历检查完成即可找出所有所有的“敏感词”。</p><p>所以时间复杂度为O（n）。</p><h1 id="两个10G-的文件，200m-内存，排序"><a href="#两个10G-的文件，200m-内存，排序" class="headerlink" title="两个10G 的文件，200m 内存，排序"></a>两个10G 的文件，200m 内存，排序</h1><ol><li>把 10G 大小的文件拆分成 N 个小文件，每个文件 1M 。</li><li>把每个文件拉倒内存排序，可以并行操作，在内存中直接使用快排，然后写入文件 。</li><li>对文件做两两合并。</li></ol><h1 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h1><p>【详细的解释】<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html#graphs">Introduction to the A* Algorithm (redblobgames.com)</a></p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>按照一定的顺序查找附近的node，呈现规律的扩散。</p><p><img src="/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-Unity-算法.assets\image-20230316152044206.png" alt="image-20230316152044206"></p><h2 id="迪斯卡尔算法"><a href="#迪斯卡尔算法" class="headerlink" title="迪斯卡尔算法"></a>迪斯卡尔算法</h2><p>带权路径查找，局部最优。比如从A点开始，与A相连的有B(1),C(4),B又连着C(2)。</p><p>那么更新B和C，它们分别从A而来，路径分别是1和3；目前最短的路径是B，那么从B开始下一轮；</p><p>B连着C，对于C来说，现在有两条路径到C，一个是从A来，一个是从B来，最短的是从B(1+2)来，那么更新C是从B来。</p><p>从上面可以看到，算法是暂存局部，然后遍历更多的点的时候刷新最短路径，从而获得一个点到所有点的最短路径。</p><ul><li>权（路径）的设计</li></ul><p>迪斯卡尔算法的最大特点是<strong>代价</strong>。如果充分设计代价的分布，那么可以利用这些来规划禁止区域。比如森林或水流代价很大，那就几乎不会走到那去。</p><p><img src="/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-Unity-算法.assets\image-20230316152944956.png" alt="广度优先和迪斯卡尔的区别"></p><h2 id="贪心算法（预估代价）"><a href="#贪心算法（预估代价）" class="headerlink" title="贪心算法（预估代价）"></a>贪心算法（预估代价）</h2><p>目前广度优先算法和迪斯卡尔算法都是要同时搜索（几乎）所有方位来找到 到所有点的最短的路径。</p><blockquote><p>bfs会遍历四周的所有点，迪斯卡尔也是同时开启地毯式搜索。</p></blockquote><p>但如果是只想找一个目标地点呢？或者说缩小搜索范围？朝着有限的、接近目标的方向前进。</p><ul><li>预估代价：计算和目标的距离，然后选择离目标最近的方向前进。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heuristic</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y);</span><br></pre></td></tr></table></figure><ul><li>算法：到达某一个点所需的预估代价。这个代价点会存入到优先队列里面去。只会取出最小的代价点来继续探索。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frontier = PriorityQueue()</span><br><span class="line">frontier.put(start, <span class="number">0</span>)</span><br><span class="line">came_from = <span class="built_in">dict</span>()</span><br><span class="line">came_from[start] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():</span><br><span class="line">   current = frontier.get()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> current == goal:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph.neighbors(current):</span><br><span class="line">      $ 把该代价点附近的未遍历的点纳入其中</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> came_from:</span><br><span class="line">         priority = heuristic(goal, <span class="built_in">next</span>)</span><br><span class="line">         frontier.put(<span class="built_in">next</span>, priority)</span><br><span class="line">         came_from[<span class="built_in">next</span>] = current</span><br></pre></td></tr></table></figure><p><img src="/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-Unity-算法.assets\image-20230316155013729.png" alt="迪斯卡尔和A*算法"></p><ul><li>如果是比较复杂的地形呢？</li></ul><p><img src="/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-Unity-算法.assets\image-20230316155415139.png" alt="image-20230316155415139"></p><blockquote><p>速度更快。</p></blockquote><p><img src="/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-Unity-算法.assets\image-20230316155535121.png" alt="image-20230316155535121"></p><blockquote><p>但是有障碍的时候没有形成最短路径。（只看到局部利益没有考虑全局）。</p></blockquote><h2 id="A-算法-1"><a href="#A-算法-1" class="headerlink" title="A* 算法"></a>A* 算法</h2><p>以上算法都各有缺点：</p><p>迪斯卡尔浪费很多时间在没有可能的路径上；贪心算法没有找到最短路径。</p><p>A*算法就是集合了两者优点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">frontier = PriorityQueue()</span><br><span class="line">frontier.put(start, <span class="number">0</span>)</span><br><span class="line">came_from = <span class="built_in">dict</span>()</span><br><span class="line">cost_so_far = <span class="built_in">dict</span>()</span><br><span class="line">came_from[start] = <span class="literal">None</span></span><br><span class="line">cost_so_far[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():</span><br><span class="line">   current = frontier.get()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> current == goal:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph.neighbors(current):</span><br><span class="line">      $ 迪斯卡尔计算出的局部最优</span><br><span class="line">      new_cost = cost_so_far[current] + graph.cost(current, <span class="built_in">next</span>)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost &lt; cost_so_far[<span class="built_in">next</span>]:</span><br><span class="line">         cost_so_far[<span class="built_in">next</span>] = new_cost</span><br><span class="line">         $ 再加上预估代价</span><br><span class="line">         priority = new_cost + heuristic(goal, <span class="built_in">next</span>)</span><br><span class="line">         frontier.put(<span class="built_in">next</span>, priority)</span><br><span class="line">         came_from[<span class="built_in">next</span>] = current</span><br></pre></td></tr></table></figure><p><img src="/2023/09/06/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-Unity-算法.assets\image-20230316161612276.png" alt="image-20230316161612276"></p><blockquote><p>局部利益＋全局利益：局部是（迪斯卡尔）当前点的周围路径代价，遇到障碍就能很好避开；全局是距离目标点的预估代价，贪心算法就是不知道障碍物的代价所以要绕很远；</p></blockquote><h2 id="公式分析"><a href="#公式分析" class="headerlink" title="公式分析"></a>公式分析</h2><ol><li><strong>F</strong>（总代价，走到终点消耗得代价）=<strong>G</strong>（该点离起点距离）+<strong>H</strong>（该点离终点距离）。</li><li><strong>G</strong>：从起点到达当前点要走的距离，上下左右都是1，斜边用勾股定理算出约为1.4。</li><li><strong>H</strong>：按照曼哈顿距离计算（d(i,j)=|X1-X2|+|Y1-Y2| ）。</li><li>开启列表open：用来存储<strong>可以考虑行进的点</strong>，同时存放F、G、H、父对象（从哪个点来）的信息。</li><li>关闭列表close：用来存储<strong>不再考虑的点</strong>，存放在关闭列表中的点需要从开启列表移除，同时存放F、G、H、父对象（从哪个点来）的信息。</li></ol><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p>1、将起点记录为当前点a。</p><p>2、将当前点a放入关闭列表close，并设置父对象为空。</p><p>3、将当前点a周围所有能行进的格子放入开启列表，如果周围的点已经在开启列表或者关闭列表中再或者是障碍，就不用管它了。</p><p>4、记录当前点a周围所有能行进的格子的F值和父对象（父对象为当前点）。</p><p>5、重新在open列表中寻找最优点b（F最小值）将其放入关闭列表，同时在开启列表中移除，每次往关闭列表放点时，要判断该点是否为终点，如果是证明路径已经找完了，结束寻路，如果不是则继续</p><p>6、将最优点作为起点b</p><p>7、重复上述3、4、5、6步骤，直到找到终点。</p><p>8、找到终点，寻路结束，根据终点得父节点返回到起点，为最优路径。</p><h2 id="A-优化"><a href="#A-优化" class="headerlink" title="A*优化"></a>A*优化</h2><ul><li><p>A*算法优点在于对环境反应迅速，搜索路径直接，是一种直接的搜索算法，因此被广泛应用于路径规划问题。</p><p>其缺点是实时性差，每一节点计算量大、运算时间长，而且随着节点数的增多，算法搜索效率降低。</p></li></ul><p>【待深入理解……】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;敏感词匹配&quot;&gt;&lt;a href=&quot;#敏感词匹配&quot; class=&quot;headerlink&quot; title=&quot;敏感词匹配&quot;&gt;&lt;/a&gt;敏感词匹配&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果不考虑性能的话，建立一个“敏感词”语句库，利用constains和replace操作直接替换，</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>C#-数据结构和算法</title>
    <link href="https://huangxinhere.github.io/2023/09/04/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>https://huangxinhere.github.io/2023/09/04/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</id>
    <published>2023-09-03T16:00:00.000Z</published>
    <updated>2024-03-26T14:25:47.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://www.cnblogs.com/InCerry/p/10325290.html">浅析C# Dictionary实现原理 - InCerry - 博客园 (cnblogs.com)</a>[更清晰]</p><p><a href="https://zhuanlan.zhihu.com/p/96633352">【C#】浅析C# Dictionary实现原理 - 知乎 (zhihu.com)</a></p><p>主要是拉链法。</p><p>核心是buckets和entries数组。</p><p><img src="https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232145341-1401582594.png" alt="1548491185593"></p><p>将键转化成hashcode之后，取余数，得到哈希值，找到哈希桶数组对应的位置2</p><p>将信息存入到entries数组中，0位是空的，就放到0处，将<code>Entry</code>的下标<code>entryIndex</code>赋值给<code>buckets</code>中对应下标的<code>bucket</code>。步骤3中是存放在<code>entries[0]</code>的位置，所以<code>buckets[2]=0</code>。</p><p><img src="https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144972-327613048.png" alt="1548492100757"></p><ul><li>哈希碰撞：将新加入的元素放进entries的下一个空位，更新next和哈希桶指向的索引。</li></ul><p><img src="https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144436-391161641.png" alt="1548494357566"></p><ul><li>删除的时候，如果元素在链表中间，就会让前一个指向后一个，空出来位置的用freelist记录，下一次可以接着用。不过这样就打乱了值插入的顺序。</li></ul><h2 id="Hash桶算法"><a href="#Hash桶算法" class="headerlink" title="Hash桶算法"></a>Hash桶算法</h2><p>说到Hash算法大家就会想到<strong>Hash表</strong>，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。</p><p>因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个<strong>Bucket（桶）</strong>，一般常见的Hash桶就是直接对结果取余。</p><blockquote><p>假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用<strong>8</strong>个桶来映射，那么就可以通过<code>bucketIndex = HashFunc(key1) % 8</code>这样一个算法来确定这个hashCode映射到具体的哪个桶中。</p></blockquote><p>大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。</p><h2 id="扩容操作的触发条件"><a href="#扩容操作的触发条件" class="headerlink" title="扩容操作的触发条件"></a>扩容操作的触发条件</h2><ul><li><strong>第一种情况自然就是数组已经满了，没有办法继续存放新的元素。</strong></li><li><strong>第二种，Dictionary中发生的碰撞次数太多，会严重影响性能，</strong>也会触发扩容操作。</li></ul><h2 id="扩容操作如何进行"><a href="#扩容操作如何进行" class="headerlink" title="扩容操作如何进行"></a>扩容操作如何进行</h2><blockquote><p><strong>1.申请两倍于现在大小的buckets、entries</strong><br><strong>2.将现有的元素拷贝到新的entries</strong></p><p><strong>3、如果是Hash碰撞扩容，使用新HashCode函数重新计算Hash值</strong></p></blockquote><h2 id="C-中哈希表和字典的区别"><a href="#C-中哈希表和字典的区别" class="headerlink" title="C#中哈希表和字典的区别"></a>C#中哈希表和字典的区别</h2><p><a href="https://geek-docs.com/csharp/csharp-ask-answer/the-difference-between-hash-tables-and-dictionaries-in-c.html">C#中哈希表和字典的区别|极客教程 (geek-docs.com)</a></p><p><a href="https://blog.csdn.net/sinat_23338865/article/details/83341220">c#哈希表和字典的区别_c# dictionary和hashmap_偏执灬的博客-CSDN博客</a>[更详细]</p><ul><li>字典</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# program to illustrate Dictionary</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GeekdocsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Creating a dictionary</span></span><br><span class="line">        <span class="comment">// using Dictionary&lt;TKey, TValue&gt; class</span></span><br><span class="line">        Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; My_dict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adding key/value pairs in the Dictionary</span></span><br><span class="line">        <span class="comment">// Using Add() method</span></span><br><span class="line">        My_dict.Add(<span class="string">&quot;a.01&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        My_dict.Add(<span class="string">&quot;a.02&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        My_dict.Add(<span class="string">&quot;a.03&quot;</span>, <span class="string">&quot;C#&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; element <span class="keyword">in</span> My_dict)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Key:- &#123;0&#125; and Value:- &#123;1&#125;&quot;</span>, element.Key, element.Value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>哈希表</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C# program to illustrate a hashtable</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">GeekdocsDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create a hashtable</span></span><br><span class="line">        <span class="comment">// Using Hashtable class</span></span><br><span class="line">        Hashtable my_hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Adding key/value pair in the hashtable</span></span><br><span class="line">        <span class="comment">// Using Add() method</span></span><br><span class="line">        my_hashtable.Add(<span class="string">&quot;A1&quot;</span>, <span class="string">&quot;Welcome&quot;</span>);</span><br><span class="line">        my_hashtable.Add(<span class="string">&quot;A2&quot;</span>, <span class="string">&quot;to&quot;</span>);</span><br><span class="line">        my_hashtable.Add(<span class="string">&quot;A3&quot;</span>, <span class="string">&quot;Geekdocsbai Geekdocsbai&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span>(DictionaryEntry element <span class="keyword">in</span> my_hashtable)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Key:- &#123;0&#125; and Value:- &#123;1&#125; &quot;</span>, element.Key, element.Value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>区别</li></ul><table><thead><tr><th align="center">哈希表</th><th align="center">字典</th></tr></thead><tbody><tr><td align="center">Hashtable 是一个非泛型集合。</td><td align="center">字典是一个通用集合。</td></tr><tr><td align="center">Hashtable 在 <code>System.Collections</code> 命名空间下定义。</td><td align="center">字典在 <code>System.Collections.Generic</code> 命名空间下定义。</td></tr><tr><td align="center">在 Hashtable 中，可以存储相同类型或不同类型的键/值对。</td><td align="center">在 <code>Dictionary</code> 中，可以存储相同类型的键/值对。</td></tr><tr><td align="center">在 Hashtable 中，不需要指定 key 和 value 的类型。</td><td align="center">在 Dictionary 中，必须指定键和值的类型。</td></tr><tr><td align="center">由于装箱/拆箱，数据检索比字典慢。</td><td align="center">由于没有装箱/拆箱，数据检索比 <code>Hashtable</code> 快。</td></tr><tr><td align="center">在 Hashtable 中，如果尝试访问给定 Hashtable 中不存在的键，那么它将给出 <code>null</code> 值。</td><td align="center">在 <code>Dictionary</code> 中，如果尝试访问给定 <code>Dictionary</code> 中不存在的键，则会出错。</td></tr><tr><td align="center">它是线程安全的。</td><td align="center">它也是线程安全的，但仅适用于公共静态成员。</td></tr><tr><td align="center">它不维护存储<strong>值</strong>的顺序。</td><td align="center">它始终保持存储值的顺序。</td></tr></tbody></table><blockquote><p>Dictionary&lt;Tkey,Tvalue&gt;是Hastbale的泛型实现。 </p><p>Dictionary和HashTable内部实现差不多，但前者无需装箱拆箱操作，效率略高一点。</p></blockquote><ul><li>线程方面</li></ul><p>1）单线程程序中推荐使用 Dictionary, 有泛型优势, 且读取速度较快, 容量利用更充分.<br>2）<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>程序中推荐使用 Hashtable, 默认的 Hashtable 允许单线程写入, 多线程读取, 对 Hashtable 进一步调用 Synchronized()方法可以获得完全线程安全的类型. 而Dictionary 非线程安全, 必须人为使用 lock 语句进行保护, 效率大减.</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是由一个变量名称表示的一组同类型的数据元素。</p><p>数组继承自<code>System.Array</code>。数组是<code>引用类型</code>。引用在堆或者栈上，而数组对象本身总是在堆上。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p><a href="http://www.luzexi.com/2018/07/06/Unity3D%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E9%98%B6%E4%B8%BB%E7%A8%8B-CSharp%E8%A6%81%E7%82%B9%E6%8A%80%E6%9C%AF1">《Unity3D高级编程之进阶主程》第一章，C#要点技术(一) - List 底层源码剖析 - 技术人生 (luzexi.com)</a></p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; : <span class="title">IList</span>&lt;<span class="title">T</span>&gt;, <span class="title">System.Collections.IList</span>, <span class="title">IReadOnlyList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> _defaultCapacity = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] _items;<span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _size;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _version;</span><br><span class="line">    <span class="keyword">private</span> Object _syncRoot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> T[]  _emptyArray = <span class="keyword">new</span> T[<span class="number">0</span>];        </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Constructs a List. The list is initially empty and has a capacity</span></span><br><span class="line">    <span class="comment">// of zero. Upon adding the first element to the list the capacity is</span></span><br><span class="line">    <span class="comment">// increased to 16, and then increased in multiples of two as required.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        _items = _emptyArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructs a List with a given initial capacity. The list is</span></span><br><span class="line">    <span class="comment">// initially empty, but will have room for the given number of elements</span></span><br><span class="line">    <span class="comment">// before any reallocations are required.</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);</span><br><span class="line">        Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            _items = _emptyArray;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _items = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//其他内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>List 继承于IList，IReadOnlyList，IList是提供了主要的接口，IReadOnlyList提供了迭代接口。</li><li>List内部是用数组实现的，而不是链表，并且当没有给予指定容量时，初始的容量为0。</li></ul><h2 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Adds the given object to the end of this list. The size of the list is</span></span><br><span class="line"><span class="comment">// increased by one. If required, the capacity of the list is doubled</span></span><br><span class="line"><span class="comment">// before adding the new element.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T item</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_size == _items.Length) EnsureCapacity(_size + <span class="number">1</span>);</span><br><span class="line">    _items[_size++] = item;</span><br><span class="line">    _version++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensures that the capacity of this list is at least the given minimum</span></span><br><span class="line"><span class="comment">// value. If the currect capacity of the list is less than min, the</span></span><br><span class="line"><span class="comment">// capacity is increased to twice the current capacity or to min,</span></span><br><span class="line"><span class="comment">// whichever is larger.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EnsureCapacity</span>(<span class="params"><span class="built_in">int</span> min</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_items.Length &lt; min) &#123;</span><br><span class="line">        <span class="built_in">int</span> newCapacity = _items.Length == <span class="number">0</span>? _defaultCapacity : _items.Length * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.</span></span><br><span class="line">        <span class="comment">// Note that this check works even when _items.Length overflowed thanks to the (uint) cast</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">uint</span>)newCapacity &gt; Array.MaxArrayLength) newCapacity = Array.MaxArrayLength;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; min) newCapacity = min;</span><br><span class="line">        Capacity = newCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>每次增加一个元素的数据，Add接口都会首先检查的是容量还够不够，如果不够则用 EnsureCapacity 来增加容量。</p></li><li><p>每次容量不够的时候，整个数组的容量都会<strong>扩充一倍</strong>，_defaultCapacity 是容量的默认值为4。因此整个扩充的路线为4，8，16，32，64，128，256，512，1024…依次类推。</p><blockquote><p>List使用数组形式作为底层数据结构，好处是使用索引方式提取元素很快，但在<u>扩容的时候就会很糟糕</u>，每次new数组都会造成内存垃圾，这给垃圾回收GC带来了很多负担。</p><p>这里按2指数扩容的方式，可以为GC减轻负担，但是如果当数组连续被替换掉也还是会造成GC的不小负担，特别是代码中List频繁使用的Add时。</p><p>另外，如果<u>数量不得当也会浪费大量内存空间</u>，比如当元素数量为 520（512刚好不够，却只能两倍扩充） 时，List 就会扩容到1024个元素，如果不使用剩余的504个空间单位，就造成了大部分的内存空间的浪费。</p></blockquote></li></ul><h2 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Removes the element at the given index. The size of the list is</span></span><br><span class="line"><span class="comment">// decreased by one.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Remove</span>(<span class="params">T item</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> index = IndexOf(item);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        RemoveAt(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the index of the first occurrence of a given value in a range of</span></span><br><span class="line"><span class="comment">// this list. The list is searched forwards from beginning to end.</span></span><br><span class="line"><span class="comment">// The elements of the list are compared to the given value using the</span></span><br><span class="line"><span class="comment">// Object.Equals method.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// This method uses the Array.IndexOf method to perform the</span></span><br><span class="line"><span class="comment">// search.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">IndexOf</span>(<span class="params">T item</span>)</span> &#123;</span><br><span class="line">    Contract.Ensures(Contract.Result&lt;<span class="built_in">int</span>&gt;() &gt;= <span class="number">-1</span>);</span><br><span class="line">    Contract.Ensures(Contract.Result&lt;<span class="built_in">int</span>&gt;() &lt; Count);</span><br><span class="line">    <span class="keyword">return</span> Array.IndexOf(_items, item, <span class="number">0</span>, _size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes the element at the given index. The size of the list is</span></span><br><span class="line"><span class="comment">// decreased by one.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">uint</span>)index &gt;= (<span class="built_in">uint</span>)_size) &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentOutOfRangeException();</span><br><span class="line">    &#125;</span><br><span class="line">    Contract.EndContractBlock();</span><br><span class="line">    _size--;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; _size) &#123;</span><br><span class="line">        Array.Copy(_items, index + <span class="number">1</span>, _items, index, _size - index);</span><br><span class="line">    &#125;</span><br><span class="line">    _items[_size] = <span class="literal">default</span>(T);</span><br><span class="line">    _version++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>IndexOf 启用的是 Array.IndexOf 接口来查找元素的索引位置，这个接口本身内部实现是就是按索引顺序从0到n对每个位置的比较，复杂度为O(n)。</li><li>元素删除的原理其实就是用 <strong>Array.Copy 对数组进行覆盖</strong>。</li></ul><ul><li>Insert</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inserts an element into this list at a given index. The size of the list</span></span><br><span class="line"><span class="comment">// is increased by one. If required, the capacity of the list is doubled</span></span><br><span class="line"><span class="comment">// before inserting the new element.</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T item</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// Note that insertions at the end are legal.</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">uint</span>) index &gt; (<span class="built_in">uint</span>)_size) &#123;</span><br><span class="line">        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);</span><br><span class="line">    &#125;</span><br><span class="line">    Contract.EndContractBlock();</span><br><span class="line">    <span class="keyword">if</span> (_size == _items.Length) EnsureCapacity(_size + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; _size) &#123;</span><br><span class="line">        Array.Copy(_items, index, _items, index + <span class="number">1</span>, _size - index);</span><br><span class="line">    &#125;</span><br><span class="line">    _items[index] = item;</span><br><span class="line">    _size++;            </span><br><span class="line">    _version++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>与Add接口一样，先检查容量是否足够，不足则扩容。</li><li>从源码中获悉，Insert插入元素时，使用的用<strong>拷贝数组</strong>的形式，将数组里的指定元素后面的元素<u>向后移动一个位置</u>。</li></ul><blockquote><p>List的Add，Insert，IndexOf，Remove接口都是没有做过任何形式的优化，都使用的是<u>顺序迭代</u>的方式，如果过于频繁使用的话，会导致效率降低，也会造成不少内存的冗余，使得垃圾回收(GC)时承担了更多的压力。</p><p>其他相关接口比如 AddRange，RemoveRange的原理和Add与Remove一样，区别只是多了几个元素，<u>把单个元素变成了以容器为单位的形式</u>进行操作。都是先检查容量是否合适，不合适则扩容，或者当Remove时先得到索引位置再进行整体的覆盖掉后面的的元素，容器本身大小不会变化，只是做了重复覆盖的操作。</p></blockquote><h2 id="Clear"><a href="#Clear" class="headerlink" title="Clear"></a>Clear</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clears the contents of List.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Clear</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_size &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Array.Clear(_items, <span class="number">0</span>, _size); <span class="comment">// Don&#x27;t need to doc this but we clear the elements so that the gc can reclaim the references.</span></span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _version++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Clear接口在调用时并不会删除数组，而只是将数组中的元素清零，并设置 _size 为 0 而已，用于虚拟地表明当前容量为0。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>其它</p><p>Sort：快排；</p></li><li><p>【效率低】</p><p>List 的效率并不高，只是通用性强而已，大部分的算法都使用的是<strong>线性复杂度</strong>的算法，这种线性算法当遇到规模比较大的计算量级时就会导致CPU的大量损耗。</p><p>可以自己改进它，比如不再使用有线性算法的接口，自己重写一套，但凡要优化List 中的线性算法的地方都使用，我们自己制作的工具类。</p></li><li><p>【内存分配方式】</p><p>List的内存分配方式也极为不合理，当List里的元素不断增加时，会<strong>多次重新new数组</strong>，导致原来的数组被抛弃，最后当GC被调用时造成回收的压力。</p><p>我们可以<strong>提前告知 List 对象最多会有多少元素在里面</strong>，这样的话 List 就不会因为空间不够而抛弃原有的数组，去重新申请数组了。</p></li><li><p>【线程安全】</p><p>代码是线程不安全的，它并没有对多线程下做任何锁或其他同步操作。并发情况下，无法判断 _size++ 的执行顺序，因此当我们在多线程间使用 List 时加上安全机制。</p></li></ul><h2 id="如何在遍历的时候删除list中的元素"><a href="#如何在遍历的时候删除list中的元素" class="headerlink" title="如何在遍历的时候删除list中的元素"></a>如何在遍历的时候删除list中的元素</h2><p><a href="https://www.cnblogs.com/qk2014/p/4764073.html">C#遍历List并删除某个或者几个元素的方法 - 一夜秋2014 - 博客园 (cnblogs.com)</a></p><ul><li><p>foreach方法：<code>foreach</code>循环在迭代过程中<strong>依赖集合中的迭代器</strong>，而在删除元素时，会导致<strong>迭代器失效</strong>，进而导致异常的发生。</p><p>这是一个常见的陷阱，因为<code>foreach</code>循环是为<strong>只读访问集合</strong>而设计的，其内部使用的迭代器在遍历过程中会<u>对集合的状态进行检查</u>。当集合的结构在遍历期间发生变化（例如删除元素），会导致迭代器的状态不一致，从而抛出<code>InvalidOperationException</code>异常。</p></li><li><p>for正序遍历删除：由于删除之后后面元素往前补齐，而且i++，就会跳过；</p></li><li><p>for逆序遍历删除：可正确得到结果，但逆序添加元素又不同了。</p></li></ul><h2 id="List的浅复制和深复制"><a href="#List的浅复制和深复制" class="headerlink" title="List的浅复制和深复制"></a>List的浅复制和深复制</h2><p><strong>【T是值类型的情况】</strong></p><ul><li>浅复制</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt; T &gt; oldList = <span class="keyword">new</span> List&lt; T &gt;();</span><br><span class="line">oldList.Add(…);</span><br><span class="line">List&lt; T &gt; newList = oldList;<span class="comment">// 直接赋值</span></span><br></pre></td></tr></table></figure><ul><li>深复制</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt; T &gt; oldList = <span class="keyword">new</span> List&lt; T &gt;();</span><br><span class="line">oldList.Add(…);</span><br><span class="line">List&lt; T &gt; newList = <span class="keyword">new</span> List&lt; T &gt;(oldList);<span class="comment">// 构造函数传参</span></span><br></pre></td></tr></table></figure><p><strong>【T不是值类型的情况】</strong></p><p>T是引用类型或者是类的实例。</p><ul><li>浅复制</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造函数传参</span></span><br><span class="line"><span class="comment">// 【注意！！】如果oldList = new List&lt;string&gt;()&#123;&quot;a&quot;, &quot;b&quot;&#125;; 也就是这样构造的话，效果是深复制！！</span></span><br><span class="line">List&lt; T &gt; oldList = <span class="keyword">new</span> List&lt; T &gt;();</span><br><span class="line">oldList.Add(…);</span><br><span class="line">List&lt; T &gt; newList = <span class="keyword">new</span> List&lt; T &gt;(oldList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用复制函数(是否浅拷贝有待实践)</span></span><br><span class="line">List&lt; T &gt; oldList = <span class="keyword">new</span> List&lt; T &gt;();</span><br><span class="line">oldList.Add(…);</span><br><span class="line">T[] newList = <span class="keyword">new</span> T[N];</span><br><span class="line">oldList.CopyTo(newList);</span><br></pre></td></tr></table></figure><table><thead><tr><th>[CopyTo(T[], Int32))</th><th>从目标数组的指定索引处开始，将整个 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1?view=net-6.0">List</a> 复制到兼容的一维数组。</th></tr></thead><tbody><tr><td>[CopyTo(Int32, T<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.copyto?view=net-6.0#system-collections-generic-list-1-copyto(system-int32-0()-system-int32-system-int32)">], Int32, Int32)</a></td><td>从目标数组的指定索引处开始，将元素的范围从 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1?view=net-6.0">List</a> 复制到兼容的一维数组。</td></tr><tr><td>[CopyTo(T<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1.copyto?view=net-6.0#system-collections-generic-list-1-copyto(-0())">])</a></td><td>从目标数组的开头开始，将整个 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.collections.generic.list-1?view=net-6.0">List</a> 复制到兼容的一维数组。</td></tr></tbody></table><ul><li>深复制</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Extensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IList</span>&lt;<span class="title">T</span>&gt; <span class="title">Clone</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> IList&lt;T&gt; listToClone</span>) <span class="keyword">where</span> T: ICloneable</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> listToClone.Select(item =&gt; (T)item.Clone()).ToList();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当然前提是List中的对象要实现ICloneable接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p><a href="https://zhuanlan.zhihu.com/p/307436697">【c# .net】双向链表（ LinkedList ） - 知乎 (zhihu.com)</a>【使用详解】</p><p>双向链表。</p><p><img src="https://pic2.zhimg.com/80/v2-346c17d94f06f4d41381cf2b750a792d_720w.webp" alt="img"></p><p>1）LinkedList<T> <strong>无法通过下标查找元素</strong>，在查找链表元素时，总是从头结点开始查找。</T></p><p>2）LinkedList<T> 的容量是链表最大包含的元素数，会根据元素增减而<strong>动态调整容量</strong>。</T></p><p>3）LinkedList<T> 中的每个节点 都属于 <strong>LinkedListNode<T> 类型</T></strong>。</T></p><p>4）LinkedList<T> <strong>的值可以为 null，并允许重复值</strong>。</T></p><p>5）LinkedList<T> <strong>不自带排序方法。</strong></T></p><ol start="6"><li>查询复杂度为 O(n)，操作复杂度为 O(1)。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;&lt;a </summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity-术语/概念</title>
    <link href="https://huangxinhere.github.io/2023/09/04/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5/"/>
    <id>https://huangxinhere.github.io/2023/09/04/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5/</id>
    <published>2023-09-03T16:00:00.000Z</published>
    <updated>2023-09-07T06:50:03.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h1><h2 id="欧拉角和四元数"><a href="#欧拉角和四元数" class="headerlink" title="欧拉角和四元数"></a>欧拉角和四元数</h2><p><a href="https://zhuanlan.zhihu.com/p/513687673">欧拉角和四元数的通俗理解 - 知乎 (zhihu.com)</a></p><h3 id="欧拉角（Euler-Angle）"><a href="#欧拉角（Euler-Angle）" class="headerlink" title="欧拉角（Euler Angle）"></a>欧拉角（Euler Angle）</h3><p>欧拉角具有最简单直观的表示形式，即按顺序应用三个角度值。要将欧拉旋转应用于特定对象，则依次应用每个旋转值，作为围绕其对应轴的旋转。它的局限是可能导致<strong>万向节死锁问题</strong>。</p><h3 id="万向节死锁（Gimbal-Lock"><a href="#万向节死锁（Gimbal-Lock" class="headerlink" title="万向节死锁（Gimbal Lock)"></a>万向节死锁（Gimbal Lock)</h3><p><a href="https://zhuanlan.zhihu.com/p/344050856">欧拉角万向节死锁 - 知乎 (zhihu.com)</a></p><p>简单来说就是丢失了一个方向的自由度，第一个或第二个旋转可能导致第三个轴的方向与先前两个轴之一相同。</p><p>欧拉角的万向节死锁是这样：我们依次绕物体坐标系的 X 轴、Y 轴、Z 轴旋转 90°，当 Y 轴旋转了 90° 之后，物体坐标系的 Z 轴就会指向原来的 X 轴。这样一来，我们事实上只绕了 X 轴和 Y 轴两个轴旋转，第三根轴的自由度就丢失了</p><h3 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h3><p><a href="https://docs.unity.cn/cn/current/ScriptReference/Quaternion.html">Quaternion - Unity 脚本 API</a></p><p><a href="https://zhuanlan.zhihu.com/p/27471300">四元数——基本概念 - 知乎 (zhihu.com)</a></p><p><a href="https://www.zhihu.com/question/47736315">(62 封私信) 如何通俗地解释欧拉角？之后为何要引入四元数？ - 知乎 (zhihu.com)</a></p><p>四元数用于表示旋转。</p><p><strong>它们结构紧凑，不受万向锁影响，可以轻松插值。 Unity 内部使用四元数来表示所有旋转</strong></p><p><u>它们基于复数，不容易理解</u>。 您几乎不会有机会访问或修改单个四元数分量（x、y、z、w）； </p><p>大多数情况下，您只需要获取现有旋转（例如，来自 <a href="https://docs.unity.cn/cn/current/ScriptReference/Transform.html">Transform</a>），然后使用它们构造新的旋转 （例如，在两个旋转之间平滑插值）。 </p><p>您绝大多数时间使用的四元数函数为： <a href="https://docs.unity.cn/cn/current/ScriptReference/Quaternion.LookRotation.html">Quaternion.LookRotation</a>、<a href="https://docs.unity.cn/cn/current/ScriptReference/Quaternion.Angle.html">Quaternion.Angle</a>、<a href="https://docs.unity.cn/cn/current/ScriptReference/Quaternion.Euler.html">Quaternion.Euler</a>、<a href="https://docs.unity.cn/cn/current/ScriptReference/Quaternion.Slerp.html">Quaternion.Slerp</a>、<a href="https://docs.unity.cn/cn/current/ScriptReference/Quaternion.FromToRotation.html">Quaternion.FromToRotation</a> 和 <a href="https://docs.unity.cn/cn/current/ScriptReference/Quaternion-identity.html">Quaternion.identity</a>。（其他函数仅用于一些十分奇特的用例。）</p><ul><li>解决万向节死锁（Gimbal Lock）问题</li><li>仅需存储4个浮点数，相比矩阵更加轻量</li><li>四元数无论是求逆、串联等操作，相比矩阵更加高效</li></ul><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><a href="https://blog.csdn.net/xinzhilinger/article/details/116240688">(53条消息) Unity 协程(Coroutine)原理与用法详解_unity协程原理_心之凌儿的博客-CSDN博客</a></p><p>在使用<code>Unity</code>进行游戏开发时，一般（注意是一般）不考虑<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>，那么如何处理一些在【主任务之外的需求】呢，<code>Unity</code>给我们提供了协程这种方式。</p><blockquote><p>为什么在Unity中一般不考虑多线程？</p><ul><li>因为在<code>Unity</code>中，只能在主线程中获取物体的组件、方法、对象，如果脱离这些，<code>Unity</code>的很多功能无法实现，那么多线程的存在与否意义就不大了。</li></ul></blockquote><p>既然这样，线程与协程有什么区别呢：</p><ul><li>对于协程而言，<strong>同一时间只能执行一个协程</strong>，而线程则是并发的，可以同时有多个线程在运行</li><li>两者在内存的使用上是相同的，共享堆，不共享栈</li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程，从字面意义上理解就是协助程序的意思，我们在主任务进行的同时，需要一些分支任务配合工作来达到最终的效果。</p><p>稍微形象的解释一下，想象一下，在进行主任务的过程中我们需要一个对资源消耗极大的操作时候，如果在一帧中实现这样的操作，游戏就会变得十分卡顿，这个时候，我们就可以通过协程，在一定帧内完成该工作的处理，同时不影响主任务的进行。</p><h2 id="协程的原理"><a href="#协程的原理" class="headerlink" title="协程的原理"></a>协程的原理</h2><p>首先需要了解协程不是线程，<strong>协程依旧是在主线程中进行</strong>。</p><p>然后要知道协程是通过迭代器来实现功能的，通过关键字<code>IEnumerator</code>来定义一个迭代方法，相关知识查看C#知识整理。</p><p>回顾可知，由于状态机的处理，枚举器什么时候执行MoveNext要看yield return，yield return之后会进入Suspend状态，等待调用MoveNext再进入Running状态。</p><p><code>yield</code> 的使用是实现我们协程功能的主要途径，通过该关键方法，可以使得协程的运行暂停、记录下一次启动的时间与位置等等。</p><ul><li>Unity协程不允许并发？</li></ul><p>在Unity中，协程本身是不支持并发的。这是因为Unity中的所有协程都是在主线程中按顺序执行的。</p><p>虽然不能实现真正的并发，但是可以通过一些技巧来<strong>模拟并发</strong>。一种常见的做法是使用多个协程来分段处理一个任务。例如，将一个耗时的操作分成多个子任务，每个子任务作为一个协程独立执行，并在必要时相互协作完成整个任务。</p><p>另外，可以使用协程延时（yield return new WaitForSeconds）或等待异步操作（yield return www）的方式来让协程在执行过程中暂停一段时间，让其他协程有机会执行。这种方式可以模拟出一定程度的并发效果。</p><p>需要注意的是，由于协程本身是在主线程中运行的，如果在协程中进行了耗时的计算或者阻塞式的IO操作，会<strong>造成主线程的阻塞</strong>，导致UI无响应等问题。因此，在使用协程时需要特别注意避免这种情况的发生。</p><ul><li>Unity协程的底层原理？（有没有具体例子辅助理解？）</li></ul><p>在Unity中，协程的底层实现是基于<strong>迭代器（Iterator）</strong>和<strong>状态机（StateMachine）</strong>的。具体来说，当我们在脚本中使用yield语句创建一个协程时，Unity会将这个协程转化为一个迭代器，每次执行到yield语句时会将当前状态保存下来，并返回yield语句后面的值。</p><p>当协程被启动时，Unity会<u>构建一个状态机来管理协程的状态</u>，根据协程的状态不断地调用迭代器中的MoveNext方法，并获取其中返回的对象，直到迭代器中没有更多的元素或者手动停止协程为止。</p><p>由于协程和迭代器都是轻量级的对象，因此可以在主线程中快速创建、销毁和切换执行，从而实现了高效的协程调度。同时，通过利用状态机的机制，协程可以方便地控制其执行流程，支持暂停、恢复、超时等操作，非常适合处理异步事件和复杂流程的场景。</p><p>需要注意的是，虽然协程看起来像是多线程并发执行的一种方式，但它仍然是单线程的，只是通过状态机的方式模拟出了并发的效果。因此，在使用协程时需要特别注意避免阻塞主线程，以免影响应用的响应性能和稳定性。</p><h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><ul><li><p>将一个复杂程序分帧进行；</p></li><li><p>进行计时器工作；</p></li><li><p>异步加载等功能；</p><ul><li><code>AB</code>包资源的异步加载</li><li><code>Reaources</code>资源的异步加载</li><li>场景的异步加载</li><li><code>WWW</code>模块的异步请求</li></ul><p><a href="https://blog.csdn.net/xinzhilinger/article/details/110836837?ops_request_misc=%7B%22request_id%22:%22161968340716780255223084%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=161968340716780255223084&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-110836837.pc_v2_rank_blog_default&utm_term=%E5%8A%A0%E8%BD%BD&spm=1018.2226.3001.4450">Unity 场景异步加载（加载界面的实现）_unity 异步加载场景_心之凌儿的博客-CSDN博客</a></p></li></ul><p>在C#中可枚举类型一般举例都是值类型或自定义类型，在unity中，就用到内置封装好的类型。从语义来说，有几秒钟、几个帧等。这样相当于枚举“时间”，来获得分时进行的效果。</p><ul><li>StartCoroutine（string methodName）：这种是没有参数的情况，直接通过方法名（字符串形式）来开启协程；</li><li>StartCoroutine（IEnumerator routine）：通过方法形式调用；</li><li>StartCoroutine（string methodName，object values)：带参数的通过方法名进行调用；</li></ul><ul><li><code>StopCoroutine（string methodName）</code>：通过方法名（字符串）来进行</li><li><code>StopCoroutine（IEnumerator routine）</code>:通过方法形式来调用</li><li><code>StopCoroutine(Coroutine routine)</code>：通过指定的协程来关闭</li></ul><ul><li>yield return null; 暂停协程等待下一帧继续执行</li><li>yield return 0或其他数字; 暂停协程等待下一帧继续执行</li><li>yield return new WairForSeconds(时间); 等待规定时间后继续执行</li><li>yield return StartCoroutine(“协程方法名”);开启一个协程（嵌套协程)</li><li>特殊的：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> GameObject; <span class="comment">// 当游戏对象被获取到之后执行</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForFixedUpdate</span>(<span class="params"></span>)：<span class="comment">// 等到下一个固定帧数更新</span></span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>):<span class="comment">// 等到所有相机画面被渲染完毕后更新</span></span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">break</span></span>; <span class="comment">// 跳出协程对应方法，其后面的代码不会被执行</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210429103058771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnpoaWxpbmdlcg==,size_16,color_FFFFFF,t_70#pic_center" alt="yield在生命周期的执行方法"></p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="Update和FixedUpdate"><a href="#Update和FixedUpdate" class="headerlink" title="Update和FixedUpdate"></a>Update和FixedUpdate</h2><p><a href="https://blog.csdn.net/Marine_snow/article/details/117127889">Unity3D Update和FixedUpdate的区别及深入探讨_Marine_snow的博客-CSDN博客</a></p><p>为了保证在两帧间隔较大的时候依然能精准模拟物理之类的运算，一帧之间会运行多次FixedUpdate。将较大的间隔切分成多个固定的小时间段计算。</p><p>但这种切分不能是无节制的，FixedUpdate中的运算也会带来计算负荷，如果为了追上帧间隔而带来太多FixedUpdate调用会让下一帧的时间更长，而更长的帧间距则需要更多的FixedUpdate来追上，这会导致一个恶行循环，所以FixedUpdate的调用会有一个时间限制</p><p>FixedUpdate的固定时间间隔，并不是真正意义的固定的时间差。而是相对Update来说一个类似节拍器的存在。当两帧的时差过大时，Unity会 “缩放” 时间至设定的最大帧间隔（比如这里是0.333秒），在游戏中看起来就像减慢了一样（变得又卡又慢）。这个设定可以有效防止在卡顿时游戏的物理系统彻底暴走的现象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图形&quot;&gt;&lt;a href=&quot;#图形&quot; class=&quot;headerlink&quot; title=&quot;图形&quot;&gt;&lt;/a&gt;图形&lt;/h1&gt;&lt;h2 id=&quot;欧拉角和四元数&quot;&gt;&lt;a href=&quot;#欧拉角和四元数&quot; class=&quot;headerlink&quot; title=&quot;欧拉角和四元数&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity-UI</title>
    <link href="https://huangxinhere.github.io/2023/09/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-UI/"/>
    <id>https://huangxinhere.github.io/2023/09/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-UI/</id>
    <published>2023-08-31T16:00:00.000Z</published>
    <updated>2023-10-13T08:52:56.361Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.unity.cn/cn/current/Manual/UICanvas.html">画布 - Unity 手册</a></p><p><a href="https://docs.unity.cn/2021.3/Documentation/Manual/UICanvas.html">Unity - Manual: Canvas</a></p><p>Unity内置的UI组件还有 UI Toolkit、即时模式IMGUI，现在主要用的是UnityUI。</p><h1 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h1><p><a href="https://blog.csdn.net/SGamble/article/details/100658008">Unity Canvas 详解_TravelerTD的博客-CSDN博客</a>【组件更详细的说明】</p><p><strong>画布 (Canvas)</strong> 是应该容纳所有 UI 元素的区域。画布是一种带有画布组件的游戏对象，所有 UI 元素都必须是此类画布的子项。</p><h2 id="绘制元素顺序"><a href="#绘制元素顺序" class="headerlink" title="绘制元素顺序"></a>绘制元素顺序</h2><p>画布中的 UI 元素按照它们在 Hierarchy 中显示的顺序绘制。也可以通过在变换组件上使用以下方法从脚本控制顺序：SetAsFirstSibling、SetAsLastSibling 和 SetSiblingIndex。</p><h2 id="渲染模式-Render-Modes"><a href="#渲染模式-Render-Modes" class="headerlink" title="渲染模式 Render Modes"></a>渲染模式 Render Modes</h2><ul><li><p>Screen Space - Overlay</p><p>此渲染模式将 UI 元素放置于在场景之上渲染的屏幕上。如果调整屏幕大小或更改分辨率，则画布将自动更改大小来适应此情况。</p></li><li><p>Screen Space - Camera</p><p>画布放置在指定__摄像机__前面的给定距离处。UI 元素由此摄像机渲染，这意味着摄像机设置会影响 UI 的外观。如果调整屏幕大小、更改分辨率或摄像机视锥体发生改变，则画布也将自动更改大小来适应此情况。</p></li><li><p>World Space</p><p>画布的行为与场景中的所有其他对象相同。画布大小可用矩形变换进行手动设置，而 UI 元素将基于 3D 位置在场景中的其他对象前面或后面渲染。此模式对于要成为世界一部分的 UI 非常有用。这种界面也称为“叙事界面”。</p></li></ul><h1 id="UGUI和NGUI的区别"><a href="#UGUI和NGUI的区别" class="headerlink" title="UGUI和NGUI的区别"></a>UGUI和NGUI的区别</h1><p><a href="https://www.jianshu.com/p/5891e28aa766">什么是UI?unity中NGUI与UGUI的区别？ - 简书 (jianshu.com)</a></p><p>UGUI是官方4.6以后推出的一套UI组件，相对于之前的GUI倒是改头换面了，可视化操作，便捷、省心。NGUI则是unity一直以来最强的UI插件（没有之一），甚至还是官方新UI的导师。</p><p><img src="https://upload-images.jianshu.io/upload_images/4035828-aa96cf226a850983.png?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" alt="img"></p><p>UGUI由于是Unity原生支持的，所以使用上会更加的人性化。并且伴随着版本升级功能会越来越强，逐渐将成为主流ui方案。NGUI是UGUI出现之前的产物，通过MeshRenderer来实现类似CanvasRenderer的功能，概念上有点蹩脚。作为一个插件虽然已最大努力让UI开发工作变得简单，但相比能够让UnityEditor做出相应修改的UGUI（如RectTransform的出现），其易用性是没法比的。综合来说，新的项目建议使用UGUI，学习成本不高，工具流更有助于提高开发效率。</p><h1 id="UGUI原理"><a href="#UGUI原理" class="headerlink" title="UGUI原理"></a>UGUI原理</h1><p><a href="https://www.bilibili.com/video/BV17W4y1d7dY?p=7&vd_source=bd424a1eb707161ee6ba2f47e4c49a08">7.Graphic家族_哔哩哔哩_bilibili</a></p><p><a href="https://zhuanlan.zhihu.com/p/340601785">UGUI源码解析（二十七）总结篇 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/343524911">UGUI深入理解–渲染系统 - 知乎 (zhihu.com)</a></p><p>由自实现的例子可知，核心功能是UI显示（由mesh构建保存到meshFilter并由meshRender渲染：这一系列操作是必须每帧更新重新绘制？）和射线检测点击（input发射射线，并且在mesh添加碰撞器来接收）。</p><h2 id="图形绘制"><a href="#图形绘制" class="headerlink" title="图形绘制"></a>图形绘制</h2><ul><li>基础</li></ul><p>核心概念：Mesh、Vertex、Triangle、UV；</p><p>Vertex：顶点，组成Mesh的元素；</p><p>Triangle：三角形，决定顶点顺序；（伸出左手，拇指环绕朝向也就是顺时针的一面就是正面）</p><p>Mesh：网格，决定物体的形状；</p><p>UV：纹理贴图坐标；定义模型中的位置与贴图之间的位置关系。</p><p><img src="/2023/09/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-UI/hexo_github_blog\source_posts\知识整理-Unity-UI.assets\image-20230901111459137.png" alt="image-20230901111459137"></p><ul><li><p>相关类以及结构</p><p><img src="https://pic1.zhimg.com/80/v2-57d6b7f491b04ebbc6189a3dfbec6c20_720w.webp" alt="img"></p></li><li><p>大致流程：</p></li><li><p>UI组件的基类是<strong>Graphic</strong>，Graphic核心功能是组织mesh和material然后传给底层，也就是CanvasRenderer类。</p></li><li><p><strong>CanvasRenderer</strong>连接画布和渲染组件，通过CanvasRenderer把<u>网格绘制到Canvas上</u>，CR并不是直接渲染，而是交给Canvas，Canvas还要做合批等操作；</p><p>CanvasRenderer这个名字有点误导，并不是对应Canvas，而是对应Graphic。重要的接口有两个，SetMesh和SetMaterial。一次设置后，如果没有改变，不需要重复设置，底层有缓存，mesh和material可以分开设置。</p><p>每个Graphic的CanvasRenderer保存了当前元素的mesh和material，但并不会每个Graphic一个drawcall，canvas会对节点下的Graphic进行合批，所以一个Graphic设置dirty，整个canvas都需要重新计算合批，这个消耗是比较大的，合理分配canvas，对性能影响较大，这是界面渲染性能要注意的地方。</p></li><li><p>CanvasUpdateRegistry负责<strong>驱动</strong>，也就是通知需要渲染的UI组件。</p><p>那为什么用通知的方式而不是UI自己处理呢，</p><p>UGUI的处理流程：UI自己记录是否需要重新渲染，注册事件给registry，registry在要渲染的时候触发事件，UI再去提交数据。</p><p>这样的好处是，首先UI<strong>各种数据会在一帧内多次改变</strong>，肯定不能每次改变都发渲染事件，<strong>一帧处理一次效率比较高</strong>。再一个如果不发事件，那就必然要在update里写逻辑，比统一事件要麻烦些。</p></li></ul><blockquote><p>再回想以下自定义Image的例子来理解，自己实现Image渲染的时候，是在Update里面调用构建mesh和渲染的方法；而在UGUI里面，UI自己记录是否需要重新渲染，注册事件给registry，registry在要渲染的时候触发事件，UI再去更新。（往下的重绘过程有详细说明）</p></blockquote><p>一句话总结图形绘制：正常绘制和重新绘制，绘制核心是网格和渲染，网格及渲染信息由CanvasRenderer处理给Canvas做合批，重新绘制则和CanvasUpdateRegistry相关。【待打磨】</p><h2 id="基础类详解"><a href="#基础类详解" class="headerlink" title="基础类详解"></a>基础类详解</h2><p><a href="https://blog.csdn.net/VR_iShow/article/details/92850381">【Unity/笔记】UGUI基础原理__iShow_的博客-CSDN博客</a></p><ul><li><p><strong>Graphic[图形]</strong><br><code>[RequireComponent(typeof(CanvasRenderer))]</code><br><code>[RequireComponent(typeof(RectTransform))]</code></p><blockquote><p>由Unity UI系统的C#库提供的基类，所有的<u>向画布系统提供可绘制几何内容</u>的UI系统C#类都继承它。</p><p>大多数内置的UI系统绘图类都是通过 <u>MaskableGraphic 子类</u>实现的，这个子类实现了 IMaskable 接口，<u>可以被遮罩</u>。</p><p>Drawable类的主要子类是 Image 和 Text ，它们能提供与其名称相对应的内容。</p></blockquote><p>Graphic是UGUI的图形功能基类,它必须依赖CanvasRenderer与RectTransform 组件运行。</p><p>内置UI系统通过MaskableGraphic实现，使用了IMaskabel接口，可被遮罩。<br>Text和Image都继承自MaskableGraphic, ILayoutElement(及其他)</p></li></ul><ul><li><p><strong>Layout[布局]</strong><br><code>[RequireComponent(typeof(RectTransform))]</code></p><blockquote><p>Layout组件(如ScrollRect)<u>控制RectTransform的尺寸和位置</u>，它通常用于创建具有复杂布局、并且内部组件需要相对尺寸、或者相对位置的UI。</p><p>Layout组件只依赖RectTransform并且<u>只影响与其关联的RectTransform</u>的属性。他们不依赖Graphic类，并且可以独立于UI系统的Graphic类使用。</p></blockquote></li></ul><ul><li><p><strong>Canvas[画布]</strong></p><blockquote><p>画布(Canvas) 是以原生代码编写的Unity组件，画布负责<u>将其内部的几何形状合并到批处理、生成合适的渲染指令并发送到Unity图形系统</u>。</p><p>这些操作都<u>由原生C++代码</u>完成，这被称为 重新批处理(rebatch) 或 批处理构建(batch build) 。当一个画布被标记为含有需要重新批处理的几何形状时，称这个画布为 脏画布。</p></blockquote><ol><li>几何形状是由 CanvasRenderer 组件向画布提供；</li><li>批处理就是把<u>符合条件的UI元素</u>打包成一批让GPU<u>一次性</u>的把他们绘制出来；</li><li>从API调用的角度来看，Batch和Draw call是等价的，但是在游戏引擎中他们的实际意义是不一样的：<u>Batch一般指代经过打包之后的Draw call</u>。</li><li>批处理需要符合以下条件<ul><li>在同一个canvas下；</li><li>使用同一个材质；</li><li>在同一时间渲染；</li><li>RectTransform共面(深度相同)，不重叠；</li><li>在同一个父mask下(不同mask下会造成drawcall增加)</li></ul></li></ol></li></ul><ul><li><p><strong>Sub-Canvas</strong></p><blockquote><p>子画布(Sub-canvas) 是嵌套在其他画布组件内部的画布组件。</p><p>子画布能够将其孩子节点与其父画布隔离开，一个被标记为脏的子节点不会迫使其父画布重新构建几何内容，反之亦然。</p><p>有几种特殊情况会使上述情形失效，比如，改变父画布导致子画布改变尺寸。</p></blockquote><ol><li>子画布也是Canvas</li><li>子画布嵌套在主画布内</li><li>一般情况子画布能<strong>隔离</strong>脏的子节点(使两个画布内节点相互不影响但仍然保持层级关系,优化减少重新批处理的操作)</li></ol></li></ul><ul><li><p><strong>渲染细节</strong></p><blockquote><p>使用UI构建界面时，所有的几何形状都会在透明队列(Transparent queue)中绘制。从多边形栅格化而得到的每个像素都会被采样，即使它们被其他不透明多边形完全遮盖</p></blockquote><ol><li>由UI系统生成的几何形状都带有Alpha混合，从后向前地绘制</li><li>不管是否被遮挡，几何形状都会被采样绘制。</li></ol></li></ul><h2 id="合批过程（Canvases）"><a href="#合批过程（Canvases）" class="headerlink" title="合批过程（Canvases）"></a>合批过程（Canvases）</h2><p><a href="https://blog.csdn.net/sinat_25415095/article/details/112388638">Unity3D UGUI系列之合批_ugui合批_WangShade的博客-CSDN博客</a>【在Unity里面通过面板分析直观看出合批数据，非常直观清晰】</p><h3 id="什么是合批"><a href="#什么是合批" class="headerlink" title="什么是合批"></a>什么是合批</h3><blockquote><p>我们经常用引擎<u>每帧提交的批次数量</u>来作为衡量<u>渲染压力</u>的指标。</p></blockquote><blockquote><p>在批处理构建过程中，画布<strong>合并用于表示UI元素的网格(mesh)，生成合适的渲染指令发送到Unity的绘图管线</strong>。</p><p>这一过程的结果会<strong>被缓存并重用</strong>，<strong>直到画布被标记为脏画布</strong>。脏画布会在画布的任一网格构成成员发送改变时产生。</p></blockquote><blockquote><p>画布所使用的网格是从附加到画布的CanvasRenderer组件集合中获取的，但其中不会包括子画布中的组件(隔离效果)。</p></blockquote><h3 id="合批的意义"><a href="#合批的意义" class="headerlink" title="合批的意义"></a>合批的意义</h3><h3 id="合批规则"><a href="#合批规则" class="headerlink" title="合批规则"></a>合批规则</h3><blockquote><p>计算批处理需要根据深度(depth)对网格进行排序、检查网格的重叠、共享材质等情况。</p><p>这个操作是多线程的，因此在不同的CPU架构上性能差异很大，尤其是在移动版Soc芯片（通常CPU核心数少）和现代桌面CPU（通常有4个或更多核心）之间。</p></blockquote><ul><li><p>核心流程：</p><p>合并mesh(由CanvasRenderer采集,不包括子画布中组件)</p><p> —&gt; 发送渲染指令给绘图管线(会缓存) </p><p>—&gt;脏画布产生(网格成员改变)</p><p> —&gt; 重建rebuild</p></li></ul><ul><li><p>详细流程：【参考博客有例子计算，会更明白些】</p><ol><li><p>既然合批是<strong>以Canvas为单位</strong>，第一步自然就是把所有Canvas给找出来，然后剔除掉不必渲染的Canvas(透明度为0，长宽为0，在RectMask2D控件下，且在RectMask2D的区域外)</p><blockquote><p>UGUI中Canvas下可以嵌套子Canvas，但是合批是以Canvas(不包含子Canvas)为单位的(子Canvas会是另外一个批次了)。除此之外，合批的操作是在子线程完成的。</p></blockquote></li><li><p>计算Canvas下各UI控件的<strong>深度值Depth</strong>(需要注意的是Image的属性里面也有个depth，两者不是同一个东西)</p></li><li><p>Depth的计算规则如下：</p><p>按照Hierarchy中<strong>从上往下的顺序</strong>依次遍历Canvas下所有UI元素；</p><p>对于当前的UI元素CurrentUI：</p><p>i.如果CurrentUI不渲染，则Depth = -1<br>ii.如果CurrentUI要渲染，但当前层级往上并没有与其他UI元素相交，则Depth = 0<br>iii.如果CurrentUI要渲染，往上只有一个UI元素(LowerUI)与其相交，且CurrentUI与LowerUI可以合批(材质和贴图完全相同)，则CurrentUI.Depth = LowerUI.Depth；</p><p>如果两者不能合批，CurrentUI.Depth= LowerUI.Depth + 1</p><p>iv.如果CurrentUI要渲染，下面有n个元素与其相交，则按照步骤iii，分别计算出n个Depth(Depth_1、Depth_2、Depth_3…)，然后CurrentUI.Depth取其最大值，即CurrentUI.Depth = max(Depth_1, Depth_2, Depth_3，…)</p><blockquote><p>上面步骤中的“下面”和“相交”要明确下意思，这两个概念很重要。</p><p>CurrentUI下面的UI，指Hierarchy面板中，在CurrentUI之上的元素。</p><p>两个UI元素相交，是指这两个元素的网格有相交（有重叠部分），一定要注意不是两个元素的Rect区域相交。</p></blockquote></li><li><p>各个UI的Depth计算完毕后，依次按照<strong>Depth、material ID、texture ID、RendererOrder</strong>（即UI层级队列顺序，即Hierarchy面板上的顺序）排序（条件的优先级依次递减，且均为从小到大排序）。然后剔除Depth = -1的UI元素，得到Batch前的UI 元素队列，这个队列被称之为VisiableList。</p></li><li><p>得到VisiableList之后，判断VisiableList中相邻的元素<strong>是否能够合批</strong>（<u>相同的材质和贴图</u>）。需要注意这里不再考虑Depth是否相同，只要两个元素相邻然后材质和贴图相同，即使两个元素的Depth不相同，这两个元素也能合批。然后一个批次一个批次的合并网格，提交GPU进行渲染。</p></li></ol></li></ul><h3 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h3><p><a href="https://zhuanlan.zhihu.com/p/466045943">UnityUI之UGUI优化 - 知乎 (zhihu.com)</a></p><ul><li><p>动静分离（动态部分和静态部分分别使用不同的Canvas）；</p></li><li><p>避免UI元素数目过多和层次结构过于复杂影响Batch更新速度；</p></li><li><p>使用<strong>图集</strong>（避免texture ID不同导致无法合批）；</p></li><li><p>Text如果可以用图片代替就用图片代替（Ul上的字体Texture使用的是字体的图集，往往和我们自己的UI图集不一样，因此无法合批）；</p></li><li><p>避免频繁删除/增加UI对象，UI层次结构变化会引起Canvas的更新(rebuild)；</p></li><li><p>一般情况下，常常使用gameObject的active或者该UI组件的enable来进行<strong>显隐</strong>。</p><p>但参照UGUI的源码，它会在<strong>Enable的时候设置成脏标记</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">base</span>.OnEnable();</span><br><span class="line">    CacheCanvas();</span><br><span class="line">    GraphicRegistry.RegisterGraphicForCanvas(canvas, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        GraphicRebuildTracker.TrackGraphic(<span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (s_WhiteTexture == <span class="literal">null</span>)</span><br><span class="line">            s_WhiteTexture = Texture2D.whiteTexture;</span><br><span class="line"></span><br><span class="line">    SetAllDirty();<span class="comment">//设置所有脏标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时可以通过两个方面来进行显隐：</p><ul><li>对于单个UI可以设置GetComponent<CanvasRenderer>().cull来控制</CanvasRenderer></li><li>而多个UI可以通过父物体挂上CanvasGroup，修改Alpha值来控制(??)</li></ul></li><li><p>尽量不要使用Mask（其内部使用了模板缓冲，至少会造成增加2个Draw Call）</p><p><img src="/2023/09/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-UI/hexo_github_blog\source_posts\知识整理-Unity-UI.assets\image-20230904150757537.png" alt="image-20230904150757537"></p><p><img src="/2023/09/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-UI/hexo_github_blog\source_posts\知识整理-Unity-UI.assets\image-20230904150945509.png" alt="image-20230904150945509"></p><blockquote><p>相邻的两个Image合并，而多了两个Mask，并且Image合并被打断</p></blockquote></li></ul><h2 id="重绘过程（Graphics）"><a href="#重绘过程（Graphics）" class="headerlink" title="重绘过程（Graphics）"></a>重绘过程（Graphics）</h2><p>重绘过程是指Unity UI 的 图形组件的排版和网格被重新计算。这在 CanvasUpdateRegistry类中执行。当Canvas组件触发WillRenderCanvases事件时都会调用这个方法。这个事件每一帧都会执行一次。在CanvasUpdateRegistry内部，需要关注的方法是PerformUpdate。</p><h3 id="大致理解"><a href="#大致理解" class="headerlink" title="大致理解"></a>大致理解</h3><p>也从一个简单的demo开始调试理解。demo内容是，点击button<strong>触发某个Image换颜色</strong>。</p><ul><li>更改颜色，触发SetVerticesDirty();</li><li>SetVerticesDirty()——Register…Rebuild：加入某个队列；</li><li>PerformUpdate(): 应用了队列，取element，调用它的Rebuild</li><li>如果标记了dirty，就进行UpdateGeometry…OnPopulateMesh…Generate…最后更改颜色。</li></ul><p><img src="/2023/09/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-UI/hexo_github_blog\source_posts\知识整理-Unity-UI.assets\image-20230901120719354.png" alt="image-20230901120719354"></p><blockquote><p>③把更改放进队列里面去，并由PerformUpdate调用④，由于Rebuild接口被Graphic实现，Image又继承Graphic，经过一系列的调用回到⑥</p><p>概括来说，被更改的元素存了下来，并在performUpdate又放出来调用自己的Rebuild</p></blockquote><p>那PerformUpdate在哪里调用了？这个方法被注册进Canvas.willRenderCanvases（在渲染之前调用）里面去了。</p><p><img src="/2023/09/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-UI/hexo_github_blog\source_posts\知识整理-Unity-UI.assets\image-20230901121506723.png" alt="image-20230901121506723"></p><h3 id="缓存和重建：CanvasUpdateRegistry"><a href="#缓存和重建：CanvasUpdateRegistry" class="headerlink" title="缓存和重建：CanvasUpdateRegistry"></a><strong>缓存和重建：CanvasUpdateRegistry</strong></h3><p><a href="https://www.cnblogs.com/chenggg/p/11184784.html">关于UGUI底层的小知识—上 (转雨松momo) - 深秋大街道 - 博客园 (cnblogs.com)</a></p><ul><li><p>【缓存要更改的元素】通常UGUI界面操作卡大概率都是Canvas.SendWillRenderCanvases()方法耗时，需要检查<u>界面是否存在多余或者无用的重建情况</u>。由于界面很多我们无法定位到到底是哪个界面下的哪个元素引起了网格重建。通过观察CanvasUpdateRegistry.cs源代码，我们发现需要网格重建的元素都被缓存在这两个对象中。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记更改 Graphic.cs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> abstract <span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>:</span> UIBehaviour,ICanvasElement</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBeforeTransformParentChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        GraphicRegistry.<span class="built_in">UnregisterGraphicForCanvas</span>(canvas, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//布局发生变化</span></span><br><span class="line">        LayoutRebuilder.<span class="built_in">MarkLayoutForRebuild</span>(rectTransform);</span><br><span class="line">        <span class="comment">//LayoutRebuilder.MarkLayoutForRebuild方法内部实现</span></span><br><span class="line">        <span class="comment">//private static void MarkLayoutRootForRebuild(RectTransform controller)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//    if (controller == null)</span></span><br><span class="line">        <span class="comment">//        return;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//    var rebuilder = s_Rebuilders.Get();</span></span><br><span class="line">        <span class="comment">//    rebuilder.Initialize(controller);</span></span><br><span class="line">        <span class="comment">//    局部发生变化，会通过TryRegisterCanvasElementForLayoutRebuild()将自己加入待布局重建队列</span></span><br><span class="line">        <span class="comment">//    if (!CanvasUpdateRegistry.TryRegisterCanvasElementForLayoutRebuild(rebuilder))</span></span><br><span class="line">        <span class="comment">//        s_Rebuilders.Release(rebuilder);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetMaterialDirty</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">IsActive</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        m_MaterialDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//渲染发生变化，会通过RegisterCanvasElementForGraphicRebuild()将自己加入待渲染队列</span></span><br><span class="line">        CanvasUpdateRegistry.<span class="built_in">RegisterCanvasElementForGraphicRebuild</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_OnDirtyMaterialCallback != null)</span><br><span class="line">            <span class="built_in">m_OnDirtyMaterialCallback</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 将标记放入缓存队列</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanvasUpdateRegistry</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">      <span class="comment">//...略</span></span><br><span class="line">      <span class="comment">//保存待重建布局元素（如：RectTransform变化）</span></span><br><span class="line">      <span class="keyword">private</span> readonly IndexedSet&lt;ICanvasElement&gt; m_LayoutRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line">      <span class="comment">//保存待重建渲染元素（如：Image变化）</span></span><br><span class="line">      <span class="keyword">private</span> readonly IndexedSet&lt;ICanvasElement&gt; m_GraphicRebuildQueue = <span class="keyword">new</span> IndexedSet&lt;ICanvasElement&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">* 【更改缓存队列里的元素（在PerformUpdate里面👇）】由此可见，&lt;u&gt;UI发生变化一般分两种情况&lt;/u&gt;，一种是修改了宽高这样会影响到顶点位置需要重建Mesh，还有一种仅仅只修改了显示元素，这样并不会影响顶点位置，此时unity会在代码中区别对待。</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanvasUpdateRegistry</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">      <span class="comment">//...略</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="title">CanvasUpdateRegistry</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="comment">//构造函数处委托函数到PerformUpdate()方法中</span></span><br><span class="line">          <span class="comment">//每次Canvas.willRenderCanvases就会执行PerformUpdate()方法</span></span><br><span class="line">          Canvas.willRenderCanvases += PerformUpdate;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PerformUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="comment">//开始BeginSample()</span></span><br><span class="line">          <span class="comment">//在Profiler中看到的标志性函数Canvas.willRenderCanvases耗时就在这里了</span></span><br><span class="line">          <span class="comment">//EndSample()</span></span><br><span class="line">          UISystemProfilerApi.<span class="built_in">BeginSample</span>(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">          <span class="built_in">CleanInvalidItems</span>();</span><br><span class="line">  </span><br><span class="line">          m_PerformingLayoutUpdate = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//需要重建的布局元素(RectTransform发生变化)，首先需要根据子对象的数量对它进行排序。</span></span><br><span class="line">          m_LayoutRebuildQueue.<span class="built_in">Sort</span>(s_SortLayoutFunction);</span><br><span class="line">          <span class="comment">//遍历待重建布局元素队列，开始重建</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="keyword">int</span>)CanvasUpdate.PostLayout; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m_LayoutRebuildQueue.Count; j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  var rebuild = instance.m_LayoutRebuildQueue[j];</span><br><span class="line">                  <span class="keyword">try</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      <span class="keyword">if</span> (<span class="built_in">ObjectValidForUpdate</span>(rebuild))</span><br><span class="line">                          rebuild.<span class="built_in">Rebuild</span>((CanvasUpdate)i);<span class="comment">//重建布局元素</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="built_in"><span class="keyword">catch</span></span> (Exception e)</span><br><span class="line">                  &#123;</span><br><span class="line">                      Debug.<span class="built_in">LogException</span>(e, rebuild.transform);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_LayoutRebuildQueue.Count; ++i)</span><br><span class="line">              m_LayoutRebuildQueue[i].<span class="built_in">LayoutComplete</span>();</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//布局构建完成后清空队列</span></span><br><span class="line">          instance.m_LayoutRebuildQueue.<span class="built_in">Clear</span>();</span><br><span class="line">          m_PerformingLayoutUpdate = <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// 布局构建结束，开始进行Mask2D裁切（详细内容下面会介绍）</span></span><br><span class="line">          ClipperRegistry.instance.<span class="built_in">Cull</span>();</span><br><span class="line">  </span><br><span class="line">          m_PerformingGraphicUpdate = <span class="literal">true</span>;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//需要重建的Graphics元素(Image Text RawImage 发生变化)</span></span><br><span class="line">          <span class="keyword">for</span> (var i = (<span class="keyword">int</span>)CanvasUpdate.PreRender; i &lt; (<span class="keyword">int</span>)CanvasUpdate.MaxUpdateValue; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">for</span> (var k = <span class="number">0</span>; k &lt; instance.m_GraphicRebuildQueue.Count; k++)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">try</span></span><br><span class="line">                  &#123;</span><br><span class="line">                      var element = instance.m_GraphicRebuildQueue[k];</span><br><span class="line">                      <span class="keyword">if</span> (<span class="built_in">ObjectValidForUpdate</span>(element))</span><br><span class="line">                          element.<span class="built_in">Rebuild</span>((CanvasUpdate)i);<span class="comment">//重建UI元素</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="built_in"><span class="keyword">catch</span></span> (Exception e)</span><br><span class="line">                  &#123;</span><br><span class="line">                      Debug.<span class="built_in">LogException</span>(e, instance.m_GraphicRebuildQueue[k].transform);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//这里需要思考的是，有可能一个Image对象，RectTransform和Graphics同时发生了修改，它们的更新含义不同需要区分对待</span></span><br><span class="line">          <span class="comment">//1.修改了Image的宽高，这样Mesh的顶点会发生变化，此时该对象会加入m_LayoutRebuildQueue队列</span></span><br><span class="line">          <span class="comment">//2.修改了Image的Sprite，它并不会影响顶点位置信息，此时该对象会加入m_GraphicRebuildQueue队列</span></span><br><span class="line">          <span class="comment">//所以上面代码在遍历的时候会分层</span></span><br><span class="line">          <span class="comment">//for (int i = 0; i &lt;= (int)CanvasUpdate.PostLayout; i++)</span></span><br><span class="line">          <span class="comment">//for (var i = (int)CanvasUpdate.PreRender; i &lt; (int)CanvasUpdate.MaxUpdateValue; i++)</span></span><br><span class="line">          <span class="comment">//Rebuild的时候会把层传进去，保证Image知道现在是要更新布局，还是只更新渲染。</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_GraphicRebuildQueue.Count; ++i)</span><br><span class="line">              m_GraphicRebuildQueue[i].<span class="built_in">GraphicUpdateComplete</span>();</span><br><span class="line">  </span><br><span class="line">          instance.m_GraphicRebuildQueue.<span class="built_in">Clear</span>();</span><br><span class="line">          m_PerformingGraphicUpdate = <span class="literal">false</span>;</span><br><span class="line">          UISystemProfilerApi.<span class="built_in">EndSample</span>(UISystemProfilerApi.SampleType.Layout);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>标记为dirty的排版组件通过ICanvasElement.Rebuild方法<strong>重建布局</strong>，排版重建分成三个过程（PreLayout, Layout 和 PostLayout）。</li><li>任何注册过的裁剪组件（如mask），需要去<strong>裁剪所有可剔除的组件</strong>。这是通过ClippingRegistry.Cull实现的。</li><li>被标记为dirty的图形组件，通过ICanvasElement.Rebuild方法重建它们的图形元素，<strong>重建图形</strong>包含两个过程（PreRender 和 LatePreRender）。</li></ul><blockquote><p>Layout和Graphic的重建过程会被拆分成多个部分。</p><p>Layout重建分3步完成(PreLayout,Layout和PostLayout),</p><p>Graphic重建分2步完成(PreRender和LatePreRender)</p></blockquote><h3 id="重绘触发的条件"><a href="#重绘触发的条件" class="headerlink" title="重绘触发的条件"></a>重绘触发的条件</h3><p>enable，disable，validate都会触发</p><ul><li><strong>SetVerticesDirty</strong></li></ul><p>MeshEffect有变化</p><p>shadow属性改版</p><p>transform大小改变</p><p>image类型改变，层级改变，填充方式改变</p><p>RawImage：texture改变，uvRect改变，触发动画效果</p><p>text内容改变，开关richtex，等等很多，text是最频繁dirty的</p><ul><li><strong>SetMaterialDirty</strong></li></ul><p>material替换</p><p>Image触发动画</p><p>显示mask，设置是否开启mask</p><p>transform层级变化</p><p>canvas层级变化</p><p>重新计算mask</p><p>RawImage替换texture，使触发动画</p><ul><li><strong>同时dirty，包括layout</strong></li></ul><p>transform层级改变</p><p>Sprite替换，改变图片大小，替换图集</p><p>字体改变，字体图集变化</p><p>【待细究……】</p><h3 id="布局重建（详细）"><a href="#布局重建（详细）" class="headerlink" title="布局重建（详细）"></a>布局重建（详细）</h3><blockquote><p>必须<strong>根据Layout层级顺序</strong>计算那些包含在Layout中的组件的位置和尺寸。在Game Object层级中，离根节点近的Layout有可能会改变嵌套在在它里面的Layout的位置和尺寸，所以它需要被先计算。</p></blockquote><blockquote><p>为此，UI系统依据<strong>Layout在层级中的深度</strong>对脏Layout列表中的Layout进行排序，高层的（例如，父Transform更少）的项会被移动到列表的前面。</p></blockquote><blockquote><p><strong>排序后的Layout组件列表</strong>接下来要重建布局。这时被Layout组件控制的UI元素的位置和尺寸会发生改变。有关<strong>Layout如何影响每个元素的位置</strong>的详细叙述，请查看Unity手册中的<a href="https://docs.unity3d.com/Manual/UIAutoLayout.html">UI Auto Layout</a></p></blockquote><p><strong>自动布局系统按以下顺序评估和执行布局：</strong></p><ol><li>通过调用ILayoutElement组件上的CalculateLayoutInputHorizontal来计算布局元素的最小值，首选值和灵活宽度。这是以<strong>自下而上的顺序</strong>进行的，<strong>孩子在父母面前计算</strong>，这样父母可以在他们自己的计算中考虑到孩子的信息。</li><li>通过调用ILayoutController组件上的SetLayoutHorizontal，根据父对象的可用宽度，来计算和设置子对象布局元素的宽度。这是按照<strong>自上而下的顺序</strong>执行的，因为孩子的父母分配的子宽度需要根据父母的可用宽度进行分配。在这一步之后，布局元素的Rect变换具有新的宽度。</li><li>通过调用ILayoutElement组件的CalculateLayoutInputVertical来计算布局元素的最小值，首选值和灵活高度。这是以<strong>自下而上的顺序</strong>进行的，孩子在父母面前计算，这样父母可以在他们自己的计算中考虑到孩子的信息。</li><li>通过调用ILayoutController组件的SetLayoutVertical，根据父对象的可用高度，来计算和设置子对象布局元素的高度。这是按照自上而下的顺序执行的，因为子女的高度需要根据父母的可用高度计算，子女是在父母之后计算的。在这一步之后，布局元素的Rect变换有了新的高度。</li></ol><p><strong>何时触发布局重建：</strong></p><ul><li>更改LayoutElement布局元素的属性时，比如修改Min Width，Preferred Width等属性。</li><li><strong>在OnEnable和OnDisable中</strong></li><li>OnRectTransformDimensionsChange<strong>（RectTransform大小发生改变时）</strong></li><li>OnValidate （只能编辑器中，非运行状态）</li><li>OnDidApplyAnimationProperties（应用动画属性时）</li></ul><h3 id="图形重建（详细）"><a href="#图形重建（详细）" class="headerlink" title="图形重建（详细）"></a>图形重建（详细）</h3><p><strong>Rebuild方法</strong></p><p>在Canvas渲染前被调用，在这个方法里会调用UpdateGeometry和UpdateMaterial更新顶点和材质。</p><p><img src="https://img2018.cnblogs.com/blog/1296185/201907/1296185-20190714165439386-1677932551.png" alt="img"></p><p><strong>UpdateGeometry方法</strong></p><p>确定每一个UI元素Mesh的信息，包括顶点数据、三角形数据、UV数据、顶点色数据。如下代码所示，无论Image还是Text数据都会在OnPopulateMesh函数中进行收集，它是一个虚函数会在各自的类中实现。</p><p><img src="https://img2018.cnblogs.com/blog/1296185/201907/1296185-20190714165509919-914957298.png" alt="img"></p><ul><li>调用<strong>DoMeshGeneration</strong>方法，</li><li>如果rectTransform不为空，且宽高都大于0，调用<strong>OnPopulateMesh</strong>，实际上只是把顶点和三角形信息保存到了s_VertexHelper里。</li><li>然后获取所有的<strong>IMeshModifier</strong>类型的组件，（IMeshModifier是一个接口，需要依据顶点信息的组件继承自它，例如Shadow就间接继承自它），调用IMeshModifier的ModifyMesh方法，修改Mesh信息。</li><li>最后将s_VertexHelper里修改后的信息设置给canvasRenderer。<strong>概括的说就是，把顶点和三角形信息进行修改，并设置给CanvasRenderer。</strong></li><li>顶点数据准备完毕后会调用canvasRenderer.SetMesh()方法来提交。很遗憾CanvasRenderer.cs并没有开源，我们只能继续反编译看它的实现了，如下代码所示，SetMesh()方法最终在C++中实现，毕竟由于UI的元素很多，同时参与合并顶点的信息也会很多，在C++中实现效率会更好。看到这里，我相信大家应该能明白UGUI为什么效率会被NGUI要高一些了，因为NGUI的网格Mesh合并都是在C#中完成的，而<strong>UGUI网格合并都是在C++中底层中完成的</strong>。 </li></ul><p><strong>UpdateMaterial方法</strong></p><p><strong>更新canvasRenderer的材质和纹理。</strong>在给canvasRenderer设置材质时，会遍历所有IMaterialModifier类型的组件，调用IMaterialModifier.GetModifiedMaterial方法，用于重建图像时，获取修改后的Material，来实现遮罩效果。</p><h3 id="重建总结"><a href="#重建总结" class="headerlink" title="重建总结"></a>重建总结</h3><ul><li><p>在UGUI中，网格的更新或重建（为了尽可能合并UI部分的DrawCall）是以Canvas为单位的，且只在其中的UI元素发生变动（位置、颜色等）时才会进行。因此，将<strong>动态UI元素与静态UI元素分离</strong>后，可以将动态UI元素的变化所引起的网格更新或重建所涉及到的范围变小，从而降低一定的开销。</p></li><li><p>重建中更新指的是UI元素本身的某些属性发生变化，从而需要重新生成，或者更新顶点属性。比如颜色变了，在UGUI中颜色的变化是通过修改顶点色实现的，所以就需要更新UI元素对应的每个顶点的顶点色属性（可以认为就是修改下某个数组里的数值）。</p><p> UI元素和别的网格不同点在于，UI的网格是需要进行<strong>合并</strong>的，并且在UGUI中是<strong>以Canvas为单位</strong>的，在提交GPU之前，同一Canvas下的所有UI元素都会被合入一个Mesh中（但包含多个SubMesh）。</p><p>所以位置的移动，顶点属性的变化，都会<strong>导致这个Mesh要重新合并</strong>，也就是网格重建。这也是为什么说要“动静分离”的原因，完全静态的Canvas是不需要重建的，但只要里面有一个UI元素在动，就会引起Canvas的重建。</p></li><li><p>在UGUI里更改了Image的Color属性，其原理是修改顶点色，因此是会引起网格的Rebuild的。通过修改顶点色来实现UI元素变色的好处在于，<strong>修改顶点色可以保证其材质不变，因此不会产生额外的Draw Call</strong>。在UI的默认Shader中存在一个Tint Color的变量，正常情况下，该值为常数(1,1,1)，且并不会被修改。如果是用脚本访问Image的Material，并修改其上的Tint Color属性时，对UI元素产生的网格信息并没有影响，因此就不会引起网格的Rebuild。但这样做因为修改了材质，所以会增加一个Draw Call。（？</p></li></ul><h2 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h2><p>UGUI的层叠顺序是按照Hierarchy中的顺序从上往下进行的，也就是越靠上的组件，就会被绘制在越底部。</p><ul><li><p>渲染顺序</p></li><li><p>Unity3d中的渲染顺序如下：<br> 不同的<strong>Camera</strong>的Depth<br> 相同Camera下的不同SortingLayer<br> 相同<strong>SortingLayer</strong>下的不同Z轴/Order in Layer</p></li><li><p>改变控件之间的层级关系</p><ol><li>同一canvas下：<br>   改变控件transform的SiblingIndex,<br>   transform.GetSiblingIndex();<br>   transform.SetSiblingIndex(int index); //index值越大，越后渲染，层级越大，越显示在前面</li><li>不同Canvas下：<br>  设置Canvas下的Sort Order //Sort Order值越大，越后渲染，层级越大，越显示在前面</li></ol></li></ul><hr><p>创建任意UGUI元素时自动生成一个Canvas物体，Canvas下的所有物体从上往下渲染，即排在下面的会遮盖排上面的。同理，子元素会覆盖父元素。</p><p>在游戏运行中如何修改UGUI的显示层级？<br>在代码中调整该元素的层级位：使用RectTransform类的函数。</p><ul><li>SetAsFirstSibling：移动到所有兄弟节点的第一个位置（Hierarchy同级最上面，先渲染，显示在最下面）</li><li>SetAsLastSibling：移动到所有兄弟节点的最后一个位置（Hierarchy同级最下面，后渲染，显示在最上面）</li><li>GetSiblingIndex：获得该元素在当前兄弟节点层级的位置</li><li>SetSiblingIndex：设置该元素在当前兄弟节点层级的位置</li></ul><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><p><a href="https://zhuanlan.zhihu.com/p/339378916">【详细解析版】Unity UGUI Mask组件实现原理 - 知乎 (zhihu.com)</a></p><blockquote><p>另：模板测试详解看UnityShader初级入门篇。</p></blockquote><p>两个方式，Rect2DMask和mask，只对子节点生效，理论上可以改源码，一般没啥必要改。</p><p><strong>RectMask2D</strong></p><p>只能遮挡矩形范围，类似NGUIpanel的裁剪方式。这种方式<strong>不增加drawcall</strong>，比mask性能高些，但是只能遮挡矩形区域。</p><p>shader部分，定义UNITY_UI_CLIP_RECT，color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect);实现裁剪。</p><p>代码部分，调用CanvasRenderer的EnableRectClipping方法，传遮挡区域，底层设置给_ClipRect。</p><p>RectMask2D节点下的maskable组件，注册到ClipperRegistry类，底层控制对应的shader打开宏定义。</p><p><strong>Mask</strong></p><p>原理设置模板缓冲值，通过测试的像素才能显示，从而只在指定范围内显示图像。透明度为0的区域不显示。</p><ul><li>实现方式</li></ul><p>将渲染分3个步骤，首先渲染mask，设置模板缓冲的值，然后渲染模板下的对象，判断模板缓冲值，相同才渲染，也就是在根节点定义的区域内（Mask子物体中）渲染，最后将模板缓冲区设置为0。</p><ul><li>原理</li></ul><ol><li><p>Mask对象有模板测试：</p><p>Mask的关键代码其实只有一行，如下（为方便理解，对代码做了简化处理）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maskMaterial = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Replace, CompareFunction.Always);</span><br></pre></td></tr></table></figure><p>它的作用是<strong>为Mask对象生成一个特殊的材质，这个材质会将StencilBuffer的值置为1</strong>。</p></li><li><p>需要遮罩效果的对象也有模板测试：</p><p>同样的，在Image，Text和RawImage的基类 MaskableGraphic 中，有这样一行关键代码（为方便理解，对代码做了简化处理）：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maskMat = StencilMaterial.Add(baseMaterial, <span class="number">1</span>, StencilOp.Keep, CompareFunction.Equal, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>它的作用是<strong>为MaskableGraphic生成一个特殊的材质，这个材质在渲染时会取出StencilBuffer的值，判断是否为1，如果是才进行渲染。</strong></p></li></ol><blockquote><p>上述对StencilBuffer的操作是逐像素的，这样即达到了Mask的效果。</p><p>简单来说，<strong>gpu为每个像素点分配一个称之为stencil buffer的1字节大小的内存区域，这个区域可以用于保存或丢弃像素的目的。</strong></p></blockquote><ul><li>缺点</li></ul><ol><li>打乱合批。</li><li>圆形边缘锯齿明显，原因是并不支持边缘渐变，只有显示和不显示两个状态。</li><li>遮挡效果只是显示，点击逻辑还是完整的区域，一般常用的，扩展一个图形更好，比如圆形</li></ol><h2 id="图集"><a href="#图集" class="headerlink" title="图集"></a>图集</h2><h2 id="输入系统"><a href="#输入系统" class="headerlink" title="输入系统"></a>输入系统</h2><p><a href="https://blog.csdn.net/woodengm/article/details/123393108">Unity中的UGUI源码解析之事件系统(1)-概述_unity事件系统源码_拂面清风三点水的博客-CSDN博客</a></p><p>广义的<strong>事件系统</strong>是指Unity中整个事件相关的一整个系统, 而狭义的<strong>事件系统</strong>指的是一个专门的组件: <strong>EventSystem</strong>.</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>事件系统</strong>主要负责:</p><ul><li>处理输入</li><li>射线投射</li><li>发送事件</li></ul><p><strong>事件系统</strong>主要由以下几个部分组成:（整个<strong>事件系统</strong>由很多角色组成, 互相协作来完成事件相关工作.）</p><ul><li><code>EventSystem</code>组件</li><li>输入模块(InputModule): <code>BaseInputModule</code>和其子类</li><li>射线投射器(Raycaster)</li><li>消息系统</li><li>各种支持的事件</li><li>事件触发器(EventTrigger)</li></ul><h3 id="EventSystem"><a href="#EventSystem" class="headerlink" title="EventSystem"></a>EventSystem</h3><p><a href="https://blog.csdn.net/woodengm/article/details/123416615">Unity中的UGUI源码解析之事件系统(2)-EventSystem组件_unity eventsystem raycastcomparer_拂面清风三点水的博客-CSDN博客</a></p><p><strong>EventSystem</strong>相当于<strong>事件系统的管理器</strong>, 负责协调各个模块.</p><p><strong>EventSystem</strong>主要负责:</p><ul><li><strong>事件系统</strong>对外的接口</li><li>负责各个事件相关模块之间通讯的管理和协调</li><li>管理选中的游戏对象</li><li>管理正则使用的输入模块</li><li>管理射线投射</li><li>根据需要更新所有的输入模块</li></ul><p><strong>EventSystem</strong>需要与其它组件协同工作, 根据任务不同, 搭配的组件不同, Unity建议我们一个场景只有一个<strong>EventSystem</strong>, 当然, 这并不是强制要求.</p><p>在一个场景中添加任意的UI控件, 会默认添加一个EventSystem对象, 身上挂载EventSystem组件和一个StandaloneInputModule(独立输入模块)组件. 各种事件要生效, 场景中至少需要一个EventSystem. 但是也可以存在多个, 但是只会生效一个.</p><blockquote><p>Unity默认会从挂载<strong>EventSystem</strong>组件的对象上查找输入模块并添加到其内部列表中进行管理和配合使用.</p></blockquote><h3 id="输入模块-InputModule"><a href="#输入模块-InputModule" class="headerlink" title="输入模块(InputModule)"></a>输入模块(InputModule)</h3><p>输入模块主要处理输入, 也是整个<strong>事件系统</strong>的主要部分, Unity提供了下面的几个类来抽象输入的处理:</p><ul><li><strong>BaseInputModule</strong>:整个输入模块的基类</li><li><strong>PointerInputModule : BaseInputModule</strong>: 处理<u>指针设备输入</u>的基类</li><li><strong>StandaloneInputModule: PointerInputModule</strong>: 独立输入模块, 目前是主要的输入处理模块</li><li>TouchInputModule : PointerInputModule: 处理触摸事件输入, (已经废弃, 内容包含到StandaloneInputModule中)</li></ul><blockquote><p>指针输入(PointerInput)：</p><p><strong>指针输入设备</strong>指的是那些在2d表面追踪输入位置的设备, 事件系统支持的指针输入有: <strong>触摸, 鼠标和触控笔</strong>. <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/manual/Pointers.html">详情在这里</a>. 虽然这里面讲的是新的输入系统, 但是概念是一样的, 不影响理解.</p></blockquote><h3 id="射线投射器（Raycaster）"><a href="#射线投射器（Raycaster）" class="headerlink" title="射线投射器（Raycaster）"></a>射线投射器（Raycaster）</h3><p>这就是经常听到的射线检测器, 原理是在点击或者触摸的位置发射一条射线, 然后收集所有被射线穿透的对象, 然后返回最可能(比如最接近屏幕的对象)的目标. 供<strong>事件系统</strong>使用.</p><p>Unity提供了三种射线投射器:</p><ul><li><strong>图形射线投射器 (Graphic Raycaster)</strong>, 一般用于UI元素, 常挂载在Canvas上, 用于遍历该Canvas的各个元素. 就是说没有这个组件就无法触发各种UI事件.</li><li><strong>2D 物理射线投射器 (Physics 2D Raycaster)</strong>, 用于<u>2D物理元素</u>的检测, 需要对象身上有碰撞盒子(Collider)</li><li><strong>物理射线投射器 (Physics Raycaster)</strong> - 用于 3D 物理元素, 需要对象身上有碰撞盒子(Collider)</li></ul><p>只要场景中存在射线投射器, 然后从输入模块发出检测请求, 那么事件系统就会使用它, 这是通过射线管理器(<code>RaycasterManager</code>)来实现的.</p><h3 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h3><p>UGUI使用了新的消息系统来处理<strong>消息分发</strong>, 这个实现很巧妙, 没有使用常规的显得比较繁重的消息系统, </p><p>而是使用了一个静态的类ExecuteEvents和一个消息接口IEventSystemHandler, 通过每次分发时查询对象身上的<strong>实现了IEventSystemHandler接口</strong>的所有组件, 然后向这些组件分发消息, 消息系统本身不维护消息和其处理器.</p><h3 id="各种支持的事件"><a href="#各种支持的事件" class="headerlink" title="各种支持的事件"></a>各种支持的事件</h3><p>事件系统所有的事件都实现<code>IEventSystemHandler</code>接口, 这是消息系统的基础, Unity提供了以下<strong>事件</strong>:</p><blockquote><p>接收对应事件并<strong>执行</strong>自己的自定义响应方法。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IPointerEnterHandler - OnPointerEnter <span class="comment">// 当指针进入对象时调用</span></span><br><span class="line">IPointerExitHandler - OnPointerExit <span class="comment">// 当指针退出对象时调用</span></span><br><span class="line">IPointerDownHandler - OnPointerDown <span class="comment">// 在对象上按下指针时调用</span></span><br><span class="line">IPointerUpHandler - OnPointerUp - <span class="function">Called <span class="keyword">when</span> a pointer <span class="keyword">is</span> <span class="title">released</span> (<span class="params">called <span class="keyword">on</span> the original the pressed <span class="built_in">object</span></span>)</span></span><br><span class="line"><span class="function">IPointerClickHandler - OnPointerClick - 在同一对象上按下再松开指针时调用</span></span><br><span class="line"><span class="function">IInitializePotentialDragHandler - OnInitializePotentialDrag - 在找到拖动目标时调用，可用于初始化值</span></span><br><span class="line"><span class="function">IBeginDragHandler - OnBeginDrag - 即将开始拖动时在拖动对象上调用</span></span><br><span class="line"><span class="function">IDragHandler - OnDrag - 发生拖动时在拖动对象上调用</span></span><br><span class="line"><span class="function">IEndDragHandler - OnEndDrag - 拖动完成时在拖动对象上调用</span></span><br><span class="line"><span class="function">IDropHandler - OnDrop - 在拖动目标对象上调用</span></span><br><span class="line"><span class="function">IScrollHandler - OnScroll - 当鼠标滚轮滚动时调用</span></span><br><span class="line"><span class="function">IUpdateSelectedHandler - OnUpdateSelected - 每次勾选时在选定对象上调用</span></span><br><span class="line"><span class="function">ISelectHandler - OnSelect - 当对象成为选定对象时调用</span></span><br><span class="line"><span class="function">IDeselectHandler - OnDeselect - 取消选择选定对象时调用</span></span><br><span class="line"><span class="function">IMoveHandler - OnMove <span class="comment">// 发生移动事件（上、下、左、右等）时调用</span></span></span><br><span class="line"><span class="function">ISubmitHandler - OnSubmit - 按下 Submit 按钮时调用</span></span><br><span class="line"><span class="function">ICancelHandler - OnCancel - 按下 Cancel 按钮时调用</span></span><br></pre></td></tr></table></figure><p>通过在Monobehavior脚本上实现这些接口就能接收事件. 也可以直接实现<code>IEventSystemHandler</code>接口, 自定义消息. 示例如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NavigationEventTest</span> : <span class="title">MonoBehaviour</span>, <span class="title">IMoveHandler</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnMove</span>(<span class="params">AxisEventData eventData</span>)</span> &#123;</span><br><span class="line">Debug.LogError(<span class="string">&quot;onMove: &quot;</span> + eventData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomMessageTarget</span> : <span class="title">IEventSystemHandler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可通过消息系统调用的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Message1</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Message2</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomMessageTarget</span> : <span class="title">MonoBehaviour</span>, <span class="title">ICustomMessageTarget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Message1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log (<span class="string">&quot;Message 1 received&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Message2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log (<span class="string">&quot;Message 2 received&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExecuteEvents.Execute&lt;ICustomMessageTarget&gt;(target, <span class="literal">null</span>, (x,y)=&gt;x.Message1());</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="事件触发器-EventTrigger"><a href="#事件触发器-EventTrigger" class="headerlink" title="事件触发器(EventTrigger)"></a>事件触发器(EventTrigger)</h3><p>上面添加事件的方式需要脚本实现事件接口, 我们也可以通过事件触发器来拦截所有事件, 处理我们想要处理的事件.</p><p>有两种事件事件触发器的方式, 一个是通过继承, 然后重写指定的事件方法, 如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventTriggerExample</span> : <span class="title">EventTrigger</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnBeginDrag</span>(<span class="params">PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnBeginDrag called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCancel</span>(<span class="params">BaseEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnCancel called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种是通过设置委托的方式, 如下:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EventTriggerDelegateExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EventTrigger trigger = GetComponent&lt;EventTrigger&gt;();</span><br><span class="line">        EventTrigger.Entry entry = <span class="keyword">new</span> EventTrigger.Entry();</span><br><span class="line">        entry.eventID = EventTriggerType.PointerDown;</span><br><span class="line">        entry.callback.AddListener((data) =&gt; &#123; OnPointerDownDelegate((PointerEventData)data); &#125;);</span><br><span class="line">        trigger.triggers.Add(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerDownDelegate</span>(<span class="params">PointerEventData data</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnPointerDownDelegate called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过事件触发器的方式来注册和处理事件更加灵活, 但是会拦截所有事件, 导致事件无法传递到父对象, 在使用的时候需要注意.</p><p>【更详细的等遇到再深入了解，还有更详细的博客在同一个专栏】</p><h2 id="UGUI的事件传递"><a href="#UGUI的事件传递" class="headerlink" title="UGUI的事件传递"></a>UGUI的事件传递</h2><p><a href="https://www.xuanyusong.com/archives/4241">Unity3D研究院之将UI的点击事件渗透下去（九十） | 雨松MOMO程序研究院 (xuanyusong.com)</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span>,<span class="title">IPointerClickHandler</span> ,<span class="title">IPointerDownHandler</span>,<span class="title">IPointerUpHandler</span></span><br><span class="line">&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//监听按下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerDown</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.pointerDownHandler);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//监听抬起</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerUp</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.pointerUpHandler);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//监听点击</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnPointerClick</span>(<span class="params">PointerEventData eventData</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.submitHandler);</span><br><span class="line">        PassEvent(eventData,ExecuteEvents.pointerClickHandler);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//把事件透下去</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">PassEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">PointerEventData data,ExecuteEvents.EventFunction&lt;T&gt; function</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> T : IEventSystemHandler</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;RaycastResult&gt; results = <span class="keyword">new</span> List&lt;RaycastResult&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发射射线，获得被射线击中的物体</span></span><br><span class="line">        EventSystem.current.RaycastAll(data, results);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己？</span></span><br><span class="line">        GameObject current = data.pointerCurrentRaycast.gameObject ;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>; i&lt; results.Count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 除了自己其它被射中的物体都执行响应</span></span><br><span class="line">            <span class="keyword">if</span>(current!= results[i].gameObject)</span><br><span class="line">            &#123;</span><br><span class="line">                ExecuteEvents.Execute(results[i].gameObject, data,function);</span><br><span class="line">                <span class="comment">//RaycastAll后ugui会自己排序，如果你只想响应透下去的最近的一个响应，这里ExecuteEvents.Execute后直接break就行。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仍然遵循这样的流程：输入（各种类型的输入）-射线检测-被检测到的物体（根据输入类型）执行事件。</p><p>由于Unity默认是最近的发生响应，如果想要都被响应就要手动处理（？</p>]]></content>
    
    
    <summary type="html">UI部分</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-知识整理</title>
    <link href="https://huangxinhere.github.io/2023/07/30/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://huangxinhere.github.io/2023/07/30/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-29T16:00:00.000Z</published>
    <updated>2023-09-07T03:37:24.204Z</updated>
    
    <content type="html"><![CDATA[<p>【更广泛的设计模式分类】<a href="https://blog.csdn.net/cooldragon/article/details/52164380">设计模式总结之模式分类_迷死特兔的博客-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/340507902">游戏中的设计模式 - 知乎 (zhihu.com)</a></p><ul><li>创建型设计模式</li><li>结构型设计模式</li><li>行为型设计模式</li></ul><h1 id="单例模式【创建型】"><a href="#单例模式【创建型】" class="headerlink" title="单例模式【创建型】"></a>单例模式【创建型】</h1><p><a href="https://juejin.cn/post/6844903517648355342">到底是用”静态类”还是单例 - 掘金 (juejin.cn)</a></p><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例模式指的是在应用<em><strong>整个生命周期内只能存在一个实例。</strong></em>单例模式是一种被广泛使用的设计模式。</p><p>他有很多好处，能够避免实例对象的重复创建，减少创建实例的系统开销，节省内存。</p><p> 1.一个类只能有一个实例；</p><p> 2.自己创建这个实例；</p><p>3.整个系统都要使用这个实例。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li>饿汉模式</li></ul><p>所谓饿汉模式就是立即加载，一般情况下再调用getInstancef方法之前就已经产生了实例，也就是在类加载的时候已经产生了。</p><p>这种模式的缺点很明显，就是<strong>占用资源</strong>，当单例类很大的时候，其实我们是想使用的时候再产生实例。因此这种方式适合占用资源少，在初始化的时候就会被用到的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class SingletonHungary &#123;</span><br><span class="line">    private static SingletonHungary singletonHungary = new SingletonHungary();</span><br><span class="line">    //将构造器设置为private禁止通过new进行实例化</span><br><span class="line">    private SingletonHungary() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonHungary getInstance() &#123;</span><br><span class="line">        return singletonHungary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>懒汉模式</li></ul><p>在类加载的时候没有直接实例化，而是调用指定实例方法的时候再进行实例化，这样就能保证不想使用的时候也不会实例化。一般来说比饿汉模式的效率高。</p><h2 id="在Unity中的实践"><a href="#在Unity中的实践" class="headerlink" title="在Unity中的实践"></a>在Unity中的实践</h2><p>如果挂载在场景物体上面，由于继承MonoBehaviour所以构造函数应该不会私有化，也就是说受unity的生命周期控制，如果场景中多个挂载的话，就有多个实例。</p><p>如果是挂载的，就放在Awake里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    public static Singleton Instance;</span><br><span class="line">    </span><br><span class="line">    Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if(instance == null)// 在场景多个实例取第一个作为单例？</span><br><span class="line">            instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不继承monobehavior，就按照一般的情况来处理。</p><ul><li>和DontDestroyOnLoad结合使用</li></ul><p>对DontDestroyOnLoad的理解：比如在场景A对A中的一个物体a进行这个方法的处理，那么就把a放入DontDestroyOnLoad场景里面。这样在场景BCD加载的时候，由于<strong>DontDestroyOnLoad</strong>场景一直保持、没有重新加载，所以该场景的脚本都一直保持。</p><p>但是回到场景A的时候，由于A里面本来就有物体a，那么加载A就必然加载a，这样的话如果重复回到A就会有多个a（如果场景B也有a，应该也会重复出现？）都扔到DontDestroyOnLoad里面去了。</p><p>所以处理方法就是，如果有哪个场景持有物体a，想要再次初始化的时候，就用单例或者布尔变量标记这个物体已经处理过了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GameManager : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">private static GameManager _instance;   // 单例</span><br><span class="line">public GameManager GameManagerInstance</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return _instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_instance != null)</span><br><span class="line">        &#123;</span><br><span class="line">        //这里一定要销毁this.gameObject</span><br><span class="line">            Destroy(this.gameObject);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //这句话只执行一次，第二次上面return了</span><br><span class="line">        _instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者用静态布尔变量来标记已经处理过了。</p></blockquote><p>或者考虑某个场景只进入一次。</p><h2 id="与静态类的区别"><a href="#与静态类的区别" class="headerlink" title="与静态类的区别"></a>与静态类的区别</h2><p>首先理解一下什么是静态类，静态类就是一个类里面都是静态方法和静态field，构造器被<a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a>修饰，因此不能被实例化。Math类就是一个静态类。</p><p>1）首先单例模式会提供给你一个全局唯一的对象，静态类只是提供给你很多静态方法，这些方法不用创建对象，通过类就可以直接调用；</p><p>2）<em><strong>单例模式的灵活性更高，方法可以被override，因为静态类都是静态方法，所以不能被override；</strong></em></p><p>3）如果是一个非常重的对象，单例模式可以懒加载，静态类就无法做到；</p><p>那么时候时候应该用静态类，什么时候应该用单例模式呢？</p><p>首先如果你只是想使用一些工具方法，那么最好用静态类，<em><strong>静态类比单例类更快</strong></em>，因为静态的绑定是在编译期进行的。</p><p><em><strong>如果你要维护状态信息，或者访问资源时，应该选用单例模式。</strong></em>还可以这样说，当你需要面向对象的能力时（比如继承、多态）时，选用单例类，当你仅仅是提供一些方法时选用静态类。</p><p><a href="https://zhuanlan.zhihu.com/p/542442083">C#中的单例类与静态类 - 知乎 (zhihu.com)</a></p><h1 id="工厂模式【创建型】"><a href="#工厂模式【创建型】" class="headerlink" title="工厂模式【创建型】"></a>工厂模式【创建型】</h1><p><a href="https://juejin.cn/post/6989591565295419400">一文彻底弄懂工厂模式(Factory) - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/83535678">C++ 深入浅出工厂模式（初识篇） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/83537599">C++ 深入浅出工厂模式（进阶篇） - 知乎 (zhihu.com)</a></p><p>这种类型的设计模式属于创建型模式，它<strong>提供了一种创建对象的最佳方式</strong>。</p><p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>这满足创建型模式中所要求的“<strong>创建与使用相分离</strong>”的特点。</p><h1 id="观察者模式【行为型】"><a href="#观察者模式【行为型】" class="headerlink" title="观察者模式【行为型】"></a>观察者模式【行为型】</h1><p>观察者模式定义了对象间的一种<strong>一对多的依赖关系</strong>，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知，并自动更新。</p><p>观察者模式属于<strong>行为型模式</strong>，行为型模式关注的是<strong>对象之间的通讯</strong>，观察者模式就是观察者和被观察者之间的通讯。</p><p>观察者模式有两个重要的角色，即<strong>目标和观察者</strong>。在目标和观察者之间是没有事件通道的。一方面，观察者要想订阅目标事件，由于没有事件通道，因此必须<u>将自己添加到目标(Subject) 中进行管理</u>；另一方面，目标在触发事件的时候，也无法将通知操作(notify) 委托给事件通道，因此只能<u>亲自去通知所有的观察者</u>。</p><p>观察者模式有一个别名叫“发布-订阅模式”，或者说是“订阅-发布模式”，订阅者和订阅目标是联系在一起的，当订阅目标发生改变时，逐个通知订阅者。但是经过时间的沉淀，似乎他已经强大了起来，已经独立于观察者模式，成为另外一种不同的设计模式。</p><p>游戏中观察者的适用环境：</p><p>角色属性更新。当我们使用观察者模式监听了角色的属性后，那么角色属性的任何改变都将会通知其关联对象。</p><h1 id="发布-订阅者模式"><a href="#发布-订阅者模式" class="headerlink" title="发布-订阅者模式"></a>发布-订阅者模式</h1><p>是一种消息范式，消息的发送者（称为<strong>发布者</strong>）不会将消息直接发送给特定的接收者（称为<strong>订阅者</strong>）。而是将发布的消息分为不同的类别，无需了解哪些订阅者（如果有的话）可能存在。同样的，订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息，无需了解哪些发布者存在。</p><ul><li>观察者模式 与 发布/订阅者模式 的区别：</li></ul><p>​    在观察者模式中，观察者是知道Subject的，Subject一直保持对观察者进行记录。然而，<strong>在发布订阅模式中，发布者和订阅者不知道对方的存在</strong>。它们只有通过<strong>消息代理</strong>进行通信。</p><p>​    观察者和被观察者，是松耦合的关系。发布订阅模式里，发布者和订阅者，不是松耦合，而是完全解耦的。观察者模式大多数时候是同步的，比如当事件触发，Subject就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。</p><p><img src="https://img-blog.csdnimg.cn/c6e86dbf4e614dd1ad795d358be3ffc8.png" alt="img"></p><p>​    可以看出，发布订阅模式相比观察者模式多了个事件通道，<strong>事件通道作为调度中心</strong>，管理事件的订阅和发布工作，<strong>彻底隔绝了订阅者和发布者的依赖关系</strong>。即订阅者在订阅事件的时候，只关注事件本身，而不关心谁会发布这个事件；发布者在发布事件的时候，只关注事件本身，而不关心谁订阅了这个事件。</p><h1 id="状态模式【行为型】"><a href="#状态模式【行为型】" class="headerlink" title="状态模式【行为型】"></a>状态模式【行为型】</h1><p>[状态模式（State模式）_好人Luke的博客-CSDN博客](<a href="https://blog.csdn.net/qq_35784669/article/details/121238278#:~:text=%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9">https://blog.csdn.net/qq_35784669/article/details/121238278#:~:text=状态模式的定义与特点</a> 1 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。 2,将状态转换显示化，减少对象间的相互依赖。 将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。 3 状态类职责明确，有利于程序的扩展。 通过定义新的子类很容易地增加新的状态和转换。)</p><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4744158f2ed64c314209070a9e4e0602.gif" alt="状态模式的结构图"></p><p>状态模式是一种对象行为型模式，其主要优点如下：</p><ol><li>结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ol><p>状态模式的主要缺点如下：</p><ol><li>状态模式的使用必然会增加系统的类与对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li><li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ol><h1 id="命令模式【行为型】"><a href="#命令模式【行为型】" class="headerlink" title="命令模式【行为型】"></a>命令模式【行为型】</h1><p>​    命令模式（Command Pattern）是一种<strong>数据驱动</strong>的设计模式，它属于<strong>行为型模式</strong>。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><p>​    命令模式<strong>将“请求”封装成对象</strong>，以便使用不同的请求、队列或者日志来参数化其他对象，同时支持可撤消的操作。</p><p>​    多用于用户的客户端请求，实现请求的队列操作和日志里，并且支持对操作进行<u>撤销回退</u>。</p><h1 id="策略模式【行为型】"><a href="#策略模式【行为型】" class="headerlink" title="策略模式【行为型】"></a>策略模式【行为型】</h1><p>​    定义一系列算法，并<strong>将每个算法封装起来</strong>，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。</p><p>​    策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p><p>​    多用于技能效果类和方法的构建。</p><h1 id="组合模式【结构型】"><a href="#组合模式【结构型】" class="headerlink" title="组合模式【结构型】"></a>组合模式【结构型】</h1><p>​    组合模式（Composite Pattern），又叫部分整体模式，是用于<strong>把一组相似的对象当作一个单一的对象</strong>。</p><p>​    组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><p>多用于：</p><p>（具体实践？？看不太懂）</p><p>1、您想表示对象的部分-整体层次结构（树形结构）。</p><p>2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p><p>​    例如：不同的界面的逻辑和UI通过一个管理器统一控制。</p><h1 id="代理模式【结构型】"><a href="#代理模式【结构型】" class="headerlink" title="代理模式【结构型】"></a>代理模式【结构型】</h1><p>一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理对象实现同一个接口,先访问代理类再访问真正要访问的对象。</p><p>​    代理模式就是多一个代理类出来，替原对象进行一些操作。</p><p>​    比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。</p><p>​    多用于代理Text, Button, Image等组件的功能；登陆设置；委托；代理下载资源等。</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p><a href="https://zhuanlan.zhihu.com/p/39096277">Unity中使用简易MVC详解 - 知乎 (zhihu.com)</a></p><p>MVC全名是Model View Controller，是模型（Model）-视图（View）-控制器（Controller）的缩写，一种软件设计典范。</p><p>用一种<strong>业务逻辑、数据、界面显示分离</strong>的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><ul><li><p>同一个模块内</p><p>M只用来操作数据并发送更新消息；</p><p>V只用来接受消息并控制界面显示跳转；</p><p>使用C来处理界面与数据的频繁操作。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/3fcd5d6f9e81414ead33a191b68b9924.png" alt="img"></p><p>一般流程:</p><ol><li>View(界面)触发事件</li><li>Controller (业务）处理了业务触发数据更新</li><li>更新了Model (数据)</li><li>Model(带着数据)回到了View(界面)</li><li>View更新了数据</li></ol><h1 id="游戏设计模式：ECS架构"><a href="#游戏设计模式：ECS架构" class="headerlink" title="游戏设计模式：ECS架构"></a>游戏设计模式：ECS架构</h1><p><a href="https://blog.csdn.net/qq_14914623/article/details/81451002?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-81451002-blog-48625257.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-81451002-blog-48625257.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=2">游戏开发中的ECS 架构概述_游戏ecs是什么意思_钢与铁的博客-CSDN博客</a></p><p><em><strong>ECS</strong></em>，即 Entity-Component-System（实体-组件-系统） 的缩写，其模式遵循<strong>组合优于继承</strong>原则，游戏内的每一个基本单元都是一个<strong>实体</strong>，每个<strong>实体</strong>又由一个或多个<strong>组件</strong>构成，每个组件仅仅包含代表其特性的<strong>数据</strong>（即在组件中没有任何方法）。</p><p>例如：移动相关的组件<code>MoveComponent</code>包含速度、位置、朝向等属性，一旦一个实体拥有了<code>MoveComponent</code>组件便可以认为它拥有了移动的能力，</p><p><strong>系统</strong>便是来处理拥有一个或多个相同组件的<u>实体集合</u>的工具，其<strong>只拥有行为</strong>（即在系统中没有任何数据），</p><p>在这个例子中，处理移动的系统仅仅关心拥有移动能力的实体，它会遍历所有拥有<code>MoveComponent</code>组件的实体，并根据相关的数据（速度、位置、朝向等），更新实体的位置。</p><p>实体与组件是一个一对多的关系，<u>实体拥有怎样的能力，完全是取决于其拥有哪些组件</u>，通过动态添加或删除组件，可以在（游戏）运行时改变实体的行为。</p><p><img src="https://pic3.zhimg.com/80/v2-04e15b14964c9b61bffdfad42e907ffc_hd.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;【更广泛的设计模式分类】&lt;a href=&quot;https://blog.csdn.net/cooldragon/article/details/52164380&quot;&gt;设计模式总结之模式分类_迷死特兔的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huangxinhere.github.io/2023/07/04/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93-Unity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BFishnet/"/>
    <id>https://huangxinhere.github.io/2023/07/04/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93-Unity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BFishnet/</id>
    <published>2023-07-04T08:18:28.933Z</published>
    <updated>2023-07-08T07:43:45.980Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Server和Client"><a href="#Server和Client" class="headerlink" title="Server和Client"></a>Server和Client</h2><p><img src="/2023/07/04/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93-Unity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BFishnet/hexo_github_blog\source_posts\实践总结-Unity网络编程Fishnet.assets\image-20230708152931525.png" alt="image-20230708152931525"></p><ul><li><p>独立：目前理解是，server和clients分别拥有一个运行的“单机”游戏，逻辑都一样运行，但联机不同的是，每端都有ID，分为Client和Server两类，根据ID不同 判断并执行逻辑。</p></li><li><p>共享 / 同步：联机的意义在于“异步中的同步”，比如玩家控制的一个角色，在ABC三个端都是同步的，理想状态是相同时刻执行的效果相同。</p><ul><li><p>通过服务器：服务器作为“总部”负责接收单个客户端的请求，并把更新的信息（客户端或服务器的更新）告诉给所有客户端。</p><p>ServerRpc：直接请求服务器；</p><p>变量同步：基于对象，在对象上修改 SyncType 时，更改会自动从服务器发送到客户端（以可调整的间隔发送）。客户端将在同一对象上本地接收更改。</p></li><li><p>广播：不分服务器和客户端，只要有更新，监听的所有Observer都进行更新。（ObserverRpc、Observer组件）</p></li><li><p>各端的沟通：RPCs。默认是单机执行逻辑，如果要通知其它端，就要用到Rpc</p></li></ul></li></ul><h1 id="在没有继承NetworkBehaviour的脚本中Spawn新的物体"><a href="#在没有继承NetworkBehaviour的脚本中Spawn新的物体" class="headerlink" title="在没有继承NetworkBehaviour的脚本中Spawn新的物体"></a>在没有继承NetworkBehaviour的脚本中Spawn新的物体</h1><p>由于人物状态机用了ScriptableObject，无法继承NetworkBehavior，所以简单的一个ServerRpc的Spawn使用不了，充满了曲折与辛酸泪。</p><h2 id="instancefinder"><a href="#instancefinder" class="headerlink" title="instancefinder"></a>instancefinder</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GameObject currObj = Instantiate(currPrefab, pos, Quaternion.identity);</span><br><span class="line">InstanceFinder.ServerManager.Spawn(currObj, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>在客户端调用不了，警告：<code>Cannot spawn object because server is not active and predicted spawning is not enabled.</code></p><p>在客户端和server一起的（host？）就可以。也就是服务器端才能使用？任何关于网络物体的操作似乎都要继承NetworkBehaviour，作为一个网络物体才能和server client链接？</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>那我在这个脚本用不了，调用其它脚本的方法总可以吧？可惜构建物体的参数作为传参放入rpc方法的话不可行，因为不可序列化（例如Sprite、Collider这些不行）。</p><p>回调也不行，想用action作为构建物体的包装方法，在invoke触发，但action不可序列化；同时泛型类型参数也不允许。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToCallServerRpc</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; action, T arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    action?.Invoke(arg);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p>对于Rpc能传的参数类型感到非常疑惑：首先我第一个认识是不可序列化的不能传，然后是GameObject类型可以，接着是Transform能传但传进方法里面就为空？有什么规律吗……</p><p><code>GameObject bone_4 cannot be serialized because it does not have a NetworkObject nor NetworkBehaviour.</code></p><p>看来要有相关的网络设置才能被序列化……</p></li></ul><blockquote><p>可序列化的：（待完善，感觉ai不完全对）</p><ol><li>基本数据类型（Primitive Types）：包括整数（int，float，double等），布尔值（bool），字符（char）等。</li><li>string</li><li>Array</li><li>List和其他集合类型</li><li>枚举（Enum）：Unity能够序列化枚举类型，使其在Inspector窗口中可编辑。</li><li>自定义的可序列化类（Custom Serializable Classes）：你可以创建自己的类，并使用[SerializeField]属性将其标记为可序列化。这样，类的成员变量可以在Inspector窗口中显示并编辑。</li><li>Unity内置组件（Built-in Unity Components）：Unity内置的一些组件，如Transform，MeshRenderer，Rigidbody等，都是可序列化的。</li></ol><p>不是所有类型都可以被Unity直接序列化。一般来说，只有继承自Unity提供的可序列化基类（如MonoBehaviour）或标记为可序列化的类型才能被序列化。</p></blockquote><h2 id="类的字段"><a href="#类的字段" class="headerlink" title="类的字段"></a>类的字段</h2><p>我不用传参，我用类的字段总可以吧？最好不这样做。因为server端的脚本变量和client不互通，所以server的脚本变量会是空的，serverRpc会用空的变量执行那个方法。真麻了</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原来除了基础类型，GameObject也可以当作传参！麻了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;Server和Client&quot;&gt;&lt;a href=&quot;#Server和Client&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统：Unity</title>
    <link href="https://huangxinhere.github.io/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/"/>
    <id>https://huangxinhere.github.io/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/</id>
    <published>2023-06-16T16:00:00.000Z</published>
    <updated>2023-06-20T02:40:29.005Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/19972689">Unity将来时：IL2CPP是什么？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/smilejoi/p/14785295.html">Unity为什么能够使用c#进行开发—-原理篇 - zhengjiayu - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/591320059">Unity中C#的底层原理 - 知乎 (zhihu.com)</a></p><h1 id="从编译原理说起"><a href="#从编译原理说起" class="headerlink" title="从编译原理说起"></a>从编译原理说起</h1><p>一句话介绍编译器：编译器是将用某种程式语言写成的源代码（源语言），转换成另一种程式语言（目标语言）等价形式的程序。</p><p>通常我们是将某种高级语言（如C、C++、C# 、Java）转换成低级语言（汇编语言、机器语言）。<br>编译器以流水线的形式进行工作，分为几个阶段：源代码 → 词法分析 → 语法分析 → 语义分析 → 目标代码 → 链接 → 可执行文件。</p><blockquote><p><strong>链接（linking）解释：</strong>上一步骤的结果可能会引用外部的函数，把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中，这就叫做链接。——两种，静态链接（编译时）和动态链接（runtime）。 </p></blockquote><p>现代编译器还会更复杂，中间会增加更多的处理过程，比如预处理器，中间代码生成，代码优化等。</p><p><img src="https://img-blog.csdn.net/20180927202022582?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTMzMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><blockquote><p>借用C++的编译过程。</p></blockquote><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机（VM），简单理解，就是可以执行特定指令的一种程序。为了执行指令，还需要一些配套的设施，如寄存器、栈等。虚拟机可以很复杂，复杂到模拟真正的计算机硬件，也可以很简单，简单到只能做加减乘除。</p><p>在编译器领域，虚拟机通常执行一种叫中间代码的语言，中间代码由高级语言转换而成，以 Java 为例，Java 编译后产生的并不是一个可执行的文件，而是一个 ByteCode （字节码）文件，里面包含了从 Java 源代码转换成等价的字节码形式的代码。Java 虚拟机（JVM）负责执行这个文件。</p><p>虚拟机执行中间代码的方式分为 2 种：解释执行和 <strong>JIT（即时编译）</strong>。解释执行即逐条执行每条指令，JIT 则是先将中间代码在开始运行的时候编译成机器码，然后执行机器码。由于执行的是中间代码，所以，在不同的平台实现不同的虚拟机，都可以执行同样的中间代码，也就实现了跨平台。</p><p>总结一下，虚拟机本身并不跨平台，而是语言是跨平台的，对于开发人员来说，只需要关心开发语言即可，不需要关心虚拟机是怎么实现的，这也是 Java 可以跨平台的原因，C# 也是同样的。推而广之，理论上任何语言都可以跨平台，只要在相应平台实现了编译器或者虚拟机等配套设施。</p><h1 id="C-、CIL、CLR与反射"><a href="#C-、CIL、CLR与反射" class="headerlink" title="C#、CIL、CLR与反射"></a>C#、CIL、CLR与反射</h1><p>C# 和 Java 类似，C# 会编译成一个中间语言（CIL，Common Intermediate Language，也叫 MSIL），CIL 也是一个高级语言，而<strong>运行 CIL 的虚拟机叫 CLR</strong>（Common Language Runtime）。</p><p>通常我们把 C#、CIL、CLR，再加上微软提供的一套基础类库称为 .Net Framework。</p><p><img src="/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/hexo_github_blog\source_posts\知识整理-操作系统：Unity.assets\image-20230617221205492.png" alt="image-20230617221205492"></p><ul><li>.NET语言的编译器接受源代码文件，并生成名为<strong>程序集</strong>的输出文件。程序集包含的信息中，包括下列项目：<ul><li>程序的<strong>CIL</strong>：Common Intermediate Language 公共中间语言 / IL / MSIL；不是本机代码，是一种中间语言。</li><li>程序中使用的类型的元数据；</li><li>对其他程序集引用的<strong>元数据</strong>。</li></ul></li></ul><blockquote><p>元数据：为了CLR能够向托管代码提供服务，语言编译器必须产出元数据（描述类型、成员、引用的文件），每一个PE文件（可移植、可执行文件，表现为exe、dll等格式的文件）都需要包含元数据。<u>CLR需要元数据来生成机器码</u>。</p></blockquote><ul><li>CIL直到被调用运行时才会被编译成本机代码；在运行时，<strong>CLR</strong>执行以下步骤：<ul><li>检查程序集的安全性；</li><li>在内存中分配空间；</li><li>把程序集中的可执行代码发送给即时（just-in-time，<strong>JIT</strong>）编译器，把其中一部分编译成本机代码。</li></ul></li></ul><p><img src="/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/hexo_github_blog\source_posts\知识整理-操作系统：Unity.assets\image-20230617222202975.png" alt="image-20230617222202975"></p><p>.NET 框架的核心组件是CLR，它在操作系统的顶层，负责管理程序的执行。</p><ul><li><p>反射：C#编写的程序会编译成一个程序集(.DLL或.exe)，其中会包含元数据、编译代码和资源，通过反射可以获取到程序集中的信息。通俗来讲，反射就是我们在只知道一个对象的外部而不了解内部结构的情况下，可以知道这个对象的内部实现。</p><p>反射可以做到的事情：</p><ul><li><p>通过Type类获取程序集、模块、类的信息；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = &#123; <span class="number">42</span>, <span class="number">34</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// Start is called before the first frame update</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type type = a.GetType();</span><br><span class="line">    Debug.Log(type);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Name: &quot;</span> + type.Name);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Assembly: &quot;</span> + type.Assembly);</span><br><span class="line">    Debug.Log(<span class="string">&quot;BaseType: &quot;</span> + type.BaseType);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Is class? &quot;</span> + type.IsClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态创建实例：这种方式比new效率要低；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Reflection</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//创建一个类的实例</span></span><br><span class="line">        <span class="built_in">object</span> c = Activator.CreateInstance(<span class="keyword">typeof</span>(TestClass), <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        Debug.Log(c.ToString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个结构体的实例</span></span><br><span class="line">        student stua = (student)Activator.CreateInstance(<span class="keyword">typeof</span>(student));</span><br><span class="line">        stua.name = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line">        stua.age = <span class="number">12</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;The boy &quot;</span> + stua.name + <span class="string">&quot; is &quot;</span> + stua.age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestClass</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> student</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowName</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取方法或者动态调用方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Reflection</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span> c = Activator.CreateInstance(<span class="keyword">typeof</span>(TestClass), <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        Debug.Log(c.ToString());</span><br><span class="line">        <span class="keyword">var</span> m1 = c.GetType().GetMembers();</span><br><span class="line">        <span class="keyword">var</span> m2 = c.GetType().GetMethod(<span class="string">&quot;ShowName&quot;</span>);</span><br><span class="line">        m2.Invoke(c, <span class="literal">null</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestClass</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowName</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;this is a test class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><a href="https://blog.csdn.net/LLLLL__/article/details/118695042">(53条消息) C#中的反射_c# 反射_Hello Bug.的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_39847278/article/details/129816667?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-129816667-blog-118695042.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-129816667-blog-118695042.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=5">(53条消息) c#之反射详解_c# 反射_鲤籽鲲的博客-CSDN博客</a>【超详细】</p><h1 id="Net-Framework-vs-Mono"><a href="#Net-Framework-vs-Mono" class="headerlink" title=".Net Framework vs Mono"></a>.Net Framework vs Mono</h1><p>Mono 是跨平台的 .Net Framework 的实现。Mono 做了一件很了不起的事情，将 CLR 在所有支持的平台上重新实现了一遍，将 .Net Framework 提供的基础类库也重新实现了一遍。</p><p><img src="https://img2020.cnblogs.com/blog/1565924/202007/1565924-20200701114759725-520977280.png" alt="img"></p><blockquote><p>以上，Compile Time 的工作实际上可以直接用微软已有的成果，只要将 Runtime 的 CLR 在其他平台实现，这个工作量不仅大，而且需要保证兼容，非常浩大的一个工程，Mono 做到了，致敬！</p></blockquote><ul><li><p>Unity3D 内嵌了一个 Mono 虚拟机，从上文可以知道，当实现了某个平台的虚拟机，那语言就可以在该平台运行，所以，严格的讲，Unity3D 是通过 Mono 虚拟机，运行 C# 通过编译器编译后生成的 CIL 代码。</p><p>Unity3D 默认使用 C# 作为开发语言，除此之外，还支持 JS 和 BOO，因为 Unity3D 开发了相应的编译器，将 JS 和 BOO 编译成了 IL。</p></li><li><p>C# 在 Windows 下，是通过微软的 C# 编译器，生成了 CIL 代码，运行在 CLR 中。</p></li><li><p>C# 在除 Windows 外的平台下，是通过 Mono 的编译器，生成了 CIL 代码，运行在 Mono 虚拟机中，也可以直接运行将已经编译好的 CIL 代码（通过任意平台编译）。</p></li></ul><h1 id="IL2CPP、IL2CPP-VM"><a href="#IL2CPP、IL2CPP-VM" class="headerlink" title="IL2CPP、IL2CPP VM"></a>IL2CPP、IL2CPP VM</h1><p>把IL中间语言转换成CPP文件。大家如果看明白了上面动态语言的 CLI， IL以及VM，再看到IL2CPP一定心中充满了疑惑。现在的大趋势都是把语言加上动态特性，哪怕是c++这样的静态语言，也出现了适合IL的c++编译器，为啥Unity要反其道而行之，把IL再弄回静态的CPP呢？</p><ul><li><p>mono的核心原理是，将C#代码，转化成 IL 中间代码，然后通过各个平台的mono虚拟机解释执行，在运行时，解释的过程中，最终转化成了机器码。</p></li><li><p>而 il2cpp，是在各个平台，先将 C# 转化成 C++ 代码，然后通过各个平台的C++编译器直接生成了机器码，也就是在你发包的时候已经是机器码了，所以很快。</p></li><li><p>另外，il2cpp 生成出的项目 无法反编译，这相当于将C#代码加密了；而 mono生成出的项目，是可以 ILSpy 反编译出来的。</p></li></ul><p>使用Mono的时候，脚本的编译运行如下图所示：</p><p><img src="https://pic4.zhimg.com/80/a0c8e96a34348e26ea2f7763e3452ae3_1440w.webp" alt="img"></p><p>简单的来说，3大脚本被编译成IL，在游戏运行的时候，IL和项目里其他第三方兼容的DLL一起，放入Mono VM虚拟机，由虚拟机解析成机器码，并且执行;</p><p>加入红色部分后，就是在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p><ul><li>将IL变回CPP的目的除了CPP的执行效率快以外，另一个很重要的原因是可以利用现成的在各个平台的C++编译器对代码执行编译期优化，这样可以进一步减小最终游戏的尺寸并提高游戏运行速度。</li><li>由于动态语言的特性，他们多半无需程序员太多关心内存管理，所有的内存分配和回收都由一个叫做GC（Garbage Collector）的组件完成。虽然通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 IL2CPP VM的原因：它负责提供诸如GC管理，线程创建这类的服务性工作。但是由于去除了IL加载和动态解析的工作，使得IL2CPP VM可以做的很小，并且使得游戏载入时间缩短。</li></ul><h1 id="Unity与内存"><a href="#Unity与内存" class="headerlink" title="Unity与内存"></a>Unity与内存</h1><p>[Unity的内存管理与性能优化 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/362941227#:~:text=Unity%E7%9A%84VM%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AVirtual">https://zhuanlan.zhihu.com/p/362941227#:~:text=Unity的VM（虚拟机：Virtual</a> Machine）依旧还是存在，主要用于跨平台，有了一层VM抽象后，跨平台的工作会容易很多，IL2CPP本身也是个VM。 Unity内存按照分配方式分为： Native Memory,（原生内存）和 Managed Memory （托管内存）。 Native Memory并不会被系统自动管理，需要我们手动去释放。)【超详细！！可多翻看】</p><p><a href="https://zhuanlan.zhihu.com/p/370467923">Unity游戏内存分布概览 - 知乎 (zhihu.com)</a></p><h2 id="内存相关概念"><a href="#内存相关概念" class="headerlink" title="内存相关概念"></a>内存相关概念</h2><h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><h4 id="缓存和Cache-Miss"><a href="#缓存和Cache-Miss" class="headerlink" title="缓存和Cache Miss"></a>缓存和Cache Miss</h4><p>物理内存也就是我们真的硬件设备，例如内存条。</p><p>我们需要知道，<strong>CPU访问内存是一个慢速过程。</strong></p><p>访问过程具体为：先访问Cache，Cache包含L1，L2，L3，也就是一级缓存，二级缓存和三级缓存，若在这些缓存里全没找到我们要的数据，再去访问内存，接着会把找到的数据存放到Cache中，完成一次操作。</p><p>在Cache中没有找到数据，我们称之为<strong>Cache Miss</strong>。因此<strong>过多的Cache Miss就会导致大量的内存和Cache的IO交换，浪费大量时间</strong>。</p><p>因此我们需要尽量减少Cache Miss，来提高访问速度，Unity为此提出了<strong>ECS</strong>方案，有兴趣的小伙伴可以看看之前有关<a href="https://link.zhihu.com/?target=https://blog.csdn.net/wangjiangrong/article/details/106850847">ECS</a>介绍的文章，它们可以将存储在内存中的不连续数据，变为连续的数据，从而降低Cache Miss的概率。</p><h4 id="台式设备和移动设备内存架构的差异"><a href="#台式设备和移动设备内存架构的差异" class="headerlink" title="台式设备和移动设备内存架构的差异"></a>台式设备和移动设备内存架构的差异</h4><ol><li>首先移动设备没有独立显卡。</li><li>移动设备没有独立显存（显存的作用是用来存储显卡芯片处理过或者即将提取的渲染数据），所有在<u>移动端数据内存和显存是同一块内存</u>。所以有可能我们游戏占用的内存并不大，但是依旧爆内存了，其实是因为显存分配不出来了。这种情况，我们可以去查看一下Log，例如Android会有一个 OpenGL Error：Out Of Memory。</li><li>移动设备的CPU面积更小，因此会导致<u>缓存级数更少，大小也更小</u>，例如一般的台式机三级缓存可能有8-16M，而移动设备则只有2M左右。</li></ol><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。</p><h4 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h4><p>操作系统在使用内存不够的情况下，会尝试把一些不用的内存（Dead Memory）交换到硬盘上，从而节省出更多的物理内存。这个操作我们称之为<strong>内存交换</strong>，它会占用大量的硬盘空间。</p><p><strong>然而移动设备不做该操作</strong>，因为移动设备的IO速度很慢，而且移动设备的可存储物（例如sd卡，内存芯片等）的可擦写次数也比硬盘少很多，会影响使用寿命。</p><h3 id="内存压缩"><a href="#内存压缩" class="headerlink" title="内存压缩"></a>内存压缩</h3><p>在IOS中（Android没有）会将不活跃的内存压缩起来存储到一个特定空间里，来节省出物理内存空间，来给活跃的app使用，这个操作称之为<strong>内存压缩</strong>。（可以查看XCode的Virtual Memory）</p><h3 id="内存寻址范围"><a href="#内存寻址范围" class="headerlink" title="内存寻址范围"></a>内存寻址范围</h3><p>内存寻址范围也称寻址空间，指的是CPU对于内存寻址的能力（最大能查找多大范围的地址）。数据在内存中存放是有规律的，CPU在运算的时候需要把数据提取出来就需要知道数据在那里，这时候就需要挨家挨户的找，这就叫做<strong>寻址</strong>，但如果地址太多超出了CPU的能力范围，CPU就无法找到数据了。</p><p>内存寻址范围和Memory Controller（内存控制器）有关，和运算位数（32位或64位）无直接关系。当然一般情况下，64位的CPU寻址范围更大。</p><h2 id="Unity的内存管理"><a href="#Unity的内存管理" class="headerlink" title="Unity的内存管理"></a>Unity的内存管理</h2><h3 id="Unity是一个C-引擎"><a href="#Unity是一个C-引擎" class="headerlink" title="Unity是一个C++引擎"></a>Unity是一个C++引擎</h3><p>Unity是一个C++引擎，并不是C#引擎，底层代码全部是由c++写的，除了一些Editor里面的Services可能会用到NodeJS这些网络的语言，Runtime里面用到的每一行Unity底层代码全是C++的。</p><p>Unity实际上分为三层：</p><ul><li>最底层是我们的Runtime，全是Native C++代码。</li><li>最上层是我们的C#，Unity自己有一些C#，例如Unity的Editor是用C#写的，还有些Package也是C#写的。</li><li><u>中间还有一层我们叫Binding</u>，可以看见很多的**.bindings.cs**文件（基于C#的binding语言，一开始是Unity自定义的一种语言），这些文件的作用就是<u>把C++和C#联系在一起，为我的C#层提供所有的API</u>。</li></ul><p>因此我们平时使用Unity时看见的C# API，都是在Binding层中自定义的。这些文件底层运行的时候还是C++，只是个Wrapper（封装）。</p><p>最早我们的用户代码是运行在C#上，是MonoRuntime。但是现在可以通过IL2CPP将其转成C++代码，所有现在几乎没有纯正的C#在运行了。</p><p>Unity的VM（虚拟机：Virtual Machine）依旧还是存在，主要用于跨平台，有了一层VM抽象后，跨平台的工作会容易很多，IL2CPP本身也是个VM。</p><h3 id="Unity内存管理"><a href="#Unity内存管理" class="headerlink" title="Unity内存管理"></a>Unity内存管理</h3><p><u>Unity内存按照分配方式</u>分为：<strong>Native Memory</strong>（原生内存）和<strong>Managed Memory</strong>（托管内存）。Native Memory并不会被系统自动管理，需要我们手动去释放。而Managed Memory的内存管理是自动的，会通过GC来释放。</p><p>此外Unity在Editor和Runtime下，内存的管理方式是不同的，除了内存大小不同，内存的分配时机以及分配方式也可能不同。</p><p>例如Asset，在Runtime时，只有我们Load的时候才会进内存。而Editor模式下，只要打开Unity就会进内存（所以打开很慢）。因此后续有推出<strong>Asset Pipeline 2.0</strong>，它会一开始导入一些基本的Asset，剩下的Asset只有你使用的时候才会导入。</p><p><u>Unity按照内存管理方式</u>分为：<strong>引擎管理内存</strong>和<strong>用户管理内存</strong>。引擎管理内存即引擎运行的时候自己要分配一些内存，例如很多的Manager和Singleton，这些内存开发者一般是碰触不到的。用户管理内存也就是我们开发者开发时使用到的内存，需要我们重点注意。</p><h4 id="Native-Memory"><a href="#Native-Memory" class="headerlink" title="Native Memory"></a>Native Memory</h4><h4 id="Managed-Memory"><a href="#Managed-Memory" class="headerlink" title="Managed Memory"></a>Managed Memory</h4><ul><li>VM内存池</li></ul><p>即Mono虚拟机的内存池，我们的内存以Block的形式管理，当一个Block<strong>连续6次</strong>GC没有被访问到，这块<strong>内存会被返回给系统</strong>，条件苛刻，比较难触发。（？</p><ul><li>GC</li></ul><h4 id="堆栈Stack和堆积Heap"><a href="#堆栈Stack和堆积Heap" class="headerlink" title="堆栈Stack和堆积Heap"></a>堆栈Stack和堆积Heap</h4><ul><li>堆栈</li></ul><p>堆栈是内存中存储<strong>函数</strong>和<strong>值类型</strong>的地方。</p><p>例如我们调用一个函数A，会将这个函数体与函数收到的参数放入到堆栈中，若在函数A中调用函数B，同样会把函数B存放到堆栈中。当函数B运行结束，会将其从堆栈中移除，然后当A运行结束，把A从堆栈中移除。</p><p>因此我们在看Debug信息的时候，就会发现Log里面能够做到一层层的方法回溯，方便我们查看整体的调用过程，这也就是<strong>堆栈回溯</strong>。</p><p>由于是堆栈的结构，因此不会遇到碎片化或是垃圾收集（GC）的问题。但是可能会碰见堆栈溢出的问题，比如调用了太多的函数导致一直push东西进堆栈，占据越来越多的内存空间，导致<strong>堆栈溢出</strong>。</p><ul><li>堆积</li></ul><p>堆积是内存中另一个区域，要比堆栈大，我们将所有的<strong>引用类型</strong>存放在这。通常我们每创建一个新的对象，会在堆积中找到下一个足够存放的空位置，将其存储。但是当我们销毁对象后，<strong>内存空间不会马上释放出来</strong>，而是标记成未使用，之后垃圾收集器会释放这部分空间。</p><p><strong>对象实例化和摧毁的过程其实很慢</strong>，所以我们要尽可能地避免在堆积中配置内存的行为。如果我们需要的内存比之前已经配置好的还多，在放不下的情况下，<strong>堆积会膨胀，并且每次都增长两倍，且不会再缩回去</strong>，过大的堆积就会影响到我们游戏的性能。当我们在堆积中释放了一些占用空间小的对象，而后添加一些占用空间大的对象时，由于前面释放的空间不足以存放下，就会导致这些空间空出来，使得内存的使用情况就变得断断续续起来，这也就是内存的<strong>碎片化</strong>，同样降低我们的游戏性能。</p><p>而我们前面所提到的GC就是在堆积上进行的，每一次GC，都会遍历堆积上所有的对象，找到需要释放的东西，也就是没有被引用的对象，然后将其释放。但是有时候我们的一些错误引用，导致一些我们希望释放掉的对象没有被GC掉，那么就会造成<strong>内存泄漏</strong>。</p><p>假如游戏玩到一半，GC必须要释放数十或数百个游戏对象的内存，那么这会对你的游戏过程造成一个负载峰值，我们要避免这样的负载峰值。</p><h2 id="优化Native-Memory"><a href="#优化Native-Memory" class="headerlink" title="优化Native Memory"></a>优化Native Memory</h2><h2 id="优化Managed-Memory"><a href="#优化Managed-Memory" class="headerlink" title="优化Managed Memory"></a>优化Managed Memory</h2><h3 id="Destroy与null"><a href="#Destroy与null" class="headerlink" title="Destroy与null"></a>Destroy与null</h3><p>用Destroy，别用null，显示的调用Destroy才能真正的销毁掉。</p><h3 id="Class和Struct"><a href="#Class和Struct" class="headerlink" title="Class和Struct"></a>Class和Struct</h3><p>根据具体使用情况选择Class或Struct。</p><h3 id="减少装箱拆箱操作"><a href="#减少装箱拆箱操作" class="headerlink" title="减少装箱拆箱操作"></a>减少装箱拆箱操作</h3><p>例如LINQ和常量表达式以装箱的方式实现，String.Format()也常常会产生装箱操作等。</p><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>虽然VM自己有内存池，但是我们还是需要自己使用内存池来管理。</p><p>在游戏程序中，创建和销毁对象事很常见的操作，通常会通过 <strong>Instantiate</strong> 和 <strong>Destroy</strong> 方法来实现，如果频繁的进行这些操作，GC的时候会导致负载很重，因为会有大量的已摧毁对象的存在，不仅会造成CPU的负载峰值，还可能导致堆积碎片化。因此我们可以使用对象池来处理这类问题。</p><p>使用对象池时需要注意，要决定对象池的大小，以及一开始要产生多少数量的对象在池中。因为如果你需要的对象数量多过池中现有的，就必须将对象池变大，扩的太大可能造成浪费，扩的小可能又造成频繁的添加。</p><h3 id="闭包和匿名函数"><a href="#闭包和匿名函数" class="headerlink" title="闭包和匿名函数"></a>闭包和匿名函数</h3><p>所有的匿名函数和闭包在c#编IL代码时都会被new成一个Class（匿名class），所以在里面所有函数，变量以及new的东西，都是要占内存的。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程属于闭包和匿名函数的特例，游戏开始启动一个协程直到游戏结束才释放，错误的做法。因为协程只要没被释放，里面的所有变量，即使是局部变量（包括值类型），也都会在内存里。建议用的时候才生产一个协程，不用的时候就丢掉。</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>慎用单例，且不要什么都往里放，因为里面的变量会一直占用内存。</p>]]></content>
    
    
    <summary type="html">Unity的编译原理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法-刷题思考-算法思想</title>
    <link href="https://huangxinhere.github.io/2023/06/07/202367-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>https://huangxinhere.github.io/2023/06/07/202367-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</id>
    <published>2023-06-06T16:00:00.000Z</published>
    <updated>2023-06-08T06:23:11.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="2611-老鼠和奶酪"><a href="#2611-老鼠和奶酪" class="headerlink" title="2611.老鼠和奶酪"></a>2611.老鼠和奶酪</h2><blockquote><p>一共有n块奶酪，两只老鼠，每一个奶酪，被不同老鼠吃会有不同的reward值。都被老鼠1吃的话，会有rewards1数组，反之都被老鼠2吃的话就有rewards2数组。</p><p>要求老鼠1要吃够k次，老鼠2可吃可不吃，老鼠1吃k次的时候得分最大是多少。</p></blockquote><p>老鼠各自吃有各自的得分，都有局部最优，但是同一块奶酪不能同时吃，所以每一块奶酪对于每只老鼠的利益互斥。而且要考虑全局最优。所以逐个遍历是找不到判断标准的。</p><p>受到一点启发，为了得分最高，那么老鼠2肯定要把数组长度n-k的都吃完，假设先让老鼠2吃完全部，然后比较每i个奶酪老鼠2让老鼠1吃的利益是多少。再把所有的利益排序，求k个最大值。</p>]]></content>
    
    
    <summary type="html">虽然很笨，但是也想突破自己学得更好</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统四：文件管理</title>
    <link href="https://huangxinhere.github.io/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://huangxinhere.github.io/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</id>
    <published>2023-06-06T16:00:00.000Z</published>
    <updated>2023-09-04T13:28:54.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h1><h2 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h2><ul><li>定义：以计算机<strong>硬盘</strong>为载体的 存储在计算机上的信息（文件内容和属性）集合；</li><li>属性：<u>描述文件</u>状态的一组信息，比如名称、标识符等；</li><li>基本操作：创建、读写、文件重定位、删除 截断等。</li></ul><h2 id="文件的结构"><a href="#文件的结构" class="headerlink" title="文件的结构"></a>文件的结构</h2><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><ul><li><p>无结构文件（流式文件）（从头到尾逐个字节）</p><p>以字节为单位；</p><p>没有具体结构；</p><p>采用穷举方式搜索；（从头到尾逐个识别）</p></li><li><p>有结构文件（记录式文件）每一个单位的数据算是一条记录；</p><p>顺序文件；（分为变长或定长）</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230607195101522.png" alt="image-20230607195101522"></p><p>索引文件；</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230607195216461.png" alt="image-20230607195216461"></p><p>索引顺序文件；索引对应的是顺序文件（可能是链式或数组）。</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230607195323999.png" alt="image-20230607195323999"></p><p>索引表表项过多的时候，可以再加一级索引表。</p><p>愿意牺牲一点空间来提高检索效率。</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230607195553779.png" alt="image-20230607195553779"></p></li><li><p>直接文件或散列文件（Hash File）</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230607195826634.png" alt="image-20230607195826634"></p></li></ul><h3 id="文件的目录结构"><a href="#文件的目录结构" class="headerlink" title="文件的目录结构"></a>文件的目录结构</h3><ul><li><p>文件控制块（FCB）File：</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608153831345.png" alt="image-20230608153831345"></p><blockquote><p>每一个FCB可能代表一个目录，或者只是一个普通文件。</p></blockquote><p>基本信息；</p><p>存取控制信息；</p><p>使用信息；</p></li><li><p>索引节点</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608154020189.png" alt="image-20230608154020189"></p></li><li><p>目录结构</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608154249706.png" alt="image-20230608154249706"></p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608154548433.png" alt="image-20230608154548433"></p><blockquote><p>当多个用户想要访问同一个目录，（文件共享）就各自创建一个链接，不用的时候就删除链接；不需要拷贝整份文件，而且文件可能很大。</p><p>还有一个点，在哪里记录链接的信息呢？文件控制块的信息只和文件本身有关，而索引节点是在文件信息的基础上新建的数据结构；而且，尽量不在原来的数据结构上更改（也就是文件控制块），可以在新建的数据结构上更改。同时索引节点所记录的条目要少。</p></blockquote></li></ul><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><h2 id="文件共享和保护"><a href="#文件共享和保护" class="headerlink" title="文件共享和保护"></a>文件共享和保护</h2><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><ul><li>硬链接（索引节点+计数器）</li></ul><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608155424422.png" alt="image-20230608155424422"></p><blockquote><p>多个用户访问同一个文件时，持有相同的索引节点指针，同时计数器动态计数。</p></blockquote><ul><li>软链接</li></ul><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608155839310.png" alt="image-20230608155839310"></p><blockquote><p>.lnk文件，相当于快捷方式（或创建了一个新的符号/别名）本质是一个文件，本身没有什么内容，记录了目标文件的地址。</p></blockquote><ul><li><p>两者比较：硬链接方法，如果用户都不链接的话，原文件会直接删除；软连接则不会，对原文件的影响最小。</p><p>软连接占用的存储会多一些；</p><p>硬链接的效率会更高，直接访问。</p></li></ul><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><ul><li>口令保护：不够安全，只是在索引节点加口令；【对象是文件】</li><li>加密保护：对<strong>文件</strong>直接操作，</li><li>访问控制：针对<strong>不同用户</strong> 不同操作 不同文件分别进行权限控制</li></ul><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608160822240.png" alt="image-20230608160822240"></p><h1 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h1><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>用户或应用程序想要访问文件，归根结底是 通过系统调用 访问操作系统内核的功能（这里内核功能具体指文件系统和IO操作等等）。</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230608161528559.png" alt="image-20230608161528559"></p><blockquote><p>缓冲区：物理硬件操作始终会比内存操作要慢，所以设立一个缓冲区，提高效率。</p><p>整个流程：比如用户打开资源管理器，双击打开一个文件夹，此时执行了一个接口调用；</p><p>接着获取并展示对应目录的信息；</p><p>通过权限后就能打开一个文件。具体来说通过（文件地址）逻辑地址转成物理地址【是文件而不是文件数据的逻辑和物理地址】，访问硬盘对应的数据，（如果文件很大则多次访问读取）读到缓冲区，再读到内存中【因为不能直接操作IO设备中的数据】。</p></blockquote><h2 id="目录实现"><a href="#目录实现" class="headerlink" title="目录实现"></a>目录实现</h2><p>如何组织FCB；</p><ul><li>线性列表</li><li>哈希表</li></ul><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230609165147853.png" alt="image-20230609165147853"></p><blockquote><p>每一个条目存储的是文件名+索引指针。</p></blockquote><h2 id="文件实现"><a href="#文件实现" class="headerlink" title="文件实现"></a>文件实现</h2><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230609165915183.png" alt="image-20230609165915183"></p><blockquote><p>文件存储空间也会分块，一般来说是4k一块，也称为“盘块”。</p></blockquote><h3 id="文件分配方式"><a href="#文件分配方式" class="headerlink" title="文件分配方式"></a>文件分配方式</h3><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230609170232475.png" alt="image-20230609170232475"></p><p>优缺点：支持顺序和直接访问，速度快；不方便扩展，会产生磁盘碎片（需要连续的空间）。</p><h4 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h4><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230609170411282.png" alt="image-20230609170411282"></p><p>记录的是起始块号和结束块号；在每一个盘块，都有记录下一个盘块位置的指针。</p><p>优缺点：隐式链接（指向藏在盘块里面），支持顺序访问，方便拓展，没有碎片；不支持直接访问，效率低；有数据丢失的风险（缺了其中一个指针，后续都无法访问）</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230609171020086.png" alt="image-20230609171020086"></p><p>显式链接：用一块表【FAT文件分配表】来记录盘块之间的链接。相当于由链表变成指针数组。</p><p>负数代表空闲。</p><p>优点：支持顺序访问、随机访问，效率高；无外部碎片，方便拓展。</p><p>缺点：占用空间较多，可能无法充分利用。</p><h4 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h4><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230610102104366.png" alt="image-20230610102104366"></p><p>每个文件有一个索引表，里面记录了相关的盘号。</p><p>但是如果一个盘块记录不完文件存储的盘号个数（文件太大），则采用多级索引。</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230610102746375.png" alt="image-20230610102746375"></p><blockquote><p>1024×1024</p><p>也可以采用快慢表思想：一部分区域可以用来直接放热点数据，直接访问。【混合索引】</p></blockquote><h3 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h3><p>没有使用的空间的管理；而文件分配方式是指已经分配好的空间的管理。</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230610103803817.png" alt="image-20230610103803817"></p><blockquote><p>可以一个物理磁盘分成多个卷，或者多个物理磁盘合成一个卷（物理和逻辑的关系）。</p><p>可以大致分为两个区，目录区和文件区。</p></blockquote><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h4><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230610104019040.png" alt="image-20230610104019040"></p><h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h4><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230610104237087.png" alt="image-20230610104237087"></p><p>盘块链：每个盘块做为节点。</p><p>不连续的空盘块的话存储的条目就比较长，实现简单但不适合太大文件。</p><h4 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h4><p>无论连不连续，都会组成一个固定大小的组。然后组与组之间链接起来。</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230610105612454.png" alt="image-20230610105612454"></p><ul><li>每一组是栈结构；</li><li>每个分组的第一个节点记录了下一个组的信息（N还有所有盘号……？）</li><li>最后一组可以不够100；特殊值代表后面没有分组了。</li><li>超级块：第一组连续的空闲扇区，系统启动时载入内存。（相当于链表的表头）</li></ul><h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h4><p>把右下角的灰色块看成一个矩阵，比如</p><p><img src="/2023/06/07/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统四：文件管理.assets\image-20230611115128017.png" alt="image-20230611115128017"></p>]]></content>
    
    
    <summary type="html">关于操作系统的知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统三：内存管理</title>
    <link href="https://huangxinhere.github.io/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://huangxinhere.github.io/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-05-28T16:00:00.000Z</published>
    <updated>2023-12-13T14:24:20.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><h2 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h2><h3 id="0-存储器结构"><a href="#0-存储器结构" class="headerlink" title="0.存储器结构"></a>0.存储器结构</h3><ul><li><p>多层结构</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529194909107.png" alt="image-20230529194909107"></p><blockquote><p>可移动存储介质：U盘；</p><p>主存储器：内存；</p><p>缓存：连接内存和辅存、寄存器之间的缓存；</p></blockquote><p><img src="https://picx.zhimg.com/v2-6cbe0ce1ed6a7336de891e9f83ad4269_r.jpg?source=1940ef5c" alt="img"></p><blockquote><p>计算机系统结构中，存储器分为主存储器和辅助存储器。 </p><p>主存储器就是我们一般所说的<strong>内存</strong>，辅助存储器一般就是我们所说的硬盘。 </p><ul><li><strong>RAM随机存取存储器</strong>，也叫主存，它可以随时读写，速度很快，通常作为操作系统或者其他正在运行中的程序的临时数据存储介质；</li><li> <strong>ROM只读存储</strong>的简称，是一种只能读出实现所存数据的固态半导体存储器。通常用在不需经常变更资料的电子或电脑系统中，并且资料不会因为电源关闭而消失。 </li></ul><p>主存的速度比辅存要快，但是主存还是不够快，跟不上CPU的速度，所以一般CPU都带了cache，就是高速缓存，速度上cache &gt; 主存 &gt; 辅存。</p></blockquote><blockquote><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529195154467.png" alt="image-20230529195154467"></p><p>外存也就是硬盘缓存。</p></blockquote></li></ul><h3 id="0-进程运行的基本原理"><a href="#0-进程运行的基本原理" class="headerlink" title="0.进程运行的基本原理"></a>0.进程运行的基本原理</h3><p>用户程序 =&gt; 进程：编译、链接、装入</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529195631972.png" alt="image-20230529195631972"></p><ul><li>编译：属于用户，不属于OS</li></ul><h3 id="1-程序的装入和链接"><a href="#1-程序的装入和链接" class="headerlink" title="1.程序的装入和链接"></a>1.程序的装入和链接</h3><ul><li><p>链接（源码和底层函数等）：</p><p>静态链接（在程序运行前 或 装入程序前就已经完成 / 适合体量小的程序）；</p><p>装入时动态链接：一边装入一边链接；</p><p>运行时动态链接：程序在内存工作的时候按需获取。</p></li><li><p>装入：（将装入模块装入内存中，但不知道装在内存哪里）</p><p>绝对装入：直接在程序定义好放在哪个位置，在以前有可能做到；只适合单道程序</p><p>可重定位装入：若运行多道程序，动态寻找内存空闲位置（也是早期）</p><p>动态运行时装入：同一个程序被分配的内存不连续；如果程序有2G，内存只有1G，那么如何运行呢——内存扩充。</p></li></ul><h3 id="2-逻辑地址空间与物理地址空间"><a href="#2-逻辑地址空间与物理地址空间" class="headerlink" title="2.逻辑地址空间与物理地址空间"></a>2.逻辑地址空间与物理地址空间</h3><p>逻辑地址（默认从0开始）与物理地址（实际装入的地址可能有偏移）</p><h3 id="3-内存保护"><a href="#3-内存保护" class="headerlink" title="3.内存保护"></a>3.内存保护</h3><p>内存保护：寄存器（？记录物理地址的范围，保护已分配的内存防止被访问</p><h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2><p>内存扩充的两种方式：覆盖、交换（把不活跃的进程交换到硬盘缓存）。</p><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>单一用户，单一操作系统。从用户区最低的地址开始连续分配；只有一个用户在单一作业，没用的空闲空间比较多。</p><p>优点：实现简单；无外部碎片；不一定需要内存保护（虽然用户区没有多个访问，但有可能用户访问系统区）；</p><p>缺点：只能用于单用户、单任务OS；有内部碎片（整个用户区没有利用好）；存储器利用率低。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230530104612728.png" alt="image-20230530104612728"></p><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>有分区说明表来记录分区信息，比如有多少个分区、分区大小、起始地址、使用状态等；</p><p>优点：实现简单，无外部碎片（用户区已经被提前分好了，被分完全了）；</p><p>缺点：较大用户程序时，需要采用覆盖技术，降低了性能；会产生内部碎片（比如分了8M的固定内存给4M的进程，剩余4M的空间无法被利用），利用率低。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531101509403.png" alt="image-20230531101509403"></p><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>根据进程需要来动态分配。</p><p>缺点：可能产生外部碎片（被各种需求的进程分配后的剩余空间大小不一）；无内部碎片（要多少给多少，对于进程来说刚刚好）。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531102105335.png" alt="image-20230531102105335"></p><ul><li><p>怎么记录内存的使用情况？</p><p>空闲分区表：只记录空闲状态的内存分区。</p><p>数据结构：可以是双向链表。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531102428842.png" alt="image-20230531102428842"></p></li><li><p>选择哪个分区给新进程？</p><p>首次适应算法：从<strong>低地址</strong>查找合适空间；（地址低的空间可能大也可能小）</p><p>最佳适应算法：优先使用<strong>最小空闲</strong>空间；</p><p><strong>最坏</strong>适应算法：优先使用<strong>最大</strong>连续空间；（尽量第一次就找到，减少搜索时间）</p><p>临近适应算法：从上次查找处向后查找。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531103937389.png" alt="image-20230531103937389"></p><blockquote><p>补充说明：</p><p>最坏适应的小碎片少：比如有10M分区，被4M进程用了，剩下的碎片是6M，碎片比较大</p></blockquote></li><li><p>已使用的分区怎么回收？</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531104615621.png" alt="image-20230531104615621"></p><blockquote><p>要回收P4的时候，可以和前后（相邻）空闲区域合并。</p></blockquote><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531104804412.png" alt="image-20230531104804412"></p></li></ul><h2 id="非连续分配与管理方式"><a href="#非连续分配与管理方式" class="headerlink" title="非连续分配与管理方式"></a>非连续分配与管理方式</h2><p>连续分配管理方式中，固定分区分配虽然没有外部碎片但有内部碎片，动态则有外部碎片没有内部碎片，总之两者对内存的使用效率都不高。</p><p>此分配方法就是尽量最大化地利用内存空间：一个进程占用的内存空间不连续。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531110118490.png" alt="image-20230531110118490"></p><blockquote><p>数据可能记录在不同的内存块上，需要数据结构来管理。数据结构本身就存在一定消耗。</p></blockquote><h3 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h3><p>就是<strong>比较小</strong>的固定分区。一般分为4k大小。</p><p>内部碎片的产生情况：一般不会超过单位的一半，碎片比较小（页内碎片）；</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531110329662.png" alt="image-20230531110329662"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601162309742.png" alt="image-20230601162309742"></p><blockquote><p>用页表这个数据结构来记录进程分了多少页，存在PCB中。分页较多的话，数据结构记录的就多。</p><p>页号：对应进程分的页；块号：对应分配的不连续的物理地址。</p></blockquote><ul><li><p>基本地址变换机构：逻辑地址对照页表来计算物理地址。（下面的计算也就是，计算在第几个，然后算在那个区域的偏移量；其中物理地址和逻辑地址的偏移量）</p><ul><li>物理地址 =（页号=&gt;块号）+偏移量。</li><li>页号P = 逻辑地址A / 页面长度（大小）L；</li><li>偏移量W = 逻辑地址A % 页面长度L；</li><li>（位运算没搞懂……）</li></ul></li><li><p>（接）基本地址变换机构：</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601164307632.png" alt="image-20230601164307632"></p></li></ul><blockquote><p>目的：虚线框内是内存，左边是CPU，现在要进行的操作是，为1024的逻辑地址+1。</p><p>做法：先从页表中查找，找到对应块号，再通过计算找到目的物理地址。</p><p>分析：读页表取块号（一次内存访问）、计算最终物理地址并访问（一次内存访问），一共两次；</p><p>​            CPU的工作速度比内存要快；</p><p>现存的问题：页式管理中地址空间是一维的（页号默认是索引，块号成数组）；每次访存都需要地址转换，必须足够快；页表不能太大，会降低内存利用率；</p></blockquote><p>解决：具有快表的地址变换机构。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601165044304.png" alt="image-20230601165044304"></p><blockquote><p>访问物理地址肯定要访问内存，但是页表能不能放在其它地方呢？放在CPU和寄存器肯定不行，因为两者空间太小；放在寄存器和内存之间的空间——高速缓存里面。</p><p>这样就有快表与慢表之分。但快表是慢表的一部分，因为空间有限，只能存一部分。访问过的就从慢表中找并添加到快表。慢表是一位数据，而快表由于不一定连续，要记录页号和块号，所以是二维数据。</p></blockquote><ul><li>直接将页号与快表页号比较；（优先访问快表）</li><li>匹配成功，取块号+偏移量形成地址；</li><li>匹配失败，访问主存页表，并同步到快表。（局部性原理：使用过的可能会被重新使用）</li></ul><p>慢表的“慢”除了体现在放在内存中，还有所占空间较大的问题。</p><p>假设逻辑地址（由页号和页内地址组成）占32位，页号占20位，页内地址占12位。那么页号最多可能有2的20次幂，也就是1,048,576，差不多一百万多一点，而</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit </span><br><span class="line"><span class="number">1</span> KB= <span class="number">1024</span> B </span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB </span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB </span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br></pre></td></tr></table></figure><p>则假设每个页号3个字节左右，那么1048576种页号有（×2）…个字节（Byte），大概2M……？【教程是当作1个字节来算】</p><p>即使是一维数组，达到这样百万数量效率也会低；</p><p>页内地址12位占4个字节，那么整个页表有 1,048,576 × 4个字节，差不多四兆的空间，这样内存开销比较大。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602125221421.png" alt="image-20230602125221421"></p><blockquote><p>页表占用内存空间：2^20 * 4Bit；</p><p>页框数：</p></blockquote><ul><li>页表连续存放，占用大量连续空间；【可以动态装入，部分加载👇 也就是离散】</li><li>一段时间内只需要访问部分特定页面；</li><li>页表项分组 / 分页离散存储；</li><li>建页目录表管理<strong>离散</strong>页表。</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602125904172.png" alt="image-20230602125904172"></p><blockquote><p>每一个子列表最多有1024项，所需存储空间1024 × 4Bit = 4K，也就是一个页框的大小，不至于浪费内存空间。</p></blockquote><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602130400618.png" alt="image-20230602130400618"></p><blockquote><p>刚刚好都可以用位数来分区。</p></blockquote><p><strong>两级页表</strong>（索引思想）：</p><ul><li>将逻辑地址拆分成三部分；</li><li>从PCB中读取页目录表始址；</li><li>根据一级页号（&gt;&gt;22），查出二级页表位置；</li><li>根据二级页号查内存块号（&lt;&lt;10 去高位 再 &gt;&gt;22 去低位），加偏移量计算物理地址。</li></ul><h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><p>分页是把物理地址划分成 固定大小 连续 的不同区域，进程也划分成很多连续的小块。</p><ul><li>分段</li></ul><p>但实际上进程是由多个模块组成的，所以有把进程分段的需求，比如主程序、子程序、公共区域等。根据需求分段，所以每段的大小不确定。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603153243396.png" alt="image-20230603153243396"></p><ul><li><p>段表</p><p>段内是连续的，段与段之间是没有联系的；每段都是从0开始。</p><p>段表记录每段在物理地址的起始信息，还有对应的大小。这样段表就是二维的了。</p></li><li><p>地址变换机构</p></li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603153809775.png" alt="image-20230603153809775"></p><blockquote><p>比如取一号段的逻辑地址，取前16位获得段号，根据基址找到物理地址，再使用后16位地址找到物理地址对应的位置。</p></blockquote><ul><li><p>段的共享与保护</p><p>共享：比如进程有某块区域共享，有多个子进程 / 进程访问，子程序也会在自己的段表里面添加对应条目，……？</p><p>保护：越界保护。</p></li></ul><ul><li><p>分页与分段方式对比（都是非连续分配）</p><ul><li>页：物理单位按照固定大小划分；</li><li>段：逻辑单位 按照逻辑来划分；不过始终要在物理地址上分配（和分页结合）一个段可能占用多个页；</li><li>分页：一维地址空间，只需要记录起始地址；</li><li>分段：二维地址空间，由于分段大小不固定，还要记录段长；段表一般放在寄存器中，相比于页表一般要小，因为进程不会分很多段。</li><li>分段更容易信息共享和保护。分页的颗粒度太小，共享一块区域可能要很多个页，而分段颗粒度比较大。</li></ul></li></ul><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603155050139.png" alt="image-20230603155050139"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603155300794.png" alt="image-20230603155300794"></p><ul><li>先分段，再分页</li></ul><p>1个进程对应一个段表；</p><p>一个段表项对应一个页表；由于一个段可能占用多个页，比如0号段（7kb），需要占用两个页：0号页（4kb）、1号页（3kb），此时【段页表】的【页表长度】为2，【页表存放块号】为1号块（也就是物理地址编号为1的块），而块上存储了页表信息（k0、k7）……？</p><p>一个页表对应多个物理块。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603160115172.png" alt="image-20230603160115172"></p><p>前16位：一个进程可能分的段数 / 段号；</p><p>页号：一个段可能分的页数 / 页号；最多为16个页。</p><p>后14位：对应的就是4k的页的地址。</p><ul><li>逻辑地址如何映射到物理地址上呢？</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603160458909.png" alt="image-20230603160458909"></p><blockquote><p>黄色虚线区域是内存，左侧是CPU管理区域（包括寄存器）。</p><p>段表寄存器：指向那张段页表？</p></blockquote><p>比如要找到逻辑地址1024（段号+页号+页内地址）</p><ul><li>【段号】 + 【段表始址】 找到 【段表项】：段表寄存器通过段表始址找到段表放在内存的地方，找到了段表后根据段号找到对应的段表项。</li><li>根据 【页表长度】检查页号越界情况；</li><li>【页表存放块号】+【页号】找到【页表项】：根据页表存放块号找到对应的物理块，然后物理块里面存有页表的信息，取出页表，根据逻辑地址给的页号来检索对应的页表项。</li><li>【内存块号】+【页内地址】得到物理地址。上一步找到页表项就是为了取具体的存放块号的信息，那么知道块号以后，就找到了某块物理地址，再结合逻辑地址的页内地址，就定位到了那块物理地址里面的具体位置（内存物理地址空间）。</li></ul><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><p>（逻辑上的概念）具有请求调入和置换功能，从逻辑上对内存容量加以扩充的一种存储器系统。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605122423462.png" alt="image-20230605122423462"></p><blockquote><p>金字塔形状表示离CPU的远近。寄存器的执行效率和cpu一致。主存储器就是内存条。硬盘缓存物理上属于固定磁盘，看起来就是扩充了内存的容量，外存就是硬盘缓存。</p><p>一般内存指的是主存（三部分），更狭义就是内存条；而虚拟内存=内存+外存。</p></blockquote><ul><li><p>局部性原理</p><ul><li>时间局部性：操作过的短时间内可能会再次操作；</li><li>空间局部性：同一个位置……</li><li>催生了缓存技术。重复利用的放入缓存，缓存效率比内存要高。</li></ul></li><li><p>虚拟内存的特征</p><ul><li>多次性：动态请求；</li><li>对换性：不用的时候换出，要用的时候换入；</li><li>虚拟性：逻辑上扩充。</li></ul></li><li><p>虚拟内存的实现</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理（三种和上面提到的差不多</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605123411819.png" alt="image-20230605123411819"></p></li></ul><h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><p>上节内存管理提到基本分页存储管理，那是一次性把所有进程加载进去。</p><p>而请求分页是动态加载：有需要才请求装入。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605123553415.png" alt="image-20230605123553415"></p><ul><li><p>页表机制</p><ul><li>状态位P：0说明在外存中，1反之；</li><li>访问字段A：记录被访问的次数；</li><li>修改位M：是否被修改过；</li><li>外存地址：也是物理地址，调出到的地址</li></ul></li><li><p>缺页中断机构</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124615166.png" alt="image-20230605124615166"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124635902.png" alt="image-20230605124635902"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124117141.png" alt="image-20230605124117141"></p><p>程序运行当中要访问的页不存在，就要从外存中调入。这个过程首先要产生中断。</p><blockquote><p>举例子，【调入】a号块要从外存x号块加载东西，加载完后要更新页表（内存块号、状态位）。</p></blockquote><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124435301.png" alt="image-20230605124435301"></p><blockquote><p>把c号块的东西调出到z号块，也会产生中断。</p></blockquote></li><li><p>地址变换机构</p></li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606123009538.png" alt="image-20230606123009538"></p><blockquote><p>橙色虚线框内就是内存，外面是CPU和寄存器。</p></blockquote><ul><li>请求调页，判断是否在内存。比如程序运行的时候发现缺少页，就要请求从磁盘中加载页。（请求过程也就是先查找快表，找到自己的逻辑地址的页号，对应的快表项，再找到外存地址；如果快表没找到，就通过页表寄存器查找慢表。）</li><li>可能需要页面置换。如果调入的时候内存不够，可能要把不太需要的页调出到外存。</li><li>新增（换出？） / 修改页表项。</li><li>热点表项（经常访问）同步到快表。</li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>哪些页面要调入调出的问题。</p><h3 id="最佳置换算法OPT：保障最低缺页率"><a href="#最佳置换算法OPT：保障最低缺页率" class="headerlink" title="最佳置换算法OPT：保障最低缺页率"></a>最佳置换算法OPT：保障最低缺页率</h3><p>每次选择淘汰最不可能再次被使用的页面（这样要用的页面就很少被换出）；</p><p>不好实现</p><h3 id="最近最久置换算法LRU：保障时间和距离上的公平"><a href="#最近最久置换算法LRU：保障时间和距离上的公平" class="headerlink" title="最近最久置换算法LRU：保障时间和距离上的公平"></a>最近最久置换算法LRU：保障时间和距离上的公平</h3><p>每次淘汰最久（时间）最近（距离）未使用的页面；</p><p>需要硬件支持，开销大（改页表？</p><h3 id="先进先出置换算法FIFO：保障顺序上的公平"><a href="#先进先出置换算法FIFO：保障顺序上的公平" class="headerlink" title="先进先出置换算法FIFO：保障顺序上的公平"></a>先进先出置换算法FIFO：保障顺序上的公平</h3><p>每次选择淘汰最早进入内存的页面；</p><p>Belady异常（淘汰的是要用的页），性能差（程序和加载的顺序无关，主要和使用频率有关）</p><h3 id="时钟置换算法NRU：保障性能和开销均衡"><a href="#时钟置换算法NRU：保障性能和开销均衡" class="headerlink" title="时钟置换算法NRU：保障性能和开销均衡"></a>时钟置换算法NRU：保障性能和开销均衡</h3><p>为页面设置访问位（0/1），并链接成循环队列，进程访问页面后置为1.</p><p>淘汰时为1置为0并跳过，为0时淘汰。(用完之后置为0)</p><p>最多需要两轮扫描</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606124914754.png" alt="image-20230606124914754"></p><h3 id="改进型时钟置换算法【？？？但-这个是最重要的算法"><a href="#改进型时钟置换算法【？？？但-这个是最重要的算法" class="headerlink" title="改进型时钟置换算法【？？？但 这个是最重要的算法"></a>改进型时钟置换算法【？？？但 这个是最重要的算法</h3><ul><li>额外考虑是否修改，保障最少I / O操作；</li><li>访问位和修改位主要看哪个？原则：尽可能保留访问位。</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606125501363.png" alt="image-20230606125501363"></p><p>增加修改位(0 / 1)，第一轮找（0，0），第二轮找（0，1）并修改访问位0，第三轮找（0，0）……</p><h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><p>解决到底要给进程分配多大的空间，怎么分配，什么时候分之类的问题。</p><ul><li>驻留集（驻留在主存中页面数）大小 （进程在内存中占用的空间是多少，按照页面的数量来算）<ul><li>（给进程）分配空间小，进程数量多，<strong>CPU时间利用效率</strong>就高；</li><li>进程在主存中页数少，<strong>错页率</strong>就高；（要频繁加载外存）</li><li>进程在主存页数多，错页率并无明显改善；（无需频繁加载外存，因为本身错页率不高……？</li></ul></li></ul><ul><li><p>页面分配策略</p><ul><li>固定分配局部置换</li><li>可变分配全局置换</li><li>可变分配局部置换</li></ul><p>固定也就是给进程划分好固定区域，如果内存还是不够，就自己解决，换入换出；</p><p>可变也就是划分的内存空间可变，要么换入换出，要么请求操作系统继续扩充内存，这也是局部全局的概念。</p><p>那么固定分配的话，如果分配少了，就一直缺，或者频繁换入换出，这时候错页率就高；分配多了，就浪费？</p></li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607191652415.png" alt="image-20230607191652415"></p><h3 id><a href="#" class="headerlink" title></a></h3><ul><li><p>调入页面的时机</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607192638119.png" alt="image-20230607192638119"></p><ul><li><p>预调页策略（进程被创建之后，就要被调入了）</p><p>一次性调入<strong>若干相邻页面</strong>（根据空间局部性原理，一个页面被调用后，相邻的页面也很可能被调用）</p><p>多用于进程<strong>首次调入</strong>；</p></li><li><p>请求调页策略</p><p>运行时发现缺页时调入；</p><p>I / O开销较大。（调页要访问磁盘，相当于IO操作，要慢很多……？）</p></li></ul></li><li><p>从何处调页</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607192816172.png" alt="image-20230607192816172"></p></li><li><p>系统拥有足够的对换区空间的时候：</p><p>主程序加载到内存的时候，把其它程序加载在对换区，因为对换区的速度比文件区快。</p></li><li><p>系统缺少足够的对换区空间的时候：</p><p>不会被修改（数据）的文件（函数等）直接调入到文件区，因为没有要改的东西，所以能减少换出，还能减少IO操作。</p></li><li><p>Unix方式</p><p>读主要从文件区，换入换出在对换区。</p></li></ul><h1 id="内存-地址-对齐"><a href="#内存-地址-对齐" class="headerlink" title="内存/地址 对齐"></a>内存/地址 对齐</h1><p><a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解 - 知乎 (zhihu.com)</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 现代计算机中内存空间都是按照字节(byte)划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，<strong>这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排列</strong>，这就是对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s);  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p><p><img src="https://pic3.zhimg.com/80/v2-3f40af513a94901b36ceb5387982277e_1440w.webp" alt="img"></p><p>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p><p><img src="https://pic1.zhimg.com/80/v2-361e2d16876ce8383c9e6ea2dca34474_1440w.webp" alt="img"></p><p>1.有些 CPU 可以访问任意地址上的任意数据，而有些 CPU 只能在特定地址访问数据，因此<u>不同硬件平台具有差异性</u>，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有<u>平台可以移植性</u>了。</p><p>2.CPU 每次寻址都是要消费时间的，并且 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能。</p><p>​    比如有些平台每次读都是从偶数地址开始，如果一个 int 型（假设是 32 位）如果存放在偶数地址开始的地方，那么一个时钟周期就可以读出。而如果是存放在一个奇数地址开始的地方，就可能会需要 2 个时钟周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 型数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p><h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p><p>有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p><a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解 - 知乎 (zhihu.com)</a></p><p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 偏移 都是<strong>该成员大小与有效对齐值中较小那个</strong>的<u>整数倍</u>，如有需要编译器会在成员之间加上填充字节。</p><p>(2) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_1440w.webp" alt="img"></p><blockquote><p>第二幅图，char占用一个字节，占用第0单元；到了int，由于≥4，相对于结构体首地址的偏移 要为4的倍数，占用第4，5，6，7单元；第二个char &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元</p></blockquote>]]></content>
    
    
    <summary type="html">关于操作系统的知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huangxinhere.github.io/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%20%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://huangxinhere.github.io/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%20%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2023-04-26T02:16:57.469Z</published>
    <updated>2023-09-07T03:03:03.190Z</updated>
    
    <content type="html"><![CDATA[<p>title: C++ 类设计者的工具<br>date: 2023/3/3<br>categories: 知识点梳理<br>description: 关于C++知识点整理<br>top_img: img/e82f983fly1hdarthbg8rj20u00gvjvd.jpg<br>cover: img/e82f983fly1hdarthbg8rj20u00gvjvd.jpg</p><h1 id="—–拷贝控制"><a href="#—–拷贝控制" class="headerlink" title="—–拷贝控制"></a>—–拷贝控制</h1><p><a href="https://zhuanlan.zhihu.com/p/568637296">拷贝构造函数vs移动构造函数 - 知乎 (zhihu.com)</a></p><p><a href="https://blog.csdn.net/Shrimp_millet/article/details/100288343">C++ 移动构造函数和拷贝构造函数_复制构造函数 移动构造函数_小虾米 ~的博客-CSDN博客</a></p><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">// 两个变量分别占两个独立的内存，复制的只是值，所以互不影响</span></span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类变量同理</span></span><br><span class="line">Vector2 a = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Vector2 b = a;</span><br><span class="line">b.x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>但是类用new创建实例的时候，复制的是指针，指向相同的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector2* a = <span class="keyword">new</span> <span class="built_in">Vector2</span>();</span><br><span class="line">Vector2* b = a;</span><br></pre></td></tr></table></figure><p>所以可见，将一个变量<strong>赋值</strong>给另一个变量的时候，就是在进行复制操作。把数据复制给另一个变量。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>新增了一个<strong>指针</strong>指向内存。</p><p>设想一个类里面的一个成员变量是指针，实例化A和B，把A复制给B，那它们的指针变量都会指向同一个内存。当A析构的时候清空了指针指向的内存时，如果B也析构试图清空指针指向的内存，就会导致程序崩溃。因为A的指针被delete掉了，B又试图清除不属于我们的内存。</p><p>【拷贝构造函数默认是浅拷贝】</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>把内存也复制了。</p><p>【拷贝构造函数】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己实现的String类</span></span><br><span class="line"><span class="comment">// 有默认拷贝函数</span></span><br><span class="line"><span class="comment">// 手动实现新内存分配</span></span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> String&amp; other)</span><br><span class="line">    : <span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">String string = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">String second = string;<span class="comment">// 隐式构造函数</span></span><br></pre></td></tr></table></figure><p>函数传参也会进行复制，所以为了减少开销可以用引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString</span><span class="params">(<span class="keyword">const</span> String&amp; string)</span><span class="comment">// const防止修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h2><ul><li>函数的参数为类的对象</li><li>函数的返回值是类的对象</li><li>对象需要通过另一个对象进行初始化</li></ul><h2 id="防止默认拷贝发生"><a href="#防止默认拷贝发生" class="headerlink" title="防止默认拷贝发生"></a>防止默认拷贝发生</h2><p>声明一个私有拷贝构造函数；</p><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>有时候我们会遇到这样一种情况，我们用对象a初始化对象b，后对象a我们就<strong>不再使用</strong>了，但是对象a的空间还在（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能<strong>直接使用a的空间</strong>呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷。</p><p>移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个<strong>右值引用</strong>。</p><p>意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">int</span> num,<span class="keyword">char</span> *ptr) </span><br><span class="line">&#123;</span><br><span class="line">x = num; p = ptr;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="keyword">const</span> Test&amp; a) :<span class="built_in">x</span>(a.x)</span><br><span class="line">&#123;</span><br><span class="line">p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">char</span></span>(<span class="number">1</span>);    <span class="comment">//深复制</span></span><br><span class="line">*p = *(a.p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">x</span>(a.x)</span><br><span class="line">&#123;</span><br><span class="line">p = a.p;</span><br><span class="line">a.p = <span class="literal">NULL</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;移动构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span>*p = &amp;ch;</span><br><span class="line">cout &lt;&lt; (<span class="keyword">void</span> *)p &lt;&lt; endl; <span class="comment">//输出指针的值要用void*</span></span><br><span class="line"><span class="function">Test <span class="title">a</span><span class="params">(x,p)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line"><span class="function">Test <span class="title">c</span><span class="params">(move(a))</span></span>;<span class="comment">// 用move语句将左值变成将亡值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="—–重载运算符与类型转换"><a href="#—–重载运算符与类型转换" class="headerlink" title="—–重载运算符与类型转换"></a>—–重载运算符与类型转换</h1><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><p>  下列运算符只能通过成员函数进行重载： </p><p> 1）= ：赋值运算符 </p><p>  2）()：函数调用运算符 </p><p>  3）[ ]：下标运算符 </p><p>  4）-&gt;：通过指针访问类成员的运算符 </p><h2 id="箭头运算符"><a href="#箭头运算符" class="headerlink" title="箭头运算符"></a>箭头运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*p).<span class="built_in">Method</span>();</span><br><span class="line">p-&gt;<span class="built_in">Method</span>();<span class="comment">// 解引用的简洁写法</span></span><br></pre></td></tr></table></figure><ul><li>箭头运算符重载</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity* m_Obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">: <span class="built_in">m_Obj</span>(entity)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Entity* <span class="title">GetObject</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Obj; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ScopedPtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">entity.<span class="built_in">GetObject</span>()-&gt;<span class="built_in">Print</span>();<span class="comment">// 如果要访问类的指针成员变量，这样写不太优雅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以重载运算符：有点神奇。箭头原本的含义是，访问指针指向的对象 的成员，现在是 访问指针指向的对象的对象变量 ，也就是自定义返回的对象……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entity* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">entity-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure><p>更加严谨的话可以加上const，访问的时候禁止修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二个const是访问这个类的方法时禁止修改类的成员，第一个const是返回一个常量？那么<code>entity-&gt;Print();</code>此时entity是一个常量，【常量只能调用const方法】……所以可见Print（）方法自动加上了const</p><p><code>void Print() const &#123; std::cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; endl; &#125;</code></p></blockquote><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>不同于强制类型转换，什么情况下可以根据上下文来进行自动转换呢？</p><ul><li>隐式构造函数：只提供构造的参数，就能默认转换成对应的构造器。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="keyword">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="keyword">int</span> age)</span><br><span class="line">        : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">m_Age</span>(age) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 写法1</span></span><br><span class="line">    Entity a = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    Entity b = <span class="built_in">Entity</span>(<span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写法2</span></span><br><span class="line">    <span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写法3</span></span><br><span class="line">    Entity a = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    Entity a = <span class="string">&quot;Cherno&quot;</span>; <span class="comment">// 错误。const char*=&gt;string=&gt;Entity 只能进行一次隐式转换</span></span><br><span class="line">    Entity b = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法3，是因为有Entity的构造函数，一个接受整数的参数，另一个接受string。C#和Java不可以这样搞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">(<span class="keyword">const</span> Entity&amp; entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Printing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PrintName</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>虽然使代码更简洁，但是可读性不是很好。</p></blockquote><ul><li>explicit：禁止隐式调用构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">        : m_Name(<span class="string">&quot;Unknown&quot;</span>), m_Age(age) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><h3 id="标准库调用的函数对象"><a href="#标准库调用的函数对象" class="headerlink" title="标准库调用的函数对象"></a>标准库调用的函数对象</h3><h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><h1 id="—–面向对象程序设计"><a href="#—–面向对象程序设计" class="headerlink" title="—–面向对象程序设计"></a>—–面向对象程序设计</h1><h2 id="定义基类与派生类"><a href="#定义基类与派生类" class="headerlink" title="定义基类与派生类"></a>定义基类与派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><ul><li><strong>【派生类对象及派生类向基类的类型转换】</strong></li></ul><p>派生类对象包含的部分：基类部分＋自定义部分，其中内存分布没有严格安排；</p><p>类型转换：基类的指针或引用绑定到派生类对象的<strong>基类部分</strong>上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base print out&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printOut</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived print out&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 如果没有虚函数，将调用基类部分的函数</span></span><br><span class="line">base *p = <span class="keyword">new</span> derived;</span><br><span class="line">p-&gt;<span class="built_in">printOut</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>【派生类构造函数】</strong></li></ul><p>派生类必须使用基类的构造函数来初始化它的基类部分。</p><ol><li>基类构造函数</li><li>派生类构造函数及函数体</li></ol><ul><li><strong>【派生类析构函数】</strong>书里面暂时没找到这个专题，但是先放在这一起讨论</li></ul><p>派生类应该也是要用基类的析构函数来析构基类部分。顺序的话应该是先派生类再基类。</p><p>但有一种特殊情况是，假设有很多个派生类，实例化一个基类指针来指向任意一个派生类对象，那么析构的时候就要知道到底用的是哪个派生类的析构函数。</p><p>这时候就得用到<strong>虚函数</strong>（而且最好是必须用到，也就是解决找到哪个派生类析构函数的问题；构造则只需要知道基类），来实现动态绑定。</p><blockquote><p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">base *pBase = <span class="keyword">new</span> derived;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> pBase;</span><br><span class="line"><span class="comment">// 假设执行以上代码后要派生类执行析构函数：</span></span><br><span class="line"><span class="comment">// base constructor</span></span><br><span class="line"><span class="comment">// derived constructor</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// derived destructor</span></span><br><span class="line"><span class="comment">// base destructor</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 必须有virtual，否则不会执行派生类的构造函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">base</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span> :</span> <span class="keyword">public</span> base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">derived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和其他虚函数一样，析构函数的虚属性也会被继承（即使不加virtual关键字、函数名不一样？）</span></span><br><span class="line">    <span class="comment">// 所以只要确保基类的析构函数是虚函数</span></span><br><span class="line">    ~<span class="built_in">derived</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;derived destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>【派生类使用基类的成员】</li><li>【继承 与 静态成员】</li></ul><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><h2 id="虚函数【继承-amp-amp-多态】"><a href="#虚函数【继承-amp-amp-多态】" class="headerlink" title="虚函数【继承&amp;&amp;多态】"></a>虚函数【继承&amp;&amp;多态】</h2><p><a href="https://blog.csdn.net/qq_36359022/article/details/81870219">C++多态虚函数表详解(多重继承、多继承情况)_一个类有几个虚函数表_青城山小和尚的博客-CSDN博客</a>【图文详细，清晰易懂】</p><p>为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="keyword">const</span> std::string&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::out &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Entity&quot;</span></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Entity&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>可见没有用虚函数的时候，是直接根据对象的类型来进行调用的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span><span class="comment">//virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span><span class="comment">// override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::out &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Entity&quot;</span></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Player&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/75172640">C++ 虚函数表剖析 - 知乎 (zhihu.com)</a></p><h3 id="类的虚表（含有函数指针的指针数组）"><a href="#类的虚表（含有函数指针的指针数组）" class="headerlink" title="类的虚表（含有函数指针的指针数组）"></a>类的虚表（含有函数指针的指针数组）</h3><p>每个包含了虚函数的类都包含一个虚表。</p><p>当一个类（B）继承另一个类（A）时，类B会继承类A的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-e864f4fe6a480b3230a5c9aebd7df996_1440w.webp" alt="img"></p><p><strong>虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针</strong>。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。</p><p>虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。</p><h3 id="对象的虚表指针（指向虚表-数组）"><a href="#对象的虚表指针（指向虚表-数组）" class="headerlink" title="对象的虚表指针（指向虚表/数组）"></a>对象的虚表指针（指向虚表/数组）</h3><p><strong>虚表是属于类的，而不是属于某个具体的对象</strong>，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</p><p>为了指定对象的虚表，<strong>对象内部包含一个虚表的指针，来指向自己所使用的虚表</strong>。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>*__vptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p><p><img src="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_1440w.webp" alt="对象和它的虚表"></p><p>上面指出，一个继承类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。（子类也有不同于父类的虚表，所以子类对象也有自己的虚表指针）</p><h3 id="多态代码及多重继承情况（多次单继承）"><a href="#多态代码及多重继承情况（多次单继承）" class="headerlink" title="多态代码及多重继承情况（多次单继承）"></a>多态代码及多重继承情况（多次单继承）</h3><p>在有继承情况下，<strong>只要基类有虚函数，子类不论实现或没实现，都有虚函数表</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ClassA</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassA::ClassA()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ClassA</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassA::~ClassA()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassA::func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassA::func2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassA::vfunc1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassA::vfunc2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> aData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassB</span> :</span> <span class="keyword">public</span> ClassA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ClassB</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassB::ClassB()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ClassB</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassB::~ClassB()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassB::func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassB::vfunc1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> bData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassC</span> :</span> <span class="keyword">public</span> ClassB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ClassC</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassC::ClassC()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">ClassC</span>() &#123; cout &lt;&lt; <span class="string">&quot;ClassC::~ClassC()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassC::func2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;ClassC::vfunc2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> cData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ol><li>ClassA是基类, 有普通函数: func1() func2() 。虚函数: vfunc1() vfunc2() ~ClassA()</li><li>ClassB继承ClassA, 有普通函数: func1()。虚函数: vfunc1() ~ClassB()</li><li>ClassC继承ClassB, 有普通函数: func2()。虚函数: vfunc2() ~ClassB()</li></ol></blockquote><p><strong>基类的虚函数表和子类的虚函数表不是同一个表</strong>。下图是基类实例与多态情形下，数据逻辑结构。注意，虚函数表是在编译时确定的，属于类而不属于某个具体的实例。虚函数在代码段，仅有一份。</p><p><img src="https://img-blog.csdn.net/20180820162125485?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>ClassB继承与ClassA，其虚函数表是在ClassA虚函数表的基础上有所改动的，变化的仅仅是在子类中重写的虚函数。</p><p>如果子类没有重写任何父类虚函数，那么子类的虚函数表和父类的虚函数表在<strong>内容上是一致的</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ClassA *a = <span class="keyword">new</span> ClassB();</span><br><span class="line">a-&gt;func1();<span class="comment">// &quot;ClassA::func1()&quot;   隐藏了ClassB的func1()</span></span><br><span class="line">a-&gt;func2();<span class="comment">// &quot;ClassA::func2()&quot;</span></span><br><span class="line">a-&gt;vfunc1();<span class="comment">// &quot;ClassB::vfunc1()&quot;  重写了ClassA的vfunc1()</span></span><br><span class="line">a-&gt;vfunc2();<span class="comment">// &quot;ClassA::vfunc2()&quot;</span></span><br></pre></td></tr></table></figure><p>上图，<strong>ClassA类型的指针a能操作的范围只能是黑框中的范围</strong>，之所以实现了多态完全是因为子类的<strong>虚函数表指针与虚函数表的内容</strong>与基类不同。</p><blockquote><p>这个结果已经说明了C++的<strong>隐藏</strong>、**重写(覆盖)**特性。</p></blockquote><p>同理，也就不难推导出ClassC的逻辑结构图了<br>类的继承情况是: ClassC继承ClassB，ClassB继承ClassA<br>这是一个多次单继承的情况。**(多重继承)**</p><p><img src="https://img-blog.csdn.net/20180821103628852?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ClassA* a = <span class="keyword">new</span> ClassC;</span><br><span class="line">a-&gt;func1();<span class="comment">// &quot;ClassA::func1()&quot;   隐藏ClassB::func1() </span></span><br><span class="line">a-&gt;func2();<span class="comment">// &quot;ClassA::func2()&quot;隐藏ClassC::func2()</span></span><br><span class="line">a-&gt;vfunc1();<span class="comment">// &quot;ClassB::vfunc1()&quot;ClassB把ClassA::vfunc1()覆盖了</span></span><br><span class="line">a-&gt;vfunc2();<span class="comment">// &quot;ClassC::vfunc2()&quot;ClassC把ClassA::vfunc2()覆盖了</span></span><br><span class="line"></span><br><span class="line">ClassB* b = <span class="keyword">new</span> ClassC;</span><br><span class="line">b-&gt;func1();<span class="comment">// &quot;ClassB::func1()&quot;有权限操作时，子类优先</span></span><br><span class="line">b-&gt;func2();<span class="comment">// &quot;ClassA::func2()&quot;隐藏ClassC::func2()</span></span><br><span class="line">b-&gt;vfunc1();<span class="comment">// &quot;ClassB::vfunc1()&quot;ClassB把ClassA::vfunc1()覆盖了</span></span><br><span class="line">b-&gt;vfunc2();<span class="comment">// &quot;ClassB::vfunc2()&quot;ClassC把ClassA::vfunc2()覆盖了</span></span><br></pre></td></tr></table></figure><h3 id="多继承下的虚函数表-同时继承多个基类"><a href="#多继承下的虚函数表-同时继承多个基类" class="headerlink" title="多继承下的虚函数表 (同时继承多个基类)"></a>多继承下的虚函数表 (同时继承多个基类)</h3><p>多继承是指一个类同时继承了多个基类，假设这些基类都有虚函数，也就是说每个基类都有虚函数表，那么该子类的逻辑结果和虚函数表是什么样子呢？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ClassA1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassA1() &#123; cout &lt;&lt; <span class="string">&quot;ClassA1::ClassA1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassA1() &#123; cout &lt;&lt; <span class="string">&quot;ClassA1::~ClassA1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassA1::func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassA1::vfunc1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassA1::vfunc2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">int</span> a1Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ClassA2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassA2() &#123; cout &lt;&lt; <span class="string">&quot;ClassA2::ClassA2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassA2() &#123; cout &lt;&lt; <span class="string">&quot;ClassA2::~ClassA2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassA2::func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassA2::vfunc1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassA2::vfunc2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc4</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassA2::vfunc4()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">int</span> a2Data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">ClassC</span> : <span class="title">public</span> <span class="title">ClassA1</span>, <span class="title">public</span> <span class="title">ClassA2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ClassC() &#123; cout &lt;&lt; <span class="string">&quot;ClassC::ClassC()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~ClassC() &#123; cout &lt;&lt; <span class="string">&quot;ClassC::~ClassC()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassC::func1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassC::vfunc1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassC::vfunc2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc3</span>(<span class="params"></span>)</span> &#123; cout &lt;&lt; <span class="string">&quot;ClassC::vfunc3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>ClassA1是第一个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()。<br>ClassA2是第二个基类，拥有普通函数func1()，虚函数vfunc1() vfunc2()，vfunc4()。<br>ClassC依次继承ClassA1、ClassA2。普通函数func1(),虚函数vfunc1() vfunc2() vfunc3()。</p></blockquote><p><img src="https://img-blog.csdn.net/20181023164040667?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2MzU5MDIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p>在多继承情况下，有多少个基类就有多少个虚函数表指针，前提是基类要有虚函数才算上这个基类。</p><ul><li><p>如图，<strong>虚函数表指针01</strong>指向的虚函数表是以ClassA1的虚函数表为基础的，子类的ClassC::vfunc1(),和vfunc2()的<strong>函数指针</strong>覆盖了<strong>虚函数表01中的虚函数指针01的位置、02位置</strong>。</p><p>当子类有多出来的虚函数时，添加在第一个虚函数表中。</p><p>当有多个虚函数表时，虚函数表的结果是0代表没有下一个虚函数表。” * “号位置在不同操作系统中实现不同，代表有下一个虚函数表。</p></li></ul><blockquote><ol><li>子类虚函数会覆盖<strong>每一个</strong>父类的<strong>每一个</strong>同名虚函数。</li><li>父类中没有的虚函数而子类有，填入第一个虚函数表中，且用父类指针是不能调用。</li><li>父类中有的虚函数而子类没有，则不覆盖。仅子类和该父类指针能调用。</li></ol></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ClassA1 *a1 = <span class="keyword">new</span> ClassC;</span><br><span class="line">a1-&gt;func1();               <span class="comment">// &quot;ClassA1::func1()&quot;    隐藏子类同名函数</span></span><br><span class="line">a1-&gt;vfunc1();              <span class="comment">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA1虚函数</span></span><br><span class="line">a1-&gt;vfunc2();              <span class="comment">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA1虚函数</span></span><br><span class="line">没有a1-&gt;vfunc3()，父类没有这个虚函数</span><br><span class="line"></span><br><span class="line">    ClassA2 *a2 = <span class="keyword">new</span> ClassC;</span><br><span class="line">a2-&gt;func1();               <span class="comment">// &quot;ClassA2::func1()&quot;    隐藏子类同名函数</span></span><br><span class="line">a2-&gt;vfunc1();              <span class="comment">// &quot;ClassC::vfunc1()&quot;    覆盖父类ClassA2虚函数</span></span><br><span class="line">a2-&gt;vfunc2();              <span class="comment">// &quot;ClassC::vfunc2()&quot;    覆盖父类ClassA2虚函数</span></span><br><span class="line">a2-&gt;vfunc4();              <span class="comment">// &quot;ClassA2::vfunc4()&quot;   未被子类重写的父类虚函数</span></span><br><span class="line"></span><br><span class="line">ClassC *c = <span class="keyword">new</span> ClassC;</span><br><span class="line">c-&gt;func1();                <span class="comment">// &quot;ClassC::func1()&quot;</span></span><br><span class="line">c-&gt;vfunc1();               <span class="comment">// &quot;ClassC::vfunc1()&quot;</span></span><br><span class="line">c-&gt;vfunc2();               <span class="comment">// &quot;ClassC::vfunc2()&quot;</span></span><br><span class="line">c-&gt;vfunc3();               <span class="comment">// &quot;ClassC::vfunc3()&quot;</span></span><br><span class="line">c-&gt;vfunc4();               <span class="comment">// &quot;ClassA2::func4()&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态绑定的条件"><a href="#动态绑定的条件" class="headerlink" title="动态绑定的条件"></a>动态绑定的条件</h3><p>我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</p><p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p><ul><li>通过指针来调用函数</li><li>指针upcast向上转型（继承类向基类的转换称为upcast，关于什么是upcast，可以参考本文的参考资料）</li><li>调用的是虚函数</li></ul><p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p><h3 id="回避虚函数的机制"><a href="#回避虚函数的机制" class="headerlink" title="回避虚函数的机制"></a>回避虚函数的机制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base::<span class="built_in">foo</span>(); <span class="comment">// 调用父类的虚函数</span></span><br><span class="line">    <span class="comment">// 子类的其他实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>Base::foo()</code> 的调用，可以直接调用父类中的虚函数，即使子类对该函数进行了重写。这样可以在子类的实现中先调用父类的虚函数，然后再添加自己的额外逻辑。</p><p>注意，通过作用域解析运算符调用父类的虚函数只适用于在子类中进行重写的情况。如果子类没有重写父类的虚函数，则可以直接调用虚函数，无需使用作用域解析运算符。</p><h2 id="纯虚函数（抽象方法-接口"><a href="#纯虚函数（抽象方法-接口" class="headerlink" title="纯虚函数（抽象方法/接口"></a>纯虚函数（抽象方法/接口</h2><p>还是上面的例子。这次把父类的函数改成纯虚函数。纯虚函数允许在父类定义一个没有实现的函数，然后强制子类去实现该函数（类似于抽象类）。所以如果子类想实例化的话就必须实现这个方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//=0在本质上使之为纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span><span class="comment">// override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">// Entity不能被实例化了</span></span><br><span class="line"><span class="built_in">PrintName</span>(e);</span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Player&quot;</span></span><br></pre></td></tr></table></figure><p>接口类：添加一个接口，由于C++没有interface关键字，所以用class，接口本质上也是只有纯虚函数的类，因此不能被实例化。Player类和Entity类都继承了接口，所以只有实现了纯虚函数才能被实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span> :</span> <span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;<span class="comment">// 重写接口函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;<span class="comment">// 重写接口函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口类型。本质上也是类的继承、虚函数表，来实现多态。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Print</span>(e);</span><br><span class="line"><span class="built_in">Print</span>(p);</span><br></pre></td></tr></table></figure><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><p>公有、私有、受保护继承。【C++的三种继承方式】</p><h3 id="受保护的成员"><a href="#受保护的成员" class="headerlink" title="受保护的成员"></a>受保护的成员</h3><ul><li>protected：对派生类的成员和<strong>友元</strong>是可访问的。</li><li>【注意】派生类的成员或友元只能<strong>通过派生类对象</strong>来访问基类的受保护成员。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> :</span> BaseClass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetProtectedNum</span><span class="params">(BaseClass&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.prot_mem;<span class="comment">// 错误，不能通过基类实例来访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetProtectedNum</span><span class="params">(SubClass&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.prot_mem;<span class="comment">// 正确，是派生类的基类部分的受保护成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>如果能直接访问基类的protected成员的话，那相当于派生类和友元都能直接更改基类实例的protected成员，那么在外部类封装一下也就能直接操作基类的成员了，这样就规避掉protected的保护了。</p></blockquote><h3 id="公有、私有和受保护继承"><a href="#公有、私有和受保护继承" class="headerlink" title="公有、私有和受保护继承"></a>公有、私有和受保护继承</h3><p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p><ul><li>基类中：该成员的访问修饰符；</li><li>派生类列表中：访问修饰符。<code>class SubClass : protected BaseClass</code></li></ul><p>首先明确派生类肯定会“继承”基类（在内存开辟空间存基类部分？）；</p><p>其次派生类对基类成员的访问权限 只与基类中的访问说明符有关；【上面的不让我用】</p><p>而<strong>派生访问说明符</strong> 是控制派生类用户对于基类成员的访问权限。【我不让下面的用】</p><ul><li><p>派生访问说明符：</p><p>如果继承是公有的，成员将遵循原有的访问修饰符；如果私有，则都不能访问。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200221123718539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzODI3NTk1,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="构造函数与访问控制"><a href="#构造函数与访问控制" class="headerlink" title="构造函数与访问控制"></a>构造函数与访问控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><h1 id="—–模板泛型编程"><a href="#—–模板泛型编程" class="headerlink" title="—–模板泛型编程"></a>—–模板泛型编程</h1><p>模板是C++ 中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者公式。</p><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>关键字<code>template</code>＋模板参数列表<code>&lt;typename/class  参数名&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">Print</span>(<span class="number">5.15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例化函数模板</li></ul><p>当调用一个函数模板时，编译器（通常）用函数实参（如int、float）来推断模板实参（typename T）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以显式声明</span></span><br><span class="line">Print&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>); </span><br></pre></td></tr></table></figure><p>再用推断出的模板参数来实例化一个特定版本的函数。</p><p>这些编译器生成的版本通常被称为<strong>模板的实例</strong>。</p><ul><li>非类型模板参数</li></ul><p>一个非类型参数表示一个值而非一个类型。绑定到非类型<strong>整型</strong>参数的<strong>实参</strong>必须是一个<strong>常量表达式</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Array&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; array;</span><br><span class="line">std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: C++ 类设计者的工具&lt;br&gt;date: 2023/3/3&lt;br&gt;categories: 知识点梳理&lt;br&gt;description: 关于C++知识点整理&lt;br&gt;top_img: img/e82f983fly1hdarthbg8rj20u00gvjvd.jpg</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ 基础</title>
    <link href="https://huangxinhere.github.io/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/"/>
    <id>https://huangxinhere.github.io/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-25T16:00:00.000Z</published>
    <updated>2023-09-23T06:46:02.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="—–C和C-的区别"><a href="#—–C和C-的区别" class="headerlink" title="—–C和C++的区别"></a>—–C和C++的区别</h1><p><a href="https://zhuanlan.zhihu.com/p/320280579">超详细C语言与C++的区别 - 知乎 (zhihu.com)</a></p><h2 id="面向过程和面向对象语言"><a href="#面向过程和面向对象语言" class="headerlink" title="面向过程和面向对象语言"></a>面向过程和面向对象语言</h2><p><strong>1.面向过程和面向对象的区别</strong></p><p>（1）<strong>面向过程</strong>：面向过程编程就是分析出<u>解决问题的步骤</u>，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。<br>（2）<strong>面向对象</strong>：面向对象编程就是<u>把问题分解成各个对象</u>，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</p><p><strong>2.面向过程和面向对象的优缺点</strong></p><p><strong>·</strong> <strong>面向过程语言</strong></p><p>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>缺点：没有面向对象易维护、易复用、易扩展</p><p><strong>·</strong> <strong>面向对象语言</strong>：</p><p>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<br>缺点：性能比面向过程低</p><h2 id="具体语言的区别"><a href="#具体语言的区别" class="headerlink" title="具体语言的区别"></a>具体语言的区别</h2><ul><li><p>关键字不同</p><p>（1）struct：在C语言中struct定义的变量中不能有函数，而在C++中可以有函数；</p><p>C++中struct可以实现继承、实现多态。</p><p>（2）malloc ：malloc函数的返回值为void*，在C语言中可以赋值给任意类型的指针，在C++中必须强制类型转换，否则报错。<br>（3）struct和class：class是对struct的扩展，struct默认的访问权限是public，而class默认的访问权限是private。</p></li></ul><h1 id="—–C-编译过程及原理"><a href="#—–C-编译过程及原理" class="headerlink" title="—–C++编译过程及原理"></a>—–C++编译过程及原理</h1><p><a href="https://blog.csdn.net/qq_43133135/article/details/82865618">(47条消息) C++的编译过程及原理_c++编译原理_qq_43133135的博客-CSDN博客</a></p><h2 id="C和C-程序结构"><a href="#C和C-程序结构" class="headerlink" title="C和C++程序结构"></a>C和C++程序结构</h2><p>声明一般放在头文件中；</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>将各种要调用的函数声明打包成头文件，并将其添加到main函数之前，在预编译过程中，#include将会被其文件内容替换，从而实现将函数声明放在main之前，为main函数中调用打下基础，这就是为什么#include为什么被放在cpp文件的开始部分。</p><ul><li><p>将头文件内容copy进去；</p></li><li><p>#define INTEGER int：define则将相应内容替换掉；</p></li><li><p>条件编译指令：在预编译的时候执行的条件选择。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  Linux</span></span><br><span class="line">linux平台下运行的函数</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  windows</span></span><br><span class="line">Windows平台下运行的函数</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>         </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样可以兼容不同的平台，想在linux平台下运行，只要在条件编译前添加<code>#define Linux</code>就好了。<br>另外，也可以通过这种方式来选择不接入某些不需要用的模块，提高编译速度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  USE_Printf  <span class="comment">//如果没有定义USE_Printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> myPrintf(...)    <span class="comment">//定义为空（无内容）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintf</span><span class="params">(....)</span> <span class="comment">//定义为一个具体函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;           </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>每个头文件只调用一次。</li></ul><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>在预处理阶段替换文本给编译器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-string">&lt;Name&gt;</span> &#123;语句或符号或变量等&#125;</span></span><br></pre></td></tr></table></figure><ul><li>一些常用预处理命令</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>              定义一个预处理宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>             取消宏的定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>                      编译预处理中的条件命令, 相当于C语法中的<span class="meta-keyword">if</span>语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>                判断某个宏是否被定义, 若已定义, 执行随后的语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>             与#<span class="meta-keyword">ifdef</span>相反, 判断某个宏是否未被定义【容易搞错！】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span>                  若#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>或前面的#<span class="meta-keyword">elif</span>条件不满足, 则执行#<span class="meta-keyword">elif</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span>-<span class="meta-keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                与#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>对应, 若这些条件不满足, 则执行#<span class="meta-keyword">else</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>              #<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>这些条件命令的结束标志.</span></span><br><span class="line">defined          与<span class="meta">#<span class="meta-keyword">if</span>, #<span class="meta-keyword">elif</span>配合使用, 判断某个宏是否被定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>            包含文件命令</span></span><br><span class="line">#include_next   与<span class="meta">#<span class="meta-keyword">include</span>相似, 但它有着特殊的用途</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span>                标志该语句所在的行号</span></span><br><span class="line">#                      将宏参数替代为以参数值为内容的字符窜常量</span><br><span class="line">##                   将两个相邻的标记(token)连接为一个单独的标记</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>       说明编译器信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span>       显示编译警告信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>          显示编译错误信息</span></span><br></pre></td></tr></table></figure><ul><li>例子1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情境2：在Debug模式下，会有日志输出；但是在Release模式下，不希望有日志泄露秘密或者什么。</li></ul><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++基础.assets\image-20230504145743737.png" alt="image-20230504145743737"></p><blockquote><p>在Debug和Release模式下，分别设置预处理定义宏，这里写为<code>PR_DEBUG</code>和<code>PR_RELEASE</code>.</p></blockquote><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++基础.assets\image-20230504145943001.png" alt="image-20230504145943001"></p><blockquote><p>回到代码，如果是release模式，下方语句高亮；反之相同。</p></blockquote><blockquote><p>两种模式的区别：release模式下编译器会自动优化一下代码（编译结果？）；而debug模式下编译器则尽量少改动代码，好让程序员进行调试。</p></blockquote><h2 id="编译过程及链接"><a href="#编译过程及链接" class="headerlink" title="编译过程及链接"></a>编译过程及链接</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line"></span><br><span class="line">animal.cpp</span><br><span class="line">human.cpp</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Linking...</span><br><span class="line"></span><br><span class="line">main.exe - <span class="number">0</span> <span class="built_in">error</span>(s), <span class="number">0</span> <span class="built_in">waring</span>(s)</span><br></pre></td></tr></table></figure><ul><li>编译器首先对源文件进行<u>单独编译</u>【.cpp】；</li><li>在编译时,由预处理器对<u>预处理指令</u>（#include、#define…）进行处理，在内存中输出翻译单元（就是将include等在源文件上替换了以后产生的<strong>临时文件</strong>）；</li><li>编译器<u>接受临时文件</u>，将其翻译成包含机器语言指令的<strong>目标文件</strong>【.obj】</li></ul><ul><li>接下去就是链接过程（<code>Linking...</code>），连接器将目标文件和你用到的相关库文件一起链接形成main.exe。<br>到此，编译也就结束了。</li></ul><p><img src="https://img-blog.csdn.net/20180927202022582?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTMzMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h1 id="—–变量和基本类型"><a href="#—–变量和基本类型" class="headerlink" title="—–变量和基本类型"></a>—–变量和基本类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li> 枚举的本质是整型。</li><li> 默认值会依次递增</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Example</span> :</span> <span class="built_in"><span class="keyword">int</span></span>(默认) /  <span class="keyword">char</span> / <span class="built_in"><span class="keyword">float</span></span>(×只能是整型)</span><br><span class="line">&#123;</span><br><span class="line">  A = <span class="number">5</span>, B, C;<span class="comment">// 默认递增为 B=6，C=7  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example value = B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型-引用"><a href="#复合类型-引用" class="headerlink" title="复合类型-引用"></a>复合类型-引用</h2><p>引用只是指针的伪装，指针的语法糖。 </p><p>引用必须引用已经存在的变量，引用本身并不是新的变量；<strong>并不占内存</strong>。</p><p><code>int* b = &amp;a;</code>是修饰变量a的，所以是取地址符；<code>int&amp; ref = a;</code>是修饰类型的，所以是引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*value)++;<span class="comment">//直接更改内存地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value++;<span class="comment">//引用简化了参数传递，消除了拷贝代价</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br></pre></td></tr></table></figure><ul><li>声明引用的时候，必须赋值；而且赋值之后不能再更改引用？，否则</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">ref = b;<span class="comment">// a = 8, 实质是a被赋值为b，而不是更改引用</span></span><br></pre></td></tr></table></figure><h2 id="复合类型-指针"><a href="#复合类型-指针" class="headerlink" title="复合类型-指针"></a>复合类型-指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>存储（在内存中的）地址。</li><li>只会是整数类型（4个字节），因为地址名固定；指针不包含数据，所以它不知道它指向的数据内存有多大……那么不同类型的指针只是方便用户/编译器识别。比如一个<code>Void*</code>想要更改成10，那么10是什么类型呢？想象内存地址对应的只是字节，然后给了个无类型10，那么要以整型规则解读10的字节，还是以无符号整型规则解读呢？所以定义为<code>int*</code>指针，就能读写准确地读写操作了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];<span class="comment">//申请8个字节；指针指向内存开头</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);<span class="comment">//将0填充进内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;<span class="comment">//删除指针</span></span><br></pre></td></tr></table></figure><h3 id="与字符串"><a href="#与字符串" class="headerlink" title="与字符串"></a>与字符串</h3><p><a href="https://juejin.cn/post/6929382361033506823#heading-29">c++学习笔记-指针与字符串 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/Kallou/article/details/123239999">(43条消息) C++ 字符串指针和字符串指针数组详解-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_43574446/article/details/106625062?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106625062-blog-123239999.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106625062-blog-123239999.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1">(43条消息) C++之字符串数组与字符指针_挖点代码拌西瓜的博客-CSDN博客</a></p><h3 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h3><p><a href="http://c.biancheng.net/view/335.html">数组指针和指针数组的区别，C语言数组指针和指针数组区别详解 (biancheng.net)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1[<span class="number">5</span>];<span class="comment">//指针（的）数组</span></span><br><span class="line"><span class="keyword">int</span> *(p2)[<span class="number">5</span>];<span class="comment">//数组（的）指针</span></span><br></pre></td></tr></table></figure><ul><li><p>指针数组</p><p>“[]”的优先级比“*”要高，所以 p1 先与“[]”结合，构成一个数组的定义，数组名为 p1；</p><p>而“int*”修饰的是数组的内容，即<u>数组的每个元素</u>；</p><p>也就是说，该数组包含 5 个指向 int 类型数据的指针，如图 1 所示，因此，它是一个指针数组。</p><p><img src="http://c.biancheng.net/uploads/allimg/180906/2-1PZ6092I9D6.jpg" alt="img"></p></li><li><p>数组指针</p><p>对于语句“int(p2)[5]”，“()”的优先级比“[]”高，“*”号和 p2 构成一个指针的定义，指针变量名为 p2；</p><p>而 int 修饰的是数组的内容，即数组的每个元素；</p><p>也就是说，p2 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如图 2 所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。</p><p><img src="http://c.biancheng.net/uploads/allimg/180906/2-1PZ6092Q4443.jpg" alt="img"></p></li><li><p>两者区别总结</p><p>由此可见，对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针，在 32 位系统下永远占 4 字节，至于它指向的数组占多少字节，这个不能够确定，要看具体情况。</p></li></ul><ul><li><p>示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p1)[<span class="number">5</span>] = &amp;arr;<span class="comment">//&amp;arr 是指整个数组的首地址</span></span><br><span class="line"><span class="comment">/*下面是错误的*/</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p2)[<span class="number">5</span>] = arr;<span class="comment">//arr 是指数组首元素的首地址</span></span><br></pre></td></tr></table></figure><ul><li><p>不难看出，在上面的示例代码中，&amp;arr 是指<strong>整个数组</strong>的首地址，而 arr 是指<strong>数组首元素</strong>的首地址；虽然所表示的意义不同，但二者之间的值却是相同的。</p></li><li><p>那么问题出来了，既然值是相同的，为什么语句“int(<em>p1)[5]=&amp;arr”是正确的，而语句“int(<em>p2)[5]=arr”却在有些编译器下运行时会提示错误信息呢（如在 Microsoft Visual Studio 2010 中提示的错误信息为“a value of type”int</em>“cannot be used to initialize an entity of type”int(</em>)[5]””）？</p></li><li><p>其实原因很简单，在 C 语言中，赋值符号“=”号两边的数据类型必须是相同的，如果不同，则需要显示或隐式类型转换。在这里，p1 和 p2 都是数组指针，指向的是整个数组。p1 这个定义的“=”号两边的数据类型完全一致，而 p2 这个定义的“=”号两边的数据类型就不一致了（左边的类型是指向整个数组的指针，而右边的数据类型是指向单个字符的指针），因此会提示错误信息。</p></li></ul></li></ul><ul><li><p>示例代码2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><ul><li><strong>a是数组名</strong>，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。</li><li><strong>&amp;a是数组的指针</strong>，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上<u>整个数组的偏移</u>（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。(????</li></ul></li></ul><h3 id="类对象隐式指针"><a href="#类对象隐式指针" class="headerlink" title="类对象隐式指针"></a>类对象隐式指针</h3><ul><li>对象指针为NULL仍能访问类函数<a href="https://blog.csdn.net/chenzrcd/article/details/60472616">https://blog.csdn.net/chenzrcd/article/details/60472616</a></li></ul><ol><li>类的成员函数并不与具体对象绑定，<strong>所有的对象共用同一份成员函数体</strong>，当程序被编译后，成员函数的地址即已确定；</li><li>这份共有的成员函数体之所以能够把不同对象的数据区分开来，靠的是<strong>隐式传递给成员函数的this指针</strong>，成员函数中对成员变量的访问都是转化成”this-&gt;数据成员”的方式。</li><li>因此，从这一角度说，成员函数与普通函数一样，只是多了一个隐式参数，即指向对象的this指针。而类的静态成员函数只能访问静态成员变量，不能访问非静态成员变量，所以静态成员函数不需要指向对象的this指针作为隐式参数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123; cout&lt;&lt;<span class="string">&quot;f1&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123; cout&lt;&lt;<span class="string">&quot;f2&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>&#123; cout&lt;&lt;num&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> </span>&#123;cout&lt;&lt;<span class="string">&quot;f4&quot;</span>&lt;&lt;endl; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* pa = <span class="literal">NULL</span>;</span><br><span class="line">pa-&gt;<span class="built_in">f1</span>();<span class="comment">//正常</span></span><br><span class="line">pa-&gt;<span class="built_in">f2</span>();   <span class="comment">//正常</span></span><br><span class="line">pa-&gt;<span class="built_in">f3</span>();   <span class="comment">//错误，提示段错误</span></span><br><span class="line">pa-&gt;<span class="built_in">f4</span>();   <span class="comment">//错误，提示段错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h2><p>变量的定义包括一个基本数据类型和<strong>一组声明符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure><ul><li>指向指针的指针</li></ul><p>一般来说，声明符中修饰符的个数并没有限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="keyword">int</span> *ppi = &amp;pi;</span><br></pre></td></tr></table></figure><ul><li>指向指针的引用</li></ul><p>引用本身不是一个对象，因此不能定义指向引用的指针；但指针是对象，所以存在对指针的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;<span class="comment">//r是一个对指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i;<span class="comment">//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>;<span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure><blockquote><p>要理解r的类型到底是什么，最简单的方法就是从<strong>右到左</strong>阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响，因此r是一个引用。</p><p>声明符的其余部分用以确定r引用的类型是什么，*说明r引用的是一个指针。</p></blockquote><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="built_in">get_size</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;<span class="comment">//错误，没有初始化</span></span><br></pre></td></tr></table></figure><ul><li>初始化和const</li></ul><p>const类型的对象能执行的操作有：不改变其值的；初始化。</p><p>其中初始化是不在意其是否是一个const常量；因为拷贝一个对象的值不会改变它，一旦拷贝完成，新的对象和原来的对象就没有什么关系了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">int</span> j = ci;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，const对象只在文件内有效</li></ul><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><ul><li><p>应用于普通变量；</p></li><li><p>应用于引用：把引用绑定到const对象上</p><p>对常量的引用不能被用作修改它所绑定的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = ci;<span class="comment">//正确：引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">//错误：r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;<span class="comment">//错误：也不能用过引用来改变常量</span></span><br></pre></td></tr></table></figure></li><li><p>应用于指针：难一点的：常量指针和指针常量，看指针相关记录。</p><ul><li><strong>指向常量的指针/指针常量</strong>不能用于改变其所指对象的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;<span class="comment">//错误：ptr是个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;<span class="comment">//正确。*cptr前面是double类型，说明是double类型的指针；double前面是const，说明double是const的</span></span><br></pre></td></tr></table></figure><ul><li><strong>const指针/常量指针</strong>：指针是对象，所以可以作为常量；不变的是指针本身而不是所指的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;<span class="comment">//curErr将一直指着errNumb。const修饰int*类型，说明指针是常量……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;<span class="comment">//pip是一个指向常量对象的常量指针（本身和所指的都不能变）</span></span><br></pre></td></tr></table></figure><blockquote><p>从右往左阅读理解</p></blockquote></li><li><p>应用于类和方法：</p></li></ul><p><a href="https://yz.cuc.edu.cn/_web/_search/api/search/new.rst?locale=zh_CN&amp;request_locale=zh_CN&amp;_p=YXM9MTU4JnQ9NDkzJmQ9MjgxMCZwPTMmZj04NTI3JmE9MCZtPVNOJnxibm5Db2x1bW5WaXJ0dWFsTmFtZT04NTI3Jg">https://yz.cuc.edu.cn/_web/_search/api/search/new.rst?locale=zh_CN&amp;request_locale=zh_CN&amp;_p=YXM9MTU4JnQ9NDkzJmQ9MjgxMCZwPTMmZj04NTI3JmE9MCZtPVNOJnxibm5Db2x1bW5WaXJ0dWFsTmFtZT04NTI3Jg</a>__</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_X, m_Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span><span class="comment">// 在变量列表后面加，对隐含的this指针加上const限定；原来的this也就是指向非常量对象的常量指针。指针本身不能变，但指向的对象可以变；加上const之后，变成常量指针常量，所指都不能变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X = <span class="number">2</span>;<span class="comment">// 错误,无法修改</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetX</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="keyword">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::out &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl; <span class="comment">// 如果GetX()声明为const，那么不会报错；否则就报错。为什么呢？</span></span><br><span class="line">    <span class="comment">// 首先const修饰的引用意味着什么。引用本来就是一个变量的别名，可以修改内容，但不能修改“引用的对象”，所以类似于一个指针常量；加上const就是类似于常量指针常量，所指对象和内容都不能修改。</span></span><br><span class="line">    <span class="comment">// 所以如果GetX()不声明为const，还是有可能修改内容，所以不符合const引用的要求，所以报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着上面的例子。可以用const重载GetX()，这样e.GetX()默认调用有const那个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_X = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在const方法里面确实要修改呢? mutable关键字，一般在类的const方法改变某个成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_FuncCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_FuncCount++;<span class="comment">// 特殊情况下需要改变的成员变量</span></span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h2><h3 id="类和结构体外部的静态"><a href="#类和结构体外部的静态" class="headerlink" title="类和结构体外部的静态"></a>类和结构体外部的静态</h3><p>只对当前翻译单元可见。也就是编译的时候会链接每个文件，所以如果在main.cpp声明一个全局变量，那么log.cpp也能访问到。如果只想main单独使用，那么可以声明为static。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.cpp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_Variable = <span class="number">5</span>;<span class="comment">//只对该文件可用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s_Variable = <span class="number">5</span>;<span class="comment">//可以被其他文件访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">int</span> s_variable;</span><br></pre></td></tr></table></figure><h3 id="类和结构体内的静态"><a href="#类和结构体内的静态" class="headerlink" title="类和结构体内的静态"></a>类和结构体内的静态</h3><ul><li><p>相当于”类范围内的“全局变量，而不是命名空间那么大的。</p></li><li><p>可以通过类直接访问。</p></li><li><p>所有实例共享静态变量/函数。</p></li><li><p>静态变量要初始化。（一定在类之外？）<code>int  Entity::x = 0;</code></p></li><li><p>静态函数只能访问静态变量和静态函数。</p></li></ul><blockquote><p>静态函数不可以访问非静态变量。因为静态函数不知道非静态变量属于哪个实例。为什么非静态函数就可以呢？因为实例创建的时候默认用this记录实例的地址空间，所以隐式用this来访问实例以及对应的非静态变量；而静态则没有这个this。所以要想静态函数访问非静态变量，就要传入实例变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 无法访问非静态变量，不知道实例对象是谁</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line"> y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 知道实例是谁了</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">(Entity e1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e1.x = <span class="number">2</span>;</span><br><span class="line"> e1.y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="局部静态local-static"><a href="#局部静态local-static" class="headerlink" title="局部静态local static"></a>局部静态local static</h3><ul><li>变量的生存期和作用域：一直生存；只在函数内部等局部范围内有效。</li><li>相当于”函数范围内（或其他局部）“的全局变量，避免其他地方访问修改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="comment">// int i = 0;// 1 1 1</span></span><br><span class="line">    i++;</span><br><span class="line">    std::count &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例子】单例类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* s_Instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *s_Instance; &#125;</span><br><span class="line">    <span class="keyword">void</span> Hello&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line">    <span class="comment">//static Singleton* s_Instance;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Hello&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理类型-typedef"><a href="#处理类型-typedef" class="headerlink" title="处理类型-typedef"></a>处理类型-typedef</h2><p>是某种类型的同义词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;<span class="comment">// wages是double的同义词</span></span><br></pre></td></tr></table></figure><ul><li>using 关键字也可以指定别名。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using的写法把别名的名字强制分离到了左边，而把别名指向的放在了右边，比较清晰</span></span><br><span class="line"><span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(Event&amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是用typedef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* EventCallbackFn)</span> <span class="params">(Event&amp;)</span></span></span><br></pre></td></tr></table></figure><h2 id="处理类型-auto"><a href="#处理类型-auto" class="headerlink" title="处理类型-auto"></a>处理类型-auto</h2><p>让编译器自动分析表达式所属的类型。</p><ul><li>比如api返回值变化了，获取变量的类型auto可以不变；但调用特定类型的方法时就会麻烦……</li><li>可以简化很长的类型说明；如果是int,string这些基本的尽量不要使用。</li><li>auto不处理引用。要将变量识别为引用的话，<code>auto&amp; b = 2</code></li></ul><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++基础.assets\image-20230504152942936.png" alt="image-20230504152942936"></p><h2 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h2><p><a href="https://zhuanlan.zhihu.com/p/423263090">C++中的extern关键字 - 知乎 (zhihu.com)</a></p><blockquote><p>添加extern声明，可以让编译器把“寻找定义”这件事情<strong>推迟到链接阶段</strong>，而不会在编译阶段报“没有定义”的错误。</p></blockquote><p>“用到未被定义的变量/函数”这种情况一般出现在<strong>使用在其它文件中定义的变量/函数</strong>时。例如：需要在<code>a.cpp</code>文件中使用在<code>b.cpp</code>中定义的变量/函数。</p><p><strong>1. 在<code>a.cpp</code>文件中使用在<code>b.cpp</code>中定义的<em>函数</em></strong></p><p>对于“在<code>a.cpp</code>文件中使用在<code>b.cpp</code>中定义的<em>函数</em>”这种场景，我们都非常熟悉。一般我们会通过在<code>a.cpp</code>中<code>#include &lt;b.h&gt;</code>来解决这个问题。这种方式能够奏效，是因为函数声明默认被隐式的extern关键字所修饰。</p><p>在某些情况下，<u>可能<code>b.cpp</code>文件并没有对应的<code>b.h</code>头文件</u>，这时就需要在<code>a.cpp</code>中使用<code>extern</code>关键字声明<code>b.cpp</code>中的函数。</p><p><strong>2.在c++程序中声明c语言文件中的函数</strong></p><p><a href="https://blog.csdn.net/gogogo_sky/article/details/71189499">在c++程序中调用被C编译器编译后的函数，为什么要使用extern “C”_gogogo_sky的博客-CSDN博客</a></p><p><img src="https://img-blog.csdn.net/20170504213233936?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ29nb2dvX3NreQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;<span class="comment">// 要加&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">Add</span>(<span class="number">50</span>,<span class="number">50</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果不加extern “C”的话会报错：</li></ul><p>c语言程序和c++程序在编译时，是相互独立的编译；</p><p>在.c文件中，编译器将Add函数重命名为_Add; </p><p>而在.cpp文件中，编译器将用extern声明的函数重命名为（?Add@@YAHHH@Z）；</p><p>那么在链接阶段，在mian函数中该Add函数被调用；此时编译器带着（?Add@@YAHHH@Z）函数名进入test.c文件的编译文件中去寻找(?Add@@YAHHH@Z）函数，但是在test.c文件中这个Add函数被编译器重命名为_Add，由于在.cpp文件中和.c文件中同一个函数名被编译器重命名后的名字不一样；所以.cpp文件声明的外部函数找不到真正定义的地方；程序错误；</p><blockquote><p>c++语言为了支持重载，对编译时函数的重命名规则进行了更改,<br>使用extern “C” 的方式在c++程序中声明c语言文件中的函数，可以在编译时，告诉编译器使用C语言的规则对该函数的的函数名的进行重命名，这样在链接的时候，就可以顺利在.c文件中找到该函数；</p></blockquote><h1 id="—–字符串、向量和数组"><a href="#—–字符串、向量和数组" class="headerlink" title="—–字符串、向量和数组"></a>—–字符串、向量和数组</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>下面是指针（字符指针可以直接赋值字符串-C语言风格 ），那怎么知道字符串长度呢？最末尾有一个终止符00(十六进制)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 一般搭配const，因为这是一个固定分配的内存块</span></span><br><span class="line"><span class="comment">// 相当于&quot;Jeson/0&quot;，自动分配一个终止符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">5</span>] = &#123;<span class="string">&#x27;J&#x27;</span>,...&#125;;<span class="comment">// 打印出Jeson和一堆乱符号;没有终止符</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">6</span>] = &#123;..., <span class="number">0</span>&#125;;<span class="comment">// 正确打印Jeson</span></span><br><span class="line">std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>关于终止符的进一步例子：</p><p>提前放置终止符会破坏字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[<span class="number">8</span>] = <span class="string">&quot;Cher\0no&quot;</span>;<span class="comment">// 内存中是Cher.no. 在ASCⅡ中.表示0</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[<span class="number">8</span>] = <span class="string">&quot;Cherno&quot;</span>;<span class="comment">// 6</span></span><br><span class="line"><span class="built_in">strlen</span>(name);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="string类自定义实现"><a href="#string类自定义实现" class="headerlink" title="string类自定义实现"></a>string类自定义实现</h3><p><a href="https://blog.csdn.net/u012814856/article/details/79753031">让我们一步一步实现一个完整的 String 类：构造、拷贝、赋值、移动和析构_c++ string实现_曾经去过跨越一个小时的地方的博客-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造：默认（传参）、拷贝构造、移动构造</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other);</span><br><span class="line">    <span class="built_in">String</span>(String &amp;&amp;other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构</span></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值：拷贝赋值、移动赋值</span></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;other); </span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(String &amp;&amp;other);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *m_data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">        *m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Default constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];<span class="comment">// 同理，考虑中止符</span></span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Pass argument constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];<span class="comment">// 不需要清理m_data，直接赋值</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Copy constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>(String &amp;&amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = other.m_data;<span class="comment">// 直接赋值</span></span><br><span class="line">    other.m_data = <span class="literal">nullptr</span>;<span class="comment">// 清理原变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Move constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值</span></span><br><span class="line">String &amp;String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果不是自己赋值给自己</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_data) <span class="keyword">delete</span>[] m_data;<span class="comment">//先清空，再复制</span></span><br><span class="line">        <span class="keyword">int</span> length = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">        m_data = <span class="keyword">new</span> <span class="keyword">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Copy assignment&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动赋值函数</span></span><br><span class="line">String &amp;String::<span class="keyword">operator</span>=(String &amp;&amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] m_data;</span><br><span class="line">        m_data = other.m_data;</span><br><span class="line">        other.m_data = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Move assignment&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 测试：默认构造</span></span><br><span class="line">        String s1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：传参构造</span></span><br><span class="line">        <span class="function">String <span class="title">s2</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：拷贝构造</span></span><br><span class="line">        <span class="function">String <span class="title">s3</span><span class="params">(s1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：移动构造</span></span><br><span class="line">        <span class="function">String <span class="title">s4</span><span class="params">(std::move(s3))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：拷贝赋值</span></span><br><span class="line">        String s5;</span><br><span class="line">        s5 = s4;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：移动赋值</span></span><br><span class="line">        String s6;</span><br><span class="line">        s6 = std::<span class="built_in">move</span>(s5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试：自动析构</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string赋值和传参"><a href="#string赋值和传参" class="headerlink" title="string赋值和传参"></a>string赋值和传参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string name = <span class="string">&quot;Jeson&quot;</span> + <span class="string">&quot; hello!&quot;</span>; <span class="comment">// 报错，两者本质上是const char*，不能直接相加</span></span><br><span class="line"></span><br><span class="line">std::string name = std::<span class="built_in">string</span>(<span class="string">&quot;Jeson&quot;</span>) + <span class="string">&quot; hello!&quot;</span>;<span class="comment">// 正确</span></span><br><span class="line">std::string name = <span class="string">&quot;Jeson&quot;</span>;</span><br><span class="line">name += <span class="string">&quot; hello!&quot;</span>;<span class="comment">//正确，string重载了+=运算符</span></span><br></pre></td></tr></table></figure><ul><li>传递只读string变量时，这样会复制一份string，造成开销</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString</span><span class="params">(std::string string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化：&amp;确保不会被复制，const确保不会修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString</span><span class="params">(<span class="keyword">const</span> std::string&amp; string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占内存大小"><a href="#占内存大小" class="headerlink" title="占内存大小"></a>占内存大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x[]= <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> y[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* z = <span class="string">&quot;abcdefffffff&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(x) &lt;&lt; endl;<span class="comment">// 7, 有终止符</span></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(y) &lt;&lt; endl;<span class="comment">// 6, 正常大小</span></span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(z) &lt;&lt; endl;<span class="comment">// 8, 按照指针大小处理（因为不是数组名，数组名会按照整个数组长度计算）</span></span><br></pre></td></tr></table></figure><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 一般搭配const，因为这是一个固定分配的内存块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* name = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 不被允许</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// 禁止写入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>] = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 数组则是开辟了空间存入字符串常量，指针就是直接改常量</span></span><br></pre></td></tr></table></figure><p>字符串常量一般放在内存的只读区域</p><h2 id="动态数组vector"><a href="#动态数组vector" class="headerlink" title="动态数组vector"></a>动态数组vector</h2><p>地址不变，内存空间连续，所以在中间进行<u>插入和删除</u>时会造成内存块拷贝，如果插入的是结构体或者类，则会造成构造和析构，性能不是特别高，对结尾元素操作最快。</p><ul><li><p>【性能缺点一】不够空间时，会在内存分配一个新的更大的空间。然后将原数组复制过去，得到一个新的数组，并重新分配起始指针和终止指针；再删除旧位置的内存。</p><p>接下来对复制进行一个深入理解：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">: <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数（深拷贝）</span></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="keyword">const</span> Vertex&amp; vertex)</span><br><span class="line">: <span class="built_in">x</span>(vertex.x), <span class="built_in">y</span>(vertex.y), <span class="built_in">z</span>(vertex.z)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Vertex&gt; vertices;</span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);<span class="comment">// 1个元素（复制一次）</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;);<span class="comment">// 2个元素（复制两次）</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;);<span class="comment">// 3个元素（复制三次）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数被调用了六次。</p><ul><li>第一次push_back的时候，先在栈中创建了一个实例，由于vector长度不够，开辟新的内存空间，然后再复制给vector，复制了一次。</li><li>第二三次同理，扩容，然后将 栈中的实例复制过去。</li></ul></blockquote><ul><li><p>如何避免复制</p><ul><li>【避免扩容】在开始就确定有多大的内存：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;Vertex&gt; <span class="title">vertices</span><span class="params">(<span class="number">3</span>, ...)</span></span>;<span class="comment">// 用构造函数，会初始化三个空的Vertex对象</span></span><br><span class="line">vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);<span class="comment">// 只设置容量，比上一个方法好</span></span><br></pre></td></tr></table></figure><ul><li>【直接在容器中实例化】emplace_back</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));<span class="comment">// 实质上又是实例化再复制过去，不要用！</span></span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">// 应该直接给出构造参数！</span></span><br></pre></td></tr></table></figure></li><li><p>存储类类型时，最好使用对象而不是指针；因为存储对象确保存储空间是连续的，指针存储可能是碎片的。（指针本身存储是连续的，但是指向的内容并不确保连续……）</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="原始数组"><a href="#原始数组" class="headerlink" title="原始数组"></a>原始数组</h3><p>开辟连续的内存空间，并进行赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> example[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++.assets\image-20230405181710959.png" alt="image-20230405181710959"></p><p>数组名其实是指针，那怎么访问元素呢？”[index]“这个中括号其实进行了运算符重载，本质上是通过指针偏移来访问相对地址上的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = example;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两者本质上等价</span></span><br><span class="line">example[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">*(ptr+<span class="number">2</span>) = <span class="number">6</span>;<span class="comment">// int类型的指针偏移两个int（8个字节）长度</span></span><br><span class="line">*(<span class="keyword">int</span>*)((<span class="keyword">char</span>*)ptr + <span class="number">8</span>) = <span class="number">6</span>;<span class="comment">// 如果强制转换成char类型的指针，就是直接偏移8个字节</span></span><br></pre></td></tr></table></figure><ul><li>用指针来访问二维数组</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// *(a+i): 行遍历</span></span><br><span class="line"><span class="comment">// *(*(a+i)+j): 列遍历</span></span><br></pre></td></tr></table></figure><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++基础.assets\image-20230827192525798.png" alt="image-20230827192525798"></p><ul><li>在栈 或者 堆 上创建数组。生命周期不同，堆对象要手动删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> example[<span class="number">5</span>];<span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">int</span>* another = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">// 堆</span></span><br><span class="line"><span class="keyword">delete</span>[] another;</span><br></pre></td></tr></table></figure><p>不过在类里面也创建堆的数组的话，那么访问数组就要通过实例的成员变量（一个指针），再跳转到数组……？</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>性能可能差些，但也更安全。原始数组不能直接知道长度……虽然可以<code>sizeof(example)/sizeof(int)</code>(指针偏移量÷类型)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">int</span>, 5&gt; data;</span><br><span class="line">data.<span class="built_in">size</span>();</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">data[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c语言风格</span></span><br><span class="line"><span class="keyword">int</span> dataOld[<span class="number">5</span>];</span><br><span class="line">dataOld[<span class="number">0</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>相比于传统的风格，array是一个类，可以用size()方法来访问长度【这个size实际上没有花内存存储】；可以用迭代器，种种。</li><li>array不同于vector，是存储在栈中的。</li></ul><h1 id="—–表达式"><a href="#—–表达式" class="headerlink" title="—–表达式"></a>—–表达式</h1><h2 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h2><p><a href="https://blog.csdn.net/Jacky_Feng/article/details/120742414">【C++】左值和右值、左值引用（&amp;）和右值引用（&amp;&amp;）_c++ arg&amp;&amp;_Jacky_Feng的博客-CSDN博客</a></p><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><blockquote><p>左值的英文简写为“*value”，右值的英文简写为“rvalue”。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）</p></blockquote><p>① 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="number">5</span> = a; <span class="comment">//错误，5 不能为左值</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中a是一个左值，字面值5是一个右值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>【注意】 C++中的左值也可以当作右值使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>; <span class="comment">// b 是一个左值</span></span><br><span class="line">a = b; <span class="comment">// a、b 都是左值，只不过将 b 可以当做右值使用</span></span><br></pre></td></tr></table></figure><p>② 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p><p>上述示例中变量 a、b 是变量名且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>在C++11之前就有引用<strong>“&amp;”</strong>，但是此种引用有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。</p><p>C++11 标准新引入了另一种引用方式，称为<strong>右值引用</strong>，用 “<strong>&amp;&amp;</strong>“ 表示。</p><p>① 和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>② 右值引用可以修改右值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;   <span class="comment">//输出结果为11</span></span><br></pre></td></tr></table></figure><h3 id="move-函数"><a href="#move-函数" class="headerlink" title="move()函数"></a>move()函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">move</span>(arg)</span><br><span class="line"><span class="comment">//agr:左值对象，该函数返回arg对象的右值形式</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; a = std::<span class="built_in">move</span>(num);  <span class="comment">//编译成功</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;   <span class="comment">//输出结果为10；</span></span><br></pre></td></tr></table></figure><h3 id="用于移动构造函数"><a href="#用于移动构造函数" class="headerlink" title="用于移动构造函数"></a>用于移动构造函数</h3><p>事实上，对于程序执行过程中产生的<strong>临时对象</strong>，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p><blockquote><p>详情看类的设计——移动构造函数</p></blockquote><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=(b=(c=<span class="number">0</span>));</span><br><span class="line">a=b=c;</span><br><span class="line">a = b+c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><blockquote><p>赋值运算符是从右往左计算的，返回值即等号左边对象的引用。 </p><p>所以a=b=c计算顺序是(a=(b=c))，(b=c)运算结果为b的引用，而b已经被赋值为c，所以后面a的值等于c。 </p><p>a=b+c=3的计算顺序为(a=(b+c=3))，b+c的运算结果是一个右值，不能被赋值为3 。</p></blockquote><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? a : b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">MAX</span>(++a, b);<span class="comment">//++a(执行1次) &gt; b ? ++a(执行1次) : b;</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">MAX</span>(++a, b + <span class="number">10</span>);<span class="comment">//++a(执行1次) &gt; b ? ++a : b;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>%d %d %d %d\n<span class="string">&quot;, a, b, c, d&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="—–语句"><a href="#—–语句" class="headerlink" title="—–语句"></a>—–语句</h1><h2 id="语句作用域-C-对象生存期"><a href="#语句作用域-C-对象生存期" class="headerlink" title="语句作用域/C++对象生存期"></a>语句作用域/C++对象生存期</h2><p>栈上的对象生存期：一旦超过作用域就会自动销毁；堆上创建的需要手动删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">CreateArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误。不要试图返回栈上临时变量的指针，函数结束后array被销毁，不会留有分配的空间。</span></span><br></pre></td></tr></table></figure><p>那有没有可能利用这个特性呢？</p><p>一种用法是，用栈创建的类对象 包装 在堆上创建的对象指针。在构造函数中创建堆对象，在析构函数中销毁堆对象。栈上的对象会自动销毁，销毁的时候再顺便销毁堆上的对象，这也是unique_ptr要做的事。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Created Entity&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroyed Entity&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr)</span><br><span class="line">        : <span class="built_in">m_Ptr</span>(ptr)</span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">// 在堆上创建不会自动删除</span></span><br><span class="line">    ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">// 隐式转换，超过作用域自动删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="—–函数"><a href="#—–函数" class="headerlink" title="—–函数"></a>—–函数</h1><h2 id="多个返回值处理方法"><a href="#多个返回值处理方法" class="headerlink" title="多个返回值处理方法"></a>多个返回值处理方法</h2><ul><li>通过使用输入参数（引用/指针）；</li><li>通过返回数组（相同类型）array默认在栈上分配，而vector在堆上分配，所以性能会好些？</li><li>返回tuple元组：固定大小的不同类型值的集合，是泛化的std::pair。由于这个比较麻烦，先简单了解一下并搁置。（而且通过索引去获得元素的时候，无法知道元素的具体含义是什么）<a href="https://blog.csdn.net/sevenjoin/article/details/88420885">(50条消息) C++ tuple元组的基本用法(总结)_sevencheng798的博客-CSDN博客</a></li></ul><ul><li>结构体</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回</span></span><br><span class="line"><span class="keyword">return</span> &#123;x, y, name&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取返回值 可知道变量的准确定义</span></span><br><span class="line">vertex.x;</span><br><span class="line">vertex.y;</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定的类型。<strong>函数的类型由它的返回值和形参类型共同决定，与函数名无关</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>若想要声明一个可以<strong>指向该函数的指针</strong>，只需要用指针替换函数名即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;);</span><br></pre></td></tr></table></figure><blockquote><p>(<em>pf)括号不可少。否则就是名为pf的函数返回 bool</em>指针。这一长串也是函数指针的类型。</p></blockquote></li></ul><h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><ul><li><p>当把<strong>函数名作为一个值</strong>使用时，该函数自动地转化为指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;<span class="comment">// 两者等价：取地址符是可选的</span></span><br></pre></td></tr></table></figure></li><li><p>直接使用函数指针调用函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>);<span class="comment">// 直接调用</span></span><br><span class="line"><span class="keyword">bool</span> b1 = (*pf)(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>);<span class="comment">// 解引用，等价</span></span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>);<span class="comment">// 原始调用</span></span><br></pre></td></tr></table></figure></li><li><p>指向不同函数类型的指针不存在转换规则。但是可以赋值nullptr和0，代表没有指向任何一个函数。</p></li></ul><p>例子：函数指针作为传参。Printvalue函数可以在别的地方实现了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForEach</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="keyword">void</span>(*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : values)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; values = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">ForEach</span>(values, PrintValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候也可以用lambda表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ForEach</span>(values, [](<span class="keyword">int</span> value) &#123; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;&#125;);</span><br></pre></td></tr></table></figure><h3 id="函数包装器-std-function"><a href="#函数包装器-std-function" class="headerlink" title="函数包装器 std::function"></a>函数包装器 std::function</h3><ul><li>简介</li></ul><p>该函数包装器模板能包装<strong>任何类型的</strong>【可调用实体】，如普通函数，函数对象，lamda表达式等。</p><p>包装器可拷贝，移动等，并且包装器类型仅仅依赖于调用特征，而不依赖于可调用元素自身的类型。std::function是C++11的新特性，包含在头文件<code>&lt;functional&gt;</code>中。</p><p>一个std::function类型对象实例可以包装下列这几种可调用实体：函数、函数指针、成员函数、静态函数、lamda表达式和函数对象。std::function对象实例可被拷贝和移动，并且可以使用指定的调用特征来直接调用目标元素。当std::function对象实例未包含任何实际可调用实体时，调用该std::function对象实例将抛出std::bad_function_call异常。</p><ul><li>定义一个<code>std::function&lt;int(int)&gt;</code><strong>对象实例</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; callback;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>对象实例<strong>包装函数指针</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun_ptr)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    fun_ptr = fun1; <span class="comment">//函数指针fun_ptr指向fun1函数</span></span><br><span class="line">    callback = fun_ptr; <span class="comment">//std::function对象包装函数指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    callback = fun1; <span class="comment">//std::function包装函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">42</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装模板函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fun2</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    callback = fun2&lt;<span class="keyword">int</span>&gt;; <span class="comment">//std::function包装模板函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装函数对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    callback = <span class="built_in">add</span>(); <span class="comment">//std::function包装对象函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装lamda表达式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun3 = [](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a * <span class="number">2</span>;&#125;; <span class="comment">//lamda表达式</span></span><br><span class="line">    callback = fun3; <span class="comment">//std::function包装lamda表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">9</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……总之还有很多。<a href="https://zhuanlan.zhihu.com/p/390883475">C++ std::function详解与实战 - 知乎 (zhihu.com)</a></p><p>可见各种函数都能包装，并且直接传参使用。</p><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><ul><li>重载</li></ul><p>是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的<strong>同名函数</strong>，根据<strong>参数列表</strong>确定调用哪个函数，重载<strong>不关心函数返回类型</strong>。</p><blockquote><p>const也可以作为重载条件</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">float</span> i, <span class="keyword">float</span> j)</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;; <span class="comment">// ×</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>重写</li></ul><p>是指派生类中存在重新定义的函数。其<u>函数名，参数列表，返回值类型</u>，所有都必须同基类中被重写的函数<strong>一致</strong>。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">a-&gt;<span class="built_in">fun</span>(); <span class="comment">//输出B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p><a href="https://blog.csdn.net/Sunnyside_/article/details/109121002">【C/C++】宏函数与内联函数的区别_c++内联函数和宏函数区别_一条余弦Cos的博客-CSDN博客</a></p><ul><li>将内联函数在每个调用点上“内联”地展开。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">shorterString</span>(s1, s2) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> string&amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> string&amp; s1, <span class="keyword">const</span> string&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译过程中展开成类似下面的形式</span></span><br><span class="line">cout &lt;&lt; (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1 : s2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>内联函数必须是和函数体声明在一起才有效。不建议将声明和定义分离，<strong>分离会导致链接错误</strong>。因为inline被展开，就没有函数地址了，链接就会找不到。</li><li>内联函数可避免函数调用（压栈）的开销；是一种以空间换时间的做法。</li><li>用于优化规模较小、流程直接、调用频繁的函数。</li></ul><ul><li>宏函数</li></ul><p>函数的调用：必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的内容执行完后再返回到转去执行该函数前的地方。</p><p>这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。</p><p>因此函数调用要有一定的时间和空间方面的开销，于是将影响其效率。</p><p>而宏只是在预处理的地方将代码展开，不需要额外的<strong>空间和时间</strong>（内联函数还有空间开销）方面的开销，所以调用一个宏比调用一个函数更有效率。</p><p><strong>优点：</strong><br>1.增强代码的复用性。<br>2.提高性能与可读性。<br><strong>缺点：</strong><br>1.不方便调试宏。（因为预编译阶段进行了替换）<br>2.导致代码可读性差，可维护性差，容易产生二义性。<br>3.没有进行类型的检测 ，安全性低。</p><blockquote><p>和宏函数的区别：</p><p>宏是由预处理器对宏进行替换的，而内联函数是通过编译器控制实现的，宏是在<strong>预处理阶段</strong>进行替换，内联函数是在<strong>编译阶段</strong>展开的。</p><p>而且内联函数是真正的函数，只是在需要用到的时候内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。所以可以像调用函数一样来调用内联函数，而不必担心会产生像宏出现的问题。</p></blockquote><h1 id="—–类"><a href="#—–类" class="headerlink" title="—–类"></a>—–类</h1><h2 id="和struct的区别"><a href="#和struct的区别" class="headerlink" title="和struct的区别"></a>和struct的区别</h2><ul><li><strong>默认的继承访问权</strong>。class默认的是private,struct默认的是public。</li><li><strong>默认访问权限</strong>：struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的。</li><li>“class”这个关键字还用于定义模板参数，就像“typename”。但关建字“struct”不用于定义模 板参数</li><li>class和struct在使用大括号{ }上的区别<br><strong>关于使用大括号初始化</strong>(?)<br>1.）class和struct如果定义了构造函数的话，都不能用大括号进行初始化<br>2.）如果没有定义构造函数，struct可以用大括号初始化。<br>3.）如果没有定义构造函数，且所有成员变量全是public的话，class可以用大括号初始化</li></ul><h2 id="构造函数-成员初始化列表"><a href="#构造函数-成员初始化列表" class="headerlink" title="构造函数-成员初始化列表"></a>构造函数-成员初始化列表</h2><p>利于风格的简化；初始成员变量变得简洁轻松。其它的操作也能一目了然，不然一大堆初始化变量显得混乱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">z</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：如果成员变量含有别的类的对象，小心会构造多次。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">z</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>);<span class="comment">// 在方法体内“初始化”</span></span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里成员变量实际上也会创建一个对象<code>std::string m_Name;</code> 在构造方法里面再初始化<code>m_Name(&quot;Unknown&quot;);</code>（相当于<code>m_Name=string(&quot;Unknown&quot;)</code>）又创建了一个实例覆盖掉原来的。</p><p>初始化列表似乎能解决这个问题……只初始化一次。</p><h2 id="创建并初始化C-对象"><a href="#创建并初始化C-对象" class="headerlink" title="创建并初始化C++对象"></a>创建并初始化C++对象</h2><p>C++可以在栈中创建对象。栈上给变量分配的内存是很接近的，相当于栈上一个接一个分配，相当于只执行了一个CPU命令就能完成分配/删除操作。所以速度是很快的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entity* e;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">entity</span><span class="params">()</span></span>;</span><br><span class="line">    e = entity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entity 在括号外的作用域自动销毁</span></span><br></pre></td></tr></table></figure><p>也可以在堆中创建对象。但实际上在堆上创建对象要经过一系列麻烦的操作。比如有个freelist来查看是否还有足够空间，分配之后还要记录分配了多少等等，所以速度要比栈分配慢很多。</p><p>【注意】重点关键字是new；不同于C#和爪哇，C++没有GC，所以要手动删除。C#也可以构建栈上的对象，但是只能通过struct（值类型）来实现。而java创建的都是在堆上的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entity* e;</span><br><span class="line">&#123;</span><br><span class="line">    Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//</span></span><br><span class="line">    e = entity;</span><br><span class="line">    entity-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> e;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>两种方式如何选择？</p><ul><li>栈：更方便更快</li><li>堆：无法用栈分配就用堆。对象太大；需要手动设置对象生命周期</li></ul><h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><p>new 大概作用就是，<strong>在堆上</strong> 分配一连串内存，然后返回指向那个地址的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">// 4 bytes</span></span><br><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];<span class="comment">// 200 bytes</span></span><br></pre></td></tr></table></figure><p>new其实是一个操作符，这意味着可以重载它；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">Entity* e = (Entity*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Entity));<span class="comment">// C风格</span></span><br></pre></td></tr></table></figure><blockquote><p>两行代码的区别是，除了分配内存返回指针，new还调用了e的构造函数。</p></blockquote><p>new了之后必须要用delete（实际上也是一个操作符），也会调用析构函数。</p><ul><li><p>C#中的this：</p><ul><li><p>【本质】代表当前实例；new的时候，如果将内存分配给引用类型，那么对象创建表达式 就会返回一个<strong>引用</strong>，指向<strong>在堆中</strong>被分配和初始化的<strong>对象实例</strong>。（所以这应该就是对象实例的引用）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;    <span class="comment">//代表当前实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从构造函数中调用其他构造函数（用法）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _salary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name, <span class="built_in">int</span> salary</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>) : <span class="title">this</span>(<span class="params">age, <span class="string">&quot;NULL&quot;</span>, <span class="number">0</span></span>)  <span class="comment">//调用上一个构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为当前实例用作参数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span>);   <span class="comment">//作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params">Student a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a._age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><p><a href="https://zhuanlan.zhihu.com/p/338489910">关于C++ new和malloc的区别，记住这张表格就行了！ - 知乎 (zhihu.com)</a></p><p>memset是什么？？</p><h3 id="内存位置的区别"><a href="#内存位置的区别" class="headerlink" title="内存位置的区别"></a>内存位置的区别</h3><ul><li>new：此操作符分配的内存空间是在自由存储区；</li><li>malloc：申请的内存是在堆空间。</li></ul><p>C/C++的内存通常分为：堆、栈、自由存储区、全局/静态存储区、常量存储区。</p><p><strong>堆</strong> 是C语言和操作系统的术语，堆是操作系统所维护的一块特殊内存，它提供了<strong>动态分配</strong>的功能，当运行程序调用malloc()时就会从中分配，调用free()归还内存。那什么是自由存储区呢？</p><p><strong>自由存储区</strong> 是C++中<strong>动态分配和释放对象</strong>的一个概念，通过new分配的内存区域可以称为自由存储区，通过delete释放归还内存。自由存储区可以是堆、全局/静态存储区等，具体是在哪个区，主要还是要看new的实现以及C++编译器默认new申请的内存是在哪里。但是基本上，<u>很多C++编译器默认使用堆来实现自由存储</u>，<u>运算符new和delete内部默认是使用malloc和free的方式来被实现</u>，说它在堆上也对，说它在自由存储区上也正确。因为在C++中new和delete符号是可以重载的，我们可以重新实现new的实现代码，可以让其分配的内存位置在静态存储区等。而malloc和free是C里的库函数，无法对其进行重载。</p><p><img src="https://pic3.zhimg.com/v2-984e0cc1b9a79bd3fe0a7c51397cc22e_r.jpg" alt="img"></p><h1 id="—–内存管理"><a href="#—–内存管理" class="headerlink" title="—–内存管理"></a>—–内存管理</h1><p><a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368">C++内存管理（超长，例子很详细，排版很好）_草根caogen的博客-CSDN博客</a></p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p><p>　　栈，在执行函数时，<strong>函数内局部变量</strong>的存储单元都可以在栈上创建，函数执行结束时这些存储单元<strong>自动被释放</strong>。栈内存分配运算内置于处理器的指令集中，<strong>效率很高</strong>，但是分配的<strong>内存容量有限</strong>。</p><p>　　堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p><p>　　自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p><p>　　全局/静态存储区，<strong>全局变量和静态变量</strong>被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p><p>　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是<strong>常量</strong>，不允许修改。</p><ul><li>堆和栈的区别</li></ul><p>1、<strong>管理方式不同</strong>：</p><p>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p><p>2、<strong>空间大小不同</strong>：</p><p>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。</p><p>3、<strong>能否产生碎片不同</strong>：</p><p>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出</p><p>4、生长方向不同：</p><p>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p><p>5、分配方式不同：</p><p>堆都是动态分配的，没有静态分配的堆。<strong>栈有2种分配方式：静态分配和动态分配</strong>。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p><p>6、<strong>分配效率不同</strong>：</p><p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配<strong>专门的寄存器</strong>存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。</p><p>堆则是C/C++<strong>函数库</strong>提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p><p><strong>总结</strong>：堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。</p><p>所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p><h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>（需要看很长的例子或者再重新找资料）</p>]]></content>
    
    
    <summary type="html">C++基础部分</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法-刷题思考</title>
    <link href="https://huangxinhere.github.io/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/"/>
    <id>https://huangxinhere.github.io/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/</id>
    <published>2023-03-31T16:00:00.000Z</published>
    <updated>2023-09-05T07:58:23.899Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNjY5NTYxNA==&action=getalbum&album_id=1485825793120387074&scene=173&from_msgid=2247486598&from_itemidx=1&count=3&nolastread=1#wechat_redirect">#数据结构与算法 (qq.com)</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="JZ57-和为S的两个数字【哈希】【双指针】"><a href="#JZ57-和为S的两个数字【哈希】【双指针】" class="headerlink" title="JZ57 和为S的两个数字【哈希】【双指针】"></a>JZ57 和为S的两个数字【哈希】【双指针】</h2><p>首先想到用哈希表存储，遍历元素的时候记录想要的差，以后遇到这个元素就返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">        <span class="comment">// 若存在于想要的数字中，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (map[num]) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;num, sum - num&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不存在，则存储需要的值</span></span><br><span class="line">        map[sum-num] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目提供的是有序数组，那么肯定可以利用这个有序的特点。[1,2,4,7,11,15],15 比如遍历1，那么需要14，用二分查找？emmm，似乎又想复杂了。可以用双指针。首先指向开头和结尾。1+15&gt;15，数太大了，所以右指针向前一位；1+11&lt;15，又小了，所以左指针向右一位……（妙啊</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[l]+array[r] == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt; &#123;array[l], array[r]&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (array[l]+array[r] &gt; sum) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (array[l]+array[r] &lt; sum) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双指针：两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针）。此处是对撞指针。</p></blockquote><h2 id="JZ58-左旋转字符串【字符串】【反转】"><a href="#JZ58-左旋转字符串【字符串】【反转】" class="headerlink" title="JZ58 左旋转字符串【字符串】【反转】"></a>JZ58 左旋转字符串【字符串】【反转】</h2><p>刚开始想的是队列循环/或者在原基础上拼接。头元素转到尾元素。（代码简单就不贴了）</p><p>【题解】呃，直接反转。我只能说玩得很溜，比较开拓思路。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404101920920.png" alt="image-20230404101920920"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">LeftRotateString</span><span class="params">(string str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//取余，因为每次长度为m的旋转相当于没有变化</span></span><br><span class="line">    n = n % m;</span><br><span class="line">    <span class="comment">//第一次逆转全部数组元素</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//第二次只逆转开头m个</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + m - n);</span><br><span class="line">    <span class="comment">//第三次只逆转结尾m个</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>() + m - n, str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ007-数组中和为0的三个数"><a href="#OfferⅡ007-数组中和为0的三个数" class="headerlink" title="OfferⅡ007.数组中和为0的三个数"></a>OfferⅡ007.数组中和为0的三个数</h2><p>先想到排序，然后再暴力……只不过排序后遍历的可能少那么一点点。</p><p>先确定左指针，再确定右指针（没有限制），最后确定中间指针（如果不够补那么直接不行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; nums.<span class="built_in">size</span>()<span class="number">-3</span>; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[l])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[l]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetR = <span class="number">0</span> - nums[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; r &gt; l+<span class="number">1</span>; r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> targetMid = <span class="number">0</span> - nums[l] - nums[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = r<span class="number">-1</span>; mid &gt; l; mid--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然鹅还是可能出现重复情况，而且不好处理。</p><p><img src="https://img-blog.csdnimg.cn/d29041f703f74a33a2ffcc2a26299b47.png" alt="image-20230420225303368"></p><p>重复情况出现的原因是，设想有-1，-1，0，0，1，1这种多个重复的情况，也就是左、右、中间的指针都可能重复遍历，都要搞个map来存吗？欧摸，这破代码已经不忍瞩目了。</p><p>看了题解后，继续完善自己的代码。自己能想到的最近的一步是去重。其实不用哈希表也可，毕竟已经排好序了，可以通过比较前后数字来去重。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// l的去重操作：排序后，排除第一个而且和前面一个相同的</span></span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetR = <span class="number">0</span> - nums[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; r &gt; l+<span class="number">1</span>; r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// r的去重操作：排序后，排除最后一个而且和后面一个不同的</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt;= nums.<span class="built_in">size</span>()<span class="number">-2</span> &amp;&amp; nums[r] == nums[r+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> targetMid = <span class="number">0</span> - nums[l] - nums[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = r<span class="number">-1</span>; mid &gt; l; mid--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// mid的去重操作:和后面一个不同的，而且排除后一个是r的情况</span></span><br><span class="line">                <span class="keyword">if</span> ((mid != (r<span class="number">-1</span>)) &amp;&amp; nums[mid] == nums[mid+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过[0,0,0,0,0]示例就算成功</p></blockquote><p>由于时间复杂度是n的三次方，所以还是超时了。有没有办法减少循环的时间复杂度呢？再回顾一下我的思路，第一重循环必是从左到右找到第一个元素，第二重循环是从数组右到左，找到第二个元素，第三重循环就决定了结果。第二重循环b往前移的时候必然变小，那么c肯定会增大，b和c可简化成寻找<code>0-a</code>的”滑动窗口“。确定好a的循环范围，接着是b，然后c根据b的变化来进行滑动。</p><p>那这样的话其实l和r包抄mid的思路就有点复杂。比较容易理解的是l，mid，r再根据他俩滑动。mid和r是一个收缩的过程。由于mid和r是”对撞指针“，所以时间复杂度是On。【细节注意】要实现对撞指针，r不能每次都从数组末尾开始，这样就失去了意义，应该从头到尾都是往前前进。</p><ul><li><p>这个解法思路更清晰一点：</p><p>确定第一个a，然后用对撞指针；</p><p>如果先去重再判断的话，就可能漏掉mid+1=right的情况，比如(0,0,0)；</p><p>所以先判断再去重。也就是找到符合条件的元组后，这个元组就不应该再出现，那么就给它去重，跳过接下来和它一样的元素。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ008-和大于等于target的最短子数组"><a href="#OfferⅡ008-和大于等于target的最短子数组" class="headerlink" title="OfferⅡ008. 和大于等于target的最短子数组"></a>OfferⅡ008. 和大于等于target的最短子数组</h2><p>一看到连续子数组就想到了那道动态规划：求连续子数组的最大和。这次终于有机会打破自己的刻板理解：究竟什么是动态规划？其中一个重要理解点是：【没有后继性】。</p><p>想象一串数字，取其中的部分子数组，设子数组最后一个元素为I，如果是动态规划的话，那I为结尾，必然知道I所在已知子数组的答案。比如求连续子数组的最大和，I所在子数组是必定有答案的，与后面的元素无关。</p><p>而在这道题中，如<code>2、3、1、2、4、3</code>数组，要使子数组大于等于7，比如遍历到3的时候，已知2、3，你不能确定以2开头还是以3开头的子数组可以达到7，因为这还要取决于后面的元素。可见动态规划是根本不沾边的。</p><p>题目特点是【连续】，这可以想到滑动窗口：中间大致不变（遍历过的元素得到某种程度上的保留），根据目标值滑动左右边界。这里左右边界的分工也很明确，因为元素都是正整数，左缩一个sum必减少，右增一个sum必增多。</p><ul><li>确定左【。</li><li>根据target确定右】。（凑不够target就增）</li><li>符合target则计算r-l长度，更新min。（已经达到target，为了试探更小长度会左缩，所以回到第一步）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>], min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; len; l++)</span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">while</span> (sum &lt; target &amp;&amp; r &lt; len<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r++;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 符合条件时 进行长度更新</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            min = !min || ((r-l) &lt; min) ? r+<span class="number">1</span>-l : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还未达到target但已经遍历完毕 说明后面已经凑不够了 再减少l也没用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum -= nums[l];<span class="comment">// 达到target就左缩</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ009-乘积小于k的子数组【动态规划】"><a href="#OfferⅡ009-乘积小于k的子数组【动态规划】" class="headerlink" title="OfferⅡ009.乘积小于k的子数组【动态规划】"></a>OfferⅡ009.乘积小于k的子数组【动态规划】</h2><blockquote><p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，求数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: nums = [10,5,2,6], k = 100</span><br><span class="line">&gt;输出: 8</span><br><span class="line">&gt;解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br></pre></td></tr></table></figure></blockquote><p>最开始是暴力遍历，两次循环逐一判断，n！的时间复杂度。优化的地方是算过的可以利用起来，就想到滑动窗口（下图）。</p><p><img src="https://img-blog.csdnimg.cn/44e3cc7643eb42a9b8b09350aa36b675.png" alt="image-20230424160024746"></p><p>右扩大直到大于等于k，然后左边界缩小直到在k内，保持窗口内的数稳定在k内。问题来了，窗口其中一小部分连续子数组怎么办呢？</p><p>【题解】我最多想到右增一个能算一个元素与k比较，没想到右增一个就能把里面的子数组个数都算出来了……以j为结尾，与左边界i的关系如下图，如果窗口在k内的话，那么里面所有的子数组都符合小于k。其中还暗含了一点动态规划的思想，不过在这里左缩一个也要计算对应的个数。……只能说，miao啊。</p><p><img src="https://img-blog.csdnimg.cn/f064798499a3420d8ff6ccfe21c16bee.png" alt="image-20230424162111158"></p><blockquote><p>为什么子数组不会重复呢？子数组取决于窗口的左右边界。观察绿色横线，右增一个和左增一个的区别。意义分别是以l为开头的……以r为结尾的所有子数组，然后每次l和r都必然各自只遍历数组一次，所以不会重复。这么想的话，这道题想法真的很奇妙。</p><p>而且由于控制在k内，所以不会整型溢出（暴力遍历如果不加以控制的话就会踩雷）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, product = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); r++)</span><br><span class="line">    &#123;</span><br><span class="line">        product *= nums[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; product &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            product /= nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += r - l + <span class="number">1</span>;<span class="comment">// 最核心</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ010-和为k的子数组"><a href="#OfferⅡ010-和为k的子数组" class="headerlink" title="OfferⅡ010.和为k的子数组"></a>OfferⅡ010.和为k的子数组</h2><blockquote><p>给定一个整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br></pre></td></tr></table></figure></blockquote><p>滑动窗口算出来的结果不对了。为什么呢？进一步思考滑动窗口的能发挥特性的条件是什么。</p><p>如下图，当元素都是正整数时，左右边界滑动是明确可知能增能减的，所以控制在k范围内有明确的方向。</p><p>而正数和负数混合时，窗口将无法知道边界向哪才能维护目标值k（去掉负数为增，去掉正数为减，以此类推）</p><p><img src="https://img-blog.csdnimg.cn/c17c9fcd25fb485192a305168fec747a.png" alt="image-20230424170042843"></p><p>那还有什么办法呢？和以前思路大差不差，先想到暴力，再想着利用已经计算过的部分，就不用逐个重复计算了。每个元素利用（i-1）计算出i个结果，那空间复杂度就有n！了。</p><p>再想想，由于是连续数组，那么第i个元素只要和第i-1个元素的结果分别相加就行了，再之前的结果就不用保留。时间复杂度为【<strong>n</strong>（遍历每一个元素）<strong>×n-1×n-2</strong>（遍历前一个元素的数组）】也是n！……</p><p><img src="https://img-blog.csdnimg.cn/7b22b3f3498b4e818a14a63c5586ad24.png" alt="image-20230424170722046"></p><p>啊啊啊是思维陷阱啊，这似乎是遍历前面然后用空间存储以至于时间复杂度没有爆炸……好吧好吧！</p><p>【题解】</p><ol><li><p>逐个遍历子数组开头和结尾；双循环。</p></li><li><p>前缀和＋哈希表【重点】</p></li></ol><p>重新回顾一下这道题的难点，如果想提高效率，难的是确定子数组的起始(l)和结尾(r)。思路怎么也绕不过列举l和r，上一个思路为什么会导致乌龙的结果呢，也是因为l和r的动态变化导致计算的子数组并没有好用的规律……</p><p>这个解法妙在，使得和为k的(j,i)连续子数组符合k=sum[i]-sum[j-1]。sum是从0到某个元素的和，这样利用k和结尾反推开头……sum是从0开始相加的，这对于每个连续子数组都可用，提高了利用率；而且只是末尾变化，也更稳定……</p><p>大概理解是，按照我需要什么然后来找我遍历过的。已知<code>从0开始到i的所有元素和为sum</code>，那么以i为结尾的子数组要满足和为k，就意味着sum减去<code>子数组前面所有元素和sum[j-1]</code>等于k。那么目前未知数只剩下sum[j-1]。只要它满足<code>sum[j-1] = sum[i]-k</code>，就知道这个k子数组存在。</p><p>由于sum[j-1]和sum[i]都是从第0位开始，所以sum[j-1]肯定是sum[i]遍历过的，用哈希表存起来对应出现的次数，随时检查判断便可。</p><p><a href="https://leetcode.cn/problems/QTMn0o/solution/he-wei-k-de-zi-shu-zu-by-leetcode-soluti-1169/">和为 k 的子数组 - 和为 k 的子数组 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="comment">// 判断sum[j-1]是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 比如k=10, 遍历到当前14-10=4，要找的前缀和4可能有多种情况，而哈希表存储的就是前缀和的n种可能</span></span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ011-0和1个数相同的子数组"><a href="#OfferⅡ011-0和1个数相同的子数组" class="headerlink" title="OfferⅡ011.0和1个数相同的子数组"></a>OfferⅡ011.0和1个数相同的子数组</h2><p>仍然是连续子数组问题，思考如何找数组的开头和结尾。同样地，除了遍历法没有其它方法有效地遍历每一个开头和结尾，然后想到上一题和为k的子数组……这里求的是个数，不像k那样具有唯一性，那怎么办呢？</p><p>如果要有唯一性，只要把0变成-1，”0和1个数相同“就转换成连续子数组和为0了。</p><p>下一个问题，哈希表存的是和出现次数的时候，怎么知道长度呢？既然是最长长度，那就没必要知道所有的出现次数，由于是从前到后遍历的，所以只需要知道长度第一次出现的索引即可。然后计算更新长度差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前缀和，最先出现的索引</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求得0~i的连续和</span></span><br><span class="line">        <span class="keyword">if</span> (!nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="comment">// map存有第一个和的索引</span></span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(sum);</span><br><span class="line">        <span class="keyword">if</span> (it != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            count = (i-map[sum]) &gt; count ?  (i-map[sum]) : count;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连续和存入哈希表</span></span><br><span class="line">        map[sum] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注意】判断某个元素是否在哈希表内，不能用<code>map[i] == 0</code>（判断不准确，-1也会判定为true），应该用迭代器。</p></blockquote><h2 id="OfferⅡ013-二维子矩阵的和"><a href="#OfferⅡ013-二维子矩阵的和" class="headerlink" title="OfferⅡ013.二维子矩阵的和"></a>OfferⅡ013.二维子矩阵的和</h2><p>暴力算法是超时的。如何利用已经算过的子矩阵和？但是可利用的子矩阵可大可小，很难控制和存储。既然无法从动态局部推算，那就定一个有相同点的可控的局部。</p><p>【题解】又是前缀和。不得不说这真是将前缀和玩出花来了。</p><p>先看灰色、红色、蓝色框。红色框代表要求的子矩阵范围，是由黑色框减去两个蓝色框再加上重叠的部分。那么很明显就求出了上面的式子。</p><p>但是从公式中绿色下划线可见，row1和col1可能为负数，所以还要避免那三种情况，并分别进行对应的处理，这将会加大工作量。所以绿色框又添加了一行一列，这样相应的坐标改成绿色字，就避免了特殊情况讨论。（miao！</p><p><img src="https://img-blog.csdnimg.cn/366a0fe7b8ca4a549af663f4726632ba.png" alt="image-20230428101011460"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; sums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            sums.<span class="built_in">resize</span>(h+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(w+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不从1开始，可能是不想≤h，这样判断就会多判断一次n²</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sums[i+<span class="number">1</span>][j+<span class="number">1</span>] = sums[i][j+<span class="number">1</span>] + sums[i+<span class="number">1</span>][j] + matrix[i][j] - sums[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2+<span class="number">1</span>][col2+<span class="number">1</span>]-sums[row2+<span class="number">1</span>][col1]-sums[row1][col2+<span class="number">1</span>]+sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="JZ67-把字符串换成整数-atoi"><a href="#JZ67-把字符串换成整数-atoi" class="headerlink" title="JZ67 把字符串换成整数(atoi)"></a>JZ67 把字符串换成整数(atoi)</h2><p>一看这个中等难度和正确率就知道坑多多。字符串题除了坑多没别的特点……首先明确的是如果有一个连续的数字，再加上前面的符号位就已经知道结果了。</p><p>符号位这个就挺搞的，有没遍历过/遍历过（+/-）三种状态，假设默认为1，那么就是（+/-）两种状态。这看起来很有道理，但是如果遇到”+++–+-……“这种字符串的，遍历到第二个应该知道已经遍历过，返回无效的0。所以如果设成两种状态的话，并不知道有没有遍历过。所以设成（0/-1/1）三种状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果符号位已经确认</span></span><br><span class="line">    <span class="keyword">if</span> (!sign) &#123;</span><br><span class="line">        sign = s[i] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>那么问题又来了，计算sum的时候，刚遍历完符号位sum还是为0，但是以后的计算要涉及到正数还是负数。我把符号给到判断，结果再处理……反正看起来就是一坨东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(string s, <span class="keyword">int</span> &amp;i, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">-1</span> &amp;&amp; -sum &lt; -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)) &#123;</span><br><span class="line">            isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">            isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> sign != <span class="number">0</span> ? sum * sign : sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() &amp;&amp; !isValid; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果符号位已经确认</span></span><br><span class="line">            <span class="keyword">if</span> (!sign) &#123;</span><br><span class="line">                sign = s[i] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            sum = <span class="built_in">GetDigit</span>(s, i, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+i);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i]) || s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】遍历法。思路要清晰一些，去掉前面的空格，然后处理第一个符号，接着都按照是否为数字处理。这点抽象整理的思维还是值得我多多学习的。反正都是从头到尾严格地排（符号位+数字位），也不用考虑太多重复遇到的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//(如果有则)去掉前导空格</span></span><br><span class="line">    <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[index] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉空格就什么都没有了</span></span><br><span class="line">    <span class="keyword">if</span>(index == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//处理第一个符号是正负号的情况</span></span><br><span class="line">    <span class="keyword">if</span>(s[index] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[index] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉符号就什么都没有了</span></span><br><span class="line">    <span class="keyword">if</span>(index == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[index];</span><br><span class="line">        <span class="comment">//后续非法字符，截断</span></span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//处理越界</span></span><br><span class="line">        <span class="comment">// 在乘之前就判断是否越界（由于res=res*10+...，倒回来算就是MAX/10，除号会省略余数取整，所以还要判断个位数是否超过MAX最后一位</span></span><br><span class="line">        <span class="keyword">if</span>(res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; INT_MAX % <span class="number">10</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; -(INT_MIN % <span class="number">10</span>)))</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        res = res * <span class="number">10</span> + sign * (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个状态机的，不明觉厉。<a href="https://www.nowcoder.com/practice/d11471c3bf2d40f38b66bb12785df47f?tpId=265&tqId=39262&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=3&judgeStatus=undefined&tags=&title=">把字符串转换成整数(atoi)_牛客题霸_牛客网 (nowcoder.com)</a></p><h2 id="JZ75-字符串中第一个不重复的字符"><a href="#JZ75-字符串中第一个不重复的字符" class="headerlink" title="JZ75 字符串中第一个不重复的字符"></a>JZ75 字符串中第一个不重复的字符</h2><p>记录每个元素出现的次数；一旦超过1次就移出记录数组。这种解法简单又朴素……我觉得至少是得记录每个元素出现的次数；然后知道哪些元素是只出现过一次……想不出什么优化的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">char</span>&gt; array; <span class="comment">// 记录只存在一次的</span></span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;   <span class="comment">// 记录所有出现过的元素次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    map[ch]++;</span><br><span class="line">    <span class="keyword">if</span> (map[ch] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除array重复的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == ch) &#123;</span><br><span class="line">                array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        array.<span class="built_in">push_back</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(array.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ002-二进制加法"><a href="#OfferⅡ002-二进制加法" class="headerlink" title="OfferⅡ002. 二进制加法"></a>OfferⅡ002. 二进制加法</h2><p>原本想转到十进制又转回去的，long long int都不够，还是老实逐位计算了。</p><p>先翻转对齐，然后逐位计算，记录进位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string s_str, l_str, res;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s_str = a;</span><br><span class="line">        l_str = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l_str = a;</span><br><span class="line">        s_str = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(s_str.<span class="built_in">begin</span>(), s_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(l_str.<span class="built_in">begin</span>(), l_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 两者相加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (s_str[i] - <span class="string">&#x27;0&#x27;</span>) + (l_str[i] - <span class="string">&#x27;0&#x27;</span>) + add;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum<span class="number">-2</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum));</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补长的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s_str.<span class="built_in">size</span>(); i &lt; l_str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l_str[i] - <span class="string">&#x27;0&#x27;</span>) + add;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum<span class="number">-2</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum));</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一位</span></span><br><span class="line">    <span class="keyword">if</span> (add)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(add));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】代码进一步简洁。直接计算最长的，只不过每次都要判断两次越界再判断是否为1，虽然用了语法糖但其实if判断很多次……而且可读性……呃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 进位</span></span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有位运算。但首先得把两数换成整型，其实还会溢出，这个问题要靠Python语言高精度来弥补……此处略过。</p><h2 id="OfferⅡ005-单词长度的最大乘积【位运算】"><a href="#OfferⅡ005-单词长度的最大乘积【位运算】" class="headerlink" title="OfferⅡ005. 单词长度的最大乘积【位运算】"></a>OfferⅡ005. 单词长度的最大乘积【位运算】</h2><blockquote><p>给定一个字符串数组 <code>words</code>，请计算当两个字符串 <code>words[i]</code> 和 <code>words[j]</code> 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;fxyz&quot;。它们不包含相同字符，且长度的乘积最大。</span><br></pre></td></tr></table></figure></blockquote><p>初步思路是暴力遍历和匹配。肯定超时，有没有更好的方法？想到的是字符串匹配算法，但是忘了。由于每个单词长度不同，内容也没有共同性，所以必须得逐个遍历两两匹配？然后是两个单词的比较，也是要逐位配？能优化的就只有后者了吧。</p><p>【题解】位运算。因为只有24个小写字母，所以可以用bit来记录a~z是否出现过。然后将两个单词做与操作，只有结果为0时才能说明没有相同字母。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = words.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = words[i][j] - <span class="string">&#x27;a&#x27;</span>;    <span class="comment">// 易错！</span></span><br><span class="line">            bits[i] |= <span class="number">1</span> &lt;&lt; pos;            <span class="comment">// 记住这个写法，把1移动到相应位置再计算，而不是把bits[i]移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(bits[i] &amp; bits[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, <span class="built_in"><span class="keyword">int</span></span>(words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(L+n的平方)，L是全部单词长度之和。</p><p>空间复杂度：O(n)，n是数组长度。</p></blockquote><h2 id="OfferⅡ020-回文子字符串的个数"><a href="#OfferⅡ020-回文子字符串的个数" class="headerlink" title="OfferⅡ020.回文子字符串的个数"></a>OfferⅡ020.回文子字符串的个数</h2><blockquote><p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure></blockquote><p>想到暴力遍历，然后又觉得很像之前数组的前缀和，但是又进行不下去。原因是回文判断是前后对称的，不是连续子串的，每增加遍历一个元素，并不能从已遍历的判断出当前是否为回文数。</p><p>【题解】一、枚举所有回文子串</p><p>枚举又分为两种方法：</p><ul><li>枚举所有的子串，判断是否为回文：需要O(n²)枚举所有子串，又要O(ri-li+1)的时间检查回文，整个时间复杂度为O(n³)。</li><li>枚举每一个可能的回文中心，用两个指针分别向两边拓展，当两个指针指向相同的元素时继续拓展，否则停止。【利用回文的特点，多考虑一下】第一个方法就是有些中心被重复判断，加大了时间复杂度。</li></ul><p>用第二个方法的话，需要考虑如何有序地枚举可能的回文中心。如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。当然你可以做两次循环来分别枚举奇数长度和偶数长度的回文，但是我们也可以用一个循环搞定。我们不妨写一组出来观察观察，假设 n=4，我们可以把可能的回文中心列出来：</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230517153922540-16843091676041.png" alt="image-20230517153922540"></p><blockquote><p>上图是罗列的所有中心枚举的可能，可见有些中心相同但枚举范围不同的，可以合并起来一起检查（因为范围小的不符合条件，那么大范围的肯定也不符合条件；最大范围便是超过某个边界为止）。</p><p>下图是合并同类项的结果，可见中心点可以为0，0 1，1，1 2，2，2 3，3，共2*len-1组。所以可以枚举中心点，范围是超过边界为止。</p></blockquote><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230517150610670.png" alt="image-20230517150610670"></p><p>也就是说确定了中心点（包括左右）和的关系，就能找到每次遍历的范围。由上图可看出，l = i / 2, r = l + (i%2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此类解决方法还是很巧妙的，很强的观察和归纳能力。</p><p>不过动态规划可能更好理解一些，这个懒得推导的话也不好记。</p><h2 id="1156-单字符重复子串的最大长度"><a href="#1156-单字符重复子串的最大长度" class="headerlink" title="1156. 单字符重复子串的最大长度"></a>1156. 单字符重复子串的最大长度</h2><blockquote><p>如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。</p><p>给你一个字符串 <code>text</code>，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;ababa&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;aaabaaa&quot;</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure></blockquote><p>统计出现最多的字符？没有考虑到连续性，没啥用；那么考虑连续性？从当前字母开始计数为1，如果有连续则继续计数，如果出现不同数字，使用掉一次机会，继续往下遍历——如果还是立刻中断，那么要找是否还存在相同字母；如果还能继续连起来，如果剩余还有相同字母说明可以补，否则就是-1.</p><p>继续抽象整理一下，第一次中断，就假设有，继续补；第二次中断，就找是否有余下相同字母，如果有，则计数生效，如果没有，假如第一次中断的位置+1就是第二次中断的位置，比如abc =&gt; aac，说明后面没有连续的字母可以补了，比如abaa =&gt; aaab, abcd =&gt; aacd的区别。</p><p>然后每个位置的元素都遍历一次，看看有没有更长的（这块能不能优化？）。复杂度就达到了O(n²)级别（当数组都是重复元素）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRepOpt1</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : text) &#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">            <span class="comment">// step1: 找出当前连续的一段 [i, j)</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; text.<span class="built_in">size</span>() &amp;&amp; text[j] == text[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cur_cnt = j - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step2: 如果这一段长度小于该字符出现的总数，并且前面或后面有空位，则使用 cur_cnt + 1 更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (cur_cnt &lt; count[text[i]] &amp;&amp; (j &lt; text.<span class="built_in">size</span>() || i &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, cur_cnt + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step3: 找到这一段后面与之相隔一个不同字符的另一段 [j + 1, k)，如果不存在则 k = j + 1 </span></span><br><span class="line">            <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; text.<span class="built_in">size</span>() &amp;&amp; text[k] == text[i]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(k - i, count[text[i]]));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-035-最小时间差"><a href="#OfferⅡ-035-最小时间差" class="headerlink" title="OfferⅡ 035.最小时间差"></a>OfferⅡ 035.最小时间差</h2><blockquote><p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></blockquote><p>除了00：00之外都可以排序比较……？如果前或者后有一个00：00，那么前后都应该补上一个；如果前后都有00：00，那结果就是0。呃……但处理起来似乎很麻烦？（被时间间隔跳跃难住了）</p><p>【题解】因为要找最小时间差，可以先<strong>排序</strong>，那么间隔最小的不是相邻的，就是数组首和尾（是一种特殊的相邻情况）。</p><p>接着是对时间间隔的处理。如果两者超过12h，那么可以反减成间隔小于12h之内。</p><p>而且题解对时间间隔的处理也抓到了要点：将首尾换成“相隔一天”的时间，如果两个时间间隔大于12h，比如5：00、23：00，那就是29：00-23：00，会比较接近；如果间隔小于12h，比如16：00、23：00，那就是40-23，反而会拉远。呃呃呃，反正就是很奇妙啊（不会灵活变通看啥都很妙）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinutes</span><span class="params">(string &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>)) * <span class="number">60</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt; &amp;timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(timePoints.<span class="built_in">begin</span>(), timePoints.<span class="built_in">end</span>());<span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> t0Minutes = <span class="built_in">getMinutes</span>(timePoints[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> preMinutes = t0Minutes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timePoints.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minutes = <span class="built_in">getMinutes</span>(timePoints[i]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, minutes - preMinutes); <span class="comment">// 相邻时间的时间差</span></span><br><span class="line">            preMinutes = minutes;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, t0Minutes + <span class="number">1440</span> - preMinutes); <span class="comment">// 首尾时间的时间差</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O(nlogn)，n是数组长度，排序所需时间；</li><li>空间复杂度：O(n)或O(nlogn)，排序需要空间，取决于具体语言的实现。</li></ul></blockquote><p>【鸽巢原理】根据题意，一共有 24×60=1440种不同的时间。由鸽巢原理可知，如果 timePoints 的长度超过1440，那么必然会有两个相同的时间，此时可以直接返回0。</p><p>鸽巢原理：如果有n+1个鸽子飞进了n个鸽巢中，那么必定有鸽巢中至少飞进了2只鸽子。</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="OfferⅡ-030-插入、删除和随机访问都是O-1-的容器"><a href="#OfferⅡ-030-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="OfferⅡ 030. 插入、删除和随机访问都是O(1)的容器"></a>OfferⅡ 030. 插入、删除和随机访问都是O(1)的容器</h2><p>插入删除无疑用哈希表，随机访问还想遍历一下，但是时间复杂度不行，所以引入变长容器vector；</p><p>vector可以直接访问索引，所以通过索引访问随机元素。但vector又不好插入删除，也要依赖哈希表动态更新，哈希表插入时vector在尾部添加，删除时获取哈希表对应的索引进行特定位置的删除。</p><p>但是这样的话vector某个元素的索引是时时变化的。比如原来是第3个，前面删除了，那么就变成了第2个，暂且不说哈希表也要对应变化，后面的一连串也要跟着变化……时间复杂度又上去了。如果vector不删除，或者不连续，都影响随机数每个数字概率都一样的要求……</p><p>总结来说，随机数只和vector有关，插入的话只需要哈希表，但是删除的话vector又依赖哈希表（需要知道哪个被删除了），此时要求哈希表的值和索引值严格对应，但vector的索引由于删除又实时更新……</p><p>【针对删除出现的问题，就是把删除的位置idx和最后一个last替换，并把last索引更新，时间复杂度就是1了】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indices.<span class="built_in">count</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(val);</span><br><span class="line">        indices[val] = index;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!indices.<span class="built_in">count</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = indices[val];</span><br><span class="line">        <span class="keyword">int</span> last = nums.<span class="built_in">back</span>();</span><br><span class="line">        nums[index] = last;</span><br><span class="line">        indices[last] = index;</span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        indices.<span class="built_in">erase</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = <span class="built_in">rand</span>()%nums.<span class="built_in">size</span>();<span class="comment">// rand()</span></span><br><span class="line">        <span class="keyword">return</span> nums[randomIndex];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所以这道题的难度是，哈希表的特点是判断是否存在但没有索引访问且不连续，而随机数又给出了这样的要求……那么怎样才能辅助哈希表呢？</p><p>【题解】哈希表＋滑动窗口。比我原来的想法高明在，找是否有相同的字母来补，不是遍历，而是哈希表计数确定。如果还有其它一部分没算，那就在前一位或者后一位来补。</p><p>再看后面有没有重复的部分……有待斟酌。(????这哪跟哪？)</p><h2 id="OfferⅡ-031-最近最少使用缓存"><a href="#OfferⅡ-031-最近最少使用缓存" class="headerlink" title="OfferⅡ 031.最近最少使用缓存"></a>OfferⅡ 031.最近最少使用缓存</h2><blockquote><p> <a href="https://baike.baidu.com/item/LRU">LRU (Least Recently Used，最近最少使用) 缓存机制</a></p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul></blockquote><p>逻辑就是以下这样。put的时候会检查存储是否足够，若不够，则删除最久未用的数据；而get的时候会更新该元素的使用情况。其实就满了删除的时候才需要知道哪些元素要删，map做不到，就只能借助于其它数据结构，记录元素更新情况。</p><p>如果用数组：put的时候更新元素位置就很麻烦，因为要移动元素；</p><p>如果用队列：读元素只能从队头读，也不好移动元素；</p><p>什么数据结构能方便读取和移动元素呢？</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230523152452370.png" alt="image-20230523152452370"></p><p>【题解】哈希表＋双向链表。<a href="https://leetcode.cn/problems/OrIXps/solution/zui-jin-zui-shao-shi-yong-huan-cun-by-le-p3c2/">最近最少使用缓存 - 最近最少使用缓存 - 力扣（LeetCode）</a></p><ul><li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li><li>哈希表即为普通的哈希映射（HashMap），键存的是数字，值存的是对应的链表结点。而链表结点又存了value值。利用了双向链表<strong>方便插入删除</strong>的特点；还有可以<strong>头插或者尾插</strong>的特点（插入头部后面或尾部前面）。因为辅助的数据结构既要实现队列的功能，也要知道中间的元素（被更新到尾部），使用数组会打乱顺序，使用队列就访问不到中间的元素，所以双向链表是最优选择。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ033-变位词组"><a href="#OfferⅡ033-变位词组" class="headerlink" title="OfferⅡ033.变位词组"></a>OfferⅡ033.变位词组</h2><blockquote><p>给定一个变位词组，组合变位词，可以按照任意顺序返回结果。变位词是指字母相同，但排列不同的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p>首先想到遍历。每个元素依次遍历，遇到变位词就组合在一起，再把它们从数组中移除。最坏的情况是每个元素只有自己为一组，那就达到O(n²)的复杂度。</p><p>那怎么把遍历的结果存下来呢？想要记录的结果是，有什么字母，对应多少个出现次数；这个用哈希表怎么记录呢？不用哈希表直接映射的话，逐个遍历比较也很耗时间。</p><p>【题解】排序。由于互为字母异位词的两个字符串包含的<strong>字母相同</strong>，因此对两个字符串分别进行<strong>排序之后得到的字符串一定是相同的</strong>，故可以将排序之后的字符串作为哈希表的键。</p><p>从键来说，简化了记录字母和对应数字，直接整合成字符串；从对来说，哈希表可以存数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (string&amp; str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);  <span class="comment">// 哈希表的second可以放数组？</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O(nklogk)，其中 n 是strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历n 个字符串，对于每个字符串，需要 O(klogk) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nklogk)。</li><li>空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</li></ul></blockquote><p>【计数】直接使用数组作为哈希表的键？需要自定义了。自定义那个看了比较麻烦，有人用字符串来代替数组。需要注意的是，把字符串当作数组来看的话，字符串的元素是char，也就占一个字节，最多记录-128~127，比int记录的要少很多。（怎么解决？待思考</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; hash_al;<span class="comment">//unordered_map的key不能存储vector.</span></span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123;</span><br><span class="line">            <span class="comment">//将字符串转为字母表</span></span><br><span class="line">            <span class="function">string <span class="title">temp</span><span class="params">(<span class="number">26</span>,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : str) &#123;</span><br><span class="line">                --temp[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将变位词放在同一键下面</span></span><br><span class="line">            hash_al[temp].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历哈希表，将变位词组改成输出格式形式</span></span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;string, vector&lt;string&gt;&gt;::iterator it = hash_al.<span class="built_in">begin</span>(); it != hash_al.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-034-外星语言是否排序"><a href="#OfferⅡ-034-外星语言是否排序" class="headerlink" title="OfferⅡ 034.外星语言是否排序"></a>OfferⅡ 034.外星语言是否排序</h2><blockquote><p>只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；</p><p>字典顺序：如果前一个单词的第一个字母比后一个单词的第一个字母靠前，则返回true；如果前者靠后，则返回false；如果相同，就看两者的第二个字母，规则同上；如果都相同的情况下，后一个单词比前一个单词长才返回true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在该语言的字母表中，&#x27;h&#x27; 位于 &#x27;l&#x27; 之前，所以单词序列是按字典序排列的。</span><br></pre></td></tr></table></figure></blockquote><p>想到的思路是，从头开始遍历两两比较，如果前一个大于后一个，则返回false；否则继续。</p><p>然后是两个单词的比较，也是从头遍历两两比较，如果前一个大于后一个，返回false。由于要参照被打乱的字母表，所以要遍历字母表查两个字母的前后；但是每次比较都遍历的话就很耗时间，k（最短单词长度）×n（数组长度）×26。那么如何记录比较过的信息呢？我想到的键值对是string-int，string是c1c2……但我写得很冗长……</p><p>【题解】突破点在如何快速高效地知道乱序字母表的每个字母对应的位置。这里很巧妙地用<code>index[order[i] - &#39;a&#39;] = i;</code>也就是，默认数组的索引0<del>26对应a</del>z，然后元素记录的是新的索引值……所以比较的时候就能直接检索到所需字母以及对应新索引……实在是妙极了啊啊啊啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            index[order[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接当作二维数组来比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i - <span class="number">1</span>].<span class="built_in">size</span>() &amp;&amp; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> prev = index[words[i - <span class="number">1</span>][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">int</span> curr = index[words[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (prev &lt; curr) &#123;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev &gt; curr) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="comment">/* 比较两个字符串的长度 */</span></span><br><span class="line">                <span class="keyword">if</span> (words[i - <span class="number">1</span>].<span class="built_in">size</span>() &gt; words[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这几题下来有些新的启发，最重要的是记录的思想，并不一定是要哈希表，哈希表只是一种快速定位的键值对形式，数组（字符串）也能有索引快速定位的功能。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="JZ56-数组中只出现一次的两个数字"><a href="#JZ56-数组中只出现一次的两个数字" class="headerlink" title="JZ56 数组中只出现一次的两个数字"></a>JZ56 数组中只出现一次的两个数字</h2><p>想的是直接排序，然后遍历删除重复的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i<span class="number">-1</span>) &gt;= <span class="number">0</span> &amp;&amp; (array[i] == array[i<span class="number">-1</span>])) &#123;</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+(i<span class="number">-1</span>));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】用到了位运算。</p><p>1.总体思路：有一道和它类似的题,它所指的数组中只有一个出现一次的数,而解法就是从头开始不断地异或下去,由于相同的两个数异或值为0,因此最终的异或结果就是答案；</p><p>2.而本题有两个只出现一次的数a和b,我们按异或方法<u>最终只能得到a异或b的值</u>,就需要思考一下这两个数异或的结果有何特点；（利用两数不同且唯一的特点做区分）</p><p>3.我们可以发现,首先这两个数一定不同,故异或结果一定不为0,那么<u>a异或b的结果中一定有一位为1</u>,假设是第x位,那么就说明了a和b的二进制的第x位是不同,根据这一特点,我们可以将数组分为两个集合,即<u>第x位为1的数和第x位为0的数</u>,两部分的异或和即为a和b的值；（找到区分的点，确保两者独立，然后再区分阵营…好抽象！）</p><p>4.要快速求得最后一位1,可以用lowbit运算,它可以快速得到x的最后一位1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;<span class="comment">// 是一种快速运算</span></span><br><span class="line">    </span><br><span class="line">    temp = a ^ b;<span class="comment">// 常规运算</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;<span class="comment">// 0001</span></span><br><span class="line">    <span class="keyword">while</span>((k &amp; temp) == <span class="number">0</span>)</span><br><span class="line">        k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> twoNums = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 两数异或的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        twoNums ^= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个不同的1</span></span><br><span class="line">    <span class="keyword">int</span> difPos = <span class="built_in">lowbit</span>(twoNums);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        <span class="comment">// 比如difPos = 0010, 那么只有那位为1的时候，与的结果才【不为0】，否则必然为0</span></span><br><span class="line">        <span class="keyword">if</span> (difPos &amp; i) &#123;</span><br><span class="line">            a ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到a的值，也就知道b的值：b = (a^b)^a</span></span><br><span class="line">    b = twoNums ^ a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? vector&lt;<span class="keyword">int</span>&gt;&#123;a,b&#125; : vector&lt;<span class="keyword">int</span>&gt;&#123;b,a&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230403153532720.png" alt="image-20230403153532720"></p><h2 id="OfferⅡ004-只出现一次的数字"><a href="#OfferⅡ004-只出现一次的数字" class="headerlink" title="OfferⅡ004. 只出现一次的数字"></a>OfferⅡ004. 只出现一次的数字</h2><p>除了答案是出现一次，其他元素出现三次。两相同数异或为0，0再异或那个数还是那个数，所以全部异或一遍的话就是所有不重复数异或的结果。</p><p>那怎么办呢？感觉要从出现三次的地方入手……怎么和出现一次作出区分呢？</p><p>【题解】依次确定每一个二进制位。考虑答案的第 i 个二进制位（i 从0开始编号），它可能为0 或 1。对于数组中非答案的元素，每一个元素都出现了 3 次，对应着第 i 个二进制位的 3 个 0 或3 个 1，无论是哪一种情况，它们的和都是 3 的倍数（即和为0 或3）。</p><p>所以把每一个进位对应的所有1/0加起来，就是3的倍数加上0/1。反向取余拼接起来就是答案了……OMG！</p><p>进一步细节思考：数据条件是<code>-2的31次方 &lt;= nums[i] &lt;= 2的31次方 - 1</code>所以是一个有符号整数，那负数的话……？由于补码就是为了正常运算而存在的，那么应该没影响？   需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，那么可能会得到错误的答案。这是因为「有符号整数类型」（即int 类型）的第 31 个二进制位（即最高位）是补码意义下的符号位，对应着 −2的31次方，而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2的31次方。因此在某些语言（例如 Python）中需要对最高位进行特殊判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            total += ((num &gt;&gt; i) &amp; <span class="number">1</span>);  <span class="comment">// 取某位要&amp;1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="JZ76-删除链表中重复的结点"><a href="#JZ76-删除链表中重复的结点" class="headerlink" title="JZ76 删除链表中重复的结点"></a>JZ76 删除链表中重复的结点</h2><p>题意很简单，但是仔细思考觉得操作起来蛮复杂。</p><p>刚开始想用三个指针。pre，curr，last（和curr重复的最后一个结点，但因为循环，所以重复的话会到最后一个结点的下一个）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHead) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    pre-&gt;next = pHead;</span><br><span class="line">    ListNode* curr = pHead, *last;</span><br><span class="line">    vector&lt;ListNode*&gt; deletes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!curr) &#123;</span><br><span class="line">        last = curr;</span><br><span class="line">        <span class="comment">// 找出重复的范围</span></span><br><span class="line">        <span class="keyword">while</span> (!last-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last-&gt;next-&gt;val == last-&gt;val) &#123;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理重复结点</span></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;val != last-&gt;val) &#123;</span><br><span class="line">            pre-&gt;next = last-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (!curr) &#123;</span><br><span class="line">                deletes.<span class="built_in">push_back</span>(curr);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针更新</span></span><br><span class="line">        curr = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就写不下去了，因为指针多的时候要考虑指针为空的情况，那将要考虑更多情况和写更多的if和while语句，觉得好闹心……而且还要删除重复的指针，不能简单地越过。</p><p>然后就思考，单链表麻烦的地方在于必须维护前后关系，然后要考虑下一个结点可能为空的情况；关系一复杂，就很难搞，要很多变量存储这些关系；那如果使用额外空间/顺序数据结构来帮助维护关系呢？</p><p>接着想到队列，可知队头和队尾，重复的部分删除就好，重要的是两边的头尾……</p><ul><li>确定头：当入队的结点和队首的结点值不同且相邻时，队首出队（必不重复），作为pre</li><li>当入队的结点和队首的结点值相同时，继续入队</li><li>当入队的结点和队首的结点值不同且不相邻时，队首和队尾必然有重复的，从队首开始逐一删除重复元素</li><li>回到第一点，如果出队的时候有pre，那么pre下一个就是队首，出队后接着做pre（头尾相连）</li></ul><p>另，要把空结点也加进去。因为重复的范围必须由下一个元素确定，比如445，但如果后面只有重复的，比如4455，那么空结点也是判断条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHead) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;ListNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* curr = pHead-&gt;next, *head = pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        queue.<span class="built_in">push</span>(curr);</span><br><span class="line">        <span class="comment">// 确定不是重复的数</span></span><br><span class="line">        <span class="keyword">if</span> ((!curr || queue.<span class="built_in">front</span>()-&gt;val != curr-&gt;val) &amp;&amp; queue.<span class="built_in">front</span>()-&gt;next == curr) &#123;</span><br><span class="line">            pre-&gt;next = queue.<span class="built_in">front</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定重复的范围</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((!curr || queue.<span class="built_in">front</span>()-&gt;val != curr-&gt;val) &amp;&amp; queue.<span class="built_in">front</span>()-&gt;next != curr) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="built_in">front</span>() != queue.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                <span class="comment">//ListNode* temp = queue.front();</span></span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//delete temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复继续往下遍历</span></span><br><span class="line">        <span class="keyword">if</span> (curr) &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完链表，必须有个收尾</span></span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过实际上还是没有解决删除问题，只是删除了临时变量。</p></blockquote><p>【题解】呃，别人还是用指针解决了问题，来学习一下。它只用了一个指针，是判断指针的下一个和下下一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//在链表前加一个表头</span></span><br><span class="line">    res-&gt;next = pHead; </span><br><span class="line">    ListNode* cur = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="comment">//遇到后两个节点值相同</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123; </span><br><span class="line">            <span class="keyword">int</span> temp = cur-&gt;next-&gt;val;</span><br><span class="line">            <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;val == temp) </span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回时去掉表头</span></span><br><span class="line">    <span class="keyword">return</span> res-&gt;next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短路运算确实在这起了很大效果。<code>cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL</code>如果前面为空，那么后面必不会运算，这就不会报错。除此之外，跨数字链接，它不是记录头和尾，而是头的next一直往后指……总之它一个指针就能完成这些事情，值得思考和学习。</p><h2 id="OfferⅡ-022-链表中环的入口节点"><a href="#OfferⅡ-022-链表中环的入口节点" class="headerlink" title="OfferⅡ 022. 链表中环的入口节点"></a>OfferⅡ 022. 链表中环的入口节点</h2><p>对这种题还是不知道如何思考才正确……</p><p>首先知道有环的话两者必定相遇…为什么要先假设速度就是1，2呢？然后要懂得分析相遇时走过的路径……</p><p><a href="https://leetcode.cn/problems/c32eOV/solution/lian-biao-zhong-huan-de-ru-kou-jie-dian-vvofe/">链表中环的入口节点 - 链表中环的入口节点 - 力扣（LeetCode）</a></p><h2 id="OfferⅡ-026-重排链表"><a href="#OfferⅡ-026-重排链表" class="headerlink" title="OfferⅡ 026. 重排链表"></a>OfferⅡ 026. 重排链表</h2><p>原想法是，用快慢指针找到后一半，然后把后一半用栈存起来，再一一遍历插入。</p><p>之前从来没有注意到一个问题，仔细想想真的还很drama。存入栈的其实是结点的一份拷贝，但指向还是原链表，所以当把栈的元素插入链表中的时候，链表后半部分还在。要是把栈变量的指向改动的话，结果很难设想。这样用空间存储一部分链表的话似乎要十分谨慎，把链表全存入或者构建新链表还好。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230519120051323.png" alt="image-20230519120051323"></p><p>原错误思路:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, *fast = head;</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将后半部分存入栈</span></span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow)</span><br><span class="line">    &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(slow);</span><br><span class="line">        <span class="comment">//ListNode* temp = slow;</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">//delete temp;// 这个好像把slow也删掉了？搞晕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete slow;</span></span><br><span class="line">    <span class="comment">//delete fast;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新遍历，插入</span></span><br><span class="line">    ListNode* curr = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() <span class="comment">/* &amp;&amp; curr */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* node = stack.<span class="built_in">top</span>(); stack.<span class="built_in">pop</span>();</span><br><span class="line">        node-&gt;next = curr-&gt;next;    <span class="comment">// leetcode 报heap-use-after-use错</span></span><br><span class="line"></span><br><span class="line">        curr-&gt;next = node;</span><br><span class="line">        curr = curr-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete curr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若例子是1,2,3,4，结果是1,4,2,3,4,,,,</p></blockquote><p>【题解】一、线性表。存储整个链表。</p><p>因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。</p><p>因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。</p><p>这里题解是用线性表重构整个链表。但是不也拷贝了吗？这个要仔细分析才不会先入为主。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230519122422519.png" alt="image-20230519122422519"></p><blockquote><p>拷贝出来的是node，存入vec的是圈出来的部分。当修改node的next时，由于next是指针，其实是访问指向的对象的next，这和head的next是一样的，所以效果一样。</p><p>仔细想想坑还是好多，以后多积累多思考多注意。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;ListNode*&gt; vec;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (node)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            vec[l]-&gt;next = vec[r];</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[r]-&gt;next = vec[l];</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[l]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【方法二】链表中点+链表逆序+合并链表</p><p>也就是把存储改为逆序，在原链表基础上改，这样就感觉稳很多了。</p><h2 id="OfferⅡ-027-回文链表"><a href="#OfferⅡ-027-回文链表" class="headerlink" title="OfferⅡ 027.回文链表"></a>OfferⅡ 027.回文链表</h2><p>后半部分反转链表，再逐一比较：很慢，就超过百分之十几。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = <span class="built_in">reverse</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明链表长度是奇数, slow在中间点，不需要反转</span></span><br><span class="line">        <span class="keyword">if</span> (fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后半部分</span></span><br><span class="line">        ListNode* head2 = <span class="built_in">reverse</span>(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两比较</span></span><br><span class="line">        <span class="keyword">while</span> (head2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != head2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【题解】递归。可知递归是从链表的尾部逐一往前，而再用一个全局变量来遍历前半部分，这样就能前后同时比较了。递归对于<strong>链表往前遍历</strong>也是一种很好的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    ListNode* frontPointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       <span class="comment">// 往后递归，直到空结点，返回true；则if判断为!true</span></span><br><span class="line">            <span class="comment">// 从语义来说，也就是递归过的末尾链表符合条件了才返回true，才能够继续往下执行比较，否则就直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上一个if判断为false，开始判断值是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录头结点</span></span><br><span class="line">        frontPointer = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-028-展平多级双向链表"><a href="#OfferⅡ-028-展平多级双向链表" class="headerlink" title="OfferⅡ 028.展平多级双向链表"></a>OfferⅡ 028.展平多级双向链表</h2><p>尝试理解展平的规则：去掉了child指针信息。首先先顺着child往下走，直到没有child的那一个结点，再往右走访问同一行的结点；访问完后回到上一层有孩子结点的结点的右边……用栈来存储有child结点的next结点，访问完child则从栈取出继续访问…</p><p>没有好的抽象思维习惯一下子就绕晕了。</p><p>【题解】深度优先搜索。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230522111207578.png" alt="image-20230522111207578"></p><blockquote><p>这样就好理解多了。把孩子那层扁平化成一条链表再插入到右边去。那在代码实现层面怎么回溯呢？想象了一下递归代码，把孩子层的头结点传进去，返回last结点，把head 和last与自己当前的结点curr和curr-&gt;next连接起来。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* curr = node;</span><br><span class="line">        <span class="comment">// ！记录链表最后一个结点（没有child和扁平化child的结果不同）</span></span><br><span class="line">        Node* last = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr <span class="comment">/* &amp;&amp; curr-&gt;next */</span>)    <span class="comment">// ！要考虑到最后一个结点也可能有child 这样就不需要和next连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* next = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;child)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 扁平化</span></span><br><span class="line">                Node* child_last = <span class="built_in">dfs</span>(curr-&gt;child);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// curr与child连接</span></span><br><span class="line">                curr-&gt;next = curr-&gt;child;</span><br><span class="line">                curr-&gt;child-&gt;prev = curr;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// last和next连接</span></span><br><span class="line">                    child_last-&gt;next = next;</span><br><span class="line">                    next-&gt;prev = child_last;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ！将child置为空</span></span><br><span class="line">                curr-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                last = child_last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ！接着原来的next继续往后</span></span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>时间复杂度：O(n)，其中 n 是链表中的节点个数。</p></li><li><p>空间复杂度：O(n)。上述代码中使用的空间为深度优先搜索中的栈空间，如果给定的链表的「深度」为<br>d，那么空间复杂度为 O(d)。在最坏情况下，链表中的每个节点的next 都为空，且除了最后一个节点外，每个节点的child 都不为空，整个链表的深度为n，因此时间复杂度为O(n)。</p></li></ul></blockquote><p>顺着题解的思路能写出递归的大概，但一些细节是对照别人的代码才看出来的，以后要自己实践一下。</p><p><a href="https://leetcode.cn/problems/Qv1Da2/solution/zhan-ping-duo-ji-shuang-xiang-lian-biao-x5ugr/">展平多级双向链表 - 展平多级双向链表 - 力扣（LeetCode）</a></p><p>【题解】迭代。按照原先的想法，就是：如果有child就往下遍历，往下-往右遍历完后，再看栈还有没有存储（上一层）的结点，继续出栈访问，以此类推。整个过程就是依次遍历的过程，可以在一个while中完成。</p><p>遇到child则进入child所在层，若走到当前层最后一个结点，则考察上一层是否有后续结点，若有则链回上一层（展平）。为了能够链回上一层，需要在通过当前结点cur进入child层时，先将cur.next保存起来，显然应当借助栈来保存。整体是一个层层深入后再自下而上展平的过程。现在来考虑完成展平（结束while）的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.cur为空结点 而且 没有上一层（栈空），则为false</span></span><br><span class="line"><span class="keyword">while</span>(cur != null || !stack.<span class="built_in">isEmpty</span>())</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-029-排序的循环链表"><a href="#OfferⅡ-029-排序的循环链表" class="headerlink" title="OfferⅡ 029.排序的循环链表"></a>OfferⅡ 029.排序的循环链表</h2><p>刚开始想到，既然是非降序，那么插入一个数字，要么是最大/最小的，要么是中间的，但是一想到这是循环链表，可能不好找，没仔细想就放弃了。然后果断用了数组存……这样就随便遍历了。好理解但是麻烦了些，空间复杂度为n。</p><p>【题解】找了一个评论，思路和我很像，但是别人写出来了，值得学习。</p><p>有一个核心点我没想到，就是既然是非降序循环，那么肯定有“断点”，最大值和最小值相邻的地方。这样就很快判断插入的值是否为最大最小值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断点 或 边界跳跃点</span></span><br><span class="line">cur-&gt;val &gt; cur-&gt;next-&gt;val <span class="comment">// 当前值大于下一个值</span></span><br><span class="line">value &gt;= cur-&gt;val<span class="comment">// 插入的值比当前值还大，那就是新的最大值</span></span><br><span class="line">value &lt;= cur-&gt;next-&gt;val<span class="comment">// 插入的值比最小值（当前的下一个）还小，就是新的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要满足以上情况，此时cur就是要插入的点的前结点</span></span><br></pre></td></tr></table></figure><p>剩下就是中间的情况。只要满足：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur-&gt;val &lt;= cur-&gt;next-&gt;val<span class="comment">// 升序的情况</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(value &gt;= cur-&gt;val &amp;&amp; value &lt;= cur-&gt;next-&gt;val)<span class="comment">// 夹在两值中间</span></span><br></pre></td></tr></table></figure><p>所以找到符合条件的cur，也就是找到了插入的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结点为空，要创建一个指向自己的新结点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">            head-&gt;next = head;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="comment">// 只遍历一次不重复的</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=head)&#123;</span><br><span class="line">            <span class="comment">// 边界点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val&lt;cur-&gt;val)&#123;</span><br><span class="line">                <span class="comment">// 最小值</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next-&gt;val&gt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 最大值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val&lt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处在中间值</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&lt;=insertVal&amp;&amp;cur-&gt;next-&gt;val&gt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 都不符合条件，继续遍历</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal, cur-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思路很简洁，还有抓住cur以及next的判断也很巧妙。遇到这题觉得头疼是因为没有找到 <strong>结点间的关系 和 判断条件的关系</strong>，总觉得链表遍历单一，一定要有辅助遍历才行，所以没有分析到位。</p></blockquote><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="OfferⅡ-037-小行星碰撞"><a href="#OfferⅡ-037-小行星碰撞" class="headerlink" title="OfferⅡ 037.小行星碰撞"></a>OfferⅡ 037.小行星碰撞</h2><h2 id="OfferⅡ-038-每日温度"><a href="#OfferⅡ-038-每日温度" class="headerlink" title="OfferⅡ 038.每日温度"></a>OfferⅡ 038.每日温度</h2><p>时间复杂度为O(n²)果然还是超时了。一个数要找到后面第一个比它大的数……除了一个个找还能咋办呢？</p><p>想着要利用已知信息，从左到右遍历的话，比如知道76，78，77，79，即使78知道下一个比它大的数是79，知道有77的存在，但77除了重新遍历还能怎么知道下一个比它大的数呢？</p><p>这里的有逆向思维的方法。最后一个元素对应的答案肯定为0，因为后面没有任何元素了。那倒数第一个呢，已知最后一个，也可以推断答案；倒数第三个……已知后面的所有元素，也能记录索引，那么可以有目的地遍历比它大的，找有没有存在对应索引……（反正细细品</p><p>【题解】虽然说是暴力，但比我那个暴力要巧妙得多。这脑子就是转不过弯来啊。从前往后，用过的元素对题目条件其实没多大帮助，要是倒过来的话，知道后面所有存在的元素反而可以利用起来。</p><p>这里将后面遍历过的元素，存在[30, 100]的数组next里面，记录这个数字（从左往右）第一次出现的索引。然后当当前元素想要找到比它大的元素时，就往[i+1,100]挨个找，看看有没有最近的索引。</p><p>这样看起来每次都要遍历(100-i)次，但是由于肯定不超过100，那么时间复杂度可以算作O(n)，n是温度列表的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="number">101</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> warmerIndex = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = temperatures[i] + <span class="number">1</span>; j &lt; <span class="number">101</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                warmerIndex = <span class="built_in">min</span>(warmerIndex, next[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (warmerIndex != INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            next[temperatures[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="JZ54-二叉搜索树的第k个节点"><a href="#JZ54-二叉搜索树的第k个节点" class="headerlink" title="JZ54 二叉搜索树的第k个节点"></a>JZ54 二叉搜索树的第k个节点</h2><p>二叉搜索一般和中序遍历挂钩，然后遇到k就记录下来……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> target = <span class="number">0</span>, res = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!proot) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = k;</span><br><span class="line">    <span class="built_in">dfs</span>(proot);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count == target) &#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过找到目标后递归并不能停止。所以加上几个递归条件就更好。不过话说这真的是中等题吗……</p><blockquote><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，其中<em>n</em>为二叉树的节点数，所有节点遍历一遍</li><li>空间复杂度：<em>O</em>(<em>n</em>)，栈空间最大深度为二叉树退化为链表，长度为<em>n</em></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!root || res != <span class="number">-1</span> || count &gt; target) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好久没有用过栈了，copy一下来回顾一下：先遍历左子树，把节点都入栈，然后取出栈顶作为当前根节点，来进行判断，接着访问右节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//记录遍历了多少个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    TreeNode* p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用栈辅助建立中序</span></span><br><span class="line">    stack&lt;TreeNode*&gt; s;  </span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() || proot != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (proot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(proot);</span><br><span class="line">            <span class="comment">//中序遍历每棵子树从最左开始</span></span><br><span class="line">            proot = proot-&gt;left;  </span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//第k个直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(count == k)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        proot = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77 按之字形顺序打印二叉树"></a>JZ77 按之字形顺序打印二叉树</h2><p>从左往右遍历的层，就从左往右入队，然后再从右往左取出每个节点，按照右子树左子树的顺序把子树入队；</p><p>同理，从右往左遍历的层，就根据上层是从右往左入队，然后再从左往右出队按照左子树右子树把子树入队。</p><p>按照这个规律，都是先进后出，那么为了分清层次，用两个栈交替使用。</p><p>再梳理一下，比如该层是应该从右往左遍历，但是为了下一层能够从左往右进栈，会从左往右遍历然后将子树入栈，所以遍历的记录要反转一下。【核心是取出栈的节点，然后存节点的顺序】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckLayer</span><span class="params">(stack&lt;TreeNode*&gt; &amp;a, stack&lt;TreeNode*&gt; &amp;b, <span class="keyword">bool</span> isL2R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 遍历每个节点，存入</span></span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* curr = a.<span class="built_in">top</span>();</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isL2R) &#123;</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack1 从左往右存放，从右往左取出，右左遍历</span></span><br><span class="line">    <span class="comment">// stack2 从右往左存放，从左往右取出，左右遍历</span></span><br><span class="line">    stack&lt;TreeNode*&gt; stack1, stack2;</span><br><span class="line">    stack1.<span class="built_in">push</span>(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>() || !stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">CheckLayer</span>(stack1, stack2, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">CheckLayer</span>(stack2, stack1, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】使用队列。要用size记录当前队列长度——解决每一层的问题。然后用level来记录打印方向……确实要简洁很多，直接翻转数组不是快很多吗（doge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res; </span><br><span class="line">        <span class="keyword">if</span> (!pRoot)</span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        queue&lt;TreeNode*&gt; q; <span class="comment">// 定义队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(pRoot); <span class="comment">// 根结点入队列</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; arr; <span class="comment">// 定义数组存储每一行结果</span></span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>(); <span class="comment">// 当前队列长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* tmp = q.<span class="built_in">front</span>(); <span class="comment">// 队头元素</span></span><br><span class="line">                q.<span class="built_in">pop</span>(); </span><br><span class="line">                <span class="keyword">if</span> (!tmp) <span class="comment">// 空元素跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;left); <span class="comment">// 左孩子入队列</span></span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;right); <span class="comment">// 右孩子入队列</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从左至右打印</span></span><br><span class="line">                    arr.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从右至左打印</span></span><br><span class="line">                    arr.<span class="built_in">insert</span>(arr.<span class="built_in">begin</span>(), tmp-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++; <span class="comment">// 下一层，改变打印方向</span></span><br><span class="line">            <span class="keyword">if</span> (!arr.<span class="built_in">empty</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(arr); <span class="comment">// 放入最终结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ78-把二叉树打印成多行"><a href="#JZ78-把二叉树打印成多行" class="headerlink" title="JZ78 把二叉树打印成多行"></a>JZ78 把二叉树打印成多行</h2><p>甚至比JZ77要简单，记录每一层的个数（也就是上一层遍历完后队列的长度）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 存储每一行的结果</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; eachLayer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环每一层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* curr = queue.<span class="built_in">front</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            eachLayer.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line">            queue.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            queue.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eachLayer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(eachLayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ84-二叉树中和为某一值的路径（三）"><a href="#JZ84-二叉树中和为某一值的路径（三）" class="headerlink" title="JZ84 二叉树中和为某一值的路径（三）"></a>JZ84 二叉树中和为某一值的路径（三）</h2><p>由于不知道起点和终点，所以感觉有很多种可能，如果从上往下，虽然每个节点都只有一个父节点，但是从父节点来的也可能有很多种（如含父/祖父等），更不用说从下往上的子节点的可能性了（每一个子树多种可能）。之前对树的记忆一般都是递归（子树返回唯一值），从上往下（父给予唯一值）……不知道如何入手。</p><p>感觉从上往下的思路似乎明确一点。路径就是从父到子，正常思路就是父不够子来凑吧。</p><p>那么接着从某个节点角度来思考，它的任务就是接收父节点传来的要求，然后处理。刚好够的话就凑成一条路径，不够的话继续传给子树，多了的话就返回；</p><p>末尾问题解决了，那么起始点的问题呢？不是从父节点来的，就是以自己为起始。</p><p>所以递归的思路差不多就出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, target;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入子树继续找</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以自己为开始</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, target - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, target - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = sum;</span><br><span class="line">    <span class="built_in">dfs</span>(root, target);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是，以自己为开始的代码会重复执行多次。比如一个底层子节点，它的每一个父辈传下去时都试一下自己为初始节点（多次递归到底层节点），那么它就得每次都重复尝试自己作为初始点的情况。</p><p>所以起始点的两种情况应该分开。父节点需求找完，就开始新的根节点。</p><p>【题解】脑子有点转不过来了。</p><p>既然要找所有路径上节点和等于目标值的路径个数，那肯定先找这样的路径起点，但是我们不知道起点究竟在哪里，而且任意节点都有可能是起点，那我们就前序遍历二叉树的所有节点，每个节点都可以作为一次起点，即子树的根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以其子结点为新根</span></span><br><span class="line"><span class="built_in">FindPath</span>(root.left, sum); </span><br><span class="line"><span class="built_in">FindPath</span>(root.right, sum);</span><br></pre></td></tr></table></figure><p>查找路径的时候呢，也需要往下遍历，因此还可以继续前序遍历该子树，在遍历的过程遇到一个节点，sum相应减少，若是到最后往下的一个节点值正好等于剩下的sum，则找到一种情况。</p><p>因为前序递归的次序是根左右，因此一定是往下找的路径，不会往上回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入子节点继续找</span></span><br><span class="line"><span class="built_in">dfs</span>(root.left, sum - root.val);</span><br><span class="line"><span class="built_in">dfs</span>(root.right, sum - root.val);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入子树继续找</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询以某结点为根的路径数</span></span><br><span class="line">    <span class="built_in">dfs</span>(root, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以其子结点为新根</span></span><br><span class="line">    <span class="built_in">FindPath</span>(root-&gt;left, sum);</span><br><span class="line">    <span class="built_in">FindPath</span>(root-&gt;right, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O*(<em>n</em>2)，其中n*为二叉树的结点数，两层dfs嵌套递归</li><li>空间复杂度：<em>O</em>(<em>n</em>)，每层dfs最深递归栈都只有n</li></ul></blockquote><p>仔细一想我的想法稍微有点复杂，再抽象一点就是每个节点都可能作为路径起始点，就简化了好多（其实也就是暴力啦！）。然后每个节点为根遍历一次……这样就明白许多了。</p><p>这种看似多种解法的题很容易想复杂，怎么样才能抓住关键点呢？这道题而言，可能是起始点和终点的问题。</p><p>【题解】前缀和 &amp; DFS &amp; 回溯。</p><p>思路类似于<code>和为k的子数组个数</code>，树中某一条从上到下的路径就相当于一个数组，计算前缀和 ；只是树的路径遍历完进行变换 / 回溯的时候，就取消记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* curr, <span class="keyword">int</span> targetSum, <span class="keyword">long</span> <span class="keyword">long</span> prefixSum)</span> </span>&#123;</span><br><span class="line">        prefixSum += curr-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(prefixSum - targetSum) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            count += hash[prefixSum - targetSum];</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefixSum]++;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(curr-&gt;left, targetSum, prefixSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(curr-&gt;right, targetSum, prefixSum);</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefixSum]--; <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>只需要遍历每个节点，时间复杂度为O(n)。哈希表同理。栈空间最多n？</p></blockquote><h2 id="JZ86-在二叉树找到两个节点的最近公共祖先"><a href="#JZ86-在二叉树找到两个节点的最近公共祖先" class="headerlink" title="JZ86 在二叉树找到两个节点的最近公共祖先"></a>JZ86 在二叉树找到两个节点的最近公共祖先</h2><p>之前做过，印象最深的就是路径法，迅速写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; path1, path2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; target, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> left = <span class="built_in">FindPath</span>(root-&gt;left, target, path);</span><br><span class="line">    <span class="keyword">bool</span> right = <span class="built_in">FindPath</span>(root-&gt;right, target, path);</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FindPath</span>(root, o1, path1);</span><br><span class="line">    <span class="built_in">FindPath</span>(root, o2, path2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = path1.<span class="built_in">size</span>() &gt; path2.<span class="built_in">size</span>() ? path1.<span class="built_in">size</span>() : path2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">            res = path1[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O*(<em>n</em>)，其中n*为二叉树节点数，递归遍历二叉树每一个节点求路径，后续又遍历路径</li><li>空间复杂度：O*(<em>n</em>)，最坏情况二叉树化为链表，深度为<em>n</em>，递归栈深度和路径数组为n*</li></ul></blockquote><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230412090059518.png" alt="image-20230412090059518"></p><p>数据很多的时候不知道哪里出了问题……照着题解试改了一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int len = path1.size() &gt; path2.size() ? path1.size() : path2.size();</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path1.<span class="built_in">size</span>() &amp;&amp; i &lt; path2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">        res = path1[i];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就成功了！呃，为什么呢？为啥感觉是一样的意思？</p><p>根据逻辑判断。要满足条件，首先某个节点必须为符合条件的左右孩子的父节点；或者其中一个节点作为父节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; o1, <span class="keyword">int</span>&amp; o2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> left = <span class="built_in">dfs</span>(root-&gt;left, o1, o2);</span><br><span class="line">    <span class="keyword">bool</span> right = <span class="built_in">dfs</span>(root-&gt;right, o1, o2);</span><br><span class="line">    <span class="comment">// 找到某个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == o1 || root-&gt;val == o2) &#123;</span><br><span class="line">        <span class="comment">// 看看子树有没有另外一个节点，有就是结果</span></span><br><span class="line">        <span class="keyword">if</span> (left || right)&#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子树都没有，自己也不是，那么必然不是</span></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 刚好左右子树都有</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 似乎没啥意义……</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root, o1, o2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>空间复杂度On，最坏情况二叉树化为链表，递归栈深度为�<em>n</em></p></blockquote><p>【题解】</p><ul><li>step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。</li><li>step 2：如果都不匹配，则分别递归左、右子树。</li><li>step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.</li><li>step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。</li><li>step 5：继续递归左、右子树，直到遇到step1或者step3的情况。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该子树没找到，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//该节点是其中某一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == o1 || root-&gt;val == o2) </span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="comment">//左子树寻找公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, o1, o2); </span><br><span class="line">    <span class="comment">//右子树寻找公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, o1, o2); </span><br><span class="line">    <span class="comment">//左子树为没找到，则在右子树中</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="comment">//右子树没找到，则在左子树中</span></span><br><span class="line">    <span class="keyword">if</span>(right == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">//否则是当前节点</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;val; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110.删点成林"></a>1110.删点成林</h2><p>把要删的存进哈希表里面，然后该节点被删除的时候，如果有左子树，该左子树就成为新的树；如果有右子树则同理。但是我处理的时候用了delete，感觉不太行，删除该节点的指针后，就好像变成了无意义的内存空间，让上一级指向一个不明所以的内存，似乎很不妙。那就想，指向空行不行？怎么告诉父节点该子节点变为空了呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midOrderTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(root-&gt;val) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> root;    <span class="comment">// 指向空还是delete掉？</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">midOrderTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">midOrderTree</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">midOrderTree</span>(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果被删除，则返回nullptr，作为父节点的子节点，而左右子树则作为根节点；不被删除，返回自己，继续作为父节点的子节点……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">midOrderTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把左右节点都处理好</span></span><br><span class="line">        root-&gt;left = <span class="built_in">midOrderTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">midOrderTree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该节点不用删除，返回自己</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(root-&gt;val) == map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 该节点要删除，返回空。但存在的子树将作为新的根</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">midOrderTree</span>(root))</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-051-节点之和最大的路径"><a href="#OfferⅡ-051-节点之和最大的路径" class="headerlink" title="OfferⅡ 051.节点之和最大的路径"></a>OfferⅡ 051.节点之和最大的路径</h2><blockquote><p>路径 被定义为一条<strong>从树中任意节点出发</strong>，沿<strong>父节点-子节点</strong>连接，<strong>达到任意节点</strong>的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。</p></blockquote><p>刚开始只能想到按照路径逐个遍历节点 来计算路径值。然后就卡在当前节点-父节点-子节点这个遍历顺序上。即使是左右根遍历顺序，当前节点也不知道哪一个节点才是父节点……所以从传统的树遍历顺序来说，很难实现。</p><p>【题解】其实有点不够理解题意，如果父节点也可以是自身节点……？也就是从自己出发直接往下走…… 或者从自己出发沿着父节点再往子节点……这样一来每个节点可能是路径中的一个节点 或者路径的开头 或者自己单成一个路径也行……</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230607123600961.png" alt="image-20230607123600961"></p><p>假设20是当前节点，要走成一条最大和的路径，首先保证加入的节点是最大和，但是不遍历到叶子节点是不知道最大和子路径是多少。所以要递归到叶子节点，再一步步往上累加，每个节点的“最大贡献值” = 左子树最大贡献值 + 右子树最大贡献值 + 当前value。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230607124010161.png" alt="image-20230607124010161"></p><blockquote><p>神乎其神又匪夷所思……解题思路是尽量利用树的结构特点：递归+回溯吗？利用每个节点和子树的关系……？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 【只有在最大贡献值大于 0 时，才会选取对应子节点】</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node-&gt;val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + <span class="built_in">max</span>(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxGain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>时间空间复杂度都是O(n)</p></blockquote><h2 id="OfferⅡ-503-二叉搜索树的中序后继"><a href="#OfferⅡ-503-二叉搜索树的中序后继" class="headerlink" title="OfferⅡ 503.二叉搜索树的中序后继"></a>OfferⅡ 503.二叉搜索树的中序后继</h2><p>原做法是按照中序遍历，记录前一个节点，然后比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">inorderSuccessor</span>(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;val == p-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        TreeNode* right = <span class="built_in">inorderSuccessor</span>(root-&gt;right, p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>细节：虽然题目要求返回节点，但即使节点包含指向其它节点的指针，也无所谓，也就是直接返回原节点就行；</p><p>而且递归的话由于是要往上返回值的，所以找到的话就立马结束递归往上传递值……这样的话还不如迭代。</p></blockquote><p>【题解】利用二叉搜索树的性质。已知p节点，p的中序后继节点要么是右子树的最左节点，（如果没有右子树）要么是祖先节点。前一种情况可以直接求，第二种情况要从root重新往下找起。</p><p>此时如果p的值比cur大，说明p在cur的右子树，往右找；反之往左找。往左找的时候（也就是p比cur小）才更新node，那么一定能记录到p的中序后继。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode *successor = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            successor = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (successor-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                successor = successor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val &gt; p-&gt;val) &#123;</span><br><span class="line">                successor = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-057-值和下标之差都在给定的范围内"><a href="#OfferⅡ-057-值和下标之差都在给定的范围内" class="headerlink" title="OfferⅡ 057 值和下标之差都在给定的范围内"></a>OfferⅡ 057 值和下标之差都在给定的范围内</h2><p>除了暴力实在想不到别的了，因为两两数字组合没什么规律，除非给它排序之类。要是把全部元素排序的话，还得额外开一个数组一边排序一边记录原索引。</p><p>想的是限定k范围（也就是索引范围）然后逐个遍历，判断元素差的绝对值是否符合要求。</p><p>【题解】方法的改进之处是，</p><p>①利用滑动窗口，只在当前元素x前面的[x-k, x-1]范围内判断。（后面的元素肯定也能遍历到前面的元素）</p><p>②对于窗口内的元素，采用有序的排列数据结构set，因为逐个遍历的话就没有改进，用二分查找就快些；窗口内要找到[x-t, x+t]内的元素，所以先找到第一个≥x-t的元素，再判断是否≤x+t 即可。若没有符合的，就继续往下滑动窗口。</p><p>如果窗口内有重复的数字，由于在窗口内已经符合k的条件，那么绝对值为最小值0肯定符合要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = rec.<span class="built_in">lower_bound</span>(<span class="built_in">max</span>(nums[i], INT_MIN + t) - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != rec.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= <span class="built_in">min</span>(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                rec.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="JZ41-数据流中的中位数"><a href="#JZ41-数据流中的中位数" class="headerlink" title="JZ41 数据流中的中位数"></a>JZ41 数据流中的中位数</h2><p>很明确用直接排序来找到中间的数，根据数组奇数或偶数长度来决定。时间复杂度根据内置sort函数，每插入一个数字都进行排序。</p><ul><li>如何根据排序目标和数组特点，结合各种排序方法的特点，来进行多个维度的思考呢？</li></ul><p>快排：有点分治的思想，不稳定排序，确保选中的数左右两边各大于小于那个数；</p><p>堆：注重最大值最小值，而中位数的左边和右边各是小顶堆和大顶堆……</p><h2 id="JZ45-把数组排成最小的数"><a href="#JZ45-把数组排成最小的数" class="headerlink" title="JZ45 把数组排成最小的数"></a>JZ45 把数组排成最小的数</h2><p>重点是排序规则。字符串比较大小……</p><h2 id="JZ51-数组中的逆序对【分治】"><a href="#JZ51-数组中的逆序对【分治】" class="headerlink" title="JZ51 数组中的逆序对【分治】"></a>JZ51 数组中的逆序对【分治】</h2><p>刚开始想的是排序求位移差……忽略了补在数字前面的也可能利用了本来比它大的空缺，比如7312，排序1237，3往后只移动一位，因为本来7在3前面占了一个空位。</p><p>接着想，一个数要知道它的所有逆序对，首先可以暴力遍历。进一步优化来想，每遍历一个可以来利用的信息是大概知道这个数的位置（<u>7</u>314=&gt;<u>3</u>14<u>7</u>=&gt;14<u>3</u>7一种趋于有序的情况）。但是即使趋于有序（非完全有序），比如4还是不能很好利用有序情况，还是要逐一遍历。那么怎么做到完全有序呢？思考分治。【待思考……】</p><p>如果两个区间为[4, 3] 和[1, 2]，那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2]的结果是一样的，也就是说区间有序和无序结果是一样的。<br>但是如果区间有序会有什么好处吗？当然，如果区间有序，比如[3,4] 和 [1,2]，如果3 &gt; 1, 显然3后面的所有数都是大于1， 这里为 4 &gt; 1, 明白其中的奥秘了吧。所以我们可以在合并的时候利用这个规则。</p><p><img src="https://uploadfiles.nowcoder.com/images/20211207/78416044_1638883228849/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt"></p><h2 id="2517-【二分查找】礼盒的最大甜蜜度"><a href="#2517-【二分查找】礼盒的最大甜蜜度" class="headerlink" title="2517.【二分查找】礼盒的最大甜蜜度"></a>2517.【二分查找】礼盒的最大甜蜜度</h2><p>刚开始只能想到穷举法。k种组合，然后是两两绝对值差……感觉穷举复杂度直线飙升。但是除了穷举法，这个也没啥规律可言，咋办呢？</p><p>【题解】二分查找+贪心。思路有点和常规穷举相反，先确定好大概的甜度值，再看看有没有k种组合的可能。</p><p>先把price排序，然后最大甜度值就是左右两边的差值，（逐渐缩小甜度值的范围×错误，二分查找应该遵循从中值开始左右波动），只要【找到第一个符合条件的甜度值】，就是目标甜度值了。前提是题目只要求甜度值，不用列举情况……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumTastiness</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = price.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> left = price[<span class="number">0</span>], right = price[len - <span class="number">1</span>] - price[<span class="number">0</span>]; <span class="comment">// 这里的left right的含义是甜蜜度（价格差）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;  <span class="comment">// +1?</span></span><br><span class="line">            <span class="comment">// 当前预估甜蜜度 是否有k种组合满足</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(price, k, mid))</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="keyword">int</span> k, <span class="keyword">int</span> tastiness)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = INT_MIN &gt;&gt; <span class="number">1</span>;    <span class="comment">// 为确保数组第一个元素作为prev，整一个很小的值也不至于溢出</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : price)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p - prev &gt;= tastiness)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                prev = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O(nlogn + nlogC)，前者是数组price的排序时间，后者是二分查找次数，每次查找的时间是n。</li><li>空间复杂度：O(logn)，排序的空间复杂度。</li></ul></blockquote><p>总之又是很奇妙的一题，当有多种可能性的时候，可以选可能性最小的某个切入点，然后二分查找遍历？</p><h2 id="【堆】OfferⅡ061-和最小的k个数对"><a href="#【堆】OfferⅡ061-和最小的k个数对" class="headerlink" title="【堆】OfferⅡ061.和最小的k个数对"></a>【堆】OfferⅡ061.和最小的k个数对</h2><p>有意识到k个最小和组合，必定是两个有序数组的最前面部分的组合，但是不知道怎么枚举比较快。</p><p>以下解法有图示更加清晰容易理解。</p><p><a href="https://leetcode.cn/problems/qn8gGX/solution/by-licold-ytad/">【时光】图解+详细推导，小顶堆 - 和最小的 k 个数对 - 力扣（LeetCode）</a></p><ul><li>题解：重构解空间+哈希表</li></ul><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230709224955451.png" alt="image-20230709224955451"></p><blockquote><p>罗列了 按升序排序后的两个数组，各自的索引对应的元素相加之和的必然关系。比如[1,1]的和必然大于[0,1]或[1,0]的和。</p><p>所以需要从左往后遍历枚举的可能，直到满足k个为止。</p><p>不过不是按照一层层遍历，而是取当前最小和的[i,j]，将[i+1,j]或[i,j+1]插入优先队列，继续排序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pair 的比较函数</span></span><br><span class="line">    <span class="keyword">auto</span> greaterthan = </span><br><span class="line">        [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)-&gt;<span class="keyword">bool</span></span><br><span class="line">        &#123; <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second]; &#125;;</span><br><span class="line">    <span class="comment">// pair 的hash函数</span></span><br><span class="line">    <span class="keyword">auto</span> hash = [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a)-&gt;<span class="keyword">size_t</span> &#123; <span class="keyword">return</span> a.first*<span class="number">31</span> + a.second; &#125;;</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(greaterthan)&gt; <span class="built_in">que</span>(greaterthan);</span><br><span class="line">    <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// set 防止重复放入节点</span></span><br><span class="line">    unordered_set&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(hash)&gt; <span class="built_in">st</span>(<span class="number">8</span>, hash);</span><br><span class="line">    que.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    st.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (k -- &amp;&amp; !que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [i, j] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 最小和放入结果中，并移出优先队列</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(initializer_list&lt;<span class="keyword">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">        <span class="comment">// 1. 放入后继节点[i,j+1]</span></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">count</span>(&#123;i, j+<span class="number">1</span>&#125;) &amp;&amp; j+<span class="number">1</span>&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">            st.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 放入后继节点[i+1,j]</span></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">count</span>(&#123;i+<span class="number">1</span>, j&#125;) &amp;&amp; i+<span class="number">1</span>&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(i+<span class="number">1</span>, j);</span><br><span class="line">            st.<span class="built_in">emplace</span>(i+<span class="number">1</span>, j);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先理解基本的，优化方法再看链接。</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="JZ46-把数字翻译成字符串"><a href="#JZ46-把数字翻译成字符串" class="headerlink" title="JZ46 把数字翻译成字符串"></a>JZ46 把数字翻译成字符串</h2><p>首先思考子问题的对象是谁，然后子问题之间的相互关系是什么。</p><p>每增加一个字符，要么算它自己一个(如2=&gt;b)，要么和前面一位组成一个（如26=&gt;z)。</p><p>这个和爬楼梯就挺像的，</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230401145219925.png" alt="image-20230401145219925"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(string nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] codesNum=<span class="keyword">new</span> <span class="keyword">int</span>[nums.Length]; <span class="comment">//状态数组，记录f(x)</span></span><br><span class="line">        <span class="comment">//初始条件：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>].ToString() != <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">            codesNum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数组第2位枚举到最后一位：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.Length;++i)&#123;</span><br><span class="line">            <span class="comment">//判断nums[i]是否不为0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i].ToString() != <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">                codesNum[i]+=codesNum[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断nums[i-1]与nums[i]的数字组合是否在[10,26]内</span></span><br><span class="line">            <span class="keyword">int</span> temp=<span class="keyword">int</span>.Parse(nums[i-<span class="number">1</span>].ToString() + nums[i].ToString());</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>)&#123; <span class="comment">//即f(2)，因为不存在f(0)，所以需要特殊处理：</span></span><br><span class="line">                    codesNum[i]+=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    codesNum[i]+=codesNum[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> codesNum[nums.Length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ47-礼物的最大价值"><a href="#JZ47-礼物的最大价值" class="headerlink" title="JZ47 礼物的最大价值"></a>JZ47 礼物的最大价值</h2><p>最开始想的是回溯算法。遍历所有可能的结果然后记录最大值……结果超时了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_max, j_max, res, max;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 条件判断</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span> || i &gt;= i_max) || (j &lt; <span class="number">0</span> || j &gt;= j_max)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前值</span></span><br><span class="line">    res += grid[i][j];</span><br><span class="line">    flag[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个计算 或 递归</span></span><br><span class="line">    <span class="keyword">if</span> (i == i_max<span class="number">-1</span> &amp;&amp; j == j_max<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; max) &#123;</span><br><span class="line">            max = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, j+<span class="number">1</span>, grid, flag);</span><br><span class="line">        <span class="built_in">dfs</span>(i+<span class="number">1</span>, j, grid, flag);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    res -= grid[i][j];</span><br><span class="line">    flag[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i_max = grid.<span class="built_in">size</span>();</span><br><span class="line">    j_max = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    res = <span class="number">0</span>; max = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">flag</span>(i_max, vector&lt;<span class="keyword">bool</span>&gt;(j_max, <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, grid, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到提示说可以用动态规划。为什么能用动态规划呢？又要怎么思考公式呢？？</p><p>回溯是每个元素都要往右往下进行”试探“，都可能进行n次（？遍历？n的n次方？</p><p>由于只能往下或往右走，所以就某个当前元素来说，要到达这个元素，只能从左边来或者从上面来。那么两个方向来的谁最大谁的值就保留相加，存储在当前位置。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230401212846966.png" alt="image-20230401212846966"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i_max = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> j_max = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(i_max, vector&lt;<span class="keyword">int</span>&gt;(j_max, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; i_max; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; j_max; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个遍历元素，存储最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; i_max; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; j_max; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i_max<span class="number">-1</span>][j_max<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优化的空间是，可以把结果直接存储在grid里面，元素遍历过就没用了。呜呜是为数不多想得明白的动态规划。</p></blockquote><h2 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043.分隔数组以得到最大和"></a>1043.分隔数组以得到最大和</h2><p>开始还是靠正常推敲，想到要尽可能将大数旁边的小数同化，大数不连累更大的数等等，得到基础的思路如下：</p><ul><li>排序依次遍历较大数</li><li>找到那个数对应的范围</li><li>更改数值，记录遍历过的数字，重复第二步</li></ul><p>难在第二步找范围。以那个数为中心，可能有1~k个数，而且起始点和终点也不好确定。总之是要遍历好多遍的样子……想想就不想写。</p><p>【题解】动态规划。还是难以突破思维的惯性，总是习惯找最大数，然后往它左右边找。 </p><p>【dp[i]的含义：以i为结尾的所有可能性之中的，整个数组的最大值】</p><p>假设已有数组A，每增添一个i，增加的可能性是什么呢？</p><p>对于i来说，由于它是数组的结尾，所以包含它的子数组要往前找。它可能自己成为一个数组；或者i、A[i-1]成为一个子数组；或者i、A[i-1]、A[i-2]；直到i 、……A[i-k]。</p><p>成为同一个数组的元素，要全部换成最大元素。那么由上可得，数组的总和的可能性有：</p><ul><li>i+A的总和；</li><li>max(i, A[i-1]) * 2 + A[i-2]…的总和；</li><li>max(i, A[i-1], A[i-2]) * 3 + A[i-3]…的总和等等，以此类推。</li></ul><p>所以i和前面的哪些元素一组，就自成一个独立的子数组，再前面的也是独立的子数组……</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230419223227216.png" alt="image-20230419223227216"></p><blockquote><p>遍历了1，15，7，9后易得每一个最大值都是和15一组。遍历到2的时候，2组队情况有多种，2和9组队时，前面就是以7为结尾的子数组，以7为结尾的子数组中最大值是1，15，7。</p></blockquote><p>总结：在[i-k, i]范围中，计算多种可能的结果，然后取最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历到的当前元素</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和元素组队的范围逐渐扩大，并计算每一种可能的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; j &gt;= i - k; j--) &#123;</span><br><span class="line">            <span class="comment">// d[i]是单独组队，右边是和其它元素组队</span></span><br><span class="line">            d[i] = <span class="built_in">max</span>(d[i], d[j] + maxValue * (i - j));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 范围扩大，更新范围内最大值</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue, arr[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><a href="https://leetcode.cn/problems/MPnaiL/solution/by-flix-0h27/">『 一招吃遍七道 』滑动窗口的应用 - 字符串中的变位词 - 力扣（LeetCode）</a></p><h2 id="JZ48-最长不含重复字符的子字符串"><a href="#JZ48-最长不含重复字符的子字符串" class="headerlink" title="JZ48 最长不含重复字符的子字符串"></a>JZ48 最长不含重复字符的子字符串</h2><p> 逐个遍历，如果在哈希表里面没有记录，那么就继续遍历记录加一，否则清空记录，从被重复的后一位继续开始。（单指针：只需要维护一个指针；原来的想法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 没有重复</span></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(s[i]) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s[i]] = i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始重复</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        i = hash[s[i]];</span><br><span class="line">        hash.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化的空间：从上图可见，第二次遇到a的时候又从b开始，灰色的部分又重复遍历了一次。为了避免重复遍历，这里可用滑动窗口；保留记录过的部分。</p><p>如下图所示，第二次遇到a的时候，窗口左边边界向右滑动一个，确保窗口内没有重复值后，右边界继续滑动……（双指针：维护两个指针，右指针肯定向右，左指针根据右指针是否遍历重复值来进行递增）</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402105626689.png" alt="image-20230402105626689"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.<span class="built_in">length</span>(); right++) &#123;</span><br><span class="line">        hash[s[right]]++;</span><br><span class="line">        <span class="comment">// 有重复，去掉左边的记录，左边界右移</span></span><br><span class="line">        <span class="keyword">while</span> (hash[s[right]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ74-和为S的连续序列"><a href="#JZ74-和为S的连续序列" class="headerlink" title="JZ74 和为S的连续序列"></a>JZ74 和为S的连续序列</h2><p>想到滑动窗口。处理左/右指针（加/减）-判断-移动指针 步骤要区分清楚。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>; r &lt;= sum;) &#123;</span><br><span class="line">    total += r;</span><br><span class="line">    <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &lt; sum) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>()+l);</span><br><span class="line">        total -= l;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; r &lt;= sum;) &#123;</span><br><span class="line">    <span class="comment">// 右指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (total &lt;= sum) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        total += r;</span><br><span class="line">        <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左指针移动</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>()+l);</span><br><span class="line">        total -= l;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; r &lt;= sum;) &#123;</span><br><span class="line">    <span class="comment">// 计算当前情况，再进行下一步操作</span></span><br><span class="line">    total += curr;</span><br><span class="line">    <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        curr = ++r;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &lt; sum) &#123;</span><br><span class="line">        curr = ++r;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        <span class="comment">// 删除左值</span></span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">        curr = -(l++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ014-字符串中的变位词【固定滑动窗口】"><a href="#OfferⅡ014-字符串中的变位词【固定滑动窗口】" class="headerlink" title="OfferⅡ014.字符串中的变位词【固定滑动窗口】"></a>OfferⅡ014.字符串中的变位词【固定滑动窗口】</h2><blockquote><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p></blockquote><p>刚开始有点懵，排列是什么？想到多种可能性又脑袋疼了。从所需结果来看，只需要判断是否包含。那么换个思路，就是长度为n1的子串，有与s1相同多的字母就符合条件了。</p><ul><li>s2的子串必须是连续的且长度为n1。</li><li>出现的字母数量和s1相同。</li></ul><p>【遍历法-滑动窗口】之前觉得滑动窗口是根据目标值伸缩边界，这里是固定长度，所以没有左缩右扩的条件。遍历时更新记录字母出现次数的数组，然后比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.<span class="built_in">length</span>(), len2 = s2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt1[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnt2[s2[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt1 == cnt2) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 原来是有==重载的…</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len1; i &lt; len2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt2[s2[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnt2[s2[i-len1]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == cnt2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【滑动窗口优化】注意到每次窗口滑动时，只统计了一进一出两个字符，却比较了整个 <em>cnt1</em> 和 <em>cnt2</em> 数组。</p><p>然后想到差值，数组1和数组2是否相等，换句话来说就是数组1和数组2每个元素的差是否为0.那先计算数组2-数组1的差值用cnt记录，如果cnt[i]为正数，说明数组2多了，否则差了，每遍历一次都要检查是否全为0（而且26个字母也有s1不存在的字母，无法比较）。这样的话也只是比方法一少遍历了一次数组。如果用一个变量记录字母数量不同的个数呢？</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230504161211284.png" alt="image-20230504161211284"></p><p>仔细想明白觉得滑动窗口真的很奥妙，要灵活运用还得多体悟思考。此题中窗口大小固定，因为要比较的s1长度固定，需要求s2子串的字母个数和s1分别相等。第一次把两个数组都一起遍历一次，得知s2和s1还差多少字母个数不同的。然后利用滑动窗口，一进一出遍历，减少重复遍历，比如一进，如果进了之后反而增加了差值，那么diff++；反之进了之后减少差值恰好为0，那么diff–。一出同理。</p><p>可能考虑到s2有s1不存在的字母怎么办，也会算进diff里面。这就是连续窗口的奥妙了，如果要确保连续子串，那么存在的话必有diff=0的情况。由于窗口会“吞吐”，即使吃到不存在的字母diff++, 在找到合适之前会一直往前滚动遍历，直到吐出不存在的字母diff–。</p><h2 id="OfferⅡ017-含有所有字符的最短字符串【变长滑动窗口】"><a href="#OfferⅡ017-含有所有字符的最短字符串【变长滑动窗口】" class="headerlink" title="OfferⅡ017.含有所有字符的最短字符串【变长滑动窗口】"></a>OfferⅡ017.含有所有字符的最短字符串【变长滑动窗口】</h2><p>这次t对于s来说不是连续，而是“含有”，求最短长度。那必然是滑动窗口了，首先返回的结果子串是连续的，其次有明确的边界要求（含有t的所有字母及个数）。先右扩找到符合条件的，再左缩缩小范围看有没有更短的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p: ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右扩：找到含t的所有字母个数为止 需要知道含什么字母，以及对应个数</span></span><br><span class="line">    <span class="comment">// 左缩：原基础再缩小看看能否再短</span></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录t的字母及对应个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = INT_MAX, ansL = <span class="number">-1</span>, ansR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; <span class="built_in"><span class="keyword">int</span></span>(s.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="comment">// 记录有效（t含有的）字母[!!]</span></span><br><span class="line">            <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[++r]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++cnt[s[r]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否已经符合t 符合t则判断长度、回缩</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">check</span>() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[l]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ansL == <span class="number">-1</span> ? <span class="built_in">string</span>() : s.<span class="built_in">substr</span>(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="基础数学"><a href="#基础数学" class="headerlink" title="基础数学"></a>基础数学</h1><h2 id="JZ65-不用加减乘除做加法【位运算】"><a href="#JZ65-不用加减乘除做加法【位运算】" class="headerlink" title="JZ65 不用加减乘除做加法【位运算】"></a>JZ65 不用加减乘除做加法【位运算】</h2><p>a+b，结果由进位和非进位相加而成，前提是二进制。因为二进制运算可以方便直接获得进制位，只有1和1才有进位，也就是1&amp;1=1，其余都没有进位，即为0。如果是十进制的话，求进位还要减去10……感觉是做复杂了。关于二进制的运算特点和应用还有待深究。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add = num2;</span><br><span class="line">    <span class="keyword">int</span> sum = num1;</span><br><span class="line">    <span class="comment">// 每一轮只计算 a 和 b 的进位和非进位！不要弄混了</span></span><br><span class="line">    <span class="comment">// 【反例】sum = sum ^ add; add = (sum &amp; add) &lt;&lt; 1; 后者sum改变了，逻辑容易混乱</span></span><br><span class="line">    <span class="keyword">while</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非进位</span></span><br><span class="line">        <span class="keyword">int</span> temp = sum ^ add;</span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">        add = (sum &amp; add) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新新的和</span></span><br><span class="line">        sum = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指offerⅡ-001-整数除法【快速乘】"><a href="#剑指offerⅡ-001-整数除法【快速乘】" class="headerlink" title="剑指offerⅡ 001.整数除法【快速乘】"></a>剑指offerⅡ 001.整数除法【快速乘】</h2><p>思来想去，还是想到最朴素的 被除数暴力相加，为了方便相加，把ab做同号处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ab同号，b不变；ab异号，b变号</span></span><br><span class="line">    <span class="keyword">if</span> ((a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) || (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">        flag = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(sum) &lt;= <span class="built_in">abs</span>(a))</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        sum += b;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) || sum &gt;= <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> count * flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>被除数越小，除数越大，时间也越多，改了一些细节后，还是超时了……</p></blockquote><p>【题解】</p><p>题目要求只能使用加减法，那我们自然想到用减法实现除法，用“被减数”能减去几次“减数”来衡量最后的结果，这时候我们想到求x的幂次的快速解法，将x成倍成倍的求幂，这里【将减数成倍成倍的增大，次数对应也是成倍成倍的增大】，例如：取a=23，b=2，b的变化如下:2-&gt;4-&gt;8-&gt;16,次数count的变化如下1-&gt;2-&gt;4-&gt;8,最后a-b=23-16=7，对7再执行一次上述过程，b:2-&gt;4,count:1-&gt;2,a-b=3, 然后对3再执行一次，b:2,count:1,a-b=1，1已经小于原b=2，可以结束了，最后计数一下每轮的count是多少8+2+1=11，就是我们要的答案啦！</p><blockquote><p>也想过成倍求，但是一想到可能超过很多，就没再继续考虑了……要在范围内进行快速倍求。</p></blockquote><ul><li>为方便运算，我们需要将a，b都转为同正or同负，由于INT_MIN<code>[−2的31次方, 2的31次方−1]</code>转正就越界了，我们只好都转负，这也是都转负的原因；</li><li>有一种特殊情况 INT_MIN/(-1)就overflow了 所以直接特殊处理</li><li>最终结果的正负</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用减法实现除法 均已保证传入的a，b是负数  </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(a&lt;=b)&#123;<span class="comment">//a的绝对值大</span></span><br><span class="line">           <span class="keyword">int</span> temp=b;</span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> count=<span class="number">1</span>;<span class="comment">//a的绝对值大于b的 那么肯定a能减一次b</span></span><br><span class="line">           <span class="keyword">while</span>(temp&gt;=<span class="number">0xc0000000</span>&amp;&amp;a&lt;=temp+temp)&#123;<span class="comment">//减数不越界方便控制后一个条件：且a的绝对值比两倍的减数还大</span></span><br><span class="line">           count+=count;<span class="comment">//可以减的次数翻倍</span></span><br><span class="line">           temp+=temp;<span class="comment">//减数也翻倍</span></span><br><span class="line">           &#125;</span><br><span class="line">           res+=count;</span><br><span class="line">           a-=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> positive=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positive=!positive;</span><br><span class="line">            a = -a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positive=!positive;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> res = <span class="built_in">div</span>(a, b);</span><br><span class="line">        <span class="keyword">return</span> positive? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>越界这个实在是太恶心人了……a,b都有可能达到边界，或者两者的结果。count是必须要unsigned的，因为有可能达到2的31次方……</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = -a;</span><br><span class="line">        positive = !positive;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">        positive = !positive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 快速求倍数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// a,b都是负数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(a) &gt;= <span class="built_in">abs</span>(b)) <span class="comment">// 或者a &lt;= b</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//a的绝对值大于b的 那么肯定a能减一次b</span></span><br><span class="line">        <span class="keyword">int</span> bs = b; </span><br><span class="line">        <span class="keyword">while</span> (bs &gt;= -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) &amp;&amp; <span class="number">2</span> * bs &gt;= a)</span><br><span class="line">        &#123;</span><br><span class="line">            bs *= <span class="number">2</span>;    <span class="comment">// b的倍数翻倍</span></span><br><span class="line">            count *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a -= bs;</span><br><span class="line">        res += count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a,b异号，结果为负</span></span><br><span class="line">    <span class="keyword">return</span> positive ? res : -res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自己模仿写了一下，为什么老是没过**-2147483648/1**啊呜呜呜。找到了，是<code>while (abs(a) &gt;= abs(b))</code>这个判断出了问题。原来是因为-2147483648一取绝对值又改成正数了，就溢出了……</p></blockquote><p>【题解2】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (b == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> a == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = -a;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = -b;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="comment">// x：被除数</span></span><br><span class="line">        <span class="comment">// y：除数</span></span><br><span class="line">        <span class="comment">// z：x/y</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">bool</span> check = <span class="built_in">quickAdd</span>(b, mid, a);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这个感觉好难懂……</p></blockquote><h2 id="JZ64-求1-2-3-…-n【短路运算】"><a href="#JZ64-求1-2-3-…-n【短路运算】" class="headerlink" title="JZ64 求1+2+3+…+n【短路运算】"></a>JZ64 求1+2+3+…+n【短路运算】</h2><p>要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。想到的是递归，<code>n += Sum_Solution(n-1);</code>每次都和<code>1~n-1的和</code>相加。但是递归条件也要判断，那该怎么办呢？或者是有限次计算就能算出？不懂。</p><p>【题解】利用短路运算结束递归。<a href="https://blog.csdn.net/bulebin/article/details/79345875">(49条消息) &amp;&amp; || 与或 逻辑运算符的短路运算_&amp;&amp;的运算规则_bulebin的博客-CSDN博客</a></p><p>短路运算：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值。</p><ul><li>表达式1 <strong>&amp;&amp;</strong> 表达式2 &amp;&amp; 表达式3…<br>①如果表达式1的值为真，则继续往后执行<br>②如果表达式1的值为假，则返回表达式1</li><li>表达式1 <strong>||</strong> 表达式2 || 表达式3…<br>①如果表达式1的值为真，则返回表达式1<br>②如果表达式1的值为假，则继续往后执行</li></ul><p>所以如果n==0的时候（也就是为false），刚好返回0。果然很妙啊~~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前者返回一个确定值（为false的时候，即为0）</span></span><br><span class="line">    <span class="comment">// 后者继续递归</span></span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">Sum_Solution</span>(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ49-丑数"><a href="#JZ49-丑数" class="headerlink" title="JZ49 丑数"></a>JZ49 丑数</h2><p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=265&tqId=39247&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=3&judgeStatus=undefined&tags=&title=">丑数_牛客题霸_牛客网 (nowcoder.com)</a></p><p>根据丑数概念可知，</p><ul><li>丑数：只包含2/3/5质数；</li><li>非丑数：不含2/3/5；含2/3/5，但还有其他质数。</li></ul><p>如果求有没有包含2/3/5，那么就要考虑三种情况，变得很复杂。既然题目求的是第n个丑数，而不是判断是不是丑数，就没必要一一遍历，而是直接构建丑数。</p><p>那么哪些是丑数呢，基础的是1/2/3/5，然后由小到大相乘（如果a*b两者都没有其他素数，那么结果肯定也没有其他素数）。那么按照怎么样的顺序相乘呢，可见按照右边这样乘不一定按照从小到大的顺序。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402154507020.png" alt="image-20230402154507020"></p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402154832984.png" alt="image-20230402154832984"></p><p>然后想到既然是每位数字都要乘2/3/5，那么只要取出最小的结果先入数组，就能依次排序了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next2 = <span class="number">0</span>, next3 = <span class="number">0</span>, next5 = <span class="number">0</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中一个指针到达index-1</span></span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() != index) &#123;</span><br><span class="line">        next2 = res[i2] * <span class="number">2</span>;</span><br><span class="line">        next3 = res[i3] * <span class="number">3</span>;</span><br><span class="line">        next5 = res[i5] * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">min</span>(next2, <span class="built_in">min</span>(next3, next5));</span><br><span class="line">        <span class="comment">// 确保不重复</span></span><br><span class="line">        <span class="keyword">if</span> (*(res.<span class="built_in">end</span>()<span class="number">-1</span>) != num) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == next2) &#123;</span><br><span class="line">            i2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == next3) &#123;</span><br><span class="line">            i3++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == next5) &#123;</span><br><span class="line">            i5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[index<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ62-圆圈中最后剩下的数"><a href="#JZ62-圆圈中最后剩下的数" class="headerlink" title="JZ62 圆圈中最后剩下的数"></a>JZ62 圆圈中最后剩下的数</h2><p>开始借用了一个数组来循环遍历。（原来叫模拟法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; array;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        array.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (array.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删去元素的时候，后面的数会前移一位，所以i已经代表了下一个数</span></span><br><span class="line">        <span class="comment">// 而且count也是1个数</span></span><br><span class="line">        <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i = (i+<span class="number">1</span>) % array.<span class="built_in">size</span>();</span><br><span class="line">            count = count+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不借用额外空间的话，那么怎么知道中间删除了哪些？</p><p>【题解】找规律/公式递推。这种方法怎么想到的呢……太抽象太神奇了……</p><p><strong>令f(n,m)表示最后一个人的下标</strong>。</p><p>1.假设有n个人，报数m， 从0 开始报数，易知出圈的人下标为 m-1。</p><p>2.m-1 出圈后，我们对剩余人重新编号 即 第m个人下标为0，第m+1 下标为1 ……以此编号。 那么重新编号之后，那么最后一个人的下标为f(n-1,m)</p><p>问题1： 在重新编号之后的f(n-1,m) 与 重新编号之前的f(n,m)有什么关系？<br>重新编号之前 m, m+1,m+2,….（剩余人的编号）<br>重新编号之后 0 ，1 ，2，….<br>可知 (新编号+m)%n = 旧编号</p><blockquote><p>f(n,m)表示的不是下一个将要删除的人，而是最后一个；可能是因为最后一个人必定是会留下来的，所以只有他的编号是时刻变化着的？</p></blockquote><p>\3. f(n,m) = (f(n-1,m)+m) %n;<br>递归写法复杂度分析：<br>时间复杂度： O(N)<br>空间复杂度： O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//约瑟夫</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">LastRemaining_Solution</span>(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404213229515.png" alt="image-20230404213229515"></p><blockquote><p>绿色是位置，绿三角形是被删除的位置，黑圈是最后的数。</p></blockquote><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404213240076.png" alt="image-20230404213240076"></p><blockquote><p>分析了才知道，一直描述的都是最后那个留下的时刻变动的位置。最后只剩下那个数时，位置必然为0，此时n=1；每删除一个数，假如更新第m个的位置使之为0，那么其它的数字位置也会变化，都遵循相同的变化规律。总之觉得太抽象了！！</p></blockquote><h2 id="JZ70-矩阵覆盖"><a href="#JZ70-矩阵覆盖" class="headerlink" title="JZ70 矩阵覆盖"></a>JZ70 矩阵覆盖</h2><p>刚开始觉得要硬刚……算图形是什么的，然后想得好复杂，放弃。没想到……竟然是数学归纳法……emmm。</p><blockquote><p>由规律发现，2∗<em>n</em>的矩形的情况数为*f(n)=f(n−1)+f(n−2)*，即这就是一个斐波那契数列，按照斐波那契数列的解法来即可，需要注意不同点在于n小于等于2时，都只有n种。</p></blockquote>]]></content>
    
    
    <summary type="html">虽然很笨，但是也想突破自己学得更好</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统（二）：进程管理</title>
    <link href="https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-26T16:00:00.000Z</published>
    <updated>2023-11-26T08:01:19.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前驱图、顺序执行与并发执行的特征"><a href="#前驱图、顺序执行与并发执行的特征" class="headerlink" title="前驱图、顺序执行与并发执行的特征"></a>前驱图、顺序执行与并发执行的特征</h1><p><a href="https://blog.csdn.net/qq_43722079/article/details/108033191">(42条消息) 【OS笔记 5】前驱图、顺序执行与并发执行的特征_os 顺序执行 前驱图_Crayon小鱼干的博客-CSDN博客</a></p><p>顺序执行</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center.jpeg" alt="在这里插入图片描述"></p><p>并发执行</p><p><img src="https://img-blog.csdnimg.cn/20200816124803336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>程序并发执行时的特征</li></ul><p>① 间断性<br>也就是一个程序的整个执行过程是“走走停停”的，由于共享资源，这些并发的程序相互制约，有时需要进行等待，造成了 “执行——暂停——执行” 的间断性活动规律。</p><p>② 失去封闭性<br>由于并发的程序之间共享系统资源，导致其中任一程序在运行时，其环境都必然会收到其它程序的影响，所以就失去了运行环境的封闭性。</p><p>③ 不可再现性<br>程序在并发执行时，由于失去了封闭性，从而也失去了不可再现性。换句话说，程序在多次执行后，虽然它们执行的环境和初始条件是相同的，但得到的结果却各不相同。<br>比如 A 和 B 两个程序共享变量N，A 中会让 N+1 ，B 中会让 N=0 。那么 N 最后的数值肯定跟 A 和 B 执行的情况（比如执行顺序什么的）有关系。</p><p>此时还未引入进程的概念。如果每次执行的结果都不同，岂不是失去了程序的意义，因此，人们引入了“进程”的概念，并且设计了相应的进程同步机制，<u>使得程序在并发同时也能独立地运行</u>。【两个进程同时跑，但又可能得占用同样的资源，就会发生冲突】</p><h1 id="——进程是什么？——"><a href="#——进程是什么？——" class="headerlink" title="——进程是什么？——"></a>——进程是什么？——</h1><h1 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h1><ul><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是 / 具有独立功能的程序 / 在一个数据集合上 / 的运行过程，它是<u>系统进行资源分配和调度的一个独立单位</u>。</li><li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立过程。</li></ul><h1 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h1><p><strong>进程实体 = 程序 + 数据 + PCB</strong></p><p>为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之<u>配置一个专门的数据结构</u>，称为<strong>进程控制块</strong>（Process Control Block，<strong>PCB</strong>）。</p><p><strong>PCB 的作用：</strong> 描述进程的基本情况和活动过程，方便系统控制和管理进程。所谓创建进程，实质上是创建进程实体中的 PCB；而撤销进程，实质上是撤销进程的 PCB。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230328122220686.png" alt="image-20230328122220686"></p><blockquote><p>程序段可被多个进程共享：一个应用开启多个线程时，数据不一样，但是程序相同，所以没必要再开辟新的内存来存放程序。</p></blockquote><h2 id="进程控制块PCB详解"><a href="#进程控制块PCB详解" class="headerlink" title="进程控制块PCB详解"></a>进程控制块PCB详解</h2><p>【PCB是什么】</p><p>PCB是用以记录与进程相关信息的<u>主存区</u>，是进程存在的唯一标志。</p><p><img src="https://img-blog.csdnimg.cn/20200816155207727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>【PCB中的信息】</p><ul><li><p><strong>进程标识符</strong>：唯一地标识一个进程；</p><p>进程本身：外标识、内部标识；？<br>家族信息：父进程、子进程信息；？</p></li><li><p><strong>处理机状态</strong></p><p>处理机状态信息也称为处理机的上下文（Context），主要是由处理机的各种<a href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&spm=1001.2101.3001.7020">寄存器</a>中的内容组成的。<br>也就是中断现场的保留区，当进程被切换时，处理机状态信息必须都保存在相应的PCB中，以便该进程在重新执行时能再从断点继续执行。</p></li><li><p><strong>进程调度信息</strong></p><p>在OS进行调度时，必须了解<u>进程的状态</u>以及<u>有关进程调度的信息</u>。这些信息包括：</p><p>① 进程状态<br>就绪、执行、阻塞等，是进程调度和对换的依据</p><p>② 进程优先级<br>是分配CPU的重要依据</p><p>③ 其它信息<br>比如进程已等待CPU的时间总和、已执行的时间总和等</p><p>④ 事件<br>指的是阻塞原因（即程序由执行状态变为阻塞状态的原因）</p></li><li><p><strong>进程控制信息</strong></p><p>① 程序和数据的首地址<br>调度到该进程的时候，可以找到其程序和数据</p><p>② 进程同步和通信机制<br>如消息队列指针、信号量等，以后的进程同步中会学到</p><p>③ 资源清单<br>列出了该进程在运行期间所需的全部资源（CPU除外），另外还有一张该进程已分配的资源清单</p><p>④ 链接指针<br>给出了该进程（PCB）所在队列中下一个进程的PCB首地址，跟链表一样</p></li></ul><p>【PCB的三种组织方式】</p><ul><li><strong>线性方式</strong></li></ul><p>系统中所有PCB都组织在一张线性表中，表的首地址存放在内存专用区</p><p><strong>优点：</strong> 实现简单、开销小</p><p><strong>缺点：</strong> 每次查找时都要扫描一整张表，因此适合进程数目不多的系统</p><p><img src="https://img-blog.csdnimg.cn/20200816202839640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>链接方式</strong></li></ul><p>具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。</p><p><img src="https://img-blog.csdnimg.cn/20200816203026357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>内存存储方式还是线性的，然后通过类似于链表的链接组成一个逻辑上的队列？</p></blockquote><ul><li><strong>索引方式</strong></li></ul><p>系统根据所有进程状态的不同，建立几张索引表，并把索引表的首地址记录在内存的专用单元中。在每个索引表的表目中，记录具有相应状态的PCB在PCB表中的首地址</p><p>（其实就是改进版的线性方式，分类之后，变成了很多子表，不需要把整个PCB表都扫描一遍，只需要先根据进程状态找到对应的子表，然后再扫描子表就行了）</p><p><img src="https://img-blog.csdnimg.cn/20200816203851862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h1><ul><li>动态性。进程的实质是进程实体的执行过程，“它由创建而产生，由撤销而死亡。” 有一定的生命周期，动态性是进程最基本的特征。</li><li>并发性。引入进程后，只有建立了PCB的程序，也就是进程才能并发执行。并发性是进程的另一重要特征。</li><li>独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。 凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li><li>异步性。指进程是按各自独立的、不可预知的速度向前推进的。（是不是想到了操作系统的基本特征也有异步性？二者是一个意思）所以才要配备相应的进程同步机制，让各进程之间独立地运行，使得<u>程序每次运行的结果都是一样的</u>。</li><li>制约性。进程之间由于对资源的征用而相互制约。</li></ul><p><a href="https://blog.csdn.net/qq_43722079/article/details/104874035">(42条消息) 试比较程序和进程的异同（区别与联系）_试比较进程和程序的区别_Crayon小鱼干的博客-CSDN博客</a></p><h1 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h1><p><a href="https://blog.csdn.net/weixin_49199646/article/details/109210547">(43条消息) 进程、线程及协程的区别_协程与线程的区别_clw_18的博客-CSDN博客</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>进程：一个具有一定独立功能的程序 / 关于某个数据集合上的 / 一次运行活动，是<strong>系统资源分配和独立运行</strong>的最小单位；为了使多个程序并发执行，提高资源利用率和系统效率，OS引入了进程。</li><li>线程：是进程的 / 一个执行单元，是<strong>任务调度和系统执行</strong>的最小单位；为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好，OS引入了线程。</li><li>协程：协程是一种<strong>用户态的轻量级线程</strong>，协程的调度<strong>完全由用户控制</strong>。</li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li><strong>根本区别</strong>：进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li><li><strong>地址空间区别</strong>： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li><strong>上下文切换开销区别：</strong> 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li><li><strong>支持多处理机系统方面</strong>：不管有几个处理机，一个进程只能分配到一个CPU上执行，但同一进程内的多个线程可分配到多个CPU上并行执行。</li><li>为什么要引用线程：提高OS的并发性（如同一个应用程序同时执行多个功能），减少资源的分配；</li></ul><h2 id="进程和线程的联系"><a href="#进程和线程的联系" class="headerlink" title="进程和线程的联系"></a>进程和线程的联系</h2><p>一个进程由<u>共享空间</u>（包括堆、代码区、数据区、进程空间和打开的文件描述符）和<u>一个或多个线程</u>组成，<u>各个线程之间共享进程的内存空间</u>，而<strong>一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成</strong>。</p><blockquote><p>为了实现并发性，线程需要独享某些资源。例如CPU寄存器的值。 当从一个线程切换到另一个线程上时，必须将原有线程的CPU寄存器集合状态保存，以便该线程在被重新切换到运行状态时能得以恢复。</p></blockquote><p>进程和线程之间的联系如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20201021221100545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201021221114554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>多线程的优点：</p><ul><li>响应度高：只需要阻塞部分线程，提高了对用户的响应；</li><li>资源共享：线程默认共享所属进程的内存和资源；</li><li>经济：创建和切换线程的代价更小；</li><li>多处理器体系结构的利用：在多CPU上提高了并行性。</li></ul></blockquote><p>线程的实现方式：</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230329161419124.png" alt="image-20230329161419124"></p><ul><li>用户级线程ULT【User Level Thread】（控制块在用户空间）：多个线程通过一个<strong>进程</strong>来系统调用；对内核不可见有多少个线程；进程内切换，都与内核无关，所以减少切换开销。</li><li>内核级线程KLT【Kernel Level Thread】（控制块在内核空间）：多个处理机处理多个线程-并行。由于控制块在内核，程序在用户空间，所以切换时首先到内核空间进行切换，再切换回用户空间执行程序，线程调度开销较大；</li><li>组合方式：内核的一般比用户少。</li></ul><h2 id="进程与线程的选择"><a href="#进程与线程的选择" class="headerlink" title="进程与线程的选择"></a>进程与线程的选择</h2><p>1、线程的<u>创建或销毁的代价</u>比进程小，需要频繁创建和销毁时应优先选用线程；</p><p>2、线程<u>上下文切换的速度</u>比进程快，需要大量计算时优先选用线程；</p><p>3、线程<u>在CPU上的使用效率</u>更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程；</p><p>4、线程的<u>安全性、稳定性</u>没有进程好，需要更稳定安全时优先使用进程。</p><p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，<u>因此一般情况下优先选择线程进行高并发编程</u>；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此<u>对安全稳定性要求较高时，需要优先选择进程进行高并发编程</u>。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><a href="https://blog.csdn.net/zheng199172/article/details/88800275">(43条消息) 什么是协程_笑是神的伪装的博客-CSDN博客</a></p><p>协程拥有自己的<strong>寄存器上下文和栈</strong>。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态。这个过程<u>完全由程序控制，不需要内核进行调度</u>。<br><img src="https://img-blog.csdnimg.cn/a550c0974c584398a71c29f783d9b4d9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><p>1、根本区别： 协程是用户态的轻量级线程，不受内核调度；线程是任务调度和系统执行的最小单位，需要内核调度。<br>2、运行机制区别： 线程和进程是同步机制，而协程是异步机制。<br>3、上下文切换开销区别： 线程运行状态切换及上下文切换需要内核调度，会消耗系统资源；而协程完全由程序控制，状态切换及上下文切换不需要内核参与。</p><h1 id="——-进程是怎么运行的？——"><a href="#——-进程是怎么运行的？——" class="headerlink" title="——-进程是怎么运行的？——-"></a>——-进程是怎么运行的？——-</h1><h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p>由于多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现<strong>间断性的运行规律</strong>，所以进程在其<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>内可能具有多种状态。</p><h2 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h2><ul><li><strong>就绪状态</strong></li></ul><p>进程已分配到<u>除CPU之外的所有必要资源</u>，只要再获得CPU，便可立即执行。（可运行但未运行）</p><ul><li><strong>执行状态</strong></li></ul><p>进程<u>已获得CPU</u>，正在执行。（多处理机系统中，则有多个进程处于执行状态）</p><ul><li><strong>阻塞状态</strong></li></ul><p>正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）<u>暂时无法继续执行</u>的状态，即进程的执行受到阻塞。</p><p>引起进程阻塞的事件：</p><p>​    ① 向系统请求共享资源失败<br>​    ② 等待某种操作的完成<br>​    ③ 新数据尚未到达<br>​    ④ 等待新任务的到达</p><p>在执行过程中，如果发生了上述事件，进程便通过阻塞原语 block 将自己阻塞。可见，<strong>阻塞是进程自身的一种主动行为</strong>。 </p><h2 id="三种基本状态的转换"><a href="#三种基本状态的转换" class="headerlink" title="三种基本状态的转换"></a>三种基本状态的转换</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330223850527.png" alt="image-20230330223850527"></p><blockquote><p>I/O请求是广义的资源调度吗？</p></blockquote><h2 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h2><ul><li><p><strong>创建状态（New）</strong>：进程正在创建的状态。创建工作尚未完成（即未进入就绪状态），进程不能被调度运行。</p><ul><li><p>引起进程创建的事件：</p><p><u>（由系统内核创建的三种情况）</u></p><p>① 用户登录<br>在分时系统中，用户登录成功后，系统将为该用户建立一个进程。<br>② 作业调度<br>在多道批处理系统中，从后备队列中选择进程调度时，便为它（们）创建进程，并插入就绪队列中。<br>③ 提供服务<br>比如用户程序要求文件进行打印，操作系统将为它创建一个打印进程。</p><p><u>（用户进程自己创建）</u></p><p>④ 应用请求</p></li><li><p>创建的步骤：</p><p>① 申请<u>空白 PCB</u><br>② 为新进程分配其运行<u>所需的资源</u><br>③ <u>初始化</u>进程控制块 PCB<br>④ 将新进程插入就绪队列</p></li><li><p>进程的层次结构</p><p>在OS中，允许一个进程创建另一个进程，也就是父进程创建子进程，由此便形成了一个进程的层次结构。</p></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200818104211935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p>终止状态</p><p>进程正常或异常结束，<u>移出就绪队列</u>，但<u>尚未被撤销</u>时的状态。</p><ul><li><p>引起进程终止的事件</p><p>① 正常结束<br>表示进程的任务已经完成，准备退出运行。<br>② 异常结束<br>指进程在运行时发生了某种异常事件，使程序无法继续运行。比如越界错、保护错、非法指令、运行超时等等。<br>③ 外界干预<br>进程应外界的请求而终止运行。比如操作员或操作系统干预、父进程请求、父进程终止时随着父进程而终止。</p></li><li><p>终止需要经过两个步骤：</p><p>① 等待操作系统进行善后处理（标记？）<br>② 将进程的<u>PCB清零</u>，并将PCB空间返还系统</p></li></ul></li></ul><h2 id="五种状态的转换"><a href="#五种状态的转换" class="headerlink" title="五种状态的转换"></a>五种状态的转换</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330224650329.png" alt="image-20230330224650329"></p><h2 id="引入挂起原语"><a href="#引入挂起原语" class="headerlink" title="引入挂起原语"></a>引入挂起原语</h2><p>在许多系统中，为了<u>系统和用户观察分析进程的需要</u>，还引入了挂起操作。</p><p>程序被挂起，意味着进入静止状态。</p><p>如果程序正处于执行状态，它将暂停执行。</p><p>如果程序正处于就绪状态，它将暂不接受调度。</p><ul><li>引入原因<ul><li>终端用户的需要：用户发现自己的程序有可疑问题，希望暂停时，可以使用挂起使之停止。</li><li>父进程请求：有时父进程希望挂起自己的某个子进程，以便考察和修改。</li><li>负荷调节的需要：实时系统中的工作负荷较重时，可以将一些不重要的进程挂起。</li><li>操作系统的需要：操作系统有时需要挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li></ul></li><li>引入挂起操作后的状态转换图</li></ul><p>在 就绪-执行-阻塞 的状态基础上添加以下状态：</p><p>就绪有两种：活动就绪Readya（Ready + active）/ 静止就绪Readys（Ready + suspend）；一旦被挂起就从活动就绪转换到静止就绪；要被激活成活动就绪才能被执行。</p><p>阻塞也有两种：活动阻塞 Blockeda（Blocked + active）/ 静止阻塞 Blockeds（Blocked + suspend）；一旦被挂起就从活动阻塞转换到静止阻塞；要被激活成活动阻塞才能进入活动就绪。</p><p><img src="https://img-blog.csdnimg.cn/20200817200724452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><p>即OS对进程实现有效的管理，包括创建新进程、撤销已有进程、挂起、阻塞和唤醒、进程切换等多种操作。OS通过<strong>原语（Primitive）</strong>操作实现进程控制。</p><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><ul><li>概念：计算机控制器的机器指令是微操作构成的，原语是机器指令的延伸，是由<u>若干条机器指令构成</u>用以完成特定功能的<u>一段程序</u>。为保证操作的正确性，它们应当是<strong>原子操作</strong>(AtomicOperation)。所谓原子操作是指：一个操作中的所有动作，要么全做，要么全不做。原子操作是一个不可分割的操作。</li><li>特点<ul><li>原子操作，要么全做，要么全不做，执行过程不会被中断；</li><li>在管态、系统态、内核态下执行，常驻内存；</li><li>是内核三大支撑功能之一（中断处理、时钟管理、原语操作）。</li></ul></li></ul><h2 id="创建-终止-阻塞-唤醒"><a href="#创建-终止-阻塞-唤醒" class="headerlink" title="创建/终止/阻塞/唤醒"></a>创建/终止/阻塞/唤醒</h2><ul><li>创建原语：create</li><li>阻塞原语：block</li><li>唤醒原语：wakeup</li><li>撤销原语：destroy </li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330230746574.png" alt="image-20230330230746574"></p><h2 id="挂起和激活"><a href="#挂起和激活" class="headerlink" title="挂起和激活"></a>挂起和激活</h2><p>为了系统和用户观察和分析进程。</p><ul><li>挂起是放在外存，不在内存中。</li><li>创建=&gt;挂起：创建的时候资源还够，执行的时候要挂起？</li><li>活动阻塞=&gt;挂起：可能因为等待时间过久。</li><li>严格来说”挂起“不算状态。</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230402115106696.png" alt="image-20230402115106696"></p><h1 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h1><h2 id="处理机调度和调度层次"><a href="#处理机调度和调度层次" class="headerlink" title="处理机调度和调度层次"></a>处理机调度和调度层次</h2><p>也叫做处理机调度。根据一定的算法和原则 / 将处理机资源 / 进行重新分配的过程。（上面进程的控制中，控制的对象是进程，对其活动进行干涉；而调度则是面对多个进程）</p><ul><li>前提：作业/进程数 远远大于 处理机数。</li><li>目的：提高资源利用率，减少处理机空闲时间。</li><li>调度程序：一方面要满足特定系统用户的需求（快速响应），另一方面要考虑系统整体效率（系统平均周转时间）和调度算法本身的开销。</li></ul><p>【<strong>调度的层次</strong>】</p><p>多道批处理系统：三级调度模型。</p><p>在多道批处理系统中，一个作业从提交到获得CPU执行，直到作业运行完毕，可能需要经历多级处理机调度。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230402121120477.png" alt="image-20230402121120477"></p><ul><li><p>高级调度（作业调度/长期调度）</p><ul><li>把后备<strong>作业</strong><u>调入内存</u>；</li><li>只调入一次，调出一次（进程的创建和销毁）；</li></ul></li><li><p>中级调度（内存调度/中程调度）</p><ul><li>将<u><strong>进程</strong>调至外存</u>，条件合适再调入内存；</li><li>在内、外存对换区进行进程对换。</li></ul></li><li><p>低级调度（进程调度/短程调度）</p><ul><li>从就绪队列选取<strong>进程</strong>分配给处理机；</li><li>最基本的调度，频率非常高（相当于一个时间片完成）；</li></ul></li></ul><h2 id="进程调度方式（策略）"><a href="#进程调度方式（策略）" class="headerlink" title="进程调度方式（策略）"></a>进程调度方式（策略）</h2><ul><li><p>剥夺式 / 抢占式调度</p><ul><li>立即暂停当前进程；</li><li>分配处理机给另一个进程；</li><li>原则：优先权 / 短进程优先 / 时间片原则。</li></ul></li><li><p>非剥夺式 / 非抢占式调度</p><ul><li>若有进程请求执行；</li><li>等待直到当前进程完成或阻塞；</li><li>缺点：适用于批处理系统，不适用分时/实时系统。</li></ul></li></ul><h2 id="调度的时机、切换与过程（执行）"><a href="#调度的时机、切换与过程（执行）" class="headerlink" title="调度的时机、切换与过程（执行）"></a>调度的时机、切换与过程（执行）</h2><ul><li>调度时机<ul><li>进程运行完毕；</li><li>进程时间片用完；</li><li>进程要求I/O操作；</li><li>执行某种原语操作；</li><li>高优先级进程申请运行（剥夺式调度）。</li></ul></li><li>调度过程（调度策略/保存进程/切换）<ul><li>保存镜像：记录进程现场信息；</li><li>调度算法：确定分配处理机的原则；</li><li>进程切换：分配处理机给其他进程；</li><li>处理机回收：从进程收回处理机。</li></ul></li></ul><h2 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h2><p>调度算法指标：<u>CPU利用率</u>（忙碌时间/总时间）；<u>系统吞吐量</u>（完成作业数/总时间）；周转时间（作业完成时间-提交时间）；等待时间（作业等待处理机调度时间-关注平均值）；响应时间（提交请求到首次响应间隔）……</p><h2 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230403193116458.png" alt="image-20230403193116458"></p><h3 id="先来先服务（FCFS-First-Come-First-Served）"><a href="#先来先服务（FCFS-First-Come-First-Served）" class="headerlink" title="先来先服务（FCFS, First Come First Served）"></a>先来先服务（FCFS, First Come First Served）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230403193607734.png" alt="image-20230403193607734"></p><ul><li>算法内容：调度作业/就绪队列中最先入队者，等待操作完成或阻塞；</li><li>算法原则：按作业/进程到达顺序 服务；</li><li>调度方式：非抢占式调度；</li><li>适用场景：作业/进程调度；</li><li>优缺点：有利于CPU繁忙型作业，充分利用CPU资源；不利于I/O繁忙型作业，操作耗时，其他饥饿。</li></ul><h3 id="短作业优先（SJF，Shortest-Job-First）"><a href="#短作业优先（SJF，Shortest-Job-First）" class="headerlink" title="短作业优先（SJF，Shortest Job First）"></a>短作业优先（SJF，Shortest Job First）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230413165325539.png" alt="image-20230413165325539"></p><ul><li>算法内容：<strong>所需服务时间最短</strong>的作业 / 进程优先服务；</li><li>算法原则：追求最少的平均（带权）周转时间；</li><li>调度方式：SJF / SPF 非抢占式（？还没进CPU？；</li><li>适用场景：作业 / 进程调度；</li><li>优缺点<ul><li>平均等待/周转时间最少；</li><li>长作业周转时间会增加或饥饿；</li><li>估计时间不准确，不能保证紧迫任务及时处理。</li></ul></li></ul><h3 id="高响应比优先（HRRN，Highest-Response-Ratio-Next"><a href="#高响应比优先（HRRN，Highest-Response-Ratio-Next" class="headerlink" title="高响应比优先（HRRN，Highest Response Ratio Next)"></a>高响应比优先（HRRN，Highest Response Ratio Next)</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424194517483.png" alt="image-20230424194517483"></p><ul><li>算法内容：总和FCFS和SJF，综合考虑等待时间和服务时间响应比，高的优先调度；</li><li>算法原则：综合考虑作业 / 进程的等待时间和服务时间；</li><li>调度方式：非抢占式；</li><li>适用场景：作业 / 进程调度；</li><li>响应比计算：<ul><li>响应比 = <strong>（等待时间+服务时间）/服务时间</strong> = 等待时间/服务时间 + 1， ≥1；</li><li>只有当前进程放弃执行权（完成 / 阻塞）时，重新计算所有进程响应比；</li><li><u>长作业</u>等待<u>越久</u>响应比越高，更容易获得处理机。</li></ul></li></ul><h3 id="优先级调度（PSA，Priority-Scheduling-Algorithm）"><a href="#优先级调度（PSA，Priority-Scheduling-Algorithm）" class="headerlink" title="优先级调度（PSA，Priority-Scheduling Algorithm）"></a>优先级调度（PSA，Priority-Scheduling Algorithm）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424195233727.png" alt="image-20230424195233727"></p><ul><li>算法内容：又叫优先权调度，按作业 / 进程 的优先级（紧迫程度）进行调度；</li><li>算法原则：优先级最高（最紧迫）的作业 / 进程先调度；</li><li>调度方式：抢占 / 非抢占式（并不能获得及时执行）</li><li>优先级设置原则：<ul><li>静态（进程创建就确定了） / 动态优先级；</li><li>系统 ＞用户；交互型 ＞ 非交互型；I/O型 ＞计算型；</li><li>低优先级进程可能会产生”饥饿“。</li></ul></li></ul><h3 id="【时间片轮转调度算法】（RR，Round-Robin"><a href="#【时间片轮转调度算法】（RR，Round-Robin" class="headerlink" title="【时间片轮转调度算法】（RR，Round-Robin)"></a>【时间片轮转调度算法】（RR，Round-Robin)</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424195725057.png" alt="image-20230424195725057"></p><blockquote><p>后面的进程必须要等到前面的进程完成时间片，所以严格来说不是实时的，有一定等待时间。</p></blockquote><ul><li>算法内容：按进程到达就绪队列的顺序，轮流分配一个时间片去执行，时间用完则剥夺；</li><li>算法原则：<strong>公平、轮流</strong>为每个进程服务，进程在一定时间内都能得到响应；</li><li>调度方式：抢占式，由<strong>时钟中断</strong>确定时间到；</li><li>适用场景：进程调度；（作业调度是一次性的）</li><li>优缺点：<ul><li>公平，响应快，适用于分时系统；</li><li>时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力；</li><li>时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大。</li></ul></li></ul><h3 id="【多级反馈队列调度】（MFQ，Multileveled-Feedback-Queue）"><a href="#【多级反馈队列调度】（MFQ，Multileveled-Feedback-Queue）" class="headerlink" title="【多级反馈队列调度】（MFQ，Multileveled Feedback Queue）"></a>【多级反馈队列调度】（MFQ，Multileveled Feedback Queue）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230426123415014.png" alt="image-20230426123415014"></p><ul><li>算法内容<ul><li>设置<strong>多个按优先级排序的</strong>就绪队列；</li><li>优先级由高到低，时间片从小到大；</li><li>新进程采用队列降级法（进入第一级队列，按FCFS分时间片）（没有执行完，移到第二级，第三级……）</li><li>前面队列不为空，不执行后续队列进程。</li></ul></li></ul><blockquote><p>无论优先级多少 或者是长短作业，首先都会进入第一个优先级队列，没执行完就进入下一个队列……至少都会执行一下，不至于完全饥饿的状态。</p><p>越往下，优先级越低，但是执行时间越长……</p></blockquote><ul><li>算法原则：集前几种算法优点，相当于PSA+RR</li><li>调度方式：抢占式</li><li>适用场景：进程调度</li><li>优缺点<ul><li>对各类型相对公平；快速响应；</li><li> 终端型作业用户：短作业优先；</li><li>批处理作业用户：周转时间短；</li><li>长批处理作业用户：在前几个队列部分执行。</li></ul></li></ul><h1 id="——进程之间是怎么协作的——"><a href="#——进程之间是怎么协作的——" class="headerlink" title="——进程之间是怎么协作的——-"></a>——进程之间是怎么协作的——-</h1><p><a href="https://cloud.tencent.com/developer/article/1803377">看完了进程同步与互斥机制，我终于彻底理解了 PV 操作-腾讯云开发者社区-腾讯云 (tencent.com)</a>[比较通俗易懂的。]</p><ul><li><p>进程调度是为了最大程度的利用 CPU 资源，选用合适的算法调度就绪队列中的进程。</p></li><li><p>进程同步是为了<strong>协调一些进程以完成某个任务</strong>，比如读和写，你肯定先写后读，不能先读后写吧，这就是进程同步做的事情了，指定这些进程的先后执行次序使得某个任务能够顺利完成。</p></li><li><p>进程同步：进程 A 应在进程 B 之前执行</p></li><li><p>进程互斥：进程 A 和进程 B 不能在同一时刻执行。</p></li></ul><p>从上不难看出，<strong>「进程互斥是一种特殊的进程同步」</strong>，即逐次使用临界资源，也是对进程使用资源的先后执行次序的一种协调。</p><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427160912451.png" alt="image-20230427160912451"></p><ul><li>概念：进程通信即<strong>进程间的信息交换</strong>。<ul><li>进程是资源分配的基本单位，各进程内存空间彼此独立；</li><li>一个进程不能随意地访问其它进程的地址空间。</li></ul></li><li>特点<ul><li>共享存储（Shared-Memory)</li><li>消息传递（Message-Passing）</li><li>管道通信（Pipe）</li></ul></li></ul><h2 id="共享存储（Shared-Memory"><a href="#共享存储（Shared-Memory" class="headerlink" title="共享存储（Shared-Memory)"></a>共享存储（Shared-Memory)</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427161116063.png" alt="image-20230427161116063"></p><ul><li><p>基于<strong>共享数据结构</strong>（只是存储量小）的通信方式</p><ul><li>多个进程共用某个数据结构（OS提供并控制）；</li><li>由<u>用户（程序员）负责</u>同步处理（读写操作的先后等）；</li><li>低级通信：可以传递少量数据，效率低。（低级：直接操控物理硬件/如内存等</li></ul></li><li><p>基于<strong>共享存储区</strong>的通信方式</p><ul><li>多个进程共用内存中的一块存储区域；</li><li>由<u>进程控制</u>数据的形式和方式（进程自己动态申请）；</li><li>高级通信：可以传递<u>大量数据</u>，效率高（不是调用数据结构的底层操作……？</li></ul></li></ul><blockquote><p>数据收发过程双方不可见，存在安全隐患。</p></blockquote><h2 id="消息传递（Message-Passing）"><a href="#消息传递（Message-Passing）" class="headerlink" title="消息传递（Message-Passing）"></a>消息传递（Message-Passing）</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427161951629.png" alt="image-20230427161951629"></p><ul><li><p>直接通信：点到点发送</p><ul><li>发送和接收时指明<u>双方进程的ID</u>；</li><li>每个进程维护一个<u>消息缓冲</u>队列；</li><li>格式化消息：遵循一定格式，如消息头、进程ID等。</li></ul></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427162351207.png" alt="image-20230427162351207"></p><ul><li><p>间接通信：广播信箱</p><ul><li>以信箱为媒介，作为中间实体；</li><li>发进程将消息发送到信箱，收进程从信箱读取；</li><li>可以广播，容易建立双向通信链。</li></ul><blockquote><p>和共享内存什么区别？操作方式。消息传递是通过send / receive原语……</p></blockquote></li></ul><h2 id="管道通信（Pipe）"><a href="#管道通信（Pipe）" class="headerlink" title="管道通信（Pipe）"></a>管道通信（Pipe）</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230428115510038.png" alt="image-20230428115510038"></p><ul><li>管道<ul><li>用于连接读 / 写进程的共享<strong>文件</strong>，pipe文件；把从一个进程连接到另一个进程的一个数据流称为一个“管道”。</li><li>本质上是<strong>内存中</strong><u>固定大小</u>的缓冲区。</li><li>写满（或者通过结束符标志）才能读(一次性读完)，读完才能写；空的时候不读，空的时候才写；读写两操作互斥</li></ul></li><li><strong>半双工</strong>通信<ul><li>同一时段只能单向通信，双工通信需要两个管道；</li><li>以先进先出（FIFO）方式组织数据传输；</li><li>通过系统调用read()/write()函数进行读写操作。</li></ul></li><li>优点：可传输数据量大，而且安全（对共享存储进行了改进）</li></ul><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>协调</strong>进程间的<strong>相互制约关系</strong>，使它们按照预期的方式执行的过程。（让这些进程按照我们想要的规则/顺序去执行）</p><ul><li>前提<ul><li>进程是并发执行的，进程间存在相互制约关系；</li><li>并发的进程对系统共享资源进行竞争；</li><li>进程通信，过程中相互发送的信号称为消息或事件。</li></ul></li><li>两种相互制约形式<ul><li>间接相互制约关系（<strong>互斥</strong>）：进程<u>排他性</u>地访问共享资源；</li><li>直接相互制约关系（<strong>同步</strong>）：进程间的<u>合作</u>，比如管道通信；</li></ul></li></ul><blockquote><p>理解广义和狭义的同步概念是什么</p></blockquote><h2 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h2><p>进程同步：互斥地访问临界资源（也就是共享资源）。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230501094800100.png" alt="image-20230501094800100"></p><ul><li><p>访问过程</p><ol><li>进入区：尝试进入临界区，成功则【<strong>加锁（lock）</strong>】</li><li>临界区：访问共享资源</li><li>退出区：【<strong>解锁（unlock）</strong>】，唤醒其它阻塞进程</li><li>剩余区：其它代码</li></ol></li><li><p>访问原则</p><ol><li>空闲让进：临界区空闲，允许一个进程进入；</li><li>忙则等待：临界区已有进程，其它进程等待（阻塞状态）；</li><li>有限等待：处于等待的进程，等待时间有限；</li><li>让权等待：等待时应让出CPU执行权，防止“忙等待”（例如死循环</li></ol></li><li><p>软件实现方法</p><ul><li>单标志法：</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230503165357299.png" alt="image-20230503165357299"></p><blockquote><p>对于P0来说：turn≠0的时候（也就是该进入临界区访问共享资源的进程不是它），就一直在进入区（也就是while循环）里面等待；直到别的进程把turn设置为0的时候才会跳出循环，进入下一步临界区进行访问……其它进程以此类推。</p><p>在这里，两个进程是交替访问。</p><p>【问题】当P0在剩余区执行不再返回到进入区的时候（只设置一次turn=1），P1如果想反复进入临界区的话 将一直在进入区等待。临界区没人使用，但是P1却用不了。这违背了【空闲让进】原则。</p></blockquote><ul><li><p>双标志法先检查：</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230503171625478.png" alt="image-20230503171625478"></p><blockquote><p>在临界区的进程对应的元素位就设置成true。就P0来说，如果P1在临界区，就在进入区等待；直到P1退出并唤醒P0。如果P0想反复进入临界区，只要p1不在临界区就能执行。</p><p>【问题】虚线框的代码。如果P0刚刚好执行完<code>while(flag[1]);</code>此时还没执行<code>flag[0]=true</code>也就是仍然是false，若此时p1刚好执行了<code>while(flag[0])</code>，那就误判P0还未进入临界区，此时两线程将一起访问临界区，违背了【忙则等待】原则。</p></blockquote></li><li><p>双标志法后检查：</p></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230504164520333.png" alt="image-20230504164520333"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可能执行的顺序</span><br><span class="line">flag[0] = true;</span><br><span class="line">flag[1] = true;</span><br><span class="line">while(flag[1]);</span><br><span class="line">while(flag[0]);</span><br></pre></td></tr></table></figure><blockquote><p>双方都以为对方在临界区，所以都在进入区等待，违背了【空闲让进】【有限等待】原则。</p></blockquote><ul><li>皮特森算法（在双标志法的基础上加上单标志）</li></ul><p> <img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230504170107437.png" alt="image-20230504170107437"></p></li></ul><ul><li><p>硬件实现方法</p><ul><li><p>中断屏蔽方法：关中断/开中断</p><p><strong>禁止一切中断，CPU执行完临界区之前不会切换</strong>；</p><p>关中断可能会被滥用；</p><p>关中断时间长影响效率；</p><p>不适用于多处理机，无法防止其它处理机调度其它进程访问临界区；（不能锁其它处理机，没有实现效果）</p><p>只适用于内核进程（中断等操作是低级指令，运行在内核态）</p></li><li><p>Test-And-Set（TS指令/TSL指令）</p><p>下图是简要理解。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230517184530800.png" alt="image-20230517184530800"></p><blockquote><p>先看第二个框，当TestAndSet函数一直返回true的时候，while将在进入临界区之前一直执行循环，也叫自旋、忙等；即该线程还不能进入临界区。</p><p>为什么还不能进入呢，看第一框，old = *lock，也就是lock为true的时候，即其它线程正在锁，该线程只能等待；当lock为false，则跳出循环，进入临界区，直到执行完毕，把lock赋值为false解锁，给其它线程用。</p></blockquote><p>读出标志并设置为true，返回旧值，<strong>原子操作</strong>。 （函数内执行的话不会被打断）；</p><p>也被称为TSL指令（Test-And-Set-Lock)；</p><p>违背“让权等待”，会发生忙等。</p></li><li><p>Swap指令</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230522224425218.png" alt="image-20230522224425218"></p><blockquote><p>只有lock为false的时候，交换后old为false，才会跳出进入临界区之前的循环。</p></blockquote><ul><li>交换两个变量的值，<strong>原子操作</strong>；</li><li>违背“让权等待”（忙等</li></ul></li></ul></li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><ul><li>信号量（Semaphore）机制<ul><li>PV操作：P操作——<strong>wait原语</strong>，进程等待；V操作——<strong>signal原语</strong>，唤醒等待进程；</li><li>整型信号量：表示可用资源数；</li></ul></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523193837115.png" alt="image-20230523193837115"></p><blockquote><p>违背“让权等待”，会发生忙等</p></blockquote><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523194347162.png" alt="image-20230523194347162"></p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523195423701.png" alt="image-20230523195423701"></p><blockquote><ul><li><p>改成用block原语阻塞进程，就不会发生忙等（死循环且在执行）。</p></li><li><p>整个流程：假设有三个进程，一个资源，进程1执行wait的时候，S.value=0，可以进入临界区访问资源；进程2执行wait的时候，S.value=-1, 小于0，进行阻塞；进程3也进来了，S.value=-2，也在阻塞。</p><p>等到进程1访问完到退出区了，执行signal方法，S.value=-1,但还是小于等于0，此时用wakeup原语（重复执行signal方法，直到S.value&gt;0）唤醒等待队列（L）的所有进程。</p></li></ul></blockquote><p>这个是<strong>记录型信号量</strong>：进程进入<strong>阻塞状态</strong>，不会忙等。</p><ul><li>分析进程同步和互斥问题的方法步骤<ul><li>分析关系：进程的数量、进程间的同步或互斥关系、前驱关系；</li><li>整理思路：根据进程的操作流程，确定等待（P）、唤醒（V）的大致顺序；</li><li>设置信号量：根据前两步分析和整理，设置信号量初始值。</li></ul></li></ul><h2 id="管程（Monitor，监视器）"><a href="#管程（Monitor，监视器）" class="headerlink" title="管程（Monitor，监视器）"></a>管程（Monitor，监视器）</h2><ul><li><p>定义</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230525192806235.png" alt="image-20230525192806235"></p><p>“管理进程”，<strong>即用于实现进程同步的工具</strong>。是由代表<u>共享资源的数据结构</u>和<u>一组过程（进行PV操作的函数）组成的管理程序</u>（封装）。</p><p>把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理，管程的局部变量只能由该管程的过程存取，进程只能互斥地调用管程中的过程。</p><p>【比信号量封装性更高，工作原理和信号量一致；面向对象思想：数据和函数的封装；是被进程调用的程序，本身不是进程】</p></li><li><p>管程的组成</p><ul><li>管程名称；</li><li>局部于管程内部的共享数据结构；【数据私有】</li><li>对该数据结构操作的一组过程（函数）；</li><li>管程内共享数据的初始化语句；</li></ul></li><li><p>管程的基本特性</p><ul><li>是一个模块化的基本程序单位，可以单独编译；（可以对应一个对象实例，有多个管程）；</li><li>是一种抽象数据类型，包含数据和操作；（也就是一个类型；</li><li>信息掩蔽，共享数据只能被管程内的过程访问；</li></ul></li><li><p>条件变量 / 条件对象</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230526200939155.png" alt="image-20230526200939155"></p><ul><li>进入管程的进程可能由于条件不满足而阻塞（Wait操作）；</li><li>此时进程应释放管程以便其它进程调用管程；</li><li>进程被阻塞的条件（原因）有多个，移入不同的条件队列；</li><li>进程被移入条件队列后，应释放管程。</li></ul></li></ul><h2 id="经典同步问题（缺）"><a href="#经典同步问题（缺）" class="headerlink" title="经典同步问题（缺）"></a>经典同步问题（缺）</h2><h1 id="——-如何处理死锁问题？——–"><a href="#——-如何处理死锁问题？——–" class="headerlink" title="——-如何处理死锁问题？——–"></a>——-如何处理死锁问题？——–</h1><h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>多个进程由于<strong>竞争资源</strong>而造成的<strong>阻塞现象</strong>，若无外力作用，这些进程将无法继续推进。</p><ul><li>相似概念：饥饿。<strong>等待时间过长</strong>以至于给进程推进和响应带来明显影响，“饿而<strong>不死</strong>”。（能得到执行但效率很低，不至于完全阻塞）</li></ul><h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><ul><li>系统资源的竞争；</li><li>进程推进顺序非法。</li></ul><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>必要条件：条件缺一不可。（?</p><p>【狭义的死锁】</p><ul><li>互斥条件：共享资源的非他性访问 / 独占性访问；（有且只有一个进程访问）</li><li>不剥夺条件：访问时该共享资源不会被剥夺；（只有进程主动释放）</li><li>请求并保持条件：<strong>保持</strong>当前资源时<strong>请求</strong>另一个资源；（某个进程持有某个进程的时候，还想访问另一个资源，但这个资源正在被持有；占有资源一直不出来的一个原因，否则迟早都会出来……？）</li><li>循环等待条件：存在共享资源的<strong>循环等待链</strong>。（你等我，我等你……）</li></ul><h1 id="死锁处理策略"><a href="#死锁处理策略" class="headerlink" title="死锁处理策略"></a>死锁处理策略</h1><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230528144335190.png" alt="image-20230528144335190"></p><ul><li><p>破坏互斥条件</p><ul><li>将只能互斥访问的资源改为<strong>同时共享访问</strong>；</li><li>将独占锁改为共享锁；（信号量＞1）</li><li>不是所有资源都能改成可共享的；</li></ul></li><li><p>破坏不剥夺 / 不可抢占条件</p><ul><li>请求<strong>新资源无法满足</strong>时必须释放已有资源；</li><li>由OS协助<strong>强制剥夺</strong>某进程持有的资源；</li><li>实现复杂，代价高；</li><li>此操作过多导致原进程任务无法推进。</li></ul></li><li><p>破坏请求并保持条件</p><ul><li>进程开始运行时一次性申请所需资源——资源浪费（资源用没用上都被占着）、进程饥饿（其它进程拿不到资源）；【P0】（理解是，进程一直占有很多资源，暂时用不到的资源但其它进程想要请求，就造成了等待；所以阶段性请求和释放就增大资源的利用率，减少等待）</li><li>阶段性请求和释放资源；【P1】</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529084721110.png" alt="image-20230529084721110"></p></li></ul><ul><li>破坏循环等待条件<ul><li>对所有资源现行排序，按序号请求资源；（之前执行的都是乱序的）<ul><li>请求时先低再高；</li><li>释放时先高再低；</li></ul></li><li>对资源的编号应相对稳定，限制了新设备的增加；（预先知道并安排资源）</li><li>进程使用资源的顺序可能与系统编号顺序不同；</li><li>限制了用户编程；（内定好顺序了）</li></ul></li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>死锁避免：安全性算法。</p><ul><li><p>系统安全状态</p><ul><li>安全状态一定不会出现死锁；</li><li>不安全状态可能出现死锁；</li></ul></li><li><p>银行家算法</p><ul><li>系统预判进程请求是否导致不安全状态；</li><li>是则拒绝请求，否则答应请求；</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529085923176.png" alt="image-20230529085923176"></p><blockquote><p>进程先让操作系统知道，最大需求是多少；系统判断：申请的数量是否大于所需最大数量、可用数量够不够。</p><p>（如果分配给进程的资源数量 ＋ 进程已分配的资源 ≤ 最大需求，进程未得到满足就继续占有已有资源并等待请求更多的资源——请求并保持，所以要确保满足进程最大需求，好让它用完并释放）</p></blockquote></li></ul><h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><ul><li>死锁检测（判断 死锁产生的条件 是否出现）<ul><li>需要一种数据结构，保存有关资源的请求和分配信息；</li><li>提供一种算法，利用这些信息检测是否形成了死锁。</li></ul></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529091141333.png" alt="image-20230529091141333"></p><blockquote><p>【资源分配图】两种资源、两种节点。请求边：进程向资源请求；反之。</p></blockquote><ul><li><p>死锁定理（死锁状态的充分条件；而死锁的四个产生条件是必要条件）：</p><ul><li>当且仅当此状态下资源分配图是不可完全简化的；</li><li>简化过程<strong>类似于</strong>“拓扑排序”算法（先找到没有入边的节点，然后循环找没有入边的节点进行排序）</li></ul><blockquote><p>先看是否为孤点（无两种边）。是否阻塞主要看请求边。请求的是否能得到满足；</p><p>上面示意图中，先取出P0（资源充足，执行完可以释放掉，再轮到P1），再取出P1，简化完成，所以不会阻塞。</p></blockquote></li><li><p>死锁解除</p><ul><li>资源剥夺；（解决资源不够的问题）<ul><li>挂起死锁进程；</li><li>剥夺其资源；</li><li>将资源分配给其它（死锁）进程。</li></ul></li><li>撤销进程；（Destroy）</li><li>进程回退。<ul><li>回退到足以避免死锁的地步；</li><li>需要记录进程历史信息，设置还原点。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">关于操作系统的知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huangxinhere.github.io/2023/03/18/Unity%E5%BC%80%E5%8F%91-%E9%80%83%E5%87%BA%E5%9C%B0%E7%90%83/"/>
    <id>https://huangxinhere.github.io/2023/03/18/Unity%E5%BC%80%E5%8F%91-%E9%80%83%E5%87%BA%E5%9C%B0%E7%90%83/</id>
    <published>2023-03-18T02:50:15.984Z</published>
    <updated>2023-03-19T14:08:59.071Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="Tilemap"><a href="#Tilemap" class="headerlink" title="Tilemap"></a>Tilemap</h1><p><a href="https://docs.unity.cn/cn/2018.4/Manual/class-Tilemap.html">Tilemap - Unity 手册</a></p><p><a href="https://blog.csdn.net/weixin_41054345/article/details/109329638">(47条消息) Unity Tilemap动态生成2d地图_tilemap 动态地形_crushKB的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/sanyejun/p/9298592.html">unity2018使用tileMap生成地图 类似泰拉瑞亚创建和销毁地图块 - 三页菌 - 博客园 (cnblogs.com)</a></p><p>开始的想法是用Tilemap，因为可以方便地选择格子来填充或删除。</p><p>但是看了好多资料，却越来越清晰地意识到：Tilemap还是为了地图而存在的，也就是静态的，单元格集成的。所以，几乎不可能移动单个Tile？都是跟随Tilemap一起的刚体属性。</p><h1 id="纯物理"><a href="#纯物理" class="headerlink" title="纯物理"></a>纯物理</h1><p><a href="https://docs.unity.cn/cn/2021.3/Manual/Joints2D.html">2D 关节 - Unity 手册</a></p><p>【例子不全面，好坑】[(47条消息) <a href="https://blog.csdn.net/rickshaozhiheng/article/details/78509632">Unity] Unity2D 中的物理关节_Rickshao1993的博客-CSDN博客</a></p><h1 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a>网格系统</h1><p><a href="https://www.bilibili.com/video/BV1AY411a7QV/?vd_source=bd424a1eb707161ee6ba2f47e4c49a08">Unity中的网格系统 Grid System in Unity (How to make it and where to use it)_哔哩哔哩_bilibili</a></p><h1 id="用UI直接代替逻辑网格系统"><a href="#用UI直接代替逻辑网格系统" class="headerlink" title="用UI直接代替逻辑网格系统"></a>用UI直接代替逻辑网格系统</h1><p><a href="file:///D:/Unity/2021.3.8f1c1/Editor/Data/Documentation/en/Manual/class-Canvas.html">统一 - 手动：画布</a></p><ul><li><p>先排好Grid按钮，整理好画布</p></li><li><p>接着将点击的UI坐标转化成世界坐标。Button坐标-&gt;屏幕坐标-&gt;世界坐标【关于坐标转换的知识要学习一下】</p><p>获得坐标后，生成砖块【资产获取的知识】；</p><p>生成砖块的时候要检查是否已经存在方块【屏幕射线检查物体[Unity 射线检测（RayCast） - Mr.Cat~ - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/Haha1999/p/13272109.html#:~:text=%E5%B8%B8%E7%94%A8%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95">https://www.cnblogs.com/Haha1999/p/13272109.html#:~:text=常用射线检测方法</a> 1 1. 普通射线检测（一般用于检测某一个物体） 1 Ray ray %3D,2 2. 直线射线检测多个物体 … 3 3. 球形射线检测（一般用于检测周边物体） )】</p></li><li><p>构建砖块搭建的逻辑算法：</p><ul><li><p>砖块start的时候，要执行搭建算法：左边有，扣住左边；右边有，扣住右边；否则自然向下。</p><p>射线检测：方向-检测到的物体判断；RayCast也会检测到自己…【射线检测】<a href="https://docs.unity.cn/cn/current/ScriptReference/Physics2D.Raycast.html">Physics2D-Raycast - Unity 脚本 API</a></p><p>生成固定关节组件：</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Tilemap&quot;&gt;&lt;a href=&quot;#Tilemap&quot; class=&quot;headerlink&quot; title=&quot;Tilemap&quot;&gt;&lt;/a&gt;Tilemap&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.unity.cn/cn/2018.4</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++ 数据结构</title>
    <link href="https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++/"/>
    <id>https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++/</id>
    <published>2023-03-02T16:00:00.000Z</published>
    <updated>2024-03-12T10:55:10.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p><a href="https://blog.csdn.net/Dr_Myst/article/details/123164599">C/C++标准输入输出终极最全解析（不全捶我）- scanf、fgets、getchar、cin，printf、fputs、putchar、cout等_c++輸入輸出該用什麼_MidoQ的博客-CSDN博客</a></p><h2 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h2><p><code>cin</code>是 C++ 的标准输入流对象，即<code>istream</code>类的一个对象实例。</p><p><code>cin</code>有自己的缓冲区，但默认情况下是与<code>stdin</code>同步的，因此在 C++ 中可以混用 C++ 和 C 风格的输入输出（在不手动取消同步的情况下）。<code>cin</code>与<code>stdin</code>一样是行缓冲，即遇到换行符时才会将数据同步到输入缓冲区。</p><ul><li>对空白字符的处理</li></ul><p><code>cin</code>对空白字符的处理与<code>scanf</code>一致。即：<strong>跳过</strong>开头空白字符，遇到空白字符停止读取，且空白字符（包括换行符）残留在缓冲区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 待读入的两个字符串，其中有换行符</span></span><br><span class="line">adfadfsgdas</span><br><span class="line">dafasdgaa</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果在笔试编程中无法读到换行符并中止</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; c)</span><br><span class="line"><span class="comment">// 这样就可以分别读串……</span></span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br></pre></td></tr></table></figure><h2 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h2><p>读取单个或指定长度的字符，包括空白字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a, b;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读取一个字符，读取失败时返回0，多余字符残留在缓冲区（包括换行符）</span></span><br><span class="line">a = cin.<span class="built_in">get</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 读取一个字符，读取失败时返回EOF，多余字符残留在缓冲区（包括换行符）</span></span><br><span class="line">cin.<span class="built_in">get</span>(b);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在遇到指定终止字符（参数3）前，至多读取n-1个（参数2）字符</span></span><br><span class="line"><span class="comment">// 当不指定终止字符时，默认为换行符\n</span></span><br><span class="line"><span class="comment">// 如果输入的字符个数小于等于n-1（不含终止字符），则终止字符不残留在缓冲区</span></span><br><span class="line"><span class="comment">// 如果输入的字符个数多于n-1（不含终止字符），则余下字符将残留在缓冲区</span></span><br><span class="line">cin.<span class="built_in">get</span>(str, <span class="built_in"><span class="keyword">sizeof</span></span>(str), <span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p><a href="https://blog.csdn.net/weixin_52668597/article/details/114606407?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-114606407-blog-77979697.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-114606407-blog-77979697.235%5Ev38%5Epc_relevant_sort_base1">printf怎么输出? 如何正确使用%s,%c,%d,%p?=＞这篇详解用法_printf(“%s”)_踏过山河，踏过海的博客-CSDN博客</a></p><ul><li>%c</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>] = &#123; <span class="string">&quot;123&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span>*p = op;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, *op);<span class="comment">//=&gt;1 =&gt;*op是值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>%s</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> op[<span class="number">20</span>] = &#123; “<span class="number">123</span>” &#125;;</span><br><span class="line">    <span class="keyword">char</span>*p = op;</span><br><span class="line">    <span class="comment">//op是指针(地址),*op是值,p是指针,*p是值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, op);<span class="comment">//=&gt;123 =&gt;op是指针(地址)或者printf(&quot;%s&quot;,p);=&gt;p是指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断是否为字母或数字"><a href="#判断是否为字母或数字" class="headerlink" title="判断是否为字母或数字"></a>判断是否为字母或数字</h1><ul><li>范围确定</li></ul><p>判断一个字符是否为：</p><p>小写字母：字符大于等于a，小于等于z；</p><p>大写字母：字符大于等于A，小于等于Z；</p><p>数字：字符大于等于0，小于等于9；</p><ul><li>STL库函数判断</li></ul><p>字母（不区分大小写）：isalpha();</p><p>大写字母：isupper();</p><p>小写字母：islower();</p><p>数字：isdigit();</p><p>字母和数字：isalnum();</p><ul><li><p>大小写字母转化：</p><p>（1）转化为大写：toupper();</p><p>（2）转化为小写：tolower();</p></li></ul><h1 id="—–数据结构"><a href="#—–数据结构" class="headerlink" title="—–数据结构"></a>—–数据结构</h1><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>priority_queue，优先队列。和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面，优先出队。<a href="https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">优先队列</a>具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。</p><p><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">(49条消息) c++优先队列(priority_queue)用法详解_吕白_的博客-CSDN博客</a></p></li></ul><blockquote><p>和队列基本操作相同:</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;Type, Container, Functional&gt;</span><br><span class="line"><span class="comment">//Type 就是数据类型;</span></span><br><span class="line"><span class="comment">//Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector）;</span></span><br><span class="line"><span class="comment">//Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line"><span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="built_in">push</span>(i);<span class="comment">// 4 3 2 1 0</span></span><br><span class="line">    c.<span class="built_in">push</span>(i);<span class="comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);<span class="comment">// cbd abcd abc</span></span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><a href="http://c.biancheng.net/view/6834.html">C++ STL vector插入元素（insert()和emplace()）详解 (biancheng.net)</a></p><ul><li>insert</li></ul><table><thead><tr><th align="center">语法格式</th><th align="center">用法说明</th></tr></thead><tbody><tr><td align="center">iterator insert(pos,elem)</td><td align="center">在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td align="center">iterator insert(pos,n,elem)</td><td align="center">在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td align="center">iterator insert(pos,first,last)</td><td align="center">在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td align="center">iterator insert(pos,initlist)</td><td align="center">在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>emplace：是 <a href="http://c.biancheng.net/cplus/">C++</a> 11 标准新增加的成员函数，用于在 vector 容器<strong>指定位置之前</strong>插入<strong>一个</strong>新的元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator pos, args...)</span></span>;</span><br><span class="line"><span class="comment">//其中，pos 为指定插入位置的迭代器；args... 表示与 /* 新插入元素的构造函数 * /相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);<span class="comment">//3 1 2</span></span><br></pre></td></tr></table></figure><ul><li>emplace 比 insert 的效率更高。 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐大家优先使用 emplace()。</li></ul><h2 id="vector、map、list"><a href="#vector、map、list" class="headerlink" title="vector、map、list"></a>vector、map、list</h2><p><a href="https://blog.csdn.net/qq_44943840/article/details/121990808">C++最经典的三大容器Vector、Map、List_c++ vector map_你不懂细节的博客-CSDN博客</a></p><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>地址不变，内存空间连续，所以在中间进行插入和删除时会造成内存块拷贝，如果插入的是结构体或者类，则会造成构造和析构，性能不是特别高，对结尾元素操作最快。</p><p><img src="https://img-blog.csdnimg.cn/675389428bed4e489f5e0a65dd79a561.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L2g5LiN5oeC57uG6IqC,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>优点：支持随机访问，即下标访问和迭代器访问，所以<strong>查询效率高</strong>。</p><p>缺点：往头部或中部插入或删除元素时，为了保持原本的相对次序，插入或删除之后的所有元素都必须移动，所以<strong>插入效率比较低</strong>。</p><p>适用场景：适用于对象简单，变化较小，并且频繁随机访问的场景。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><strong>双向链表</strong>实现而成。</p><p>元素存放与堆区，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问。</p><p>没有提供迭代器，每删除一个元素都会释放它占用的内存，可以<u>在任意地方插入和删除</u>，访问头尾两个元素最快，其他元素的访问时间一样。</p><p><img src="https://img-blog.csdnimg.cn/42055bdee9314cde9c51d0f4d9e69f5e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5L2g5LiN5oeC57uG6IqC,size_13,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>优点：内存不连续，动态操作，可以在任意位置插入或删除且效率高。</p><p>缺点：不支持随机访问。</p><p>适用场景：经常进行插入和删除并且不经常随机访问的场景。</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>详情看下面部分。</p><h2 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h2><p>和顺序容器不同，是关联容器。关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p><p>关联容器包括set 和 map。</p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p><a href="https://blog.csdn.net/Peealy/article/details/116895964">(49条消息) 一文看懂哈希表并学会使用C++ STL 中的哈希表_哈希表end函数_嗯行家啊的博客-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>声明</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;elemType_1, elemType_2&gt; var_name; <span class="comment">//声明一个没有任何元素的哈希表，</span></span><br><span class="line"><span class="comment">//其中elemType_1和elemType_2是模板允许定义的类型，如要定义一个键值对都为Int的哈希表：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pair&lt;,&gt;不行，要自定义函数</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br></pre></td></tr></table></figure><ul><li>初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//如果知道要创建的哈希表的元素个数时，也可以在初始化列表中指定元素个数</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;&#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125;&#125;,<span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们想向哈希表中添加元素时也可以直接通过下标运算符添加元素，格式为: mapName[key]=value;</span></span><br><span class="line"><span class="comment">//如：hmap[4] = 14;</span></span><br><span class="line"><span class="comment">//但是这样的添加元素的方式会产生覆盖的问题，也就是当hmap中key为4的存储位置有值时，</span></span><br><span class="line"><span class="comment">//再用hmap[4]=value添加元素，会将原哈希表中key为4存储的元素覆盖</span></span><br><span class="line">hmap[<span class="number">4</span>] = <span class="number">14</span>;</span><br><span class="line">hmap[<span class="number">5</span>] = <span class="number">15</span>;</span><br><span class="line">cout &lt;&lt; hmap[<span class="number">4</span>];  <span class="comment">//结果为15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过insert()函数来添加元素的结果和通过下标来添加元素的结果一样，不同的是insert()可以避免覆盖问题，</span></span><br><span class="line"><span class="comment">//insert()函数在同一个key中插入两次，第二次插入会失败</span></span><br><span class="line">hmap.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="number">15</span> &#125;);</span><br><span class="line">hmap.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="number">16</span> &#125;);</span><br><span class="line">cout &lt;&lt; hmap[<span class="number">5</span>];  <span class="comment">//结果为15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line"><span class="function">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">hmap1</span><span class="params">(hmap)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>常用函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// erase()</span></span><br><span class="line">hmap.<span class="built_in">erase</span>(iter_begin);  <span class="comment">//删除开始位置的元素</span></span><br><span class="line">hmap.<span class="built_in">erase</span>(iter_begin, iter_end); <span class="comment">//删除开始位置和结束位置之间的元素</span></span><br><span class="line">hmap.<span class="built_in">erase</span>(<span class="number">3</span>); <span class="comment">//删除key==3的键值对</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line"><span class="comment">// 以key作为参数寻找哈希表中的元素，如果哈希表中存在该key值则返回该位置上的迭代器，否则返回哈希表最后一个元素下一位置上的迭代器</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter = hmap.<span class="built_in">find</span>(<span class="number">2</span>); <span class="comment">//返回key==2的迭代器，可以通过iter-&gt;second访问该key对应的元素</span></span><br><span class="line"><span class="keyword">if</span>(iter != hmap.<span class="built_in">end</span>())  cout &lt;&lt; iter-&gt;second;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// at()</span></span><br><span class="line"><span class="comment">// 根据key查找哈希表中的元素</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> elem = hmap.<span class="built_in">at</span>(<span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>遍历哈希表</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递遍历</span></span><br><span class="line"><span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; kv:map)&#123;</span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> kv:map)&#123;<span class="comment">// auto</span></span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; kv:map)&#123;<span class="comment">//&amp;</span></span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; kv:map)&#123;</span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=map.<span class="built_in">begin</span>();it!=map.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;it-&gt;first&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><p><a href="http://c.biancheng.net/view/7250.html">C++ STL unordered_set容器完全攻略 (biancheng.net)</a></p><table><thead><tr><th align="center">集合</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::set</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">否</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multiset</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">是</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_set</td><td align="center">哈希表</td><td align="center">无序</td><td align="center">否</td><td align="center">否</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><table><thead><tr><th align="center">映射</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::map</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multimap</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key可重复</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_map</td><td align="center">哈希表</td><td align="center">key无序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><ul><li><p>特性</p><ul><li>不再以键值对的形式存储数据，而是直接存储数据的值；</li><li>容器内部存储的各个元素的值都互不相等，且不能被修改；</li><li>不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关，可阅读《<a href="http://c.biancheng.net/view/7235.html">C++ STL无序容器底层实现原理</a>》一文做详细了解）；</li></ul><blockquote><p>对于 unordered_set 容器不以键值对的形式存储数据，读者也可以这样认为，即 unordered_set 存储的都是键和值相等的键值对，为了节省存储空间，该类容器在实际存储时选择只存储每个键值对的值。</p></blockquote></li><li><p>头文件</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>创建</li></ul><p>通过调用 unordered_set 模板类的默认构造函数，可以创建空的 unordered_set 容器。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;string&gt; uset;</span><br></pre></td></tr></table></figure><p>创建的同时进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;string&gt; uset&#123; <span class="string">&quot;string1&quot;</span>,<span class="string">&quot;string2&quot;</span>,<span class="string">&quot;string3&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>利用拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;string&gt; <span class="title">uset2</span><span class="params">(uset)</span></span>;</span><br></pre></td></tr></table></figure><p>直接用vector构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="keyword">int</span>&gt; <span class="title">to_delete_set</span><span class="params">(to_delete.begin(), to_delete.end())</span></span>;</span><br></pre></td></tr></table></figure><ul><li>添加新元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uset.<span class="built_in">insert</span>(x);</span><br></pre></td></tr></table></figure><ul><li>成员方法</li></ul><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器。</td></tr><tr><td>end();</td><td>返回指向容器中最后一个元素之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找值为 key 的元素的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新元素。</td></tr><tr><td>erase()</td><td>删除指定元素。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有元素。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_set 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_set 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储元素的数量。</td></tr><tr><td>bucket(key)</td><td>返回值为 key 的元素所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_set 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_set 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳 count 个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><a href="https://blog.csdn.net/yas12345678/article/details/52601454">(53条消息) C++中set用法详解_c++ set_Donny-You的博客-CSDN博客</a></p><ul><li>元素<strong>自动排序</strong>，这为查找元素提供了良好性能，但同时也造成了一个重要限制：不能直接改变元素值，因为这会打乱原本正确的顺序。（unordered_set 里面的元素是无序的）</li><li>底部实现是非常高效的平衡检索二叉树：红黑树（Red-Black Tree）RB树。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>()     　　 ,返回set容器的第一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>() 　　　　 ,返回set容器的最后一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>()   　　     ,删除set容器中的所有的元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>() 　　　,判断set容器是否为空</span><br><span class="line"></span><br><span class="line"><span class="built_in">max_size</span>() 　 ,返回set容器可能包含的元素最大个数</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>() 　　　　 ,返回当前set容器中的元素个数</span><br><span class="line"></span><br><span class="line">rbegin　　　　 ,返回的值和<span class="built_in">end</span>()相同</span><br><span class="line"></span><br><span class="line"><span class="built_in">rend</span>()　　　　 ,返回的值和<span class="built_in">rbegin</span>()相同</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p><a href="http://c.biancheng.net/view/480.html">C++ priority_queue(STL priority_queue)用法详解 (biancheng.net)</a></p><ul><li>最小堆：最小的元素会排在队列前面</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;string, vector&lt;string&gt;,greater&lt;string&gt;&gt; words1 </span><br></pre></td></tr></table></figure><ul><li>最大堆【默认】</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;string, vector&lt;string&gt;,less&lt;string&gt;&gt; words1 </span><br></pre></td></tr></table></figure><ul><li>基础操作</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push</span>(<span class="keyword">const</span> T&amp; obj)：<span class="comment">//将obj的副本放到容器的适当位置，这通常会包含一个排序操作。</span></span><br><span class="line"><span class="built_in">push</span>(T&amp;&amp; obj)：<span class="comment">//将obj放到容器的适当位置，这通常会包含一个排序操作。</span></span><br><span class="line"><span class="built_in">emplace</span>(T constructor a rgs...)：<span class="comment">// 通过调用传入参数的构造函数，在序列的适当位置构造一个T对象。为了维持优先顺序，通常需要一个排序操作。</span></span><br><span class="line"><span class="built_in">top</span>()：<span class="comment">// 返回优先级队列中第一个元素的引用。</span></span><br><span class="line"><span class="built_in">pop</span>()：<span class="comment">// 移除第一个元素。</span></span><br><span class="line"><span class="built_in">size</span>()：<span class="comment">// 返回队列中元素的个数。</span></span><br><span class="line"><span class="built_in">empty</span>()：<span class="comment">// 如果队列为空的话，返回true。</span></span><br><span class="line"><span class="built_in">swap</span>(priority_queue&lt;T&gt;&amp; other)：<span class="comment">// 和参数的元素进行交换，所包含对象的类型必须相同。</span></span><br></pre></td></tr></table></figure><h2 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h2><h3 id="字符串和数字的转换"><a href="#字符串和数字的转换" class="headerlink" title="字符串和数字的转换"></a>字符串和数字的转换</h3><p><a href="https://blog.csdn.net/fengbohello/article/details/115499395">(49条消息) C++：字符串和数字的转换_number 转std::string_miaow~miaow的博客-CSDN博客</a></p><ul><li>数字转字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">int</span> value)</span></span>;   </span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> value)</span></span>;   </span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>字符串转数字</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="增删改查（含vector）"><a href="#增删改查（含vector）" class="headerlink" title="增删改查（含vector）"></a>增删改查（含vector）</h3><p><a href="http://c.biancheng.net/view/2236.html">C++ string详解，C++字符串详解 (biancheng.net)</a></p><p><a href="https://blog.csdn.net/qiancm/article/details/119611928">(49条消息) vector 详解（C++）_vector c++_偏安一隅任逍遥的博客-CSDN博客</a></p><ul><li>提取字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;first second third&quot;</span>;</span><br><span class="line">string s2;</span><br><span class="line">s2 = s1.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><ul><li>删</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/af58c3d0f1989d3a8e639567a5106028.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// erase</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除元素 2</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove</span></span><br><span class="line">deque&lt;<span class="keyword">double</span>&gt; samples&#123; <span class="number">1.5</span>, <span class="number">2.6</span>, <span class="number">0.0</span>, <span class="number">3.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.0</span>, <span class="number">6.7</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">samples.<span class="built_in">erase</span>(<span class="built_in">remove</span>(<span class="built_in">begin</span>(samples), <span class="built_in">end</span>(samples), <span class="number">0.0</span>), <span class="built_in">end</span>(samples));</span><br></pre></td></tr></table></figure><blockquote><p>在vector中，remove的时候只是通过迭代器的指针向前移动来删除，将没有被删除的元素放在链表的前面，并返回一个指向新的超尾值的迭代器。由于remove()函数不是vector成员函数，因此不能调整vector容器的长度。<a href="https://blog.csdn.net/qq_37529913/article/details/125568345">(49条消息) C++ remove()函数用法详解(深入了解,一文学会)_双子座断点的博客-CSDN博客</a></p></blockquote><h1 id="—–算法"><a href="#—–算法" class="headerlink" title="—–算法"></a>—–算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(first_pointer,first_pointer+n,cmp);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ul><li>原理</li></ul><p>sort并不是简单的<strong>快速排序</strong>，它对快速排序进行了优化。此外，它还结合了<strong>插入排序</strong>和<strong>堆排序</strong>。</p><p>系统会根据<u>数据形式和数据量</u>自动选择合适的排序方法。它每次排序中不只选择一种方法，</p><p>比如给一个数据量较大的数组排序，开始采用<u>快速排序</u>，分段递归，</p><p>分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择<u>插入排序</u>，</p><p>如果递归的太深，他会选择<u>堆排序</u>。</p><ul><li>sort扩展</li></ul><p>【自定义比较函数】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;<span class="comment">//降序排列</span></span><br><span class="line"><span class="comment">//return a&lt;b;//默认的升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(A,A+<span class="number">100</span>,cmp1);</span><br></pre></td></tr></table></figure><p>【使用标准库函数】</p><p>functional提供了一堆基于模板的比较函数对象：equal_to、not_equal_to、greater、greater_equal、less、less_equal。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单使用方法</span></span><br><span class="line"><span class="built_in">sort</span>(A,A+<span class="number">100</span>,greater&lt;<span class="keyword">int</span>&gt;());<span class="comment">//降序排列</span></span><br><span class="line"><span class="built_in">sort</span>(A,A+<span class="number">100</span>,less&lt;<span class="keyword">int</span>&gt;());<span class="comment">//升序排列</span></span><br></pre></td></tr></table></figure><p>【重载结构体或类的比较运算符】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：在结构体内部重载</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">double</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Student&amp; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> id&gt;s.id;<span class="comment">//降序排列</span></span><br><span class="line">        <span class="comment">//return id&lt;s.id;//升序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Student&gt; V;</span><br><span class="line"><span class="built_in">sort</span>(V.<span class="built_in">begin</span>(),V.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>底层实现：顺序查找（逐个遍历）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><p>底层实现：二分查找，数据处于有序状态。</p><p>用于在指定区域内查找<strong>不小于（≥）目标值的第一个元素</strong>。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</p><p><a href="http://c.biancheng.net/view/7521.html">C++ lower_bound()函数用法详解 (biancheng.net)</a> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 [first, last) 区域内查找不小于 val 的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个正向迭代器。查找成功时，迭代器指向找到的元素；反之，如果查找失败，迭代器的指向和 last 迭代器相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//从 a 数组中找到第一个不小于 3( &gt;= 3)的元素</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">lower_bound</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycomp2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i, <span class="keyword">const</span> <span class="keyword">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; myvector&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">//根据 mycomp2 规则，从 myvector 容器中找到第一个违背 mycomp2 规则的元素</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator iter = <span class="built_in">lower_bound</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="built_in">mycomp2</span>());</span><br></pre></td></tr></table></figure><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><p>在指定范围内查找<strong>大于（＞）</strong>目标值的第一个元素.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找[first, last)区域中第一个大于 val 的元素。</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="取整"><a href="#取整" class="headerlink" title="取整"></a>取整</h2><p><a href="https://blog.csdn.net/dangzhangjing97/article/details/81279862">C语言（C++）中：详解floor函数、ceil函数和round函数_c语言 floor 函数-CSDN博客</a></p><h3 id="向上取整-ceil"><a href="#向上取整-ceil" class="headerlink" title="向上取整 ceil()"></a>向上取整 ceil()</h3><h3 id="向下取整floor"><a href="#向下取整floor" class="headerlink" title="向下取整floor()"></a>向下取整floor()</h3><h3 id="四舍五入round"><a href="#四舍五入round" class="headerlink" title="四舍五入round()"></a>四舍五入round()</h3><p><img src="https://img-blog.csdnimg.cn/e952e82683f042d6a4356734163dfba7.png" alt="img"></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247509201&idx=1&sn=14220c694a1dc800386fbbae45b58491&chksm=f9a19780ced61e96f439063f8d957812bab6e4bc51fe68ebe05526756107ded2d71b97cf13e4&scene=132&exptype=timeline_recommend_article_extendread_samebiz#wechat_redirect">腾讯一面，跪….. (qq.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/400033519">游戏开发面试真题合集 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <summary type="html">关于C++知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
</feed>

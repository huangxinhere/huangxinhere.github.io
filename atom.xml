<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hx&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/32690cfd58b9093251b720ee371b49ad</icon>
  <subtitle>aha</subtitle>
  <link href="https://huangxinhere.github.io/atom.xml" rel="self"/>
  
  <link href="https://huangxinhere.github.io/"/>
  <updated>2023-08-18T01:06:03.815Z</updated>
  <id>https://huangxinhere.github.io/</id>
  
  <author>
    <name>(●ˇ∀ˇ●)</name>
    <email>1159390360@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-知识整理</title>
    <link href="https://huangxinhere.github.io/2023/07/30/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://huangxinhere.github.io/2023/07/30/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-07-29T16:00:00.000Z</published>
    <updated>2023-08-18T01:06:03.815Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903517648355342">到底是用”静态类”还是单例 - 掘金 (juejin.cn)</a></p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><p>单例模式指的是在应用<em><strong>整个生命周期内只能存在一个实例。</strong></em>单例模式是一种被广泛使用的设计模式。</p><p>他有很多好处，能够避免实例对象的重复创建，减少创建实例的系统开销，节省内存。</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li>饿汉模式</li></ul><p>所谓饿汉模式就是立即加载，一般情况下再调用getInstancef方法之前就已经产生了实例，也就是在类加载的时候已经产生了。这种模式的缺点很明显，就是占用资源，当单例类很大的时候，其实我们是想使用的时候再产生实例。因此这种方式适合占用资源少，在初始化的时候就会被用到的类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class SingletonHungary &#123;</span><br><span class="line">    private static SingletonHungary singletonHungary = new SingletonHungary();</span><br><span class="line">    //将构造器设置为private禁止通过new进行实例化</span><br><span class="line">    private SingletonHungary() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonHungary getInstance() &#123;</span><br><span class="line">        return singletonHungary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>懒汉模式</li></ul><h2 id="在Unity中的实践"><a href="#在Unity中的实践" class="headerlink" title="在Unity中的实践"></a>在Unity中的实践</h2><p>如果挂载在场景物体上面，由于继承MonoBehaviour所以构造函数应该不会私有化，也就是说受unity的生命周期控制，如果场景中多个挂载的话，就有多个实例。</p><p>如果是挂载的，就放在Awake里面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    public static Singleton Instance;</span><br><span class="line">    </span><br><span class="line">    Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if(instance == null)// 在场景多个实例取第一个作为单例？</span><br><span class="line">            instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不继承monobehavior，就按照一般的情况来处理。</p><ul><li>和DontDestroyOnLoad结合使用</li></ul><p>对DontDestroyOnLoad的理解：比如在场景A对A中的一个物体a进行这个方法的处理，那么就把a放入DontDestroyOnLoad场景里面。这样在场景BCD加载的时候，由于<strong>DontDestroyOnLoad</strong>场景一直保持、没有重新加载，所以该场景的脚本都一直保持。</p><p>但是回到场景A的时候，由于A里面本来就有物体a，那么加载A就必然加载a，这样的话如果重复回到A就会有多个a（如果场景B也有a，应该也会重复出现？）都扔到DontDestroyOnLoad里面去了。</p><p>所以处理方法就是，如果有哪个场景持有物体a，想要再次初始化的时候，就用单例或者布尔变量标记这个物体已经处理过了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class GameManager : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">private static GameManager _instance;   // 单例</span><br><span class="line">public GameManager GameManagerInstance</span><br><span class="line">    &#123;</span><br><span class="line">        get &#123; return _instance; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_instance != null)</span><br><span class="line">        &#123;</span><br><span class="line">        //这里一定要是销毁this.gameObject</span><br><span class="line">            Destroy(this.gameObject);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //这句话只执行一次，第二次上面return了</span><br><span class="line">        _instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>或者用静态布尔变量来标记已经处理过了。</p></blockquote><p>或者考虑某个场景只进入一次。</p><h2 id="与静态类的区别"><a href="#与静态类的区别" class="headerlink" title="与静态类的区别"></a>与静态类的区别</h2><p>首先理解一下什么是静态类，静态类就是一个类里面都是静态方法和静态field，构造器被<a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a>修饰，因此不能被实例化。Math类就是一个静态类。</p><p>1）首先单例模式会提供给你一个全局唯一的对象，静态类只是提供给你很多静态方法，这些方法不用创建对象，通过类就可以直接调用；</p><p>2）<em><strong>单例模式的灵活性更高，方法可以被override，因为静态类都是静态方法，所以不能被override；</strong></em></p><p>3）如果是一个非常重的对象，单例模式可以懒加载，静态类就无法做到；</p><p>那么时候时候应该用静态类，什么时候应该用单例模式呢？</p><p>首先如果你只是想使用一些工具方法，那么最好用静态类，<em><strong>静态类比单例类更快</strong></em>，因为静态的绑定是在编译期进行的。</p><p><em><strong>如果你要维护状态信息，或者访问资源时，应该选用单例模式。</strong></em>还可以这样说，当你需要面向对象的能力时（比如继承、多态）时，选用单例类，当你仅仅是提供一些方法时选用静态类。</p><p><a href="https://zhuanlan.zhihu.com/p/542442083">C#中的单例类与静态类 - 知乎 (zhihu.com)</a></p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p><a href="https://juejin.cn/post/6989591565295419400">一文彻底弄懂工厂模式(Factory) - 掘金 (juejin.cn)</a></p><p><a href="https://zhuanlan.zhihu.com/p/83535678">C++ 深入浅出工厂模式（初识篇） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/83537599">C++ 深入浅出工厂模式（进阶篇） - 知乎 (zhihu.com)</a></p><p>这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><p><a href="https://zhuanlan.zhihu.com/p/39096277">Unity中使用简易MVC详解 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903517648355342&quot;&gt;到底是用”静态类”还是单例 - 掘金 (juejin.cn)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huangxinhere.github.io/2023/07/04/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93-Unity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BFishnet/"/>
    <id>https://huangxinhere.github.io/2023/07/04/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93-Unity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BFishnet/</id>
    <published>2023-07-04T08:18:28.933Z</published>
    <updated>2023-07-08T07:43:45.980Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="Server和Client"><a href="#Server和Client" class="headerlink" title="Server和Client"></a>Server和Client</h2><p><img src="/2023/07/04/%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93-Unity%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BFishnet/hexo_github_blog\source_posts\实践总结-Unity网络编程Fishnet.assets\image-20230708152931525.png" alt="image-20230708152931525"></p><ul><li><p>独立：目前理解是，server和clients分别拥有一个运行的“单机”游戏，逻辑都一样运行，但联机不同的是，每端都有ID，分为Client和Server两类，根据ID不同 判断并执行逻辑。</p></li><li><p>共享 / 同步：联机的意义在于“异步中的同步”，比如玩家控制的一个角色，在ABC三个端都是同步的，理想状态是相同时刻执行的效果相同。</p><ul><li><p>通过服务器：服务器作为“总部”负责接收单个客户端的请求，并把更新的信息（客户端或服务器的更新）告诉给所有客户端。</p><p>ServerRpc：直接请求服务器；</p><p>变量同步：基于对象，在对象上修改 SyncType 时，更改会自动从服务器发送到客户端（以可调整的间隔发送）。客户端将在同一对象上本地接收更改。</p></li><li><p>广播：不分服务器和客户端，只要有更新，监听的所有Observer都进行更新。（ObserverRpc、Observer组件）</p></li><li><p>各端的沟通：RPCs。默认是单机执行逻辑，如果要通知其它端，就要用到Rpc</p></li></ul></li></ul><h1 id="在没有继承NetworkBehaviour的脚本中Spawn新的物体"><a href="#在没有继承NetworkBehaviour的脚本中Spawn新的物体" class="headerlink" title="在没有继承NetworkBehaviour的脚本中Spawn新的物体"></a>在没有继承NetworkBehaviour的脚本中Spawn新的物体</h1><p>由于人物状态机用了ScriptableObject，无法继承NetworkBehavior，所以简单的一个ServerRpc的Spawn使用不了，充满了曲折与辛酸泪。</p><h2 id="instancefinder"><a href="#instancefinder" class="headerlink" title="instancefinder"></a>instancefinder</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GameObject currObj = Instantiate(currPrefab, pos, Quaternion.identity);</span><br><span class="line">InstanceFinder.ServerManager.Spawn(currObj, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>在客户端调用不了，警告：<code>Cannot spawn object because server is not active and predicted spawning is not enabled.</code></p><p>在客户端和server一起的（host？）就可以。也就是服务器端才能使用？任何关于网络物体的操作似乎都要继承NetworkBehaviour，作为一个网络物体才能和server client链接？</p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>那我在这个脚本用不了，调用其它脚本的方法总可以吧？可惜构建物体的参数作为传参放入rpc方法的话不可行，因为不可序列化（例如Sprite、Collider这些不行）。</p><p>回调也不行，想用action作为构建物体的包装方法，在invoke触发，但action不可序列化；同时泛型类型参数也不允许。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ToCallServerRpc</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; action, T arg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    action?.Invoke(arg);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li><p>对于Rpc能传的参数类型感到非常疑惑：首先我第一个认识是不可序列化的不能传，然后是GameObject类型可以，接着是Transform能传但传进方法里面就为空？有什么规律吗……</p><p><code>GameObject bone_4 cannot be serialized because it does not have a NetworkObject nor NetworkBehaviour.</code></p><p>看来要有相关的网络设置才能被序列化……</p></li></ul><blockquote><p>可序列化的：（待完善，感觉ai不完全对）</p><ol><li>基本数据类型（Primitive Types）：包括整数（int，float，double等），布尔值（bool），字符（char）等。</li><li>string</li><li>Array</li><li>List和其他集合类型</li><li>枚举（Enum）：Unity能够序列化枚举类型，使其在Inspector窗口中可编辑。</li><li>自定义的可序列化类（Custom Serializable Classes）：你可以创建自己的类，并使用[SerializeField]属性将其标记为可序列化。这样，类的成员变量可以在Inspector窗口中显示并编辑。</li><li>Unity内置组件（Built-in Unity Components）：Unity内置的一些组件，如Transform，MeshRenderer，Rigidbody等，都是可序列化的。</li></ol><p>不是所有类型都可以被Unity直接序列化。一般来说，只有继承自Unity提供的可序列化基类（如MonoBehaviour）或标记为可序列化的类型才能被序列化。</p></blockquote><h2 id="类的字段"><a href="#类的字段" class="headerlink" title="类的字段"></a>类的字段</h2><p>我不用传参，我用类的字段总可以吧？最好不这样做。因为server端的脚本变量和client不互通，所以server的脚本变量会是空的，serverRpc会用空的变量执行那个方法。真麻了</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>原来除了基础类型，GameObject也可以当作传参！麻了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;Server和Client&quot;&gt;&lt;a href=&quot;#Server和Client&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统：Unity</title>
    <link href="https://huangxinhere.github.io/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/"/>
    <id>https://huangxinhere.github.io/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/</id>
    <published>2023-06-16T16:00:00.000Z</published>
    <updated>2023-06-20T02:40:29.005Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/19972689">Unity将来时：IL2CPP是什么？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/smilejoi/p/14785295.html">Unity为什么能够使用c#进行开发—-原理篇 - zhengjiayu - 博客园 (cnblogs.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/591320059">Unity中C#的底层原理 - 知乎 (zhihu.com)</a></p><h1 id="从编译原理说起"><a href="#从编译原理说起" class="headerlink" title="从编译原理说起"></a>从编译原理说起</h1><p>一句话介绍编译器：编译器是将用某种程式语言写成的源代码（源语言），转换成另一种程式语言（目标语言）等价形式的程序。</p><p>通常我们是将某种高级语言（如C、C++、C# 、Java）转换成低级语言（汇编语言、机器语言）。<br>编译器以流水线的形式进行工作，分为几个阶段：源代码 → 词法分析 → 语法分析 → 语义分析 → 目标代码 → 链接 → 可执行文件。</p><blockquote><p><strong>链接（linking）解释：</strong>上一步骤的结果可能会引用外部的函数，把外部函数的代码（通常是后缀名为.lib和.a的文件），添加到可执行文件中，这就叫做链接。——两种，静态链接（编译时）和动态链接（runtime）。 </p></blockquote><p>现代编译器还会更复杂，中间会增加更多的处理过程，比如预处理器，中间代码生成，代码优化等。</p><p><img src="https://img-blog.csdn.net/20180927202022582?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTMzMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><blockquote><p>借用C++的编译过程。</p></blockquote><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><p>虚拟机（VM），简单理解，就是可以执行特定指令的一种程序。为了执行指令，还需要一些配套的设施，如寄存器、栈等。虚拟机可以很复杂，复杂到模拟真正的计算机硬件，也可以很简单，简单到只能做加减乘除。</p><p>在编译器领域，虚拟机通常执行一种叫中间代码的语言，中间代码由高级语言转换而成，以 Java 为例，Java 编译后产生的并不是一个可执行的文件，而是一个 ByteCode （字节码）文件，里面包含了从 Java 源代码转换成等价的字节码形式的代码。Java 虚拟机（JVM）负责执行这个文件。</p><p>虚拟机执行中间代码的方式分为 2 种：解释执行和 <strong>JIT（即时编译）</strong>。解释执行即逐条执行每条指令，JIT 则是先将中间代码在开始运行的时候编译成机器码，然后执行机器码。由于执行的是中间代码，所以，在不同的平台实现不同的虚拟机，都可以执行同样的中间代码，也就实现了跨平台。</p><p>总结一下，虚拟机本身并不跨平台，而是语言是跨平台的，对于开发人员来说，只需要关心开发语言即可，不需要关心虚拟机是怎么实现的，这也是 Java 可以跨平台的原因，C# 也是同样的。推而广之，理论上任何语言都可以跨平台，只要在相应平台实现了编译器或者虚拟机等配套设施。</p><h1 id="C-、CIL、CLR与反射"><a href="#C-、CIL、CLR与反射" class="headerlink" title="C#、CIL、CLR与反射"></a>C#、CIL、CLR与反射</h1><p>C# 和 Java 类似，C# 会编译成一个中间语言（CIL，Common Intermediate Language，也叫 MSIL），CIL 也是一个高级语言，而<strong>运行 CIL 的虚拟机叫 CLR</strong>（Common Language Runtime）。</p><p>通常我们把 C#、CIL、CLR，再加上微软提供的一套基础类库称为 .Net Framework。</p><p><img src="/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/hexo_github_blog\source_posts\知识整理-操作系统：Unity.assets\image-20230617221205492.png" alt="image-20230617221205492"></p><ul><li>.NET语言的编译器接受源代码文件，并生成名为<strong>程序集</strong>的输出文件。程序集包含的信息中，包括下列项目：<ul><li>程序的<strong>CIL</strong>：Common Intermediate Language 公共中间语言 / IL / MSIL；不是本机代码，是一种中间语言。</li><li>程序中使用的类型的元数据；</li><li>对其他程序集引用的<strong>元数据</strong>。</li></ul></li></ul><blockquote><p>元数据：为了CLR能够向托管代码提供服务，语言编译器必须产出元数据（描述类型、成员、引用的文件），每一个PE文件（可移植、可执行文件，表现为exe、dll等格式的文件）都需要包含元数据。<u>CLR需要元数据来生成机器码</u>。</p></blockquote><ul><li>CIL直到被调用运行时才会被编译成本机代码；在运行时，<strong>CLR</strong>执行以下步骤：<ul><li>检查程序集的安全性；</li><li>在内存中分配空间；</li><li>把程序集中的可执行代码发送给即时（just-in-time，<strong>JIT</strong>）编译器，把其中一部分编译成本机代码。</li></ul></li></ul><p><img src="/2023/06/17/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9AUnity/hexo_github_blog\source_posts\知识整理-操作系统：Unity.assets\image-20230617222202975.png" alt="image-20230617222202975"></p><p>.NET 框架的核心组件是CLR，它在操作系统的顶层，负责管理程序的执行。</p><ul><li><p>反射：C#编写的程序会编译成一个程序集(.DLL或.exe)，其中会包含元数据、编译代码和资源，通过反射可以获取到程序集中的信息。通俗来讲，反射就是我们在只知道一个对象的外部而不了解内部结构的情况下，可以知道这个对象的内部实现。</p><p>反射可以做到的事情：</p><ul><li><p>通过Type类获取程序集、模块、类的信息；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a = &#123; <span class="number">42</span>, <span class="number">34</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// Start is called before the first frame update</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Type type = a.GetType();</span><br><span class="line">    Debug.Log(type);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Name: &quot;</span> + type.Name);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Assembly: &quot;</span> + type.Assembly);</span><br><span class="line">    Debug.Log(<span class="string">&quot;BaseType: &quot;</span> + type.BaseType);</span><br><span class="line">    Debug.Log(<span class="string">&quot;Is class? &quot;</span> + type.IsClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态创建实例：这种方式比new效率要低；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Reflection</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">     <span class="comment">//创建一个类的实例</span></span><br><span class="line">        <span class="built_in">object</span> c = Activator.CreateInstance(<span class="keyword">typeof</span>(TestClass), <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        Debug.Log(c.ToString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个结构体的实例</span></span><br><span class="line">        student stua = (student)Activator.CreateInstance(<span class="keyword">typeof</span>(student));</span><br><span class="line">        stua.name = <span class="string">&quot;kk&quot;</span>;</span><br><span class="line">        stua.age = <span class="number">12</span>;</span><br><span class="line">        Debug.Log(<span class="string">&quot;The boy &quot;</span> + stua.name + <span class="string">&quot; is &quot;</span> + stua.age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestClass</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> student</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowName</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取方法或者动态调用方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Reflection</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">object</span> c = Activator.CreateInstance(<span class="keyword">typeof</span>(TestClass), <span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        Debug.Log(c.ToString());</span><br><span class="line">        <span class="keyword">var</span> m1 = c.GetType().GetMembers();</span><br><span class="line">        <span class="keyword">var</span> m2 = c.GetType().GetMethod(<span class="string">&quot;ShowName&quot;</span>);</span><br><span class="line">        m2.Invoke(c, <span class="literal">null</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> str;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestClass</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowName</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;this is a test class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><a href="https://blog.csdn.net/LLLLL__/article/details/118695042">(53条消息) C#中的反射_c# 反射_Hello Bug.的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_39847278/article/details/129816667?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-129816667-blog-118695042.235%5Ev38%5Epc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-2-129816667-blog-118695042.235%5Ev38%5Epc_relevant_sort_base1&utm_relevant_index=5">(53条消息) c#之反射详解_c# 反射_鲤籽鲲的博客-CSDN博客</a>【超详细】</p><h1 id="Net-Framework-vs-Mono"><a href="#Net-Framework-vs-Mono" class="headerlink" title=".Net Framework vs Mono"></a>.Net Framework vs Mono</h1><p>Mono 是跨平台的 .Net Framework 的实现。Mono 做了一件很了不起的事情，将 CLR 在所有支持的平台上重新实现了一遍，将 .Net Framework 提供的基础类库也重新实现了一遍。</p><p><img src="https://img2020.cnblogs.com/blog/1565924/202007/1565924-20200701114759725-520977280.png" alt="img"></p><blockquote><p>以上，Compile Time 的工作实际上可以直接用微软已有的成果，只要将 Runtime 的 CLR 在其他平台实现，这个工作量不仅大，而且需要保证兼容，非常浩大的一个工程，Mono 做到了，致敬！</p></blockquote><ul><li><p>Unity3D 内嵌了一个 Mono 虚拟机，从上文可以知道，当实现了某个平台的虚拟机，那语言就可以在该平台运行，所以，严格的讲，Unity3D 是通过 Mono 虚拟机，运行 C# 通过编译器编译后生成的 CIL 代码。</p><p>Unity3D 默认使用 C# 作为开发语言，除此之外，还支持 JS 和 BOO，因为 Unity3D 开发了相应的编译器，将 JS 和 BOO 编译成了 IL。</p></li><li><p>C# 在 Windows 下，是通过微软的 C# 编译器，生成了 CIL 代码，运行在 CLR 中。</p></li><li><p>C# 在除 Windows 外的平台下，是通过 Mono 的编译器，生成了 CIL 代码，运行在 Mono 虚拟机中，也可以直接运行将已经编译好的 CIL 代码（通过任意平台编译）。</p></li></ul><h1 id="IL2CPP、IL2CPP-VM"><a href="#IL2CPP、IL2CPP-VM" class="headerlink" title="IL2CPP、IL2CPP VM"></a>IL2CPP、IL2CPP VM</h1><p>把IL中间语言转换成CPP文件。大家如果看明白了上面动态语言的 CLI， IL以及VM，再看到IL2CPP一定心中充满了疑惑。现在的大趋势都是把语言加上动态特性，哪怕是c++这样的静态语言，也出现了适合IL的c++编译器，为啥Unity要反其道而行之，把IL再弄回静态的CPP呢？</p><ul><li><p>mono的核心原理是，将C#代码，转化成 IL 中间代码，然后通过各个平台的mono虚拟机解释执行，在运行时，解释的过程中，最终转化成了机器码。</p></li><li><p>而 il2cpp，是在各个平台，先将 C# 转化成 C++ 代码，然后通过各个平台的C++编译器直接生成了机器码，也就是在你发包的时候已经是机器码了，所以很快。</p></li><li><p>另外，il2cpp 生成出的项目 无法反编译，这相当于将C#代码加密了；而 mono生成出的项目，是可以 ILSpy 反编译出来的。</p></li></ul><p>使用Mono的时候，脚本的编译运行如下图所示：</p><p><img src="https://pic4.zhimg.com/80/a0c8e96a34348e26ea2f7763e3452ae3_1440w.webp" alt="img"></p><p>简单的来说，3大脚本被编译成IL，在游戏运行的时候，IL和项目里其他第三方兼容的DLL一起，放入Mono VM虚拟机，由虚拟机解析成机器码，并且执行;</p><p>加入红色部分后，就是在得到中间语言IL后，使用IL2CPP将他们重新变回C++代码，然后再由各个平台的C++编译器直接编译成能执行的原生汇编代码。</p><ul><li>将IL变回CPP的目的除了CPP的执行效率快以外，另一个很重要的原因是可以利用现成的在各个平台的C++编译器对代码执行编译期优化，这样可以进一步减小最终游戏的尺寸并提高游戏运行速度。</li><li>由于动态语言的特性，他们多半无需程序员太多关心内存管理，所有的内存分配和回收都由一个叫做GC（Garbage Collector）的组件完成。虽然通过IL2CPP以后代码变成了静态的C++，但是内存管理这块还是遵循C#的方式，这也是为什么最后还要有一个 IL2CPP VM的原因：它负责提供诸如GC管理，线程创建这类的服务性工作。但是由于去除了IL加载和动态解析的工作，使得IL2CPP VM可以做的很小，并且使得游戏载入时间缩短。</li></ul><h1 id="Unity与内存"><a href="#Unity与内存" class="headerlink" title="Unity与内存"></a>Unity与内存</h1><p>[Unity的内存管理与性能优化 - 知乎 (zhihu.com)](<a href="https://zhuanlan.zhihu.com/p/362941227#:~:text=Unity%E7%9A%84VM%EF%BC%88%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AVirtual">https://zhuanlan.zhihu.com/p/362941227#:~:text=Unity的VM（虚拟机：Virtual</a> Machine）依旧还是存在，主要用于跨平台，有了一层VM抽象后，跨平台的工作会容易很多，IL2CPP本身也是个VM。 Unity内存按照分配方式分为： Native Memory,（原生内存）和 Managed Memory （托管内存）。 Native Memory并不会被系统自动管理，需要我们手动去释放。)【超详细！！可多翻看】</p><p><a href="https://zhuanlan.zhihu.com/p/370467923">Unity游戏内存分布概览 - 知乎 (zhihu.com)</a></p><h2 id="内存相关概念"><a href="#内存相关概念" class="headerlink" title="内存相关概念"></a>内存相关概念</h2><h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><h4 id="缓存和Cache-Miss"><a href="#缓存和Cache-Miss" class="headerlink" title="缓存和Cache Miss"></a>缓存和Cache Miss</h4><p>物理内存也就是我们真的硬件设备，例如内存条。</p><p>我们需要知道，<strong>CPU访问内存是一个慢速过程。</strong></p><p>访问过程具体为：先访问Cache，Cache包含L1，L2，L3，也就是一级缓存，二级缓存和三级缓存，若在这些缓存里全没找到我们要的数据，再去访问内存，接着会把找到的数据存放到Cache中，完成一次操作。</p><p>在Cache中没有找到数据，我们称之为<strong>Cache Miss</strong>。因此<strong>过多的Cache Miss就会导致大量的内存和Cache的IO交换，浪费大量时间</strong>。</p><p>因此我们需要尽量减少Cache Miss，来提高访问速度，Unity为此提出了<strong>ECS</strong>方案，有兴趣的小伙伴可以看看之前有关<a href="https://link.zhihu.com/?target=https://blog.csdn.net/wangjiangrong/article/details/106850847">ECS</a>介绍的文章，它们可以将存储在内存中的不连续数据，变为连续的数据，从而降低Cache Miss的概率。</p><h4 id="台式设备和移动设备内存架构的差异"><a href="#台式设备和移动设备内存架构的差异" class="headerlink" title="台式设备和移动设备内存架构的差异"></a>台式设备和移动设备内存架构的差异</h4><ol><li>首先移动设备没有独立显卡。</li><li>移动设备没有独立显存（显存的作用是用来存储显卡芯片处理过或者即将提取的渲染数据），所有在<u>移动端数据内存和显存是同一块内存</u>。所以有可能我们游戏占用的内存并不大，但是依旧爆内存了，其实是因为显存分配不出来了。这种情况，我们可以去查看一下Log，例如Android会有一个 OpenGL Error：Out Of Memory。</li><li>移动设备的CPU面积更小，因此会导致<u>缓存级数更少，大小也更小</u>，例如一般的台式机三级缓存可能有8-16M，而移动设备则只有2M左右。</li></ol><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>虚拟内存是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。</p><h4 id="内存交换"><a href="#内存交换" class="headerlink" title="内存交换"></a>内存交换</h4><p>操作系统在使用内存不够的情况下，会尝试把一些不用的内存（Dead Memory）交换到硬盘上，从而节省出更多的物理内存。这个操作我们称之为<strong>内存交换</strong>，它会占用大量的硬盘空间。</p><p><strong>然而移动设备不做该操作</strong>，因为移动设备的IO速度很慢，而且移动设备的可存储物（例如sd卡，内存芯片等）的可擦写次数也比硬盘少很多，会影响使用寿命。</p><h3 id="内存压缩"><a href="#内存压缩" class="headerlink" title="内存压缩"></a>内存压缩</h3><p>在IOS中（Android没有）会将不活跃的内存压缩起来存储到一个特定空间里，来节省出物理内存空间，来给活跃的app使用，这个操作称之为<strong>内存压缩</strong>。（可以查看XCode的Virtual Memory）</p><h3 id="内存寻址范围"><a href="#内存寻址范围" class="headerlink" title="内存寻址范围"></a>内存寻址范围</h3><p>内存寻址范围也称寻址空间，指的是CPU对于内存寻址的能力（最大能查找多大范围的地址）。数据在内存中存放是有规律的，CPU在运算的时候需要把数据提取出来就需要知道数据在那里，这时候就需要挨家挨户的找，这就叫做<strong>寻址</strong>，但如果地址太多超出了CPU的能力范围，CPU就无法找到数据了。</p><p>内存寻址范围和Memory Controller（内存控制器）有关，和运算位数（32位或64位）无直接关系。当然一般情况下，64位的CPU寻址范围更大。</p><h2 id="Unity的内存管理"><a href="#Unity的内存管理" class="headerlink" title="Unity的内存管理"></a>Unity的内存管理</h2><h3 id="Unity是一个C-引擎"><a href="#Unity是一个C-引擎" class="headerlink" title="Unity是一个C++引擎"></a>Unity是一个C++引擎</h3><p>Unity是一个C++引擎，并不是C#引擎，底层代码全部是由c++写的，除了一些Editor里面的Services可能会用到NodeJS这些网络的语言，Runtime里面用到的每一行Unity底层代码全是C++的。</p><p>Unity实际上分为三层：</p><ul><li>最底层是我们的Runtime，全是Native C++代码。</li><li>最上层是我们的C#，Unity自己有一些C#，例如Unity的Editor是用C#写的，还有些Package也是C#写的。</li><li><u>中间还有一层我们叫Binding</u>，可以看见很多的**.bindings.cs**文件（基于C#的binding语言，一开始是Unity自定义的一种语言），这些文件的作用就是<u>把C++和C#联系在一起，为我的C#层提供所有的API</u>。</li></ul><p>因此我们平时使用Unity时看见的C# API，都是在Binding层中自定义的。这些文件底层运行的时候还是C++，只是个Wrapper（封装）。</p><p>最早我们的用户代码是运行在C#上，是MonoRuntime。但是现在可以通过IL2CPP将其转成C++代码，所有现在几乎没有纯正的C#在运行了。</p><p>Unity的VM（虚拟机：Virtual Machine）依旧还是存在，主要用于跨平台，有了一层VM抽象后，跨平台的工作会容易很多，IL2CPP本身也是个VM。</p><h3 id="Unity内存管理"><a href="#Unity内存管理" class="headerlink" title="Unity内存管理"></a>Unity内存管理</h3><p><u>Unity内存按照分配方式</u>分为：<strong>Native Memory</strong>（原生内存）和<strong>Managed Memory</strong>（托管内存）。Native Memory并不会被系统自动管理，需要我们手动去释放。而Managed Memory的内存管理是自动的，会通过GC来释放。</p><p>此外Unity在Editor和Runtime下，内存的管理方式是不同的，除了内存大小不同，内存的分配时机以及分配方式也可能不同。</p><p>例如Asset，在Runtime时，只有我们Load的时候才会进内存。而Editor模式下，只要打开Unity就会进内存（所以打开很慢）。因此后续有推出<strong>Asset Pipeline 2.0</strong>，它会一开始导入一些基本的Asset，剩下的Asset只有你使用的时候才会导入。</p><p><u>Unity按照内存管理方式</u>分为：<strong>引擎管理内存</strong>和<strong>用户管理内存</strong>。引擎管理内存即引擎运行的时候自己要分配一些内存，例如很多的Manager和Singleton，这些内存开发者一般是碰触不到的。用户管理内存也就是我们开发者开发时使用到的内存，需要我们重点注意。</p><h4 id="Native-Memory"><a href="#Native-Memory" class="headerlink" title="Native Memory"></a>Native Memory</h4><h4 id="Managed-Memory"><a href="#Managed-Memory" class="headerlink" title="Managed Memory"></a>Managed Memory</h4><ul><li>VM内存池</li></ul><p>即Mono虚拟机的内存池，我们的内存以Block的形式管理，当一个Block<strong>连续6次</strong>GC没有被访问到，这块<strong>内存会被返回给系统</strong>，条件苛刻，比较难触发。（？</p><ul><li>GC</li></ul><h4 id="堆栈Stack和堆积Heap"><a href="#堆栈Stack和堆积Heap" class="headerlink" title="堆栈Stack和堆积Heap"></a>堆栈Stack和堆积Heap</h4><ul><li>堆栈</li></ul><p>堆栈是内存中存储<strong>函数</strong>和<strong>值类型</strong>的地方。</p><p>例如我们调用一个函数A，会将这个函数体与函数收到的参数放入到堆栈中，若在函数A中调用函数B，同样会把函数B存放到堆栈中。当函数B运行结束，会将其从堆栈中移除，然后当A运行结束，把A从堆栈中移除。</p><p>因此我们在看Debug信息的时候，就会发现Log里面能够做到一层层的方法回溯，方便我们查看整体的调用过程，这也就是<strong>堆栈回溯</strong>。</p><p>由于是堆栈的结构，因此不会遇到碎片化或是垃圾收集（GC）的问题。但是可能会碰见堆栈溢出的问题，比如调用了太多的函数导致一直push东西进堆栈，占据越来越多的内存空间，导致<strong>堆栈溢出</strong>。</p><ul><li>堆积</li></ul><p>堆积是内存中另一个区域，要比堆栈大，我们将所有的<strong>引用类型</strong>存放在这。通常我们每创建一个新的对象，会在堆积中找到下一个足够存放的空位置，将其存储。但是当我们销毁对象后，<strong>内存空间不会马上释放出来</strong>，而是标记成未使用，之后垃圾收集器会释放这部分空间。</p><p><strong>对象实例化和摧毁的过程其实很慢</strong>，所以我们要尽可能地避免在堆积中配置内存的行为。如果我们需要的内存比之前已经配置好的还多，在放不下的情况下，<strong>堆积会膨胀，并且每次都增长两倍，且不会再缩回去</strong>，过大的堆积就会影响到我们游戏的性能。当我们在堆积中释放了一些占用空间小的对象，而后添加一些占用空间大的对象时，由于前面释放的空间不足以存放下，就会导致这些空间空出来，使得内存的使用情况就变得断断续续起来，这也就是内存的<strong>碎片化</strong>，同样降低我们的游戏性能。</p><p>而我们前面所提到的GC就是在堆积上进行的，每一次GC，都会遍历堆积上所有的对象，找到需要释放的东西，也就是没有被引用的对象，然后将其释放。但是有时候我们的一些错误引用，导致一些我们希望释放掉的对象没有被GC掉，那么就会造成<strong>内存泄漏</strong>。</p><p>假如游戏玩到一半，GC必须要释放数十或数百个游戏对象的内存，那么这会对你的游戏过程造成一个负载峰值，我们要避免这样的负载峰值。</p><h2 id="优化Native-Memory"><a href="#优化Native-Memory" class="headerlink" title="优化Native Memory"></a>优化Native Memory</h2><h2 id="优化Managed-Memory"><a href="#优化Managed-Memory" class="headerlink" title="优化Managed Memory"></a>优化Managed Memory</h2><h3 id="Destroy与null"><a href="#Destroy与null" class="headerlink" title="Destroy与null"></a>Destroy与null</h3><p>用Destroy，别用null，显示的调用Destroy才能真正的销毁掉。</p><h3 id="Class和Struct"><a href="#Class和Struct" class="headerlink" title="Class和Struct"></a>Class和Struct</h3><p>根据具体使用情况选择Class或Struct。</p><h3 id="减少装箱拆箱操作"><a href="#减少装箱拆箱操作" class="headerlink" title="减少装箱拆箱操作"></a>减少装箱拆箱操作</h3><p>例如LINQ和常量表达式以装箱的方式实现，String.Format()也常常会产生装箱操作等。</p><h3 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h3><p>虽然VM自己有内存池，但是我们还是需要自己使用内存池来管理。</p><p>在游戏程序中，创建和销毁对象事很常见的操作，通常会通过 <strong>Instantiate</strong> 和 <strong>Destroy</strong> 方法来实现，如果频繁的进行这些操作，GC的时候会导致负载很重，因为会有大量的已摧毁对象的存在，不仅会造成CPU的负载峰值，还可能导致堆积碎片化。因此我们可以使用对象池来处理这类问题。</p><p>使用对象池时需要注意，要决定对象池的大小，以及一开始要产生多少数量的对象在池中。因为如果你需要的对象数量多过池中现有的，就必须将对象池变大，扩的太大可能造成浪费，扩的小可能又造成频繁的添加。</p><h3 id="闭包和匿名函数"><a href="#闭包和匿名函数" class="headerlink" title="闭包和匿名函数"></a>闭包和匿名函数</h3><p>所有的匿名函数和闭包在c#编IL代码时都会被new成一个Class（匿名class），所以在里面所有函数，变量以及new的东西，都是要占内存的。</p><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程属于闭包和匿名函数的特例，游戏开始启动一个协程直到游戏结束才释放，错误的做法。因为协程只要没被释放，里面的所有变量，即使是局部变量（包括值类型），也都会在内存里。建议用的时候才生产一个协程，不用的时候就丢掉。</p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>慎用单例，且不要什么都往里放，因为里面的变量会一直占用内存。</p>]]></content>
    
    
    <summary type="html">Unity的编译原理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法-刷题思考-算法思想</title>
    <link href="https://huangxinhere.github.io/2023/06/07/202367-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"/>
    <id>https://huangxinhere.github.io/2023/06/07/202367-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</id>
    <published>2023-06-06T16:00:00.000Z</published>
    <updated>2023-06-08T06:23:11.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="2611-老鼠和奶酪"><a href="#2611-老鼠和奶酪" class="headerlink" title="2611.老鼠和奶酪"></a>2611.老鼠和奶酪</h2><blockquote><p>一共有n块奶酪，两只老鼠，每一个奶酪，被不同老鼠吃会有不同的reward值。都被老鼠1吃的话，会有rewards1数组，反之都被老鼠2吃的话就有rewards2数组。</p><p>要求老鼠1要吃够k次，老鼠2可吃可不吃，老鼠1吃k次的时候得分最大是多少。</p></blockquote><p>老鼠各自吃有各自的得分，都有局部最优，但是同一块奶酪不能同时吃，所以每一块奶酪对于每只老鼠的利益互斥。而且要考虑全局最优。所以逐个遍历是找不到判断标准的。</p><p>受到一点启发，为了得分最高，那么老鼠2肯定要把数组长度n-k的都吃完，假设先让老鼠2吃完全部，然后比较每i个奶酪老鼠2让老鼠1吃的利益是多少。再把所有的利益排序，求k个最大值。</p>]]></content>
    
    
    <summary type="html">虽然很笨，但是也想突破自己学得更好</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统三：内存管理</title>
    <link href="https://huangxinhere.github.io/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://huangxinhere.github.io/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-05-28T16:00:00.000Z</published>
    <updated>2023-06-20T15:00:26.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><h2 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h2><h3 id="0-存储器结构"><a href="#0-存储器结构" class="headerlink" title="0.存储器结构"></a>0.存储器结构</h3><ul><li><p>多层结构</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529194909107.png" alt="image-20230529194909107"></p><blockquote><p>可移动存储介质：U盘；</p><p>主存储器：内存；</p><p>缓存：连接内存和辅存、寄存器之间的缓存；</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529195154467.png" alt="image-20230529195154467"></p><p>外存也就是硬盘缓存。</p></blockquote></li></ul><h3 id="0-进程运行的基本原理"><a href="#0-进程运行的基本原理" class="headerlink" title="0.进程运行的基本原理"></a>0.进程运行的基本原理</h3><p>用户程序 =&gt; 进程：编译、链接、装入</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529195631972.png" alt="image-20230529195631972"></p><ul><li>编译：属于用户，不属于OS</li></ul><h3 id="1-程序的装入和链接"><a href="#1-程序的装入和链接" class="headerlink" title="1.程序的装入和链接"></a>1.程序的装入和链接</h3><ul><li><p>链接（源码和底层函数等）：</p><p>静态链接（在程序运行前 或 装入程序前就已经完成 / 适合体量小的程序）；</p><p>装入时动态链接：一边装入一边链接；</p><p>运行时动态链接：程序在内存工作的时候按需获取。</p></li><li><p>装入：（将装入模块装入内存中，但不知道装在内存哪里）</p><p>绝对装入：直接在程序定义好放在哪个位置，在以前有可能做到；只适合单道程序</p><p>可重定位装入：若运行多道程序，动态寻找内存空闲位置（也是早期）</p><p>动态运行时装入：同一个程序被分配的内存不连续；如果程序有2G，内存只有1G，那么如何运行呢——内存扩充。</p></li></ul><h3 id="2-逻辑地址空间与物理地址空间"><a href="#2-逻辑地址空间与物理地址空间" class="headerlink" title="2.逻辑地址空间与物理地址空间"></a>2.逻辑地址空间与物理地址空间</h3><p>逻辑地址（默认从0开始）与物理地址（实际装入的地址可能有偏移）</p><h3 id="3-内存保护"><a href="#3-内存保护" class="headerlink" title="3.内存保护"></a>3.内存保护</h3><p>内存保护：寄存器（？记录物理地址的范围，保护已分配的内存防止被访问</p><h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2><p>内存扩充的两种方式：覆盖、交换（把不活跃的进程交换到硬盘缓存）。</p><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>单一用户，单一操作系统。从用户区最低的地址开始连续分配；只有一个用户在单一作业，没用的空闲空间比较多。</p><p>优点：实现简单；无外部碎片；不一定需要内存保护（虽然用户区没有多个访问，但有可能用户访问系统区）；</p><p>缺点：只能用于单用户、单任务OS；有内部碎片（整个用户区没有利用好）；存储器利用率低。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230530104612728.png" alt="image-20230530104612728"></p><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>有分区说明表来记录分区信息，比如有多少个分区、分区大小、起始地址、使用状态等；</p><p>优点：实现简单，无外部碎片（用户区已经被提前分好了，被分完全了）；</p><p>缺点：较大用户程序时，需要采用覆盖技术，降低了性能；会产生内部碎片（比如分了8M的固定内存给4M的进程，剩余4M的空间无法被利用），利用率低。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531101509403.png" alt="image-20230531101509403"></p><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>根据进程需要来动态分配。</p><p>缺点：可能产生外部碎片（被各种需求的进程分配后的剩余空间大小不一）；无内部碎片（要多少给多少，对于进程来说刚刚好）。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531102105335.png" alt="image-20230531102105335"></p><ul><li><p>怎么记录内存的使用情况？</p><p>空闲分区表：只记录空闲状态的内存分区。</p><p>数据结构：可以是双向链表。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531102428842.png" alt="image-20230531102428842"></p></li><li><p>选择哪个分区给新进程？</p><p>首次适应算法：从<strong>低地址</strong>查找合适空间；（地址低的空间可能大也可能小）</p><p>最佳适应算法：优先使用<strong>最小空闲</strong>空间；</p><p><strong>最坏</strong>适应算法：优先使用<strong>最大</strong>连续空间；（尽量第一次就找到，减少搜索时间）</p><p>临近适应算法：从上次查找处向后查找。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531103937389.png" alt="image-20230531103937389"></p><blockquote><p>补充说明：</p><p>最坏适应的小碎片少：比如有10M分区，被4M进程用了，剩下的碎片是6M，碎片比较大</p></blockquote></li><li><p>已使用的分区怎么回收？</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531104615621.png" alt="image-20230531104615621"></p><blockquote><p>要回收P4的时候，可以和前后（相邻）空闲区域合并。</p></blockquote><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531104804412.png" alt="image-20230531104804412"></p></li></ul><h2 id="非连续分配与管理方式"><a href="#非连续分配与管理方式" class="headerlink" title="非连续分配与管理方式"></a>非连续分配与管理方式</h2><p>连续分配管理方式中，固定分区分配虽然没有外部碎片但有内部碎片，动态则有外部碎片没有内部碎片，总之两者对内存的使用效率都不高。</p><p>此分配方法就是尽量最大化地利用内存空间：一个进程占用的内存空间不连续。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531110118490.png" alt="image-20230531110118490"></p><blockquote><p>数据可能记录在不同的内存块上，需要数据结构来管理。数据结构本身就存在一定消耗。</p></blockquote><h3 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h3><p>就是<strong>比较小</strong>的固定分区。一般分为4k大小。</p><p>内部碎片的产生情况：一般不会超过单位的一半，碎片比较小（页内碎片）；</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531110329662.png" alt="image-20230531110329662"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601162309742.png" alt="image-20230601162309742"></p><blockquote><p>用页表这个数据结构来记录进程分了多少页，存在PCB中。分页较多的话，数据结构记录的就多。</p><p>页号：对应进程分的页；块号：对应分配的不连续的物理地址。</p></blockquote><ul><li><p>基本地址变换机构：逻辑地址对照页表来计算物理地址。（下面的计算也就是，计算在第几个，然后算在那个区域的偏移量；其中物理地址和逻辑地址的偏移量）</p><ul><li>物理地址 =（页号=&gt;块号）+偏移量。</li><li>页号P = 逻辑地址A / 页面长度（大小）L；</li><li>偏移量W = 逻辑地址A % 页面长度L；</li><li>（位运算没搞懂……）</li></ul></li><li><p>（接）基本地址变换机构：</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601164307632.png" alt="image-20230601164307632"></p></li></ul><blockquote><p>目的：虚线框内是内存，左边是CPU，现在要进行的操作是，为1024的逻辑地址+1。</p><p>做法：先从页表中查找，找到对应块号，再通过计算找到目的物理地址。</p><p>分析：读页表取块号（一次内存访问）、计算最终物理地址并访问（一次内存访问），一共两次；</p><p>​            CPU的工作速度比内存要快；</p><p>现存的问题：页式管理中地址空间是一维的（页号默认是索引，块号成数组）；每次访存都需要地址转换，必须足够快；页表不能太大，会降低内存利用率；</p></blockquote><p>解决：具有快表的地址变换机构。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601165044304.png" alt="image-20230601165044304"></p><blockquote><p>访问物理地址肯定要访问内存，但是页表能不能放在其它地方呢？放在CPU和寄存器肯定不行，因为两者空间太小；放在寄存器和内存之间的空间——高速缓存里面。</p><p>这样就有快表与慢表之分。但快表是慢表的一部分，因为空间有限，只能存一部分。访问过的就从慢表中找并添加到快表。慢表是一位数据，而快表由于不一定连续，要记录页号和块号，所以是二维数据。</p></blockquote><ul><li>直接将页号与快表页号比较；（优先访问快表）</li><li>匹配成功，取块号+偏移量形成地址；</li><li>匹配失败，访问主存页表，并同步到快表。（局部性原理：使用过的可能会被重新使用）</li></ul><p>慢表的“慢”除了体现在放在内存中，还有所占空间较大的问题。</p><p>假设逻辑地址（由页号和页内地址组成）占32位，页号占20位，页内地址占12位。那么页号最多可能有2的20次幂，也就是1,048,576，差不多一百万多一点，而</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit </span><br><span class="line"><span class="number">1</span> KB= <span class="number">1024</span> B </span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB </span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB </span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br></pre></td></tr></table></figure><p>则假设每个页号3个字节左右，那么1048576种页号有（×2）…个字节（Byte），大概2M……？【教程是当作1个字节来算】</p><p>即使是一维数组，达到这样百万数量效率也会低；</p><p>页内地址12位占4个字节，那么整个页表有 1,048,576 × 4个字节，差不多四兆的空间，这样内存开销比较大。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602125221421.png" alt="image-20230602125221421"></p><blockquote><p>页表占用内存空间：2^20 * 4Bit；</p><p>页框数：</p></blockquote><ul><li>页表连续存放，占用大量连续空间；【可以动态装入，部分加载👇 也就是离散】</li><li>一段时间内只需要访问部分特定页面；</li><li>页表项分组 / 分页离散存储；</li><li>建页目录表管理<strong>离散</strong>页表。</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602125904172.png" alt="image-20230602125904172"></p><blockquote><p>每一个子列表最多有1024项，所需存储空间1024 × 4Bit = 4K，也就是一个页框的大小，不至于浪费内存空间。</p></blockquote><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602130400618.png" alt="image-20230602130400618"></p><blockquote><p>刚刚好都可以用位数来分区。</p></blockquote><p><strong>两级页表</strong>（索引思想）：</p><ul><li>将逻辑地址拆分成三部分；</li><li>从PCB中读取页目录表始址；</li><li>根据一级页号（&gt;&gt;22），查出二级页表位置；</li><li>根据二级页号查内存块号（&lt;&lt;10 去高位 再 &gt;&gt;22 去低位），加偏移量计算物理地址。</li></ul><h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><p>分页是把物理地址划分成 固定大小 连续 的不同区域，进程也划分成很多连续的小块。</p><ul><li>分段</li></ul><p>但实际上进程是由多个模块组成的，所以有把进程分段的需求，比如主程序、子程序、公共区域等。根据需求分段，所以每段的大小不确定。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603153243396.png" alt="image-20230603153243396"></p><ul><li><p>段表</p><p>段内是连续的，段与段之间是没有联系的；每段都是从0开始。</p><p>段表记录每段在物理地址的起始信息，还有对应的大小。这样段表就是二维的了。</p></li><li><p>地址变换机构</p></li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603153809775.png" alt="image-20230603153809775"></p><blockquote><p>比如取一号段的逻辑地址，取前16位获得段号，根据基址找到物理地址，再使用后16位地址找到物理地址对应的位置。</p></blockquote><ul><li><p>段的共享与保护</p><p>共享：比如进程有某块区域共享，有多个子进程 / 进程访问，子程序也会在自己的段表里面添加对应条目，……？</p><p>保护：越界保护。</p></li></ul><ul><li><p>分页与分段方式对比（都是非连续分配）</p><ul><li>页：物理单位按照固定大小划分；</li><li>段：逻辑单位 按照逻辑来划分；不过始终要在物理地址上分配（和分页结合）一个段可能占用多个页；</li><li>分页：一维地址空间，只需要记录起始地址；</li><li>分段：二维地址空间，由于分段大小不固定，还要记录段长；段表一般放在寄存器中，相比于页表一般要小，因为进程不会分很多段。</li><li>分段更容易信息共享和保护。分页的颗粒度太小，共享一块区域可能要很多个页，而分段颗粒度比较大。</li></ul></li></ul><h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603155050139.png" alt="image-20230603155050139"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603155300794.png" alt="image-20230603155300794"></p><ul><li>先分段，再分页</li></ul><p>1个进程对应一个段表；</p><p>一个段表项对应一个页表；由于一个段可能占用多个页，比如0号段（7kb），需要占用两个页：0号页（4kb）、1号页（3kb），此时【段页表】的【页表长度】为2，【页表存放块号】为1号块（也就是物理地址编号为1的块），而块上存储了页表信息（k0、k7）……？</p><p>一个页表对应多个物理块。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603160115172.png" alt="image-20230603160115172"></p><p>前16位：一个进程可能分的段数 / 段号；</p><p>页号：一个段可能分的页数 / 页号；最多为16个页。</p><p>后14位：对应的就是4k的页的地址。</p><ul><li>逻辑地址如何映射到物理地址上呢？</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603160458909.png" alt="image-20230603160458909"></p><blockquote><p>黄色虚线区域是内存，左侧是CPU管理区域（包括寄存器）。</p><p>段表寄存器：指向那张段页表？</p></blockquote><p>比如要找到逻辑地址1024（段号+页号+页内地址）</p><ul><li>【段号】 + 【段表始址】 找到 【段表项】：段表寄存器通过段表始址找到段表放在内存的地方，找到了段表后根据段号找到对应的段表项。</li><li>根据 【页表长度】检查页号越界情况；</li><li>【页表存放块号】+【页号】找到【页表项】：根据页表存放块号找到对应的物理块，然后物理块里面存有页表的信息，取出页表，根据逻辑地址给的页号来检索对应的页表项。</li><li>【内存块号】+【页内地址】得到物理地址。上一步找到页表项就是为了取具体的存放块号的信息，那么知道块号以后，就找到了某块物理地址，再结合逻辑地址的页内地址，就定位到了那块物理地址里面的具体位置（内存物理地址空间）。</li></ul><h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><p>（逻辑上的概念）具有请求调入和置换功能，从逻辑上对内存容量加以扩充的一种存储器系统。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605122423462.png" alt="image-20230605122423462"></p><blockquote><p>金字塔形状表示离CPU的远近。寄存器的执行效率和cpu一致。主存储器就是内存条。硬盘缓存物理上属于固定磁盘，看起来就是扩充了内存的容量，外存就是硬盘缓存。</p><p>一般内存指的是主存（三部分），更狭义就是内存条；而虚拟内存=内存+外存。</p></blockquote><ul><li><p>局部性原理</p><ul><li>时间局部性：操作过的短时间内可能会再次操作；</li><li>空间局部性：同一个位置……</li><li>催生了缓存技术。重复利用的放入缓存，缓存效率比内存要高。</li></ul></li><li><p>虚拟内存的特征</p><ul><li>多次性：动态请求；</li><li>对换性：不用的时候换出，要用的时候换入；</li><li>虚拟性：逻辑上扩充。</li></ul></li><li><p>虚拟内存的实现</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式存储管理（三种和上面提到的差不多</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605123411819.png" alt="image-20230605123411819"></p></li></ul><h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><p>上节内存管理提到基本分页存储管理，那是一次性把所有进程加载进去。</p><p>而请求分页是动态加载：有需要才请求装入。</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605123553415.png" alt="image-20230605123553415"></p><ul><li><p>页表机制</p><ul><li>状态位P：0说明在外存中，1反之；</li><li>访问字段A：记录被访问的次数；</li><li>修改位M：是否被修改过；</li><li>外存地址：也是物理地址，调出到的地址</li></ul></li><li><p>缺页中断机构</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124615166.png" alt="image-20230605124615166"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124635902.png" alt="image-20230605124635902"></p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124117141.png" alt="image-20230605124117141"></p><p>程序运行当中要访问的页不存在，就要从外存中调入。这个过程首先要产生中断。</p><blockquote><p>举例子，【调入】a号块要从外存x号块加载东西，加载完后要更新页表（内存块号、状态位）。</p></blockquote><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124435301.png" alt="image-20230605124435301"></p><blockquote><p>把c号块的东西调出到z号块，也会产生中断。</p></blockquote></li><li><p>地址变换机构</p></li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606123009538.png" alt="image-20230606123009538"></p><blockquote><p>橙色虚线框内就是内存，外面是CPU和寄存器。</p></blockquote><ul><li>请求调页，判断是否在内存。比如程序运行的时候发现缺少页，就要请求从磁盘中加载页。（请求过程也就是先查找快表，找到自己的逻辑地址的页号，对应的快表项，再找到外存地址；如果快表没找到，就通过页表寄存器查找慢表。）</li><li>可能需要页面置换。如果调入的时候内存不够，可能要把不太需要的页调出到外存。</li><li>新增（换出？） / 修改页表项。</li><li>热点表项（经常访问）同步到快表。</li></ul><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>哪些页面要调入调出的问题。</p><h3 id="最佳置换算法OPT：保障最低缺页率"><a href="#最佳置换算法OPT：保障最低缺页率" class="headerlink" title="最佳置换算法OPT：保障最低缺页率"></a>最佳置换算法OPT：保障最低缺页率</h3><p>每次选择淘汰最不可能再次被使用的页面（这样要用的页面就很少被换出）；</p><p>不好实现</p><h3 id="最近最久置换算法LRU：保障时间和距离上的公平"><a href="#最近最久置换算法LRU：保障时间和距离上的公平" class="headerlink" title="最近最久置换算法LRU：保障时间和距离上的公平"></a>最近最久置换算法LRU：保障时间和距离上的公平</h3><p>每次淘汰最久（时间）最近（距离）未使用的页面；</p><p>需要硬件支持，开销大（改页表？</p><h3 id="先进先出置换算法FIFO：保障顺序上的公平"><a href="#先进先出置换算法FIFO：保障顺序上的公平" class="headerlink" title="先进先出置换算法FIFO：保障顺序上的公平"></a>先进先出置换算法FIFO：保障顺序上的公平</h3><p>每次选择淘汰最早进入内存的页面；</p><p>Belady异常（淘汰的是要用的页），性能差（程序和加载的顺序无关，主要和使用频率有关）</p><h3 id="时钟置换算法NRU：保障性能和开销均衡"><a href="#时钟置换算法NRU：保障性能和开销均衡" class="headerlink" title="时钟置换算法NRU：保障性能和开销均衡"></a>时钟置换算法NRU：保障性能和开销均衡</h3><p>为页面设置访问位（0/1），并链接成循环队列，进程访问页面后置为1.</p><p>淘汰时为1置为0并跳过，为0时淘汰。(用完之后置为0)</p><p>最多需要两轮扫描</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606124914754.png" alt="image-20230606124914754"></p><h3 id="改进型时钟置换算法【？？？但-这个是最重要的算法"><a href="#改进型时钟置换算法【？？？但-这个是最重要的算法" class="headerlink" title="改进型时钟置换算法【？？？但 这个是最重要的算法"></a>改进型时钟置换算法【？？？但 这个是最重要的算法</h3><ul><li>额外考虑是否修改，保障最少I / O操作；</li><li>访问位和修改位主要看哪个？原则：尽可能保留访问位。</li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606125501363.png" alt="image-20230606125501363"></p><p>增加修改位(0 / 1)，第一轮找（0，0），第二轮找（0，1）并修改访问位0，第三轮找（0，0）……</p><h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><p>解决到底要给进程分配多大的空间，怎么分配，什么时候分之类的问题。</p><ul><li>驻留集（驻留在主存中页面数）大小 （进程在内存中占用的空间是多少，按照页面的数量来算）<ul><li>（给进程）分配空间小，进程数量多，<strong>CPU时间利用效率</strong>就高；</li><li>进程在主存中页数少，<strong>错页率</strong>就高；（要频繁加载外存）</li><li>进程在主存页数多，错页率并无明显改善；（无需频繁加载外存，因为本身错页率不高……？</li></ul></li></ul><ul><li><p>页面分配策略</p><ul><li>固定分配局部置换</li><li>可变分配全局置换</li><li>可变分配局部置换</li></ul><p>固定也就是给进程划分好固定区域，如果内存还是不够，就自己解决，换入换出；</p><p>可变也就是划分的内存空间可变，要么换入换出，要么请求操作系统继续扩充内存，这也是局部全局的概念。</p><p>那么固定分配的话，如果分配少了，就一直缺，或者频繁换入换出，这时候错页率就高；分配多了，就浪费？</p></li></ul><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607191652415.png" alt="image-20230607191652415"></p><h3 id><a href="#" class="headerlink" title></a></h3><ul><li><p>调入页面的时机</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607192638119.png" alt="image-20230607192638119"></p><ul><li><p>预调页策略（进程被创建之后，就要被调入了）</p><p>一次性调入<strong>若干相邻页面</strong>（根据空间局部性原理，一个页面被调用后，相邻的页面也很可能被调用）</p><p>多用于进程<strong>首次调入</strong>；</p></li><li><p>请求调页策略</p><p>运行时发现缺页时调入；</p><p>I / O开销较大。（调页要访问磁盘，相当于IO操作，要慢很多……？）</p></li></ul></li><li><p>从何处调页</p><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607192816172.png" alt="image-20230607192816172"></p></li><li><p>系统拥有足够的对换区空间的时候：</p><p>主程序加载到内存的时候，把其它程序加载在对换区，因为对换区的速度比文件区快。</p></li><li><p>系统缺少足够的对换区空间的时候：</p><p>不会被修改（数据）的文件（函数等）直接调入到文件区，因为没有要改的东西，所以能减少换出，还能减少IO操作。</p></li><li><p>Unix方式</p><p>读主要从文件区，换入换出在对换区。</p></li></ul><h1 id="内存-地址-对齐"><a href="#内存-地址-对齐" class="headerlink" title="内存/地址 对齐"></a>内存/地址 对齐</h1><p><a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解 - 知乎 (zhihu.com)</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 现代计算机中内存空间都是按照字节(byte)划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，<strong>这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排列</strong>，这就是对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s);  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。</p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p><p><img src="https://pic3.zhimg.com/80/v2-3f40af513a94901b36ceb5387982277e_1440w.webp" alt="img"></p><p>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p><p><img src="https://pic1.zhimg.com/80/v2-361e2d16876ce8383c9e6ea2dca34474_1440w.webp" alt="img"></p><p>1.有些 CPU 可以访问任意地址上的任意数据，而有些 CPU 只能在特定地址访问数据，因此<u>不同硬件平台具有差异性</u>，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有<u>平台可以移植性</u>了。</p><p>2.CPU 每次寻址都是要消费时间的，并且 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能。</p><p>​    比如有些平台每次读都是从偶数地址开始，如果一个 int 型（假设是 32 位）如果存放在偶数地址开始的地方，那么一个时钟周期就可以读出。而如果是存放在一个奇数地址开始的地方，就可能会需要 2 个时钟周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 型数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p><h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p><p>有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p><p><a href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解 - 知乎 (zhihu.com)</a></p><p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 偏移 都是<strong>该成员大小与有效对齐值中较小那个</strong>的<u>整数倍</u>，如有需要编译器会在成员之间加上填充字节。</p><p>(2) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p><p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_1440w.webp" alt="img"></p><blockquote><p>第二幅图，char占用一个字节，占用第0单元；到了int，由于≥4，相对于结构体首地址的偏移 要为4的倍数，占用第4，5，6，7单元；第二个char &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元</p></blockquote>]]></content>
    
    
    <summary type="html">关于操作系统的知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 知识整理-基础部分</title>
    <link href="https://huangxinhere.github.io/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/"/>
    <id>https://huangxinhere.github.io/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-25T16:00:00.000Z</published>
    <updated>2023-06-05T09:08:43.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="—–C-编译过程及原理"><a href="#—–C-编译过程及原理" class="headerlink" title="—–C++编译过程及原理"></a>—–C++编译过程及原理</h1><p><a href="https://blog.csdn.net/qq_43133135/article/details/82865618">(47条消息) C++的编译过程及原理_c++编译原理_qq_43133135的博客-CSDN博客</a></p><h2 id="C和C-程序结构"><a href="#C和C-程序结构" class="headerlink" title="C和C++程序结构"></a>C和C++程序结构</h2><p>声明一般放在头文件中；</p><h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p>将各种要调用的函数声明打包成头文件，并将其添加到main函数之前，在预编译过程中，#include将会被其文件内容替换，从而实现将函数声明放在main之前，为main函数中调用打下基础，这就是为什么#include为什么被放在cpp文件的开始部分。</p><ul><li><p>将头文件内容copy进去；</p></li><li><p>#define INTEGER int：define则将相应内容替换掉；</p></li><li><p>条件编译指令：在预编译的时候执行的条件选择。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  Linux</span></span><br><span class="line">linux平台下运行的函数</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  windows</span></span><br><span class="line">Windows平台下运行的函数</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>         </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这样可以兼容不同的平台，想在linux平台下运行，只要在条件编译前添加<code>#define Linux</code>就好了。<br>另外，也可以通过这种方式来选择不接入某些不需要用的模块，提高编译速度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>  USE_Printf  <span class="comment">//如果没有定义USE_Printf</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> myPrintf(...)    <span class="comment">//定义为空（无内容）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintf</span><span class="params">(....)</span> <span class="comment">//定义为一个具体函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">&#125;           </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>每个头文件只调用一次。</li></ul><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>在预处理阶段替换文本给编译器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-string">&lt;Name&gt;</span> &#123;语句或符号或变量等&#125;</span></span><br></pre></td></tr></table></figure><ul><li>一些常用预处理命令</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>              定义一个预处理宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>             取消宏的定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>                      编译预处理中的条件命令, 相当于C语法中的<span class="meta-keyword">if</span>语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>                判断某个宏是否被定义, 若已定义, 执行随后的语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>             与#<span class="meta-keyword">ifdef</span>相反, 判断某个宏是否未被定义【容易搞错！】</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span>                  若#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>或前面的#<span class="meta-keyword">elif</span>条件不满足, 则执行#<span class="meta-keyword">elif</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span>-<span class="meta-keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                与#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>对应, 若这些条件不满足, 则执行#<span class="meta-keyword">else</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>              #<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>这些条件命令的结束标志.</span></span><br><span class="line">defined          与<span class="meta">#<span class="meta-keyword">if</span>, #<span class="meta-keyword">elif</span>配合使用, 判断某个宏是否被定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>            包含文件命令</span></span><br><span class="line">#include_next   与<span class="meta">#<span class="meta-keyword">include</span>相似, 但它有着特殊的用途</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span>                标志该语句所在的行号</span></span><br><span class="line">#                      将宏参数替代为以参数值为内容的字符窜常量</span><br><span class="line">##                   将两个相邻的标记(token)连接为一个单独的标记</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>       说明编译器信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span>       显示编译警告信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>          显示编译错误信息</span></span><br></pre></td></tr></table></figure><ul><li>例子1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">LOG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>情境2：在Debug模式下，会有日志输出；但是在Release模式下，不希望有日志泄露秘密或者什么。</li></ul><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++基础.assets\image-20230504145743737.png" alt="image-20230504145743737"></p><blockquote><p>在Debug和Release模式下，分别设置预处理定义宏，这里写为<code>PR_DEBUG</code>和<code>PR_RELEASE</code>.</p></blockquote><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++基础.assets\image-20230504145943001.png" alt="image-20230504145943001"></p><blockquote><p>回到代码，如果是release模式，下方语句高亮；反之相同。</p></blockquote><blockquote><p>两种模式的区别：release模式下编译器会自动优化一下代码（编译结果？）；而debug模式下编译器则尽量少改动代码，好让程序员进行调试。</p></blockquote><h2 id="编译过程及链接"><a href="#编译过程及链接" class="headerlink" title="编译过程及链接"></a>编译过程及链接</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Compiling...</span><br><span class="line"></span><br><span class="line">animal.cpp</span><br><span class="line">human.cpp</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Linking...</span><br><span class="line"></span><br><span class="line">main.exe - <span class="number">0</span> <span class="built_in">error</span>(s), <span class="number">0</span> <span class="built_in">waring</span>(s)</span><br></pre></td></tr></table></figure><ul><li>编译器首先对源文件进行<u>单独编译</u>【.cpp】；</li><li>在编译时,由预处理器对<u>预处理指令</u>（#include、#define…）进行处理，在内存中输出翻译单元（就是将include等在源文件上替换了以后产生的<strong>临时文件</strong>）；</li><li>编译器<u>接受临时文件</u>，将其翻译成包含机器语言指令的<strong>目标文件</strong>【.obj】</li></ul><ul><li>接下去就是链接过程（<code>Linking...</code>），连接器将目标文件和你用到的相关库文件一起链接形成main.exe。<br>到此，编译也就结束了。</li></ul><p><img src="https://img-blog.csdn.net/20180927202022582?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMTMzMTM1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h1 id="—–变量和基本类型"><a href="#—–变量和基本类型" class="headerlink" title="—–变量和基本类型"></a>—–变量和基本类型</h1><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul><li> 枚举的本质是整型。</li><li> 默认值会依次递增</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Example</span> :</span> <span class="built_in"><span class="keyword">int</span></span>(默认) /  <span class="keyword">char</span> / <span class="built_in"><span class="keyword">float</span></span>(×只能是整型)</span><br><span class="line">&#123;</span><br><span class="line">  A = <span class="number">5</span>, B, C;<span class="comment">// 默认递增为 B=6，C=7  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Example value = B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合类型-引用"><a href="#复合类型-引用" class="headerlink" title="复合类型-引用"></a>复合类型-引用</h2><p>引用只是指针的伪装，指针的语法糖。 </p><p>引用必须引用已经存在的变量，引用本身并不是新的变量；<strong>并不占内存</strong>。</p><p><code>int* b = &amp;a;</code>是修饰变量a的，所以是取地址符；<code>int&amp; ref = a;</code>是修饰类型的，所以是引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*value)++;<span class="comment">//直接更改内存地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Increment</span>(&amp;a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Increment</span><span class="params">(<span class="keyword">int</span>&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    value++;<span class="comment">//引用简化了参数传递，消除了拷贝代价</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Increment</span>(a);</span><br></pre></td></tr></table></figure><ul><li>声明引用的时候，必须赋值；而且赋值之后不能再更改，否则</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">ref = b;<span class="comment">// a = 8, 实质是a被赋值为b，而不是更改引用</span></span><br></pre></td></tr></table></figure><h2 id="复合类型-指针"><a href="#复合类型-指针" class="headerlink" title="复合类型-指针"></a>复合类型-指针</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>存储（在内存中的）地址。</li><li>只会是整数类型，因为地址名固定；指针不包含数据，所以它不知道它指向的数据内存有多大……那么不同类型的指针只是方便用户/编译器识别。比如一个<code>Void*</code>想要更改成10，那么10是什么类型呢？想象内存地址对应的只是字节，然后给了个无类型10，那么要以整型规则解读10的字节，还是以无符号整型规则解读呢？所以定义为<code>int*</code>指针，就能读写准确地读写操作了。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8</span>];<span class="comment">//申请8个字节；指针指向内存开头</span></span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">8</span>);<span class="comment">//将0填充进内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span>[] buffer;<span class="comment">//删除指针</span></span><br></pre></td></tr></table></figure><h3 id="与字符串"><a href="#与字符串" class="headerlink" title="与字符串"></a>与字符串</h3><p><a href="https://juejin.cn/post/6929382361033506823#heading-29">c++学习笔记-指针与字符串 - 掘金 (juejin.cn)</a></p><p><a href="https://blog.csdn.net/Kallou/article/details/123239999">(43条消息) C++ 字符串指针和字符串指针数组详解-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_43574446/article/details/106625062?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106625062-blog-123239999.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-106625062-blog-123239999.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1">(43条消息) C++之字符串数组与字符指针_挖点代码拌西瓜的博客-CSDN博客</a></p><h3 id="指针数组和数组指针"><a href="#指针数组和数组指针" class="headerlink" title="指针数组和数组指针"></a>指针数组和数组指针</h3><p><a href="http://c.biancheng.net/view/335.html">数组指针和指针数组的区别，C语言数组指针和指针数组区别详解 (biancheng.net)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1[<span class="number">5</span>];<span class="comment">//指针（的）数组</span></span><br><span class="line"><span class="keyword">int</span> *(p2)[<span class="number">5</span>];<span class="comment">//数组（的）指针</span></span><br></pre></td></tr></table></figure><ul><li><p>指针数组</p><p>“[]”的优先级比“*”要高，所以 p1 先与“[]”结合，构成一个数组的定义，数组名为 p1；</p><p>而“int*”修饰的是数组的内容，即<u>数组的每个元素</u>；</p><p>也就是说，该数组包含 5 个指向 int 类型数据的指针，如图 1 所示，因此，它是一个指针数组。</p><p><img src="http://c.biancheng.net/uploads/allimg/180906/2-1PZ6092I9D6.jpg" alt="img"></p></li><li><p>数组指针</p><p>对于语句“int(p2)[5]”，“()”的优先级比“[]”高，“*”号和 p2 构成一个指针的定义，指针变量名为 p2；</p><p>而 int 修饰的是数组的内容，即数组的每个元素；</p><p>也就是说，p2 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如图 2 所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。</p><p><img src="http://c.biancheng.net/uploads/allimg/180906/2-1PZ6092Q4443.jpg" alt="img"></p></li><li><p>两者区别总结</p><p>由此可见，对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针，在 32 位系统下永远占 4 字节，至于它指向的数组占多少字节，这个不能够确定，要看具体情况。</p></li></ul><ul><li><p>示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>]=&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p1)[<span class="number">5</span>] = &amp;arr;<span class="comment">//&amp;arr 是指整个数组的首地址</span></span><br><span class="line"><span class="comment">/*下面是错误的*/</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p2)[<span class="number">5</span>] = arr;<span class="comment">//arr 是指数组首元素的首地址</span></span><br></pre></td></tr></table></figure><ul><li><p>不难看出，在上面的示例代码中，&amp;arr 是指<strong>整个数组</strong>的首地址，而 arr 是指<strong>数组首元素</strong>的首地址；虽然所表示的意义不同，但二者之间的值却是相同的。</p></li><li><p>那么问题出来了，既然值是相同的，为什么语句“int(<em>p1)[5]=&amp;arr”是正确的，而语句“int(<em>p2)[5]=arr”却在有些编译器下运行时会提示错误信息呢（如在 Microsoft Visual Studio 2010 中提示的错误信息为“a value of type”int</em>“cannot be used to initialize an entity of type”int(</em>)[5]””）？</p></li><li><p>其实原因很简单，在 C 语言中，赋值符号“=”号两边的数据类型必须是相同的，如果不同，则需要显示或隐式类型转换。在这里，p1 和 p2 都是数组指针，指向的是整个数组。p1 这个定义的“=”号两边的数据类型完全一致，而 p2 这个定义的“=”号两边的数据类型就不一致了（左边的类型是指向整个数组的指针，而右边的数据类型是指向单个字符的指针），因此会提示错误信息。</p></li></ul></li></ul><ul><li><p>示例代码2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><ul><li><strong>a是数组名</strong>，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。</li><li><strong>&amp;a是数组的指针</strong>，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上<u>整个数组的偏移</u>（10个int型变量），值为数组a尾元素后一个元素的地址。</li><li>若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。(????</li></ul></li></ul><h2 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h2><p>变量的定义包括一个基本数据类型和<strong>一组声明符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure><ul><li>指向指针的指针</li></ul><p>一般来说，声明符中修饰符的个数并没有限制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival;</span><br><span class="line"><span class="keyword">int</span> *ppi = &amp;pi;</span><br></pre></td></tr></table></figure><ul><li>指向指针的引用</li></ul><p>引用本身不是一个对象，因此不能定义指向引用的指针；但指针是对象，所以存在对指针的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;<span class="comment">//r是一个对指针p的引用</span></span><br><span class="line"></span><br><span class="line">r = &amp;i;<span class="comment">//r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>;<span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure><blockquote><p>要理解r的类型到底是什么，最简单的方法就是从<strong>右到左</strong>阅读r的定义。离变量名最近的符号对变量的类型有最直接的影响，因此r是一个引用。</p><p>声明符的其余部分用以确定r引用的类型是什么，*说明r引用的是一个指针。</p></blockquote><h2 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="built_in">get_size</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;<span class="comment">//错误，没有初始化</span></span><br></pre></td></tr></table></figure><ul><li>初始化和const</li></ul><p>const类型的对象能执行的操作有：不改变其值的；初始化。</p><p>其中初始化是不在意其是否是一个const常量；因为拷贝一个对象的值不会改变它，一旦拷贝完成，新的对象和原来的对象就没有什么关系了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">int</span> j = ci;</span><br></pre></td></tr></table></figure><ul><li>默认情况下，const对象只在文件内有效</li></ul><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><ul><li><p>应用于普通变量；</p></li><li><p>应用于引用：把引用绑定到const对象上</p><p>对常量的引用不能被用作修改它所绑定的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = ci;<span class="comment">//正确：引用及其对应的对象都是常量</span></span><br><span class="line">r1 = <span class="number">42</span>;<span class="comment">//错误：r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;<span class="comment">//错误：也不能用过引用来改变常量</span></span><br></pre></td></tr></table></figure></li><li><p>应用于指针：难一点的：常量指针和指针常量，看指针相关记录。</p><ul><li><strong>指向常量的指针/指针常量</strong>不能用于改变其所指对象的值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;<span class="comment">//错误：ptr是个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;<span class="comment">//正确。*cptr前面是double类型，说明是double类型的指针；double前面是const，说明double是const的</span></span><br></pre></td></tr></table></figure><ul><li><strong>const指针/常量指针</strong>：指针是对象，所以可以作为常量；不变的是指针本身而不是所指的值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;<span class="comment">//curErr将一直指着errNumb。const修饰int*类型，说明指针是常量……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;<span class="comment">//pip是一个指向常量对象的常量指针（本身和所指的都不能变）</span></span><br></pre></td></tr></table></figure><blockquote><p>从右往左阅读理解</p></blockquote></li><li><p>应用于类和方法：</p></li></ul><p><a href="https://yz.cuc.edu.cn/_web/_search/api/search/new.rst?locale=zh_CN&amp;request_locale=zh_CN&amp;_p=YXM9MTU4JnQ9NDkzJmQ9MjgxMCZwPTMmZj04NTI3JmE9MCZtPVNOJnxibm5Db2x1bW5WaXJ0dWFsTmFtZT04NTI3Jg">https://yz.cuc.edu.cn/_web/_search/api/search/new.rst?locale=zh_CN&amp;request_locale=zh_CN&amp;_p=YXM9MTU4JnQ9NDkzJmQ9MjgxMCZwPTMmZj04NTI3JmE9MCZtPVNOJnxibm5Db2x1bW5WaXJ0dWFsTmFtZT04NTI3Jg</a>__</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_X, m_Y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span><span class="comment">// 在变量列表后面加，对隐含的this指针加上const限定；原来的this也就是指向非常量对象的常量指针。指针本身不能变，但指向的对象可以变；加上const之后，变成常量指针常量，所指都不能变</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X = <span class="number">2</span>;<span class="comment">// 错误,无法修改</span></span><br><span class="line">        <span class="keyword">return</span> m_X;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetX</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_X = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintEntity</span><span class="params">(<span class="keyword">const</span> Entity&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::out &lt;&lt; e.<span class="built_in">GetX</span>() &lt;&lt; std::endl; <span class="comment">// 如果GetX()声明为const，那么不会报错；否则就报错。为什么呢？</span></span><br><span class="line">    <span class="comment">// 首先const修饰的引用意味着什么。引用本来就是一个变量的别名，可以修改内容，但不能修改“引用的对象”，所以类似于一个指针常量；加上const就是类似于常量指针常量，所指对象和内容都不能修改。</span></span><br><span class="line">    <span class="comment">// 所以如果GetX()不声明为const，还是有可能修改内容，所以不符合const引用的要求，所以报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着上面的例子。可以用const重载GetX()，这样e.GetX()默认调用有const那个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_X = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在const方法里面确实要修改呢? mutable关键字，一般在类的const方法改变某个成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_FuncCount;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetX</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_FuncCount++;<span class="comment">// 特殊情况下需要改变的成员变量</span></span><br><span class="line">    <span class="keyword">return</span> m_X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态static"><a href="#静态static" class="headerlink" title="静态static"></a>静态static</h2><h3 id="类和结构体外部的静态"><a href="#类和结构体外部的静态" class="headerlink" title="类和结构体外部的静态"></a>类和结构体外部的静态</h3><p>只对当前翻译单元可见。也就是编译的时候会链接每个文件，所以如果在main.cpp声明一个全局变量，那么log.cpp也能访问到。如果只想main单独使用，那么可以声明为static。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.cpp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_Variable = <span class="number">5</span>;<span class="comment">//只对该文件可用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s_Variable = <span class="number">5</span>;<span class="comment">//可以被其他文件访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="keyword">int</span> s_variable;</span><br></pre></td></tr></table></figure><h3 id="类和结构体内的静态"><a href="#类和结构体内的静态" class="headerlink" title="类和结构体内的静态"></a>类和结构体内的静态</h3><ul><li><p>相当于”类范围内的“全局变量，而不是命名空间那么大的。</p></li><li><p>可以通过类直接访问。</p></li><li><p>所有实例共享静态变量/函数。</p></li><li><p>静态变量要初始化。（一定在类之外？）<code>int  Entity::x = 0;</code></p></li><li><p>静态函数只能访问静态变量和静态函数。</p></li></ul><blockquote><p>静态函数不可以访问非静态变量。因为静态函数不知道非静态变量属于哪个实例。为什么非静态函数就可以呢？因为实例创建的时候默认用this记录实例的地址空间，所以隐式用this来访问实例以及对应的非静态变量；而静态则没有这个this。所以要想静态函数访问非静态变量，就要传入实例变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 无法访问非静态变量，不知道实例对象是谁</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">x = <span class="number">2</span>;</span><br><span class="line"> y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 知道实例是谁了</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function</span><span class="params">(Entity e1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e1.x = <span class="number">2</span>;</span><br><span class="line"> e1.y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="局部静态local-static"><a href="#局部静态local-static" class="headerlink" title="局部静态local static"></a>局部静态local static</h3><ul><li>变量的生存期和作用域：一直生存；只在函数内部等局部范围内有效。</li><li>相当于”函数范围内（或其他局部）“的全局变量，避免其他地方访问修改。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 1 2 3</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 1 1 1</span></span><br><span class="line">    i++;</span><br><span class="line">    std::count &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【例子】单例类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* s_Instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *s_Instance; &#125;</span><br><span class="line">    <span class="keyword">void</span> Hello&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::s_Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line">    <span class="comment">//static Singleton* s_Instance;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Singleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> Hello&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Singleton::<span class="built_in">Get</span>().<span class="built_in">Hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理类型-typedef"><a href="#处理类型-typedef" class="headerlink" title="处理类型-typedef"></a>处理类型-typedef</h2><p>是某种类型的同义词。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;<span class="comment">// wages是double的同义词</span></span><br></pre></td></tr></table></figure><ul><li>using 关键字也可以指定别名。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// using的写法把别名的名字强制分离到了左边，而把别名指向的放在了右边，比较清晰</span></span><br><span class="line"><span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(Event&amp;)&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是用typedef</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* EventCallbackFn)</span> <span class="params">(Event&amp;)</span></span></span><br></pre></td></tr></table></figure><h2 id="处理类型-auto"><a href="#处理类型-auto" class="headerlink" title="处理类型-auto"></a>处理类型-auto</h2><p>让编译器自动分析表达式所属的类型。</p><ul><li>比如api返回值变化了，获取变量的类型auto可以不变；但调用特定类型的方法时就会麻烦……</li><li>可以简化很长的类型说明；如果是int,string这些基本的尽量不要使用。</li><li>auto不处理引用。要将变量识别为引用的话，<code>auto&amp; b = 2</code></li></ul><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++基础.assets\image-20230504152942936.png" alt="image-20230504152942936"></p><h1 id="—–字符串、向量和数组"><a href="#—–字符串、向量和数组" class="headerlink" title="—–字符串、向量和数组"></a>—–字符串、向量和数组</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>下面是指针（字符指针可以直接赋值字符串-C语言风格 ），那怎么知道字符串长度呢？最末尾有一个终止符00(十六进制)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 一般搭配const，因为这是一个固定分配的内存块</span></span><br><span class="line"><span class="comment">// 相当于&quot;Jeson/0&quot;，自动分配一个终止符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">5</span>] = &#123;<span class="string">&#x27;J&#x27;</span>,...&#125;;<span class="comment">// 打印出Jeson和一堆乱符号;没有终止符</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">6</span>] = &#123;..., <span class="number">0</span>&#125;;<span class="comment">// 正确打印Jeson</span></span><br><span class="line">std::cout &lt;&lt; name &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>关于终止符的进一步例子：</p><p>提前放置终止符会破坏字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[<span class="number">8</span>] = <span class="string">&quot;Cher\0no&quot;</span>;<span class="comment">// 内存中是Cher.no. 在ASCⅡ中.表示0</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> name[<span class="number">8</span>] = <span class="string">&quot;Cherno&quot;</span>;<span class="comment">// 6</span></span><br><span class="line"><span class="built_in">strlen</span>(name);<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string name = <span class="string">&quot;Jeson&quot;</span> + <span class="string">&quot; hello!&quot;</span>; <span class="comment">// 报错，两者本质上是const char*，不能直接相加</span></span><br><span class="line"></span><br><span class="line">std::string name = std::<span class="built_in">string</span>(<span class="string">&quot;Jeson&quot;</span>) + <span class="string">&quot; hello!&quot;</span>;<span class="comment">// 正确</span></span><br><span class="line">std::string name = <span class="string">&quot;Jeson&quot;</span>;</span><br><span class="line">name += <span class="string">&quot; hello!&quot;</span>;<span class="comment">//正确，string重载了+=运算符</span></span><br></pre></td></tr></table></figure><ul><li>传递只读string变量时，这样会复制一份string，造成开销</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString</span><span class="params">(std::string string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化：&amp;确保不会被复制，const确保不会修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString</span><span class="params">(<span class="keyword">const</span> std::string&amp; string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; string &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 一般搭配const，因为这是一个固定分配的内存块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* name = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 不被允许</span></span><br><span class="line">name[<span class="number">2</span>] = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// 禁止写入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">8</span>] = <span class="string">&quot;Jeson&quot;</span>;<span class="comment">// 数组则是开辟了空间存入字符串常量，指针就是直接改常量</span></span><br></pre></td></tr></table></figure><p>字符串常量一般放在内存的只读区域</p><h2 id="动态数组vector"><a href="#动态数组vector" class="headerlink" title="动态数组vector"></a>动态数组vector</h2><ul><li><p>【性能缺点一】不够空间时，会在内存分配一个新的更大的空间。然后将原数组复制过去，得到一个新的数组，并重新分配起始指针和终止指针；再删除旧位置的内存。</p><p>接下来对复制进行一个深入理解：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span><br><span class="line">: <span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数（深拷贝）</span></span><br><span class="line"><span class="built_in">Vertex</span>(<span class="keyword">const</span> Vertex&amp; vertex)</span><br><span class="line">: <span class="built_in">x</span>(vertex.x), <span class="built_in">y</span>(vertex.y), <span class="built_in">z</span>(vertex.z)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Copied!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Vertex&gt; vertices;</span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;);<span class="comment">// 1个元素</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;);<span class="comment">// 2个元素（复制两次）</span></span><br><span class="line">vertices.<span class="built_in">push_back</span>(&#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;);<span class="comment">// 3个元素…</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>构造函数被调用了六次。</p><ul><li>第一次push_back的时候，现在栈中创建了一个实例，由于vector长度不够，开辟新的内存空间，然后再复制给vector，复制了一次。</li><li>第二三次同理，扩容，然后将栈中的实例复制过去。</li></ul></blockquote><ul><li><p>如何避免复制</p><ul><li>【避免扩容】在开始就确定有多大的内存：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;Vertex&gt; <span class="title">vertices</span><span class="params">(<span class="number">3</span>, ...)</span></span>;<span class="comment">// 用构造函数，会初始化三个空的Vertex对象</span></span><br><span class="line">vertices.<span class="built_in">reserve</span>(<span class="number">3</span>);<span class="comment">// 只设置容量，比上一个方法好</span></span><br></pre></td></tr></table></figure><ul><li>【直接在容器中实例化】emplace_back</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="built_in">Vertex</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));<span class="comment">// 实质上又是实例化再复制过去，不要用！</span></span><br><span class="line">vertices.<span class="built_in">emplace_back</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">// 应该直接给出构造参数！</span></span><br></pre></td></tr></table></figure></li><li><p>存储类类型时，最好使用对象而不是指针；因为存储对象确保存储空间是连续的，指针存储可能是碎片的。（指针本身存储是连续的，但是指向的内容并不确保连续……）</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="原始数组"><a href="#原始数组" class="headerlink" title="原始数组"></a>原始数组</h3><p>开辟连续的内存空间，并进行赋值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> example[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p><img src="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/hexo_github_blog\source_posts\知识整理-C++.assets\image-20230405181710959.png" alt="image-20230405181710959"></p><p>数组名其实是指针，那怎么访问元素呢？”[index]“这个中括号其实进行了运算符重载，本质上是通过指针偏移来访问相对地址上的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr = example;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两者本质上等价</span></span><br><span class="line">example[<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line">*(ptr+<span class="number">2</span>) = <span class="number">6</span>;<span class="comment">// int类型的指针偏移两个int（8个字节）长度</span></span><br><span class="line">*(<span class="keyword">int</span>*)((<span class="keyword">char</span>*)ptr + <span class="number">8</span>) = <span class="number">6</span>;<span class="comment">// 如果强制转换成char类型的指针，就是直接偏移8个字节</span></span><br></pre></td></tr></table></figure><ul><li>在栈 或者 堆 上创建数组。生命周期不同，堆对象要手动删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> example[<span class="number">5</span>];<span class="comment">// 栈</span></span><br><span class="line"><span class="keyword">int</span>* another = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">// 堆</span></span><br><span class="line"><span class="keyword">delete</span>[] another;</span><br></pre></td></tr></table></figure><p>不过在类里面也创建堆的数组的话，那么访问数组就要通过实例的成员变量（一个指针），再跳转到数组……？</p><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>性能可能差些，但也更安全。原始数组不能直接知道长度……虽然可以<code>sizeof(example)/sizeof(int)</code>(指针偏移量÷类型)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">int</span>, 5&gt; data;</span><br><span class="line">data.<span class="built_in">size</span>();</span><br><span class="line">data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">data[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c语言风格</span></span><br><span class="line"><span class="keyword">int</span> dataOld[<span class="number">5</span>];</span><br><span class="line">dataOld[<span class="number">0</span>] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>相比于传统的风格，array是一个类，可以用size()方法来访问长度【这个size实际上没有花内存存储】；可以用迭代器，种种。</li><li>array不同于vector，是存储在栈中的。</li></ul><h1 id="—–表达式"><a href="#—–表达式" class="headerlink" title="—–表达式"></a>—–表达式</h1><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=(b=(c=<span class="number">0</span>));</span><br><span class="line">a=b=c;</span><br><span class="line">a = b+c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><blockquote><p>赋值运算符是从右往左计算的，返回值即等号左边对象的引用。 </p><p>所以a=b=c计算顺序是(a=(b=c))，(b=c)运算结果为b的引用，而b已经被赋值为c，所以后面a的值等于c。 </p><p>a=b+c=3的计算顺序为(a=(b+c=3))，b+c的运算结果是一个右值，不能被赋值为3 。</p></blockquote><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) ((a) &gt; (b) ? a : b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="built_in">MAX</span>(++a, b);<span class="comment">//++a(执行1次) &gt; b ? ++a(执行1次) : b;</span></span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">MAX</span>(++a, b + <span class="number">10</span>);<span class="comment">//++a(执行1次) &gt; b ? ++a : b;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&quot;</span>%d %d %d %d\n<span class="string">&quot;, a, b, c, d&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="—–语句"><a href="#—–语句" class="headerlink" title="—–语句"></a>—–语句</h1><h2 id="语句作用域-C-对象生存期"><a href="#语句作用域-C-对象生存期" class="headerlink" title="语句作用域/C++对象生存期"></a>语句作用域/C++对象生存期</h2><p>栈上的对象生存期：一旦超过作用域就会自动销毁；堆上创建的需要手动删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">CreateArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> array[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误。不要试图返回栈上临时变量的指针，函数结束后array被销毁，不会留有分配的空间。</span></span><br></pre></td></tr></table></figure><p>那有没有可能利用这个特性呢？</p><p>一种用法是，用栈创建的类对象 包装 在堆上创建的对象指针。在构造函数中创建堆对象，在析构函数中销毁堆对象。栈上的对象会自动销毁，销毁的时候再顺便销毁堆上的对象，这也是unique_ptr要做的事。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Created Entity&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroyed Entity&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Entity* m_Ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ScopedPtr</span>(Entity* ptr)</span><br><span class="line">        : <span class="built_in">m_Ptr</span>(ptr)</span><br><span class="line">    &#123;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">&#123;</span><br><span class="line">    Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">// 在堆上创建不会自动删除</span></span><br><span class="line">    ScopedPtr e = <span class="keyword">new</span> <span class="built_in">Entity</span>(); <span class="comment">// 隐式转换，超过作用域自动删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="—–函数"><a href="#—–函数" class="headerlink" title="—–函数"></a>—–函数</h1><h2 id="多个返回值处理方法"><a href="#多个返回值处理方法" class="headerlink" title="多个返回值处理方法"></a>多个返回值处理方法</h2><ul><li>通过使用输入参数（引用/指针）；</li><li>通过返回数组（相同类型）array默认在栈上分配，而vector在堆上分配，所以性能会好些？</li><li>返回tuple元组：固定大小的不同类型值的集合，是泛化的std::pair。由于这个比较麻烦，先简单了解一下并搁置。（而且通过索引去获得元素的时候，无法知道元素的具体含义是什么）<a href="https://blog.csdn.net/sevenjoin/article/details/88420885">(50条消息) C++ tuple元组的基本用法(总结)_sevencheng798的博客-CSDN博客</a></li></ul><ul><li>结构体</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回</span></span><br><span class="line"><span class="keyword">return</span> &#123;x, y, name&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取返回值 可知道变量的准确定义</span></span><br><span class="line">vertex.x;</span><br><span class="line">vertex.y;</span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><ul><li><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定的类型。<strong>函数的类型由它的返回值和形参类型共同决定，与函数名无关</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>若想要声明一个可以<strong>指向该函数的指针</strong>，只需要用指针替换函数名即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">bool</span></span> (*pf)(<span class="keyword">const</span> string &amp;, <span class="keyword">const</span> string &amp;);</span><br></pre></td></tr></table></figure><blockquote><p>(<em>pf)括号不可少。否则就是名为pf的函数返回 bool</em>指针。这一长串也是函数指针的类型。</p></blockquote></li></ul><h3 id="使用函数指针"><a href="#使用函数指针" class="headerlink" title="使用函数指针"></a>使用函数指针</h3><ul><li><p>当把<strong>函数名作为一个值</strong>使用时，该函数自动地转化为指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare;</span><br><span class="line">pf = &amp;lengthCompare;<span class="comment">// 两者等价：取地址符是可选的</span></span><br></pre></td></tr></table></figure></li><li><p>直接使用函数指针调用函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>);<span class="comment">// 直接调用</span></span><br><span class="line"><span class="keyword">bool</span> b1 = (*pf)(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>);<span class="comment">// 解引用，等价</span></span><br><span class="line"><span class="keyword">bool</span> b1 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Goodbye&quot;</span>);<span class="comment">// 原始调用</span></span><br></pre></td></tr></table></figure></li><li><p>指向不同函数类型的指针不存在转换规则。但是可以赋值nullptr和0，代表没有指向任何一个函数。</p></li></ul><p>例子：函数指针作为传参。Printvalue函数可以在别的地方实现了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintValue</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ForEach</span><span class="params">(<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="keyword">void</span>(*func)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> value : values)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">func</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; values = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">ForEach</span>(values, PrintValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用的时候也可以用lambda表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ForEach</span>(values, [](<span class="keyword">int</span> value) &#123; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;&#125;);</span><br></pre></td></tr></table></figure><h3 id="函数包装器-std-function"><a href="#函数包装器-std-function" class="headerlink" title="函数包装器 std::function"></a>函数包装器 std::function</h3><ul><li>简介</li></ul><p>该函数包装器模板能包装<strong>任何类型的</strong>【可调用实体】，如普通函数，函数对象，lamda表达式等。</p><p>包装器可拷贝，移动等，并且包装器类型仅仅依赖于调用特征，而不依赖于可调用元素自身的类型。std::function是C++11的新特性，包含在头文件<code>&lt;functional&gt;</code>中。</p><p>一个std::function类型对象实例可以包装下列这几种可调用实体：函数、函数指针、成员函数、静态函数、lamda表达式和函数对象。std::function对象实例可被拷贝和移动，并且可以使用指定的调用特征来直接调用目标元素。当std::function对象实例未包含任何实际可调用实体时，调用该std::function对象实例将抛出std::bad_function_call异常。</p><ul><li>定义一个<code>std::function&lt;int(int)&gt;</code><strong>对象实例</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; callback;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>对象实例<strong>包装函数指针</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*fun_ptr)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    fun_ptr = fun1; <span class="comment">//函数指针fun_ptr指向fun1函数</span></span><br><span class="line">    callback = fun_ptr; <span class="comment">//std::function对象包装函数指针</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    callback = fun1; <span class="comment">//std::function包装函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">42</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装模板函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fun2</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    callback = fun2&lt;<span class="keyword">int</span>&gt;; <span class="comment">//std::function包装模板函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">10</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装函数对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">add</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    callback = <span class="built_in">add</span>(); <span class="comment">//std::function包装对象函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>std::function</code>包装lamda表达式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun3 = [](<span class="keyword">int</span> a) &#123;<span class="keyword">return</span> a * <span class="number">2</span>;&#125;; <span class="comment">//lamda表达式</span></span><br><span class="line">    callback = fun3; <span class="comment">//std::function包装lamda表达式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">callback</span>(<span class="number">9</span>) &lt;&lt; std::endl; <span class="comment">//std::function对象实例调用包装的调用实体</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>……总之还有很多。<a href="https://zhuanlan.zhihu.com/p/390883475">C++ std::function详解与实战 - 知乎 (zhihu.com)</a></p><p>可见各种函数都能包装，并且直接传参使用。</p><h1 id="—–类"><a href="#—–类" class="headerlink" title="—–类"></a>—–类</h1><h2 id="构造函数-成员初始化列表"><a href="#构造函数-成员初始化列表" class="headerlink" title="构造函数-成员初始化列表"></a>构造函数-成员初始化列表</h2><p>利于风格的简化；初始成员变量变得简洁轻松。其它的操作也能一目了然，不然一大堆初始化变量显得混乱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">z</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：如果成员变量含有别的类的对象，小心会构造多次。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_Name;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>), <span class="built_in">z</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>);<span class="comment">// 在方法体内“初始化”</span></span><br><span class="line">        <span class="built_in">Init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里成员变量实际上也会创建一个对象<code>std::string m_Name;</code> 在构造方法里面再初始化<code>m_Name(&quot;Unknown&quot;);</code>（相当于<code>m_Name=string(&quot;Unknown&quot;)</code>）又创建了一个实例覆盖掉原来的。</p><p>初始化列表似乎能解决这个问题……只初始化一次。</p><h2 id="创建并初始化C-对象"><a href="#创建并初始化C-对象" class="headerlink" title="创建并初始化C++对象"></a>创建并初始化C++对象</h2><p>C++可以在栈中创建对象。栈上给变量分配的内存是很接近的，相当于栈上一个接一个分配，相当于只执行了一个CPU命令就能完成分配/删除操作。所以速度是很快的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entity* e;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Entity <span class="title">entity</span><span class="params">()</span></span>;</span><br><span class="line">    e = entity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entity 在括号外的作用域自动销毁</span></span><br></pre></td></tr></table></figure><p>也可以在堆中创建对象。但实际上在堆上创建对象要经过一系列麻烦的操作。比如有个freelist来查看是否还有足够空间，分配之后还要记录分配了多少等等，所以速度要比栈分配慢很多。</p><p>【注意】重点关键字是new；不同于C#和爪哇，C++没有GC，所以要手动删除。C#也可以构建栈上的对象，但是只能通过struct（值类型）来实现。而java创建的都是在堆上的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entity* e;</span><br><span class="line">&#123;</span><br><span class="line">    Entity* entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">//</span></span><br><span class="line">    e = entity;</span><br><span class="line">    entity-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> e;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p>两种方式如何选择？</p><ul><li>栈：更方便更快</li><li>堆：无法用栈分配就用堆。对象太大；需要手动设置对象生命周期</li></ul><h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><p>new 大概作用就是，<strong>在堆上</strong> 分配一连串内存，然后返回指向那个地址的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">// 4 bytes</span></span><br><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">50</span>];<span class="comment">// 200 bytes</span></span><br></pre></td></tr></table></figure><p>new其实是一个操作符，这意味着可以重载它；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">Entity* e = (Entity*) <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Entity));<span class="comment">// C风格</span></span><br></pre></td></tr></table></figure><blockquote><p>两行代码的区别是，除了分配内存返回指针，new还调用了e的构造函数。</p></blockquote><p>new了之后必须要用delete（实际上也是一个操作符），也会调用析构函数。</p><ul><li><p>C#中的this：</p><ul><li><p>【本质】代表当前实例；new的时候，如果将内存分配给引用类型，那么对象创建表达式 就会返回一个<strong>引用</strong>，指向<strong>在堆中</strong>被分配和初始化的<strong>对象实例</strong>。（所以这应该就是对象实例的引用）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;    <span class="comment">//代表当前实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从构造函数中调用其他构造函数（用法）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _salary;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age, <span class="built_in">string</span> name, <span class="built_in">int</span> salary</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>) : <span class="title">this</span>(<span class="params">age, <span class="string">&quot;NULL&quot;</span>, <span class="number">0</span></span>)  <span class="comment">//调用上一个构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为当前实例用作参数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        print(<span class="keyword">this</span>);   <span class="comment">//作为参数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params">Student a</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(a._age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <summary type="html">C++基础部分</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法-刷题思考</title>
    <link href="https://huangxinhere.github.io/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/"/>
    <id>https://huangxinhere.github.io/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/</id>
    <published>2023-03-31T16:00:00.000Z</published>
    <updated>2023-08-19T10:26:11.469Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNjY5NTYxNA==&action=getalbum&album_id=1485825793120387074&scene=173&from_msgid=2247486598&from_itemidx=1&count=3&nolastread=1#wechat_redirect">#数据结构与算法 (qq.com)</a></p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="JZ57-和为S的两个数字【哈希】【双指针】"><a href="#JZ57-和为S的两个数字【哈希】【双指针】" class="headerlink" title="JZ57 和为S的两个数字【哈希】【双指针】"></a>JZ57 和为S的两个数字【哈希】【双指针】</h2><p>首先想到用哈希表存储，遍历元素的时候记录想要的差，以后遇到这个元素就返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">        <span class="comment">// 若存在于想要的数字中，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (map[num]) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;num, sum - num&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不存在，则存储需要的值</span></span><br><span class="line">        map[sum-num] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目提供的是有序数组，那么肯定可以利用这个有序的特点。[1,2,4,7,11,15],15 比如遍历1，那么需要14，用二分查找？emmm，似乎又想复杂了。可以用双指针。首先指向开头和结尾。1+15&gt;15，数太大了，所以右指针向前一位；1+11&lt;15，又小了，所以左指针向右一位……（妙啊</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[l]+array[r] == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt; &#123;array[l], array[r]&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (array[l]+array[r] &gt; sum) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (array[l]+array[r] &lt; sum) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双指针：两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针）。此处是对撞指针。</p></blockquote><h2 id="JZ58-左旋转字符串【字符串】【反转】"><a href="#JZ58-左旋转字符串【字符串】【反转】" class="headerlink" title="JZ58 左旋转字符串【字符串】【反转】"></a>JZ58 左旋转字符串【字符串】【反转】</h2><p>刚开始想的是队列循环/或者在原基础上拼接。头元素转到尾元素。（代码简单就不贴了）</p><p>【题解】呃，直接反转。我只能说玩得很溜，比较开拓思路。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404101920920.png" alt="image-20230404101920920"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">LeftRotateString</span><span class="params">(string str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//取余，因为每次长度为m的旋转相当于没有变化</span></span><br><span class="line">    n = n % m;</span><br><span class="line">    <span class="comment">//第一次逆转全部数组元素</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//第二次只逆转开头m个</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + m - n);</span><br><span class="line">    <span class="comment">//第三次只逆转结尾m个</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>() + m - n, str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ007-数组中和为0的三个数"><a href="#OfferⅡ007-数组中和为0的三个数" class="headerlink" title="OfferⅡ007.数组中和为0的三个数"></a>OfferⅡ007.数组中和为0的三个数</h2><p>先想到排序，然后再暴力……只不过排序后遍历的可能少那么一点点。</p><p>先确定左指针，再确定右指针（没有限制），最后确定中间指针（如果不够补那么直接不行）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; nums.<span class="built_in">size</span>()<span class="number">-3</span>; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[l])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[l]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetR = <span class="number">0</span> - nums[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; r &gt; l+<span class="number">1</span>; r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> targetMid = <span class="number">0</span> - nums[l] - nums[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = r<span class="number">-1</span>; mid &gt; l; mid--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然鹅还是可能出现重复情况，而且不好处理。</p><p><img src="https://img-blog.csdnimg.cn/d29041f703f74a33a2ffcc2a26299b47.png" alt="image-20230420225303368"></p><p>重复情况出现的原因是，设想有-1，-1，0，0，1，1这种多个重复的情况，也就是左、右、中间的指针都可能重复遍历，都要搞个map来存吗？欧摸，这破代码已经不忍瞩目了。</p><p>看了题解后，继续完善自己的代码。自己能想到的最近的一步是去重。其实不用哈希表也可，毕竟已经排好序了，可以通过比较前后数字来去重。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// 排序</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// l的去重操作：排序后，排除第一个而且和前面一个相同的</span></span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetR = <span class="number">0</span> - nums[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; r &gt; l+<span class="number">1</span>; r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// r的去重操作：排序后，排除最后一个而且和后面一个不同的</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt;= nums.<span class="built_in">size</span>()<span class="number">-2</span> &amp;&amp; nums[r] == nums[r+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> targetMid = <span class="number">0</span> - nums[l] - nums[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = r<span class="number">-1</span>; mid &gt; l; mid--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// mid的去重操作:和后面一个不同的，而且排除后一个是r的情况</span></span><br><span class="line">                <span class="keyword">if</span> ((mid != (r<span class="number">-1</span>)) &amp;&amp; nums[mid] == nums[mid+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过[0,0,0,0,0]示例就算成功</p></blockquote><p>由于时间复杂度是n的三次方，所以还是超时了。有没有办法减少循环的时间复杂度呢？再回顾一下我的思路，第一重循环必是从左到右找到第一个元素，第二重循环是从数组右到左，找到第二个元素，第三重循环就决定了结果。第二重循环b往前移的时候必然变小，那么c肯定会增大，b和c可简化成寻找<code>0-a</code>的”滑动窗口“。确定好a的循环范围，接着是b，然后c根据b的变化来进行滑动。</p><p>那这样的话其实l和r包抄mid的思路就有点复杂。比较容易理解的是l，mid，r再根据他俩滑动。mid和r是一个收缩的过程。由于mid和r是”对撞指针“，所以时间复杂度是On。【细节注意】要实现对撞指针，r不能每次都从数组末尾开始，这样就失去了意义，应该从头到尾都是往前前进。</p><h2 id="OfferⅡ008-和大于等于target的最短子数组"><a href="#OfferⅡ008-和大于等于target的最短子数组" class="headerlink" title="OfferⅡ008. 和大于等于target的最短子数组"></a>OfferⅡ008. 和大于等于target的最短子数组</h2><p>一看到连续子数组就想到了那道动态规划：求连续子数组的最大和。这次终于有机会打破自己的刻板理解：究竟什么是动态规划？其中一个重要理解点是：【没有后继性】。</p><p>想象一串数字，取其中的部分子数组，设子数组最后一个元素为I，如果是动态规划的话，那I为结尾，必然知道I所在已知子数组的答案。比如求连续子数组的最大和，I所在子数组是必定有答案的，与后面的元素无关。</p><p>而在这道题中，如<code>2、3、1、2、4、3</code>数组，要使子数组大于等于7，比如遍历到3的时候，已知2、3，你不能确定以2开头还是以3开头的子数组可以达到7，因为这还要取决于后面的元素。可见动态规划是根本不沾边的。</p><p>题目特点是【连续】，这可以想到滑动窗口：中间大致不变（遍历过的元素得到某种程度上的保留），根据目标值滑动左右边界。这里左右边界的分工也很明确，因为元素都是正整数，左缩一个sum必减少，右增一个sum必增多。</p><ul><li>确定左【。</li><li>根据target确定右】。（凑不够target就增）</li><li>符合target则计算r-l长度，更新min。（已经达到target，为了试探更小长度会左缩，所以回到第一步）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>], min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; len; l++)</span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">while</span> (sum &lt; target &amp;&amp; r &lt; len<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r++;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 符合条件时 进行长度更新</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            min = !min || ((r-l) &lt; min) ? r+<span class="number">1</span>-l : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还未达到target但已经遍历完毕 说明后面已经凑不够了 再减少l也没用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum -= nums[l];<span class="comment">// 达到target就左缩</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ009-乘积小于k的子数组【动态规划】"><a href="#OfferⅡ009-乘积小于k的子数组【动态规划】" class="headerlink" title="OfferⅡ009.乘积小于k的子数组【动态规划】"></a>OfferⅡ009.乘积小于k的子数组【动态规划】</h2><blockquote><p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，求数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: nums = [10,5,2,6], k = 100</span><br><span class="line">&gt;输出: 8</span><br><span class="line">&gt;解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br></pre></td></tr></table></figure></blockquote><p>最开始是暴力遍历，两次循环逐一判断，n！的时间复杂度。优化的地方是算过的可以利用起来，就想到滑动窗口（下图）。</p><p><img src="https://img-blog.csdnimg.cn/44e3cc7643eb42a9b8b09350aa36b675.png" alt="image-20230424160024746"></p><p>右扩大直到大于等于k，然后左边界缩小直到在k内，保持窗口内的数稳定在k内。问题来了，窗口其中一小部分连续子数组怎么办呢？</p><p>【题解】我最多想到右增一个能算一个元素与k比较，没想到右增一个就能把里面的子数组个数都算出来了……以j为结尾，与左边界i的关系如下图，如果窗口在k内的话，那么里面所有的子数组都符合小于k。其中还暗含了一点动态规划的思想，不过在这里左缩一个也要计算对应的个数。……只能说，miao啊。</p><p><img src="https://img-blog.csdnimg.cn/f064798499a3420d8ff6ccfe21c16bee.png" alt="image-20230424162111158"></p><blockquote><p>为什么子数组不会重复呢？子数组取决于窗口的左右边界。观察绿色横线，右增一个和左增一个的区别。意义分别是以l为开头的……以r为结尾的所有子数组，然后每次l和r都必然各自只遍历数组一次，所以不会重复。这么想的话，这道题想法真的很奇妙。</p><p>而且由于控制在k内，所以不会整型溢出（暴力遍历如果不加以控制的话就会踩雷）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, product = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); r++)</span><br><span class="line">    &#123;</span><br><span class="line">        product *= nums[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; product &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            product /= nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += r - l + <span class="number">1</span>;<span class="comment">// 最核心</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ010-和为k的子数组"><a href="#OfferⅡ010-和为k的子数组" class="headerlink" title="OfferⅡ010.和为k的子数组"></a>OfferⅡ010.和为k的子数组</h2><blockquote><p>给定一个整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br></pre></td></tr></table></figure></blockquote><p>滑动窗口算出来的结果不对了。为什么呢？进一步思考滑动窗口的能发挥特性的条件是什么。</p><p>如下图，当元素都是正整数时，左右边界滑动是明确可知能增能减的，所以控制在k范围内有明确的方向。</p><p>而正数和负数混合时，窗口将无法知道边界向哪才能维护目标值k（去掉负数为增，去掉正数为减，以此类推）</p><p><img src="https://img-blog.csdnimg.cn/c17c9fcd25fb485192a305168fec747a.png" alt="image-20230424170042843"></p><p>那还有什么办法呢？和以前思路大差不差，先想到暴力，再想着利用已经计算过的部分，就不用逐个重复计算了。每个元素利用（i-1）计算出i个结果，那空间复杂度就有n！了。</p><p>再想想，由于是连续数组，那么第i个元素只要和第i-1个元素的结果分别相加就行了，再之前的结果就不用保留。时间复杂度为【<strong>n</strong>（遍历每一个元素）<strong>×n-1×n-2</strong>（遍历前一个元素的数组）】也是n！……</p><p><img src="https://img-blog.csdnimg.cn/7b22b3f3498b4e818a14a63c5586ad24.png" alt="image-20230424170722046"></p><p>啊啊啊是思维陷阱啊，这似乎是遍历前面然后用空间存储以至于时间复杂度没有爆炸……好吧好吧！</p><p>【题解】</p><ol><li><p>逐个遍历子数组开头和结尾；双循环。</p></li><li><p>前缀和＋哈希表【重点】</p></li></ol><p>重新回顾一下这道题的难点，如果想提高效率，难的是确定子数组的起始(l)和结尾(r)。思路怎么也绕不过列举l和r，上一个思路为什么会导致乌龙的结果呢，也是因为l和r的动态变化导致计算的子数组并没有好用的规律……</p><p>这个解法妙在，使得和为k的(j,i)连续子数组符合k=sum[i]-sum[j-1]。sum是从0到某个元素的和，这样利用k和结尾反推开头……sum是从0开始相加的，这对于每个连续子数组都可用，提高了利用率；而且只是末尾变化，也更稳定……</p><p>大概理解是，按照我需要什么然后来找我遍历过的。已知<code>从0开始到i的所有元素和为sum</code>，那么以i为结尾的子数组要满足和为k，就意味着sum减去<code>子数组前面所有元素和sum[j-1]</code>等于k。那么目前未知数只剩下sum[j-1]。只要它满足<code>sum[j-1] = sum[i]-k</code>，就知道这个k子数组存在。</p><p>由于sum[j-1]和sum[i]都是从第0位开始，所以sum[j-1]肯定是sum[i]遍历过的，用哈希表存起来对应出现的次数，随时检查判断便可。</p><p><a href="https://leetcode.cn/problems/QTMn0o/solution/he-wei-k-de-zi-shu-zu-by-leetcode-soluti-1169/">和为 k 的子数组 - 和为 k 的子数组 - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="comment">// 判断sum[j-1]是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 比如k=10, 遍历到当前14-10=4，要找的前缀和4可能有多种情况，而哈希表存储的就是前缀和的n种可能</span></span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ011-0和1个数相同的子数组"><a href="#OfferⅡ011-0和1个数相同的子数组" class="headerlink" title="OfferⅡ011.0和1个数相同的子数组"></a>OfferⅡ011.0和1个数相同的子数组</h2><p>仍然是连续子数组问题，思考如何找数组的开头和结尾。同样地，除了遍历法没有其它方法有效地遍历每一个开头和结尾，然后想到上一题和为k的子数组……这里求的是个数，不像k那样具有唯一性，那怎么办呢？</p><p>如果要有唯一性，只要把0变成-1，”0和1个数相同“就转换成连续子数组和为0了。</p><p>下一个问题，哈希表存的是和出现次数的时候，怎么知道长度呢？既然是最长长度，那就没必要知道所有的出现次数，由于是从前到后遍历的，所以只需要知道长度第一次出现的索引即可。然后计算更新长度差。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前缀和，最先出现的索引</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求得0~i的连续和</span></span><br><span class="line">        <span class="keyword">if</span> (!nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="comment">// map存有第一个和的索引</span></span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(sum);</span><br><span class="line">        <span class="keyword">if</span> (it != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            count = (i-map[sum]) &gt; count ?  (i-map[sum]) : count;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连续和存入哈希表</span></span><br><span class="line">        map[sum] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>【注意】判断某个元素是否在哈希表内，不能用<code>map[i] == 0</code>（判断不准确，-1也会判定为true），应该用迭代器。</p></blockquote><h2 id="OfferⅡ013-二维子矩阵的和"><a href="#OfferⅡ013-二维子矩阵的和" class="headerlink" title="OfferⅡ013.二维子矩阵的和"></a>OfferⅡ013.二维子矩阵的和</h2><p>暴力算法是超时的。如何利用已经算过的子矩阵和？但是可利用的子矩阵可大可小，很难控制和存储。既然无法从动态局部推算，那就定一个有相同点的可控的局部。</p><p>【题解】又是前缀和。不得不说这真是将前缀和玩出花来了。</p><p>先看灰色、红色、蓝色框。红色框代表要求的子矩阵范围，是由黑色框减去两个蓝色框再加上重叠的部分。那么很明显就求出了上面的式子。</p><p>但是从公式中绿色下划线可见，row1和col1可能为负数，所以还要避免那三种情况，并分别进行对应的处理，这将会加大工作量。所以绿色框又添加了一行一列，这样相应的坐标改成绿色字，就避免了特殊情况讨论。（miao！</p><p><img src="https://img-blog.csdnimg.cn/366a0fe7b8ca4a549af663f4726632ba.png" alt="image-20230428101011460"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; sums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            sums.<span class="built_in">resize</span>(h+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(w+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不从1开始，可能是不想≤h，这样判断就会多判断一次n²</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sums[i+<span class="number">1</span>][j+<span class="number">1</span>] = sums[i][j+<span class="number">1</span>] + sums[i+<span class="number">1</span>][j] + matrix[i][j] - sums[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2+<span class="number">1</span>][col2+<span class="number">1</span>]-sums[row2+<span class="number">1</span>][col1]-sums[row1][col2+<span class="number">1</span>]+sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="JZ67-把字符串换成整数-atoi"><a href="#JZ67-把字符串换成整数-atoi" class="headerlink" title="JZ67 把字符串换成整数(atoi)"></a>JZ67 把字符串换成整数(atoi)</h2><p>一看这个中等难度和正确率就知道坑多多。字符串题除了坑多没别的特点……首先明确的是如果有一个连续的数字，再加上前面的符号位就已经知道结果了。</p><p>符号位这个就挺搞的，有没遍历过/遍历过（+/-）三种状态，假设默认为1，那么就是（+/-）两种状态。这看起来很有道理，但是如果遇到”+++–+-……“这种字符串的，遍历到第二个应该知道已经遍历过，返回无效的0。所以如果设成两种状态的话，并不知道有没有遍历过。所以设成（0/-1/1）三种状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果符号位已经确认</span></span><br><span class="line">    <span class="keyword">if</span> (!sign) &#123;</span><br><span class="line">        sign = s[i] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><p>那么问题又来了，计算sum的时候，刚遍历完符号位sum还是为0，但是以后的计算要涉及到正数还是负数。我把符号给到判断，结果再处理……反正看起来就是一坨东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(string s, <span class="keyword">int</span> &amp;i, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">-1</span> &amp;&amp; -sum &lt; -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)) &#123;</span><br><span class="line">            isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">            isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> sign != <span class="number">0</span> ? sum * sign : sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() &amp;&amp; !isValid; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果符号位已经确认</span></span><br><span class="line">            <span class="keyword">if</span> (!sign) &#123;</span><br><span class="line">                sign = s[i] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            sum = <span class="built_in">GetDigit</span>(s, i, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+i);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i]) || s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】遍历法。思路要清晰一些，去掉前面的空格，然后处理第一个符号，接着都按照是否为数字处理。这点抽象整理的思维还是值得我多多学习的。反正都是从头到尾严格地排（符号位+数字位），也不用考虑太多重复遇到的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//去掉前导空格，如果有</span></span><br><span class="line">    <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[index] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉空格就什么都没有了</span></span><br><span class="line">    <span class="keyword">if</span>(index == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//处理第一个符号是正负号的情况</span></span><br><span class="line">    <span class="keyword">if</span>(s[index] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[index] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉符号就什么都没有了</span></span><br><span class="line">    <span class="keyword">if</span>(index == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[index];</span><br><span class="line">        <span class="comment">//后续非法字符，截断</span></span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//处理越界</span></span><br><span class="line">        <span class="keyword">if</span>(res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; INT_MAX % <span class="number">10</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; -(INT_MIN % <span class="number">10</span>)))</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        res = res * <span class="number">10</span> + sign * (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个状态机的，不明觉厉。<a href="https://www.nowcoder.com/practice/d11471c3bf2d40f38b66bb12785df47f?tpId=265&tqId=39262&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=3&judgeStatus=undefined&tags=&title=">把字符串转换成整数(atoi)_牛客题霸_牛客网 (nowcoder.com)</a></p><h2 id="JZ75-字符串中第一个不重复的字符"><a href="#JZ75-字符串中第一个不重复的字符" class="headerlink" title="JZ75 字符串中第一个不重复的字符"></a>JZ75 字符串中第一个不重复的字符</h2><p>记录每个元素出现的次数；一旦超过1次就移出记录数组。这种解法简单又朴素……我觉得至少是得记录每个元素出现的次数；然后知道哪些元素是只出现过一次……想不出什么优化的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">char</span>&gt; array; <span class="comment">// 记录只存在一次的</span></span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;   <span class="comment">// 记录所有出现过的元素次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    map[ch]++;</span><br><span class="line">    <span class="keyword">if</span> (map[ch] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除array重复的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == ch) &#123;</span><br><span class="line">                array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        array.<span class="built_in">push_back</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(array.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ002-二进制加法"><a href="#OfferⅡ002-二进制加法" class="headerlink" title="OfferⅡ002. 二进制加法"></a>OfferⅡ002. 二进制加法</h2><p>原本想转到十进制又转回去的，long long int都不够，还是老实逐位计算了。</p><p>先翻转对齐，然后逐位计算，记录进位。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string s_str, l_str, res;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s_str = a;</span><br><span class="line">        l_str = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l_str = a;</span><br><span class="line">        s_str = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(s_str.<span class="built_in">begin</span>(), s_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(l_str.<span class="built_in">begin</span>(), l_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 两者相加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (s_str[i] - <span class="string">&#x27;0&#x27;</span>) + (l_str[i] - <span class="string">&#x27;0&#x27;</span>) + add;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum<span class="number">-2</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum));</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补长的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s_str.<span class="built_in">size</span>(); i &lt; l_str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l_str[i] - <span class="string">&#x27;0&#x27;</span>) + add;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum<span class="number">-2</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum));</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一位</span></span><br><span class="line">    <span class="keyword">if</span> (add)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(add));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】代码进一步简洁。直接计算最长的，只不过每次都要判断两次越界再判断是否为1，虽然用了语法糖但其实if判断很多次……而且可读性……呃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 进位</span></span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有位运算。但首先得把两数换成整型，其实还会溢出，这个问题要靠Python语言高精度来弥补……此处略过。</p><h2 id="OfferⅡ005-单词长度的最大乘积【位运算】"><a href="#OfferⅡ005-单词长度的最大乘积【位运算】" class="headerlink" title="OfferⅡ005. 单词长度的最大乘积【位运算】"></a>OfferⅡ005. 单词长度的最大乘积【位运算】</h2><p>初步思路是暴力遍历和匹配。肯定超时，有没有更好的方法？想到的是字符串匹配算法，但是忘了。由于每个单词长度不同，内容也没有共同性，所以必须得逐个遍历两两匹配？然后是两个单词的比较，也是要逐位配？能优化的就只有后者了吧。</p><p>【题解】位运算。因为只有24个小写字母，所以可以用bit来记录a~z是否出现过。然后将两个单词做与操作，只有结果为0时才能说明没有相同字母。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = words.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = words[i][j] - <span class="string">&#x27;a&#x27;</span>;    <span class="comment">// 易错！</span></span><br><span class="line">            bits[i] |= <span class="number">1</span> &lt;&lt; pos;            <span class="comment">// 记住这个写法，把1移动到相应位置再计算，而不是把bits[i]移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(bits[i] &amp; bits[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, <span class="built_in"><span class="keyword">int</span></span>(words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：O(L+n的平方)，L是全部单词长度之和。</p><p>空间复杂度：O(n)，n是数组长度。</p></blockquote><h2 id="OfferⅡ020-回文子字符串的个数"><a href="#OfferⅡ020-回文子字符串的个数" class="headerlink" title="OfferⅡ020.回文子字符串的个数"></a>OfferⅡ020.回文子字符串的个数</h2><p>想到暴力遍历，然后又觉得很像之前数组的前缀和，但是又进行不下去。原因是回文判断是前后对称的，不是连续子串的，每增加遍历一个元素，并不能从已遍历的判断出当前是否为回文数。</p><p>【题解】一、枚举所有回文子串</p><p>枚举又分为两种方法：</p><ul><li>枚举所有的子串，判断是否为回文：需要O(n²)枚举所有子串，又要O(ri-li+1)的时间检查回文，整个时间复杂度为O(n³)。</li><li>枚举每一个可能的回文中心，用两个指针分别向两边拓展，当两个指针指向相同的元素时继续拓展，否则停止。【利用回文的特点，多考虑一下】第一个方法就是有些中心被重复判断，加大了时间复杂度。</li></ul><p>用第二个方法的话，需要考虑如何有序地枚举可能的回文中心。如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。当然你可以做两次循环来分别枚举奇数长度和偶数长度的回文，但是我们也可以用一个循环搞定。我们不妨写一组出来观察观察，假设 n=4，我们可以把可能的回文中心列出来：</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230517153922540-16843091676041.png" alt="image-20230517153922540"></p><blockquote><p>上图是罗列的所有中心枚举的可能，可见有些中心相同但枚举范围不同的，可以合并起来一起检查（因为范围小的不符合条件，那么大范围的肯定也不符合条件；最大范围便是超过某个边界为止）。</p><p>下图是合并同类项的结果，可见中心点可以为0，0 1，1，1 2，2，2 3，3，共2*len-1组。所以可以枚举中心点，范围是超过边界为止。</p></blockquote><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230517150610670.png" alt="image-20230517150610670"></p><p>也就是说确定了中心点（包括左右）和的关系，就能找到每次遍历的范围。由上图可看出，l = i / 2, r = l + (i%2)。</p><p>此类解决方法还是很巧妙的，很强的观察和归纳能力。</p><h2 id="1156-单字符重复子串的最大长度"><a href="#1156-单字符重复子串的最大长度" class="headerlink" title="1156. 单字符重复子串的最大长度"></a>1156. 单字符重复子串的最大长度</h2><p>统计出现最多的字符？没有考虑到连续性，没啥用；那么考虑连续性？从当前字母开始计数为1，如果有连续则继续计数，如果出现不同数字，使用掉一次机会，继续往下遍历——如果还是立刻中断，那么要找是否还存在相同字母；如果还能继续连起来，如果剩余还有相同字母说明可以补，否则就是-1.</p><p>继续抽象整理一下，第一次中断，就假设有，继续补；第二次中断，就找是否有余下相同字母，如果有，则计数生效，如果没有，假如第一次中断的位置+1就是第二次中断的位置，比如abc =&gt; aac，说明后面没有连续的字母可以补了，比如abaa =&gt; aaab, abcd =&gt; aacd的区别。</p><p>然后每个位置的元素都遍历一次，看看有没有更长的（这块能不能优化？）。复杂度就达到了O(n²)级别（当数组都是重复元素）</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="OfferⅡ-030-插入、删除和随机访问都是O-1-的容器"><a href="#OfferⅡ-030-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="OfferⅡ 030. 插入、删除和随机访问都是O(1)的容器"></a>OfferⅡ 030. 插入、删除和随机访问都是O(1)的容器</h2><p>插入删除无疑用哈希表，随机访问还想遍历一下，但是时间复杂度不行，所以引入变长容器vector；</p><p>vector可以直接访问索引，所以通过索引访问随机元素。但vector又不好插入删除，也要依赖哈希表动态更新，哈希表插入时vector在尾部添加，删除时获取哈希表对应的索引进行特定位置的删除。</p><p>但是这样的话vector某个元素的索引是时时变化的。比如原来是第3个，前面删除了，那么就变成了第2个，暂且不说哈希表也要对应变化，后面的一连串也要跟着变化……时间复杂度又上去了。如果vector不删除，或者不连续，都影响随机数每个数字概率都一样的要求……</p><p>总结来说，随机数只和vector有关，插入的话只需要哈希表，但是删除的话vector又依赖哈希表（需要知道哪个被删除了），此时要求哈希表的值和索引值严格对应，但vector的索引由于删除又实时更新……</p><p>【针对删除出现的问题，就是把删除的位置idx和最后一个last替换，并把last索引更新，时间复杂度就是1了】</p><p>所以这道题的难度是，哈希表的特点是判断是否存在但没有索引访问且不连续，而随机数又给出了这样的要求……那么怎样才能辅助哈希表呢？</p><p>【题解】哈希表＋滑动窗口。比我原来的想法高明在，找是否有相同的字母来补，不是遍历，而是哈希表计数确定。如果还有其它一部分没算，那就在前一位或者后一位来补。</p><p>再看后面有没有重复的部分……有待斟酌。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRepOpt1</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : text) &#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">            <span class="comment">// step1: 找出当前连续的一段 [i, j)</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; text.<span class="built_in">size</span>() &amp;&amp; text[j] == text[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cur_cnt = j - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step2: 如果这一段长度小于该字符出现的总数，并且前面或后面有空位，则使用 cur_cnt + 1 更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (cur_cnt &lt; count[text[i]] &amp;&amp; (j &lt; text.<span class="built_in">size</span>() || i &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, cur_cnt + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step3: 找到这一段后面与之相隔一个不同字符的另一段 [j + 1, k)，如果不存在则 k = j + 1 </span></span><br><span class="line">            <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; text.<span class="built_in">size</span>() &amp;&amp; text[k] == text[i]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(k - i, count[text[i]]));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-031-最近最少使用缓存"><a href="#OfferⅡ-031-最近最少使用缓存" class="headerlink" title="OfferⅡ 031.最近最少使用缓存"></a>OfferⅡ 031.最近最少使用缓存</h2><p>逻辑就是以下这样。put的时候会检查存储是否足够，若不够，则删除最久未用的数据；而get的时候会更新该元素的使用情况。其实就满了删除的时候才需要知道哪些元素要删，map做不到，就只能借助于数组，记录元素更新情况。但是map又无法记录索引值，所以用了最笨的遍历方法。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230523152452370.png" alt="image-20230523152452370"></p><p>【题解】哈希表＋双向链表。<a href="https://leetcode.cn/problems/OrIXps/solution/zui-jin-zui-shao-shi-yong-huan-cun-by-le-p3c2/">最近最少使用缓存 - 最近最少使用缓存 - 力扣（LeetCode）</a></p><ul><li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li><li>哈希表即为普通的哈希映射（HashMap），键存的是数字，值存的是对应的链表结点。而链表结点又存了value值。利用了双向链表<strong>方便插入删除</strong>的特点；还有可以<strong>头插或者尾插</strong>的特点（插入头部后面或尾部前面）。因为辅助的数据结构既要实现队列的功能，也要知道中间的元素（被更新到尾部），使用数组会打乱顺序，使用队列就访问不到中间的元素，所以双向链表是最优选择。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ033-变位词组"><a href="#OfferⅡ033-变位词组" class="headerlink" title="OfferⅡ033.变位词组"></a>OfferⅡ033.变位词组</h2><blockquote><p>给定一个变位词组，组合变位词，可以按照任意顺序返回结果。</p></blockquote><p>首先想到遍历。每个元素依次遍历，遇到变位词就组合在一起，再把它们从数组中移除。最坏的情况是每个元素只有自己为一组，那就达到O(n²)的复杂度。</p><p>那怎么把遍历的结果存下来呢？想要记录的结果是，有什么字母，对应多少个出现次数；这个用哈希表怎么记录呢？不用哈希表直接映射的话，逐个遍历比较也很耗时间。</p><p>【题解】排序。由于互为字母异位词的两个字符串包含的<strong>字母相同</strong>，因此对两个字符串分别进行<strong>排序之后得到的字符串一定是相同的</strong>，故可以将排序之后的字符串作为哈希表的键。</p><p>从键来说，简化了记录字母和对应数字，直接整合成字符串；从对来说，哈希表可以存数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (string&amp; str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);  <span class="comment">// 哈希表的second可以放数组？</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O(nklogk)，其中 n 是strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历n 个字符串，对于每个字符串，需要 O(klogk) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nklogk)。</li><li>空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</li></ul></blockquote><p>【计数】直接使用数组作为哈希表的键？需要自定义了。自定义那个看了比较麻烦，有人用字符串来代替数组。需要注意的是，把字符串当作数组来看的话，字符串的元素是char，也就占一个字节，最多记录-128~127，比int记录的要少很多。（怎么解决？待思考</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; hash_al;<span class="comment">//unordered_map的key不能存储vector.</span></span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123;</span><br><span class="line">            <span class="comment">//将字符串转为字母表</span></span><br><span class="line">            <span class="function">string <span class="title">temp</span><span class="params">(<span class="number">26</span>,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : str) &#123;</span><br><span class="line">                --temp[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将变位词放在同一键下面</span></span><br><span class="line">            hash_al[temp].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历哈希表，将变位词组改成输出格式形式</span></span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;string, vector&lt;string&gt;&gt;::iterator it = hash_al.<span class="built_in">begin</span>(); it != hash_al.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-034-外星语言是否排序"><a href="#OfferⅡ-034-外星语言是否排序" class="headerlink" title="OfferⅡ 034.外星语言是否排序"></a>OfferⅡ 034.外星语言是否排序</h2><p>想到的思路是，从头开始遍历两两比较，如果前一个大于后一个，则返回false；否则继续。</p><p>然后是两个单词的比较，也是从头遍历两两比较，如果前一个大于后一个，返回false。由于要参照被打乱的字母表，所以要遍历字母表查两个字母的前后；但是每次比较都遍历的话就很耗时间，k（最短单词长度）×n（数组长度）×26。那么如何记录比较过的信息呢？我想到的键值对是string-int，string是c1c2……但我写得很冗长……</p><p>【题解】突破点在如何快速高效地知道乱序字母表的每个字母对应的位置。这里很巧妙地用<code>index[order[i] - &#39;a&#39;] = i;</code>也就是，默认数组的索引0<del>26对应a</del>b，然后元素记录的是新的索引值……所以比较的时候就能直接检索到所需字母以及对应新索引……实在是妙极了啊啊啊啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            index[order[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接当作二维数组来比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i - <span class="number">1</span>].<span class="built_in">size</span>() &amp;&amp; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> prev = index[words[i - <span class="number">1</span>][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">int</span> curr = index[words[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (prev &lt; curr) &#123;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev &gt; curr) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="comment">/* 比较两个字符串的长度 */</span></span><br><span class="line">                <span class="keyword">if</span> (words[i - <span class="number">1</span>].<span class="built_in">size</span>() &gt; words[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这几题下来有些新的启发，最重要的是记录的思想，并不一定是要哈希表，哈希表只是一种快速定位的键值对形式，数组（字符串）也能有索引快速定位的功能。</p><h2 id="OfferⅡ-035-最小时间差"><a href="#OfferⅡ-035-最小时间差" class="headerlink" title="OfferⅡ 035.最小时间差"></a>OfferⅡ 035.最小时间差</h2><p>除了00：00之外都可以排序比较……？如果前或者后有一个00：00，那么前后都应该补上一个；如果前后都有00：00，那结果就是0。呃……但处理起来似乎很麻烦？（被时间间隔跳跃难住了）</p><p>【题解】啊啊啊没想到全都转化成分钟啊啊啊啊，自己的脑筋还真有点死板哇。而且题解对时间间隔的处理也抓到了要点：将首尾换成“相隔一天”的时间，如果两个时间间隔大于12h，比如5：00、23：00，那就是29：00-23：00，会比较接近；如果间隔小于12h，比如16：00、23：00，那就是40-23，反而会拉远。呃呃呃，反正就是很奇妙啊（不会灵活变通看啥都很妙）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinutes</span><span class="params">(string &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>)) * <span class="number">60</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt; &amp;timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(timePoints.<span class="built_in">begin</span>(), timePoints.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> t0Minutes = <span class="built_in">getMinutes</span>(timePoints[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> preMinutes = t0Minutes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timePoints.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minutes = <span class="built_in">getMinutes</span>(timePoints[i]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, minutes - preMinutes); <span class="comment">// 相邻时间的时间差</span></span><br><span class="line">            preMinutes = minutes;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, t0Minutes + <span class="number">1440</span> - preMinutes); <span class="comment">// 首尾时间的时间差</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O(nlogn)，n是数组长度，排序所需时间；</li><li>空间复杂度：O(n)或O(nlogn)，排序需要空间，取决于具体语言的实现。</li></ul></blockquote><p>【鸽巢原理】根据题意，一共有 24×60=1440种不同的时间。由鸽巢原理可知，如果 timePoints 的长度超过1440，那么必然会有两个相同的时间，此时可以直接返回0。</p><p>鸽巢原理：如果有n+1个鸽子飞进了n个鸽巢中，那么必定有鸽巢中至少飞进了2只鸽子。</p><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="JZ56-数组中只出现一次的两个数字"><a href="#JZ56-数组中只出现一次的两个数字" class="headerlink" title="JZ56 数组中只出现一次的两个数字"></a>JZ56 数组中只出现一次的两个数字</h2><p>想的是直接排序，然后遍历删除重复的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i<span class="number">-1</span>) &gt;= <span class="number">0</span> &amp;&amp; (array[i] == array[i<span class="number">-1</span>])) &#123;</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+(i<span class="number">-1</span>));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】用到了位运算。</p><p>1.总体思路：有一道和它类似的题,它所指的数组中只有一个出现一次的数,而解法就是从头开始不断地异或下去,由于相同的两个数异或值为0,因此最终的异或结果就是答案；</p><p>2.而本题有两个只出现一次的数a和b,我们按异或方法<u>最终只能得到a异或b的值</u>,就需要思考一下这两个数异或的结果有何特点；（利用两数不同且唯一的特点做区分）</p><p>3.我们可以发现,首先这两个数一定不同,故异或结果一定不为0,那么<u>a异或b的结果中一定有一位为1</u>,假设是第x位,那么就说明了a和b的二进制的第x位是不同,根据这一特点,我们可以将数组分为两个集合,即<u>第x位为1的数和第x位为0的数</u>,两部分的异或和即为a和b的值；（找到区分的点，确保两者独立，然后再区分阵营…好抽象！）</p><p>4.要快速求得最后一位1,可以用lowbit运算,它可以快速得到x的最后一位1；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;<span class="comment">// 是一种快速运算</span></span><br><span class="line">    </span><br><span class="line">    temp = a ^ b;<span class="comment">// 常规运算</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;<span class="comment">// 0001</span></span><br><span class="line">    <span class="keyword">while</span>((k &amp; temp) == <span class="number">0</span>)</span><br><span class="line">        k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> twoNums = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 两数异或的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        twoNums ^= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个不同的1</span></span><br><span class="line">    <span class="keyword">int</span> difPos = <span class="built_in">lowbit</span>(twoNums);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        <span class="comment">// 比如difPos = 0010, 那么只有那位为1的时候，与的结果才【不为0】，否则必然为0</span></span><br><span class="line">        <span class="keyword">if</span> (difPos &amp; i) &#123;</span><br><span class="line">            a ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到a的值，也就知道b的值：b = (a^b)^a</span></span><br><span class="line">    b = twoNums ^ a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? vector&lt;<span class="keyword">int</span>&gt;&#123;a,b&#125; : vector&lt;<span class="keyword">int</span>&gt;&#123;b,a&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230403153532720.png" alt="image-20230403153532720"></p><h2 id="OfferⅡ004-只出现一次的数字"><a href="#OfferⅡ004-只出现一次的数字" class="headerlink" title="OfferⅡ004. 只出现一次的数字"></a>OfferⅡ004. 只出现一次的数字</h2><p>除了答案是出现一次，其他元素出现三次。两相同数异或为0，0再异或那个数还是那个数，所以全部异或一遍的话就是所有不重复数异或的结果。</p><p>那怎么办呢？感觉要从出现三次的地方入手……怎么和出现一次作出区分呢？</p><p>【题解】依次确定每一个二进制位。考虑答案的第 i 个二进制位（i 从0开始编号），它可能为0 或 1。对于数组中非答案的元素，每一个元素都出现了 3 次，对应着第 i 个二进制位的 3 个 0 或3 个 1，无论是哪一种情况，它们的和都是 3 的倍数（即和为0 或3）。</p><p>所以把每一个进位对应的所有1/0加起来，就是3的倍数加上0/1。反向取余拼接起来就是答案了……OMG！</p><p>进一步细节思考：数据条件是<code>-2的31次方 &lt;= nums[i] &lt;= 2的31次方 - 1</code>所以是一个有符号整数，那负数的话……？由于补码就是为了正常运算而存在的，那么应该没影响？   需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，那么可能会得到错误的答案。这是因为「有符号整数类型」（即int 类型）的第 31 个二进制位（即最高位）是补码意义下的符号位，对应着 −2的31次方，而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2的31次方。因此在某些语言（例如 Python）中需要对最高位进行特殊判断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            total += ((num &gt;&gt; i) &amp; <span class="number">1</span>);  <span class="comment">// 取某位要&amp;1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="JZ76-删除链表中重复的结点"><a href="#JZ76-删除链表中重复的结点" class="headerlink" title="JZ76 删除链表中重复的结点"></a>JZ76 删除链表中重复的结点</h2><p>题意很简单，但是仔细思考觉得操作起来蛮复杂。</p><p>刚开始想用三个指针。pre，curr，last（和curr重复的最后一个结点，但因为循环，所以重复的话会到最后一个结点的下一个）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHead) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    pre-&gt;next = pHead;</span><br><span class="line">    ListNode* curr = pHead, *last;</span><br><span class="line">    vector&lt;ListNode*&gt; deletes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!curr) &#123;</span><br><span class="line">        last = curr;</span><br><span class="line">        <span class="comment">// 找出重复的范围</span></span><br><span class="line">        <span class="keyword">while</span> (!last-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last-&gt;next-&gt;val == last-&gt;val) &#123;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理重复结点</span></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;val != last-&gt;val) &#123;</span><br><span class="line">            pre-&gt;next = last-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (!curr) &#123;</span><br><span class="line">                deletes.<span class="built_in">push_back</span>(curr);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针更新</span></span><br><span class="line">        curr = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就写不下去了，因为指针多的时候要考虑指针为空的情况，那将要考虑更多情况和写更多的if和while语句，觉得好闹心……而且还要删除重复的指针，不能简单地越过。</p><p>然后就思考，单链表麻烦的地方在于必须维护前后关系，然后要考虑下一个结点可能为空的情况；关系一复杂，就很难搞，要很多变量存储这些关系；那如果使用额外空间/顺序数据结构来帮助维护关系呢？</p><p>接着想到队列，可知队头和队尾，重复的部分删除就好，重要的是两边的头尾……</p><ul><li>确定头：当入队的结点和队首的结点值不同且相邻时，队首出队（必不重复），作为pre</li><li>当入队的结点和队首的结点值相同时，继续入队</li><li>当入队的结点和队首的结点值不同且不相邻时，队首和队尾必然有重复的，从队首开始逐一删除重复元素</li><li>回到第一点，如果出队的时候有pre，那么pre下一个就是队首，出队后接着做pre（头尾相连）</li></ul><p>另，要把空结点也加进去。因为重复的范围必须由下一个元素确定，比如445，但如果后面只有重复的，比如4455，那么空结点也是判断条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHead) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;ListNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* curr = pHead-&gt;next, *head = pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        queue.<span class="built_in">push</span>(curr);</span><br><span class="line">        <span class="comment">// 确定不是重复的数</span></span><br><span class="line">        <span class="keyword">if</span> ((!curr || queue.<span class="built_in">front</span>()-&gt;val != curr-&gt;val) &amp;&amp; queue.<span class="built_in">front</span>()-&gt;next == curr) &#123;</span><br><span class="line">            pre-&gt;next = queue.<span class="built_in">front</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定重复的范围</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((!curr || queue.<span class="built_in">front</span>()-&gt;val != curr-&gt;val) &amp;&amp; queue.<span class="built_in">front</span>()-&gt;next != curr) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="built_in">front</span>() != queue.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                <span class="comment">//ListNode* temp = queue.front();</span></span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//delete temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复继续往下遍历</span></span><br><span class="line">        <span class="keyword">if</span> (curr) &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完链表，必须有个收尾</span></span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不过实际上还是没有解决删除问题，只是删除了临时变量。</p></blockquote><p>【题解】呃，别人还是用指针解决了问题，来学习一下。它只用了一个指针，是判断指针的下一个和下下一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//在链表前加一个表头</span></span><br><span class="line">    res-&gt;next = pHead; </span><br><span class="line">    ListNode* cur = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="comment">//遇到后两个节点值相同</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123; </span><br><span class="line">            <span class="keyword">int</span> temp = cur-&gt;next-&gt;val;</span><br><span class="line">            <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;val == temp) </span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回时去掉表头</span></span><br><span class="line">    <span class="keyword">return</span> res-&gt;next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>短路运算确实在这起了很大效果。<code>cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL</code>如果前面为空，那么后面必不会运算，这就不会报错。除此之外，跨数字链接，它不是记录头和尾，而是头的next一直往后指……总之它一个指针就能完成这些事情，值得思考和学习。</p><h2 id="OfferⅡ-022-链表中环的入口节点"><a href="#OfferⅡ-022-链表中环的入口节点" class="headerlink" title="OfferⅡ 022. 链表中环的入口节点"></a>OfferⅡ 022. 链表中环的入口节点</h2><p>对这种题还是不知道如何思考才正确……</p><p>首先知道有环的话两者必定相遇…为什么要先假设速度就是1，2呢？然后要懂得分析相遇时走过的路径……</p><p><a href="https://leetcode.cn/problems/c32eOV/solution/lian-biao-zhong-huan-de-ru-kou-jie-dian-vvofe/">链表中环的入口节点 - 链表中环的入口节点 - 力扣（LeetCode）</a></p><h2 id="OfferⅡ-026-重排链表"><a href="#OfferⅡ-026-重排链表" class="headerlink" title="OfferⅡ 026. 重排链表"></a>OfferⅡ 026. 重排链表</h2><p>原想法是，用快慢指针找到后一半，然后把后一半用栈存起来，再一一遍历插入。</p><p>之前从来没有注意到一个问题，仔细想想真的还很drama。存入栈的其实是结点的一份拷贝，但指向还是原链表，所以当把栈的元素插入链表中的时候，链表后半部分还在。要是把栈变量的指向改动的话，结果很难设想。这样用空间存储一部分链表的话似乎要十分谨慎，把链表全存入或者构建新链表还好。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230519120051323.png" alt="image-20230519120051323"></p><p>原错误思路:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, *fast = head;</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将后半部分存入栈</span></span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow)</span><br><span class="line">    &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(slow);</span><br><span class="line">        <span class="comment">//ListNode* temp = slow;</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">//delete temp;// 这个好像把slow也删掉了？搞晕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete slow;</span></span><br><span class="line">    <span class="comment">//delete fast;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新遍历，插入</span></span><br><span class="line">    ListNode* curr = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() <span class="comment">/* &amp;&amp; curr */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* node = stack.<span class="built_in">top</span>(); stack.<span class="built_in">pop</span>();</span><br><span class="line">        node-&gt;next = curr-&gt;next;    <span class="comment">// leetcode 报heap-use-after-use错</span></span><br><span class="line"></span><br><span class="line">        curr-&gt;next = node;</span><br><span class="line">        curr = curr-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete curr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若例子是1,2,3,4，结果是1,4,2,3,4,,,,</p></blockquote><p>【题解】一、线性表。存储整个链表。</p><p>因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。</p><p>因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。</p><p>这里题解是用线性表重构整个链表。但是不也拷贝了吗？这个要仔细分析才不会先入为主。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230519122422519.png" alt="image-20230519122422519"></p><blockquote><p>拷贝出来的是node，存入vec的是圈出来的部分。当修改node的next时，由于next是指针，其实是访问指向的对象的next，这和head的next是一样的，所以效果一样。</p><p>仔细想想坑还是好多，以后多积累多思考多注意。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;ListNode*&gt; vec;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (node)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            vec[l]-&gt;next = vec[r];</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[r]-&gt;next = vec[l];</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[l]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【方法二】链表中点+链表逆序+合并链表</p><p>也就是把存储改为逆序，在原链表基础上改，这样就感觉稳很多了。</p><h2 id="OfferⅡ-027-回文链表"><a href="#OfferⅡ-027-回文链表" class="headerlink" title="OfferⅡ 027.回文链表"></a>OfferⅡ 027.回文链表</h2><p>后半部分反转链表，再逐一比较：很慢，就超过百分之十几。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = <span class="built_in">reverse</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明链表长度是奇数, slow在中间点，不需要反转</span></span><br><span class="line">        <span class="keyword">if</span> (fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后半部分</span></span><br><span class="line">        ListNode* head2 = <span class="built_in">reverse</span>(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两比较</span></span><br><span class="line">        <span class="keyword">while</span> (head2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != head2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>【题解】递归。可知递归是从链表的尾部逐一往前，而再用一个全局变量来遍历前半部分，这样就能前后同时比较了。递归对于<strong>链表往前遍历</strong>也是一种很好的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    ListNode* frontPointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       <span class="comment">// 往后递归，直到空结点，返回true；则if判断为!true</span></span><br><span class="line">            <span class="comment">// 从语义来说，也就是递归过的末尾链表符合条件了才返回true，才能够继续往下执行比较，否则就直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上一个if判断为false，开始判断值是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录头结点</span></span><br><span class="line">        frontPointer = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-028-展平多级双向链表"><a href="#OfferⅡ-028-展平多级双向链表" class="headerlink" title="OfferⅡ 028.展平多级双向链表"></a>OfferⅡ 028.展平多级双向链表</h2><p>尝试理解展平的规则：去掉了child指针信息。首先先顺着child往下走，直到没有child的那一个结点，再往右走访问同一行的结点；访问完后回到上一层有孩子结点的结点的右边……用栈来存储有child结点的next结点，访问完child则从栈取出继续访问…</p><p>没有好的抽象思维习惯一下子就绕晕了。</p><p>【题解】深度优先搜索。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230522111207578.png" alt="image-20230522111207578"></p><blockquote><p>这样就好理解多了。把孩子那层扁平化成一条链表再插入到右边去。那在代码实现层面怎么回溯呢？想象了一下递归代码，把孩子层的头结点传进去，返回last结点，把head 和last与自己当前的结点curr和curr-&gt;next连接起来。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* curr = node;</span><br><span class="line">        <span class="comment">// ！记录链表最后一个结点（没有child和扁平化child的结果不同）</span></span><br><span class="line">        Node* last = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr <span class="comment">/* &amp;&amp; curr-&gt;next */</span>)    <span class="comment">// ！要考虑到最后一个结点也可能有child 这样就不需要和next连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* next = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;child)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 扁平化</span></span><br><span class="line">                Node* child_last = <span class="built_in">dfs</span>(curr-&gt;child);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// curr与child连接</span></span><br><span class="line">                curr-&gt;next = curr-&gt;child;</span><br><span class="line">                curr-&gt;child-&gt;prev = curr;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// last和next连接</span></span><br><span class="line">                    child_last-&gt;next = next;</span><br><span class="line">                    next-&gt;prev = child_last;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ！将child置为空</span></span><br><span class="line">                curr-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                last = child_last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ！接着原来的next继续往后</span></span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>时间复杂度：O(n)，其中 n 是链表中的节点个数。</p></li><li><p>空间复杂度：O(n)。上述代码中使用的空间为深度优先搜索中的栈空间，如果给定的链表的「深度」为<br>d，那么空间复杂度为 O(d)。在最坏情况下，链表中的每个节点的next 都为空，且除了最后一个节点外，每个节点的child 都不为空，整个链表的深度为n，因此时间复杂度为O(n)。</p></li></ul></blockquote><p>顺着题解的思路能写出递归的大概，但一些细节是对照别人的代码才看出来的，以后要自己实践一下。</p><p><a href="https://leetcode.cn/problems/Qv1Da2/solution/zhan-ping-duo-ji-shuang-xiang-lian-biao-x5ugr/">展平多级双向链表 - 展平多级双向链表 - 力扣（LeetCode）</a></p><p>【题解】迭代。按照原先的想法，就是：如果有child就往下遍历，往下-往右遍历完后，再看栈还有没有存储（上一层）的结点，继续出栈访问，以此类推。整个过程就是依次遍历的过程，可以在一个while中完成。</p><p>遇到child则进入child所在层，若走到当前层最后一个结点，则考察上一层是否有后续结点，若有则链回上一层（展平）。为了能够链回上一层，需要在通过当前结点cur进入child层时，先将cur.next保存起来，显然应当借助栈来保存。整体是一个层层深入后再自下而上展平的过程。现在来考虑完成展平（结束while）的条件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.cur为空结点 而且 没有上一层（栈空），则为false</span></span><br><span class="line"><span class="keyword">while</span>(cur != null || !stack.<span class="built_in">isEmpty</span>())</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-029-排序的循环链表"><a href="#OfferⅡ-029-排序的循环链表" class="headerlink" title="OfferⅡ 029.排序的循环链表"></a>OfferⅡ 029.排序的循环链表</h2><p>刚开始想到，既然是非降序，那么插入一个数字，要么是最大/最小的，要么是中间的，但是一想到这是循环链表，可能不好找，没仔细想就放弃了。然后果断用了数组存……这样就随便遍历了。好理解但是麻烦了些，空间复杂度为n。</p><p>【题解】找了一个评论，思路和我很像，但是别人写出来了，值得学习。</p><p>有一个核心点我没想到，就是既然是非降序循环，那么肯定有“断点”，最大值和最小值相邻的地方。这样就很快判断插入的值是否为最大最小值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断点 或 边界跳跃点</span></span><br><span class="line">cur-&gt;val &gt; cur-&gt;next-&gt;val <span class="comment">// 当前值大于下一个值</span></span><br><span class="line">value &gt;= cur-&gt;val<span class="comment">// 插入的值比当前值还大，那就是新的最大值</span></span><br><span class="line">value &lt;= cur-&gt;next-&gt;val<span class="comment">// 插入的值比最小值（当前的下一个）还小，就是新的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要满足以上情况，此时cur就是要插入的点的前结点</span></span><br></pre></td></tr></table></figure><p>剩下就是中间的情况。只要满足：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur-&gt;val &lt;= cur-&gt;next-&gt;val<span class="comment">// 升序的情况</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(value &gt;= cur-&gt;val &amp;&amp; value &lt;= cur-&gt;next-&gt;val)<span class="comment">// 夹在两值中间</span></span><br></pre></td></tr></table></figure><p>所以找到符合条件的cur，也就是找到了插入的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结点为空，要创建一个指向自己的新结点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">            head-&gt;next = head;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="comment">// 只遍历一次不重复的</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=head)&#123;</span><br><span class="line">            <span class="comment">// 边界点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val&lt;cur-&gt;val)&#123;</span><br><span class="line">                <span class="comment">// 最小值</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next-&gt;val&gt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 最大值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val&lt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处在中间值</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&lt;=insertVal&amp;&amp;cur-&gt;next-&gt;val&gt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 都不符合条件，继续遍历</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal, cur-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>思路很简洁，还有抓住cur以及next的判断也很巧妙。遇到这题觉得头疼是因为没有找到 <strong>结点间的关系 和 判断条件的关系</strong>，总觉得链表遍历单一，一定要有辅助遍历才行，所以没有分析到位。</p></blockquote><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="OfferⅡ-037-小行星碰撞"><a href="#OfferⅡ-037-小行星碰撞" class="headerlink" title="OfferⅡ 037.小行星碰撞"></a>OfferⅡ 037.小行星碰撞</h2><h2 id="OfferⅡ-038-每日温度"><a href="#OfferⅡ-038-每日温度" class="headerlink" title="OfferⅡ 038.每日温度"></a>OfferⅡ 038.每日温度</h2><p>时间复杂度为O(n²)果然还是超时了。一个数要找到后面第一个比它大的数……除了一个个找还能咋办呢？</p><p>想着要利用已知信息，从左到右遍历的话，比如知道76，78，77，79，即使78知道下一个比它大的数是79，知道有77的存在，但77除了重新遍历还能怎么知道下一个比它大的数呢？</p><p>这里的有逆向思维的方法。最后一个元素对应的答案肯定为0，因为后面没有任何元素了。那倒数第一个呢，已知最后一个，也可以推断答案；倒数第三个……已知后面的所有元素，也能记录索引，那么可以有目的地遍历比它大的，找有没有存在对应索引……（反正细细品</p><p>【题解】虽然说是暴力，但比我那个暴力要巧妙得多。这脑子就是转不过弯来啊。从前往后，用过的元素对题目条件其实没多大帮助，要是倒过来的话，知道后面所有存在的元素反而可以利用起来。</p><p>这里将后面遍历过的元素，存在[30, 100]的数组next里面，记录这个数字（从左往右）第一次出现的索引。然后当当前元素想要找到比它大的元素时，就往[i+1,100]挨个找，看看有没有最近的索引。</p><p>这样看起来每次都要遍历(100-i)次，但是由于肯定不超过100，那么时间复杂度可以算作O(n)，n是温度列表的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="number">101</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> warmerIndex = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = temperatures[i] + <span class="number">1</span>; j &lt; <span class="number">101</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                warmerIndex = <span class="built_in">min</span>(warmerIndex, next[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (warmerIndex != INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            next[temperatures[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="JZ54-二叉搜索树的第k个节点"><a href="#JZ54-二叉搜索树的第k个节点" class="headerlink" title="JZ54 二叉搜索树的第k个节点"></a>JZ54 二叉搜索树的第k个节点</h2><p>二叉搜索一般和中序遍历挂钩，然后遇到k就记录下来……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> target = <span class="number">0</span>, res = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!proot) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = k;</span><br><span class="line">    <span class="built_in">dfs</span>(proot);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count == target) &#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过找到目标后递归并不能停止。所以加上几个递归条件就更好。不过话说这真的是中等题吗……</p><blockquote><ul><li>时间复杂度：<em>O</em>(<em>n</em>)，其中<em>n</em>为二叉树的节点数，所有节点遍历一遍</li><li>空间复杂度：<em>O</em>(<em>n</em>)，栈空间最大深度为二叉树退化为链表，长度为<em>n</em></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!root || res != <span class="number">-1</span> || count &gt; target) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好久没有用过栈了，copy一下来回顾一下：先遍历左子树，把节点都入栈，然后取出栈顶作为当前根节点，来进行判断，接着访问右节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//记录遍历了多少个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    TreeNode* p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用栈辅助建立中序</span></span><br><span class="line">    stack&lt;TreeNode*&gt; s;  </span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() || proot != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (proot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(proot);</span><br><span class="line">            <span class="comment">//中序遍历每棵子树从最左开始</span></span><br><span class="line">            proot = proot-&gt;left;  </span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//第k个直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(count == k)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        proot = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77 按之字形顺序打印二叉树"></a>JZ77 按之字形顺序打印二叉树</h2><p>从左往右遍历的层，就从左往右入队，然后再从右往左取出每个节点，按照右子树左子树的顺序把子树入队；</p><p>同理，从右往左遍历的层，就根据上层是从右往左入队，然后再从左往右出队按照左子树右子树把子树入队。</p><p>按照这个规律，都是先进后出，那么为了分清层次，用两个栈交替使用。</p><p>再梳理一下，比如该层是应该从右往左遍历，但是为了下一层能够从左往右进栈，会从左往右遍历然后将子树入栈，所以遍历的记录要反转一下。【核心是取出栈的节点，然后存节点的顺序】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckLayer</span><span class="params">(stack&lt;TreeNode*&gt; &amp;a, stack&lt;TreeNode*&gt; &amp;b, <span class="keyword">bool</span> isL2R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 遍历每个节点，存入</span></span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* curr = a.<span class="built_in">top</span>();</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isL2R) &#123;</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack1 从左往右存放，从右往左取出，右左遍历</span></span><br><span class="line">    <span class="comment">// stack2 从右往左存放，从左往右取出，左右遍历</span></span><br><span class="line">    stack&lt;TreeNode*&gt; stack1, stack2;</span><br><span class="line">    stack1.<span class="built_in">push</span>(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>() || !stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">CheckLayer</span>(stack1, stack2, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">CheckLayer</span>(stack2, stack1, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【题解】使用队列。要用size记录当前队列长度——解决每一层的问题。然后用level来记录打印方向……确实要简洁很多，直接翻转数组不是快很多吗（doge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res; </span><br><span class="line">        <span class="keyword">if</span> (!pRoot)</span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        queue&lt;TreeNode*&gt; q; <span class="comment">// 定义队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(pRoot); <span class="comment">// 根结点入队列</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; arr; <span class="comment">// 定义数组存储每一行结果</span></span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>(); <span class="comment">// 当前队列长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* tmp = q.<span class="built_in">front</span>(); <span class="comment">// 队头元素</span></span><br><span class="line">                q.<span class="built_in">pop</span>(); </span><br><span class="line">                <span class="keyword">if</span> (!tmp) <span class="comment">// 空元素跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;left); <span class="comment">// 左孩子入队列</span></span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;right); <span class="comment">// 右孩子入队列</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从左至右打印</span></span><br><span class="line">                    arr.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从右至左打印</span></span><br><span class="line">                    arr.<span class="built_in">insert</span>(arr.<span class="built_in">begin</span>(), tmp-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++; <span class="comment">// 下一层，改变打印方向</span></span><br><span class="line">            <span class="keyword">if</span> (!arr.<span class="built_in">empty</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(arr); <span class="comment">// 放入最终结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ78-把二叉树打印成多行"><a href="#JZ78-把二叉树打印成多行" class="headerlink" title="JZ78 把二叉树打印成多行"></a>JZ78 把二叉树打印成多行</h2><p>甚至比JZ77要简单，记录每一层的个数（也就是上一层遍历完后队列的长度）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 存储每一行的结果</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; eachLayer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环每一层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* curr = queue.<span class="built_in">front</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            eachLayer.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line">            queue.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            queue.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eachLayer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(eachLayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ84-二叉树中和为某一值的路径（三）"><a href="#JZ84-二叉树中和为某一值的路径（三）" class="headerlink" title="JZ84 二叉树中和为某一值的路径（三）"></a>JZ84 二叉树中和为某一值的路径（三）</h2><p>由于不知道起点和终点，所以感觉有很多种可能，如果从上往下，虽然每个节点都只有一个父节点，但是从父节点来的也可能有很多种（如含父/祖父等），更不用说从下往上的子节点的可能性了（每一个子树多种可能）。之前对树的记忆一般都是递归（子树返回唯一值），从上往下（父给予唯一值）……不知道如何入手。</p><p>感觉从上往下的思路似乎明确一点。路径就是从父到子，正常思路就是父不够子来凑吧。</p><p>那么接着从某个节点角度来思考，它的任务就是接收父节点传来的要求，然后处理。刚好够的话就凑成一条路径，不够的话继续传给子树，多了的话就返回；</p><p>末尾问题解决了，那么起始点的问题呢？不是从父节点来的，就是以自己为起始。</p><p>所以递归的思路差不多就出来了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, target;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入子树继续找</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以自己为开始</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, target - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, target - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = sum;</span><br><span class="line">    <span class="built_in">dfs</span>(root, target);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题是，以自己为开始的代码会重复执行多次。比如一个底层子节点，它的每一个父辈传下去时都试一下自己为初始节点（多次递归到底层节点），那么它就得每次都重复尝试自己作为初始点的情况。</p><p>所以起始点的两种情况应该分开。父节点需求找完，就开始新的根节点。</p><p>【题解】脑子有点转不过来了。</p><p>既然要找所有路径上节点和等于目标值的路径个数，那肯定先找这样的路径起点，但是我们不知道起点究竟在哪里，而且任意节点都有可能是起点，那我们就前序遍历二叉树的所有节点，每个节点都可以作为一次起点，即子树的根节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以其子结点为新根</span></span><br><span class="line"><span class="built_in">FindPath</span>(root.left, sum); </span><br><span class="line"><span class="built_in">FindPath</span>(root.right, sum);</span><br></pre></td></tr></table></figure><p>查找路径的时候呢，也需要往下遍历，因此还可以继续前序遍历该子树，在遍历的过程遇到一个节点，sum相应减少，若是到最后往下的一个节点值正好等于剩下的sum，则找到一种情况。</p><p>因为前序递归的次序是根左右，因此一定是往下找的路径，不会往上回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入子节点继续找</span></span><br><span class="line"><span class="built_in">dfs</span>(root.left, sum - root.val);</span><br><span class="line"><span class="built_in">dfs</span>(root.right, sum - root.val);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入子树继续找</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询以某结点为根的路径数</span></span><br><span class="line">    <span class="built_in">dfs</span>(root, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以其子结点为新根</span></span><br><span class="line">    <span class="built_in">FindPath</span>(root-&gt;left, sum);</span><br><span class="line">    <span class="built_in">FindPath</span>(root-&gt;right, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O*(<em>n</em>2)，其中n*为二叉树的结点数，两层dfs嵌套递归</li><li>空间复杂度：<em>O</em>(<em>n</em>)，每层dfs最深递归栈都只有n</li></ul></blockquote><p>仔细一想我的想法稍微有点复杂，再抽象一点就是每个节点都可能作为路径起始点，就简化了好多（其实也就是暴力啦！）。然后每个节点为根遍历一次……这样就明白许多了。</p><p>这种看似多种解法的题很容易想复杂，怎么样才能抓住关键点呢？这道题而言，可能是起始点和终点的问题。</p><p>【题解】前缀和 &amp; DFS &amp; 回溯。</p><p>思路类似于<code>和为k的子数组个数</code>，树中某一条从上到下的路径就相当于一个数组，计算前缀和 ；只是树的路径遍历完进行变换 / 回溯的时候，就取消记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* curr, <span class="keyword">int</span> targetSum, <span class="keyword">long</span> <span class="keyword">long</span> prefixSum)</span> </span>&#123;</span><br><span class="line">        prefixSum += curr-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(prefixSum - targetSum) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            count += hash[prefixSum - targetSum];</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefixSum]++;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(curr-&gt;left, targetSum, prefixSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(curr-&gt;right, targetSum, prefixSum);</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefixSum]--; <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>只需要遍历每个节点，时间复杂度为O(n)。哈希表同理。栈空间最多n？</p></blockquote><h2 id="JZ86-在二叉树找到两个节点的最近公共祖先"><a href="#JZ86-在二叉树找到两个节点的最近公共祖先" class="headerlink" title="JZ86 在二叉树找到两个节点的最近公共祖先"></a>JZ86 在二叉树找到两个节点的最近公共祖先</h2><p>之前做过，印象最深的就是路径法，迅速写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; path1, path2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; target, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> left = <span class="built_in">FindPath</span>(root-&gt;left, target, path);</span><br><span class="line">    <span class="keyword">bool</span> right = <span class="built_in">FindPath</span>(root-&gt;right, target, path);</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FindPath</span>(root, o1, path1);</span><br><span class="line">    <span class="built_in">FindPath</span>(root, o2, path2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = path1.<span class="built_in">size</span>() &gt; path2.<span class="built_in">size</span>() ? path1.<span class="built_in">size</span>() : path2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">            res = path1[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O*(<em>n</em>)，其中n*为二叉树节点数，递归遍历二叉树每一个节点求路径，后续又遍历路径</li><li>空间复杂度：O*(<em>n</em>)，最坏情况二叉树化为链表，深度为<em>n</em>，递归栈深度和路径数组为n*</li></ul></blockquote><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230412090059518.png" alt="image-20230412090059518"></p><p>数据很多的时候不知道哪里出了问题……照着题解试改了一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int len = path1.size() &gt; path2.size() ? path1.size() : path2.size();</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path1.<span class="built_in">size</span>() &amp;&amp; i &lt; path2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">        res = path1[i];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就成功了！呃，为什么呢？为啥感觉是一样的意思？</p><p>根据逻辑判断。要满足条件，首先某个节点必须为符合条件的左右孩子的父节点；或者其中一个节点作为父节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; o1, <span class="keyword">int</span>&amp; o2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> left = <span class="built_in">dfs</span>(root-&gt;left, o1, o2);</span><br><span class="line">    <span class="keyword">bool</span> right = <span class="built_in">dfs</span>(root-&gt;right, o1, o2);</span><br><span class="line">    <span class="comment">// 找到某个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == o1 || root-&gt;val == o2) &#123;</span><br><span class="line">        <span class="comment">// 看看子树有没有另外一个节点，有就是结果</span></span><br><span class="line">        <span class="keyword">if</span> (left || right)&#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子树都没有，自己也不是，那么必然不是</span></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 刚好左右子树都有</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 似乎没啥意义……</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root, o1, o2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>空间复杂度On，最坏情况二叉树化为链表，递归栈深度为�<em>n</em></p></blockquote><p>【题解】</p><ul><li>step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。</li><li>step 2：如果都不匹配，则分别递归左、右子树。</li><li>step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.</li><li>step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。</li><li>step 5：继续递归左、右子树，直到遇到step1或者step3的情况。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该子树没找到，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//该节点是其中某一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == o1 || root-&gt;val == o2) </span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="comment">//左子树寻找公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, o1, o2); </span><br><span class="line">    <span class="comment">//右子树寻找公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, o1, o2); </span><br><span class="line">    <span class="comment">//左子树为没找到，则在右子树中</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="comment">//右子树没找到，则在左子树中</span></span><br><span class="line">    <span class="keyword">if</span>(right == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">//否则是当前节点</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;val; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110.删点成林"></a>1110.删点成林</h2><p>把要删的存进哈希表里面，然后该节点被删除的时候，如果有左子树，该左子树就成为新的树；如果有右子树则同理。但是我处理的时候用了delete，感觉不太行，删除该节点的指针后，就好像变成了无意义的内存空间，让上一级指向一个不明所以的内存，似乎很不妙。那就想，指向空行不行？怎么告诉父节点该子节点变为空了呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midOrderTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(root-&gt;val) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> root;    <span class="comment">// 指向空还是delete掉？</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">midOrderTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">midOrderTree</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">midOrderTree</span>(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果被删除，则返回nullptr，作为父节点的子节点，而左右子树则作为根节点；不被删除，返回自己，继续作为父节点的子节点……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">midOrderTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把左右节点都处理好</span></span><br><span class="line">        root-&gt;left = <span class="built_in">midOrderTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">midOrderTree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该节点不用删除，返回自己</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(root-&gt;val) == map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 该节点要删除，返回空。但存在的子树将作为新的根</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">midOrderTree</span>(root))</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-051-节点之和最大的路径"><a href="#OfferⅡ-051-节点之和最大的路径" class="headerlink" title="OfferⅡ 051.节点之和最大的路径"></a>OfferⅡ 051.节点之和最大的路径</h2><blockquote><p>路径 被定义为一条<strong>从树中任意节点出发</strong>，沿<strong>父节点-子节点</strong>连接，<strong>达到任意节点</strong>的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。</p></blockquote><p>刚开始只能想到按照路径逐个遍历节点 来计算路径值。然后就卡在当前节点-父节点-子节点这个遍历顺序上。即使是左右根遍历顺序，当前节点也不知道哪一个节点才是父节点……所以从传统的树遍历顺序来说，很难实现。</p><p>【题解】其实有点不够理解题意，如果父节点也可以是自身节点……？也就是从自己出发直接往下走…… 或者从自己出发沿着父节点再往子节点……这样一来每个节点可能是路径中的一个节点 或者路径的开头 或者自己单成一个路径也行……</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230607123600961.png" alt="image-20230607123600961"></p><p>假设20是当前节点，要走成一条最大和的路径，首先保证加入的节点是最大和，但是不遍历到叶子节点是不知道最大和子路径是多少。所以要递归到叶子节点，再一步步往上累加，每个节点的“最大贡献值” = 左子树最大贡献值 + 右子树最大贡献值 + 当前value。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230607124010161.png" alt="image-20230607124010161"></p><blockquote><p>神乎其神又匪夷所思……解题思路是尽量利用树的结构特点：递归+回溯吗？利用每个节点和子树的关系……？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 【只有在最大贡献值大于 0 时，才会选取对应子节点】</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node-&gt;val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + <span class="built_in">max</span>(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxGain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>时间空间复杂度都是O(n)</p></blockquote><h2 id="OfferⅡ-503-二叉搜索树的中序后继"><a href="#OfferⅡ-503-二叉搜索树的中序后继" class="headerlink" title="OfferⅡ 503.二叉搜索树的中序后继"></a>OfferⅡ 503.二叉搜索树的中序后继</h2><p>原做法是按照中序遍历，记录前一个节点，然后比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">inorderSuccessor</span>(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;val == p-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        TreeNode* right = <span class="built_in">inorderSuccessor</span>(root-&gt;right, p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>细节：虽然题目要求返回节点，但即使节点包含指向其它节点的指针，也无所谓，也就是直接返回原节点就行；</p><p>而且递归的话由于是要往上返回值的，所以找到的话就立马结束递归往上传递值……这样的话还不如迭代。</p></blockquote><p>【题解】利用二叉搜索树的性质。已知p节点，p的中序后继节点要么是右子树的最左节点，（如果没有右子树）要么是祖先节点。前一种情况可以直接求，第二种情况要从root重新往下找起。</p><p>此时如果p的值比cur大，说明p在cur的右子树，往右找；反之往左找。往左找的时候（也就是p比cur小）才更新node，那么一定能记录到p的中序后继。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode *successor = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            successor = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (successor-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                successor = successor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val &gt; p-&gt;val) &#123;</span><br><span class="line">                successor = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ-057-值和下标之差都在给定的范围内"><a href="#OfferⅡ-057-值和下标之差都在给定的范围内" class="headerlink" title="OfferⅡ 057 值和下标之差都在给定的范围内"></a>OfferⅡ 057 值和下标之差都在给定的范围内</h2><p>除了暴力实在想不到别的了，因为两两数字组合没什么规律，除非给它排序之类。要是把全部元素排序的话，还得额外开一个数组一边排序一边记录原索引。</p><p>想的是限定k范围（也就是索引范围）然后逐个遍历，判断元素差的绝对值是否符合要求。</p><p>【题解】方法的改进之处是，</p><p>①利用滑动窗口，只在当前元素x前面的[x-k, x-1]范围内判断。（后面的元素肯定也能遍历到前面的元素）</p><p>②对于窗口内的元素，采用有序的排列数据结构set，因为逐个遍历的话就没有改进，用二分查找就快些；窗口内要找到[x-t, x+t]内的元素，所以先找到第一个≥x-t的元素，再判断是否≤x+t 即可。若没有符合的，就继续往下滑动窗口。</p><p>如果窗口内有重复的数字，由于在窗口内已经符合k的条件，那么绝对值为最小值0肯定符合要求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = rec.<span class="built_in">lower_bound</span>(<span class="built_in">max</span>(nums[i], INT_MIN + t) - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != rec.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= <span class="built_in">min</span>(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                rec.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="JZ41-数据流中的中位数"><a href="#JZ41-数据流中的中位数" class="headerlink" title="JZ41 数据流中的中位数"></a>JZ41 数据流中的中位数</h2><p>很明确用直接排序来找到中间的数，根据数组奇数或偶数长度来决定。时间复杂度根据内置sort函数，每插入一个数字都进行排序。</p><ul><li>如何根据排序目标和数组特点，结合各种排序方法的特点，来进行多个维度的思考呢？</li></ul><p>快排：有点分治的思想，不稳定排序，确保选中的数左右两边各大于小于那个数；</p><p>堆：注重最大值最小值，而中位数的左边和右边各是小顶堆和大顶堆……</p><h2 id="JZ45-把数组排成最小的数"><a href="#JZ45-把数组排成最小的数" class="headerlink" title="JZ45 把数组排成最小的数"></a>JZ45 把数组排成最小的数</h2><p>重点是排序规则。字符串比较大小……</p><h2 id="JZ51-数组中的逆序对【分治】"><a href="#JZ51-数组中的逆序对【分治】" class="headerlink" title="JZ51 数组中的逆序对【分治】"></a>JZ51 数组中的逆序对【分治】</h2><p>刚开始想的是排序求位移差……忽略了补在数字前面的也可能利用了本来比它大的空缺，比如7312，排序1237，3往后只移动一位，因为本来7在3前面占了一个空位。</p><p>接着想，一个数要知道它的所有逆序对，首先可以暴力遍历。进一步优化来想，每遍历一个可以来利用的信息是大概知道这个数的位置（<u>7</u>314=&gt;<u>3</u>14<u>7</u>=&gt;14<u>3</u>7一种趋于有序的情况）。但是即使趋于有序（非完全有序），比如4还是不能很好利用有序情况，还是要逐一遍历。那么怎么做到完全有序呢？思考分治。【待思考……】</p><p>如果两个区间为[4, 3] 和[1, 2]，那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2]的结果是一样的，也就是说区间有序和无序结果是一样的。<br>但是如果区间有序会有什么好处吗？当然，如果区间有序，比如[3,4] 和 [1,2]，如果3 &gt; 1, 显然3后面的所有数都是大于1， 这里为 4 &gt; 1, 明白其中的奥秘了吧。所以我们可以在合并的时候利用这个规则。</p><p><img src="https://uploadfiles.nowcoder.com/images/20211207/78416044_1638883228849/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt"></p><h2 id="2517-【二分查找】礼盒的最大甜蜜度"><a href="#2517-【二分查找】礼盒的最大甜蜜度" class="headerlink" title="2517.【二分查找】礼盒的最大甜蜜度"></a>2517.【二分查找】礼盒的最大甜蜜度</h2><p>刚开始只能想到穷举法。k种组合，然后是两两绝对值差……感觉穷举复杂度直线飙升。但是除了穷举法，这个也没啥规律可言，咋办呢？</p><p>【题解】二分查找+贪心。思路有点和常规穷举相反，先确定好大概的甜度值，再看看有没有k种组合的可能。</p><p>先把price排序，然后最大甜度值就是左右两边的差值，（逐渐缩小甜度值的范围×错误，二分查找应该遵循从中值开始左右波动），只要【找到第一个符合条件的甜度值】，就是目标甜度值了。前提是题目只要求甜度值，不用列举情况……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumTastiness</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = price.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> left = price[<span class="number">0</span>], right = price[len - <span class="number">1</span>] - price[<span class="number">0</span>]; <span class="comment">// 这里的left right的含义是甜蜜度（价格差）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;  <span class="comment">// +1?</span></span><br><span class="line">            <span class="comment">// 当前预估甜蜜度 是否有k种组合满足</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(price, k, mid))</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="keyword">int</span> k, <span class="keyword">int</span> tastiness)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = INT_MIN &gt;&gt; <span class="number">1</span>;    <span class="comment">// 为确保数组第一个元素作为prev，整一个很小的值也不至于溢出</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : price)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p - prev &gt;= tastiness)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                prev = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><ul><li>时间复杂度：O(nlogn + nlogC)，前者是数组price的排序时间，后者是二分查找次数，每次查找的时间是n。</li><li>空间复杂度：O(logn)，排序的空间复杂度。</li></ul></blockquote><p>总之又是很奇妙的一题，当有多种可能性的时候，可以选可能性最小的某个切入点，然后二分查找遍历？</p><h2 id="【堆】OfferⅡ061-和最小的k个数对"><a href="#【堆】OfferⅡ061-和最小的k个数对" class="headerlink" title="【堆】OfferⅡ061.和最小的k个数对"></a>【堆】OfferⅡ061.和最小的k个数对</h2><p>有意识到k个最小和组合，必定是两个有序数组的最前面部分的组合，但是不知道怎么枚举比较快。</p><p>以下解法有图示更加清晰容易理解。</p><p><a href="https://leetcode.cn/problems/qn8gGX/solution/by-licold-ytad/">【时光】图解+详细推导，小顶堆 - 和最小的 k 个数对 - 力扣（LeetCode）</a></p><ul><li>题解：重构解空间+哈希表</li></ul><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230709224955451.png" alt="image-20230709224955451"></p><blockquote><p>罗列了 按升序排序后的两个数组，各自的索引对应的元素相加之和的必然关系。比如[1,1]的和必然大于[0,1]或[1,0]的和。</p><p>所以需要从左往后遍历枚举的可能，直到满足k个为止。</p><p>不过不是按照一层层遍历，而是取当前最小和的[i,j]，将[i+1,j]或[i,j+1]插入优先队列，继续排序。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pair 的比较函数</span></span><br><span class="line">    <span class="keyword">auto</span> greaterthan = </span><br><span class="line">        [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)-&gt;<span class="keyword">bool</span></span><br><span class="line">        &#123; <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second]; &#125;;</span><br><span class="line">    <span class="comment">// pair 的hash函数</span></span><br><span class="line">    <span class="keyword">auto</span> hash = [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a)-&gt;<span class="keyword">size_t</span> &#123; <span class="keyword">return</span> a.first*<span class="number">31</span> + a.second; &#125;;</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(greaterthan)&gt; <span class="built_in">que</span>(greaterthan);</span><br><span class="line">    <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// set 防止重复放入节点</span></span><br><span class="line">    unordered_set&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(hash)&gt; <span class="built_in">st</span>(<span class="number">8</span>, hash);</span><br><span class="line">    que.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    st.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (k -- &amp;&amp; !que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [i, j] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 最小和放入结果中，并移出优先队列</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(initializer_list&lt;<span class="keyword">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">        <span class="comment">// 1. 放入后继节点[i,j+1]</span></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">count</span>(&#123;i, j+<span class="number">1</span>&#125;) &amp;&amp; j+<span class="number">1</span>&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">            st.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 放入后继节点[i+1,j]</span></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">count</span>(&#123;i+<span class="number">1</span>, j&#125;) &amp;&amp; i+<span class="number">1</span>&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(i+<span class="number">1</span>, j);</span><br><span class="line">            st.<span class="built_in">emplace</span>(i+<span class="number">1</span>, j);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先理解基本的，优化方法再看链接。</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="JZ46-把数字翻译成字符串"><a href="#JZ46-把数字翻译成字符串" class="headerlink" title="JZ46 把数字翻译成字符串"></a>JZ46 把数字翻译成字符串</h2><p>首先思考子问题的对象是谁，然后子问题之间的相互关系是什么。</p><p>每增加一个字符，要么算它自己一个(如2=&gt;b)，要么和前面一位组成一个（如26=&gt;z)。</p><p>这个和爬楼梯就挺像的，</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230401145219925.png" alt="image-20230401145219925"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(string nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] codesNum=<span class="keyword">new</span> <span class="keyword">int</span>[nums.Length]; <span class="comment">//状态数组，记录f(x)</span></span><br><span class="line">        <span class="comment">//初始条件：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>].ToString() != <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">            codesNum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数组第2位枚举到最后一位：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.Length;++i)&#123;</span><br><span class="line">            <span class="comment">//判断nums[i]是否不为0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i].ToString() != <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">                codesNum[i]+=codesNum[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断nums[i-1]与nums[i]的数字组合是否在[10,26]内</span></span><br><span class="line">            <span class="keyword">int</span> temp=<span class="keyword">int</span>.Parse(nums[i-<span class="number">1</span>].ToString() + nums[i].ToString());</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>)&#123; <span class="comment">//即f(2)，因为不存在f(0)，所以需要特殊处理：</span></span><br><span class="line">                    codesNum[i]+=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    codesNum[i]+=codesNum[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> codesNum[nums.Length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ47-礼物的最大价值"><a href="#JZ47-礼物的最大价值" class="headerlink" title="JZ47 礼物的最大价值"></a>JZ47 礼物的最大价值</h2><p>最开始想的是回溯算法。遍历所有可能的结果然后记录最大值……结果超时了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_max, j_max, res, max;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 条件判断</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span> || i &gt;= i_max) || (j &lt; <span class="number">0</span> || j &gt;= j_max)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前值</span></span><br><span class="line">    res += grid[i][j];</span><br><span class="line">    flag[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个计算 或 递归</span></span><br><span class="line">    <span class="keyword">if</span> (i == i_max<span class="number">-1</span> &amp;&amp; j == j_max<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; max) &#123;</span><br><span class="line">            max = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, j+<span class="number">1</span>, grid, flag);</span><br><span class="line">        <span class="built_in">dfs</span>(i+<span class="number">1</span>, j, grid, flag);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    res -= grid[i][j];</span><br><span class="line">    flag[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i_max = grid.<span class="built_in">size</span>();</span><br><span class="line">    j_max = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    res = <span class="number">0</span>; max = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">flag</span>(i_max, vector&lt;<span class="keyword">bool</span>&gt;(j_max, <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, grid, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到提示说可以用动态规划。为什么能用动态规划呢？又要怎么思考公式呢？？</p><p>回溯是每个元素都要往右往下进行”试探“，都可能进行n次（？遍历？n的n次方？</p><p>由于只能往下或往右走，所以就某个当前元素来说，要到达这个元素，只能从左边来或者从上面来。那么两个方向来的谁最大谁的值就保留相加，存储在当前位置。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230401212846966.png" alt="image-20230401212846966"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i_max = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> j_max = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(i_max, vector&lt;<span class="keyword">int</span>&gt;(j_max, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; i_max; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; j_max; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个遍历元素，存储最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; i_max; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; j_max; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i_max<span class="number">-1</span>][j_max<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优化的空间是，可以把结果直接存储在grid里面，元素遍历过就没用了。呜呜是为数不多想得明白的动态规划。</p></blockquote><h2 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043.分隔数组以得到最大和"></a>1043.分隔数组以得到最大和</h2><p>开始还是靠正常推敲，想到要尽可能将大数旁边的小数同化，大数不连累更大的数等等，得到基础的思路如下：</p><ul><li>排序依次遍历较大数</li><li>找到那个数对应的范围</li><li>更改数值，记录遍历过的数字，重复第二步</li></ul><p>难在第二步找范围。以那个数为中心，可能有1~k个数，而且起始点和终点也不好确定。总之是要遍历好多遍的样子……想想就不想写。</p><p>【题解】动态规划。还是难以突破思维的惯性，总是习惯找最大数，然后往它左右边找。 </p><p>【dp[i]的含义：以i为结尾的所有可能性之中的，整个数组的最大值】</p><p>假设已有数组A，每增添一个i，增加的可能性是什么呢？</p><p>对于i来说，由于它是数组的结尾，所以包含它的子数组要往前找。它可能自己成为一个数组；或者i、A[i-1]成为一个子数组；或者i、A[i-1]、A[i-2]；直到i 、……A[i-k]。</p><p>成为同一个数组的元素，要全部换成最大元素。那么由上可得，数组的总和的可能性有：</p><ul><li>i+A的总和；</li><li>max(i, A[i-1]) * 2 + A[i-2]…的总和；</li><li>max(i, A[i-1], A[i-2]) * 3 + A[i-3]…的总和等等，以此类推。</li></ul><p>所以i和前面的哪些元素一组，就自成一个独立的子数组，再前面的也是独立的子数组……</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230419223227216.png" alt="image-20230419223227216"></p><blockquote><p>遍历了1，15，7，9后易得每一个最大值都是和15一组。遍历到2的时候，2组队情况有多种，2和9组队时，前面就是以7为结尾的子数组，以7为结尾的子数组中最大值是1，15，7。</p></blockquote><p>总结：在[i-k, i]范围中，计算多种可能的结果，然后取最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历到的当前元素</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和元素组队的范围逐渐扩大，并计算每一种可能的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; j &gt;= i - k; j--) &#123;</span><br><span class="line">            <span class="comment">// d[i]是单独组队，右边是和其它元素组队</span></span><br><span class="line">            d[i] = <span class="built_in">max</span>(d[i], d[j] + maxValue * (i - j));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 范围扩大，更新范围内最大值</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue, arr[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><a href="https://leetcode.cn/problems/MPnaiL/solution/by-flix-0h27/">『 一招吃遍七道 』滑动窗口的应用 - 字符串中的变位词 - 力扣（LeetCode）</a></p><h2 id="JZ48-最长不含重复字符的子字符串"><a href="#JZ48-最长不含重复字符的子字符串" class="headerlink" title="JZ48 最长不含重复字符的子字符串"></a>JZ48 最长不含重复字符的子字符串</h2><p> 逐个遍历，如果在哈希表里面没有记录，那么就继续遍历记录加一，否则清空记录，从被重复的后一位继续开始。（单指针：只需要维护一个指针；原来的想法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 没有重复</span></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(s[i]) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s[i]] = i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始重复</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        i = hash[s[i]];</span><br><span class="line">        hash.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化的空间：从上图可见，第二次遇到a的时候又从b开始，灰色的部分又重复遍历了一次。为了避免重复遍历，这里可用滑动窗口；保留记录过的部分。</p><p>如下图所示，第二次遇到a的时候，窗口左边边界向右滑动一个，确保窗口内没有重复值后，右边界继续滑动……（双指针：维护两个指针，右指针肯定向右，左指针根据右指针是否遍历重复值来进行递增）</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402105626689.png" alt="image-20230402105626689"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.<span class="built_in">length</span>(); right++) &#123;</span><br><span class="line">        hash[s[right]]++;</span><br><span class="line">        <span class="comment">// 有重复，去掉左边的记录，左边界右移</span></span><br><span class="line">        <span class="keyword">while</span> (hash[s[right]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ74-和为S的连续序列"><a href="#JZ74-和为S的连续序列" class="headerlink" title="JZ74 和为S的连续序列"></a>JZ74 和为S的连续序列</h2><p>想到滑动窗口。处理左/右指针（加/减）-判断-移动指针 步骤要区分清楚。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>; r &lt;= sum;) &#123;</span><br><span class="line">    total += r;</span><br><span class="line">    <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &lt; sum) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>()+l);</span><br><span class="line">        total -= l;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; r &lt;= sum;) &#123;</span><br><span class="line">    <span class="comment">// 右指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (total &lt;= sum) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        total += r;</span><br><span class="line">        <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左指针移动</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>()+l);</span><br><span class="line">        total -= l;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; r &lt;= sum;) &#123;</span><br><span class="line">    <span class="comment">// 计算当前情况，再进行下一步操作</span></span><br><span class="line">    total += curr;</span><br><span class="line">    <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        curr = ++r;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &lt; sum) &#123;</span><br><span class="line">        curr = ++r;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        <span class="comment">// 删除左值</span></span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">        curr = -(l++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OfferⅡ014-字符串中的变位词【固定滑动窗口】"><a href="#OfferⅡ014-字符串中的变位词【固定滑动窗口】" class="headerlink" title="OfferⅡ014.字符串中的变位词【固定滑动窗口】"></a>OfferⅡ014.字符串中的变位词【固定滑动窗口】</h2><blockquote><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p><p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p></blockquote><p>刚开始有点懵，排列是什么？想到多种可能性又脑袋疼了。从所需结果来看，只需要判断是否包含。那么换个思路，就是长度为n1的子串，有与s1相同多的字母就符合条件了。</p><ul><li>s2的子串必须是连续的且长度为n1。</li><li>出现的字母数量和s1相同。</li></ul><p>【遍历法-滑动窗口】之前觉得滑动窗口是根据目标值伸缩边界，这里是固定长度，所以没有左缩右扩的条件。遍历时更新记录字母出现次数的数组，然后比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.<span class="built_in">length</span>(), len2 = s2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt1[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnt2[s2[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt1 == cnt2) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 原来是有==重载的…</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len1; i &lt; len2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt2[s2[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnt2[s2[i-len1]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == cnt2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【滑动窗口优化】注意到每次窗口滑动时，只统计了一进一出两个字符，却比较了整个 <em>cnt1</em> 和 <em>cnt2</em> 数组。</p><p>然后想到差值，数组1和数组2是否相等，换句话来说就是数组1和数组2每个元素的差是否为0.那先计算数组2-数组1的差值用cnt记录，如果cnt[i]为正数，说明数组2多了，否则差了，每遍历一次都要检查是否全为0（而且26个字母也有s1不存在的字母，无法比较）。这样的话也只是比方法一少遍历了一次数组。如果用一个变量记录字母数量不同的个数呢？</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230504161211284.png" alt="image-20230504161211284"></p><p>仔细想明白觉得滑动窗口真的很奥妙，要灵活运用还得多体悟思考。此题中窗口大小固定，因为要比较的s1长度固定，需要求s2子串的字母个数和s1分别相等。第一次把两个数组都一起遍历一次，得知s2和s1还差多少字母个数不同的。然后利用滑动窗口，一进一出遍历，减少重复遍历，比如一进，如果进了之后反而增加了差值，那么diff++；反之进了之后减少差值恰好为0，那么diff–。一出同理。</p><p>可能考虑到s2有s1不存在的字母怎么办，也会算进diff里面。这就是连续窗口的奥妙了，如果要确保连续子串，那么存在的话必有diff=0的情况。由于窗口会“吞吐”，即使吃到不存在的字母diff++, 在找到合适之前会一直往前滚动遍历，直到吐出不存在的字母diff–。</p><h2 id="OfferⅡ017-含有所有字符的最短字符串【变长滑动窗口】"><a href="#OfferⅡ017-含有所有字符的最短字符串【变长滑动窗口】" class="headerlink" title="OfferⅡ017.含有所有字符的最短字符串【变长滑动窗口】"></a>OfferⅡ017.含有所有字符的最短字符串【变长滑动窗口】</h2><p>这次t对于s来说不是连续，而是“含有”，求最短长度。那必然是滑动窗口了，首先返回的结果子串是连续的，其次有明确的边界要求（含有t的所有字母及个数）。先右扩找到符合条件的，再左缩缩小范围看有没有更短的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p: ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右扩：找到含t的所有字母个数为止 需要知道含什么字母，以及对应个数</span></span><br><span class="line">    <span class="comment">// 左缩：原基础再缩小看看能否再短</span></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录t的字母及对应个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = INT_MAX, ansL = <span class="number">-1</span>, ansR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; <span class="built_in"><span class="keyword">int</span></span>(s.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="comment">// 记录有效（t含有的）字母[!!]</span></span><br><span class="line">            <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[++r]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++cnt[s[r]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否已经符合t 符合t则判断长度、回缩</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">check</span>() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[l]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ansL == <span class="number">-1</span> ? <span class="built_in">string</span>() : s.<span class="built_in">substr</span>(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="基础数学"><a href="#基础数学" class="headerlink" title="基础数学"></a>基础数学</h1><h2 id="JZ65-不用加减乘除做加法【位运算】"><a href="#JZ65-不用加减乘除做加法【位运算】" class="headerlink" title="JZ65 不用加减乘除做加法【位运算】"></a>JZ65 不用加减乘除做加法【位运算】</h2><p>a+b，结果由进位和非进位相加而成，前提是二进制。因为二进制运算可以方便直接获得进制位，只有1和1才有进位，也就是1&amp;1=1，其余都没有进位，即为0。如果是十进制的话，求进位还要减去10……感觉是做复杂了。关于二进制的运算特点和应用还有待深究。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add = num2;</span><br><span class="line">    <span class="keyword">int</span> sum = num1;</span><br><span class="line">    <span class="comment">// 每一轮只计算 a 和 b 的进位和非进位！不要弄混了</span></span><br><span class="line">    <span class="comment">// 【反例】sum = sum ^ add; add = (sum &amp; add) &lt;&lt; 1; 后者sum改变了，逻辑容易混乱</span></span><br><span class="line">    <span class="keyword">while</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非进位</span></span><br><span class="line">        <span class="keyword">int</span> temp = sum ^ add;</span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">        add = (sum &amp; add) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新新的和</span></span><br><span class="line">        sum = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="剑指offerⅡ-001-整数除法【快速乘】"><a href="#剑指offerⅡ-001-整数除法【快速乘】" class="headerlink" title="剑指offerⅡ 001.整数除法【快速乘】"></a>剑指offerⅡ 001.整数除法【快速乘】</h2><p>思来想去，还是想到最朴素的 被除数暴力相加，为了方便相加，把ab做同号处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ab同号，b不变；ab异号，b变号</span></span><br><span class="line">    <span class="keyword">if</span> ((a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) || (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">        flag = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(sum) &lt;= <span class="built_in">abs</span>(a))</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        sum += b;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) || sum &gt;= <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> count * flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>被除数越小，除数越大，时间也越多，改了一些细节后，还是超时了……</p></blockquote><p>【题解】</p><p>题目要求只能使用加减法，那我们自然想到用减法实现除法，用“被减数”能减去几次“减数”来衡量最后的结果，这时候我们想到求x的幂次的快速解法，将x成倍成倍的求幂，这里【将减数成倍成倍的增大，次数对应也是成倍成倍的增大】，例如：取a=23，b=2，b的变化如下:2-&gt;4-&gt;8-&gt;16,次数count的变化如下1-&gt;2-&gt;4-&gt;8,最后a-b=23-16=7，对7再执行一次上述过程，b:2-&gt;4,count:1-&gt;2,a-b=3, 然后对3再执行一次，b:2,count:1,a-b=1，1已经小于原b=2，可以结束了，最后计数一下每轮的count是多少8+2+1=11，就是我们要的答案啦！</p><blockquote><p>也想过成倍求，但是一想到可能超过很多，就没再继续考虑了……要在范围内进行快速倍求。</p></blockquote><ul><li>为方便运算，我们需要将a，b都转为同正or同负，由于INT_MIN<code>[−2的31次方, 2的31次方−1]</code>转正就越界了，我们只好都转负，这也是都转负的原因；</li><li>有一种特殊情况 INT_MIN/(-1)就overflow了 所以直接特殊处理</li><li>最终结果的正负</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用减法实现除法 均已保证传入的a，b是负数  </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(a&lt;=b)&#123;<span class="comment">//a的绝对值大</span></span><br><span class="line">           <span class="keyword">int</span> temp=b;</span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> count=<span class="number">1</span>;<span class="comment">//a的绝对值大于b的 那么肯定a能减一次b</span></span><br><span class="line">           <span class="keyword">while</span>(temp&gt;=<span class="number">0xc0000000</span>&amp;&amp;a&lt;=temp+temp)&#123;<span class="comment">//减数不越界方便控制后一个条件：且a的绝对值比两倍的减数还大</span></span><br><span class="line">           count+=count;<span class="comment">//可以减的次数翻倍</span></span><br><span class="line">           temp+=temp;<span class="comment">//减数也翻倍</span></span><br><span class="line">           &#125;</span><br><span class="line">           res+=count;</span><br><span class="line">           a-=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> positive=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positive=!positive;</span><br><span class="line">            a = -a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positive=!positive;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> res = <span class="built_in">div</span>(a, b);</span><br><span class="line">        <span class="keyword">return</span> positive? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>越界这个实在是太恶心人了……a,b都有可能达到边界，或者两者的结果。count是必须要unsigned的，因为有可能达到2的31次方……</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = -a;</span><br><span class="line">        positive = !positive;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">        positive = !positive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 快速求倍数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// a,b都是负数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(a) &gt;= <span class="built_in">abs</span>(b)) <span class="comment">// 或者a &lt;= b</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//a的绝对值大于b的 那么肯定a能减一次b</span></span><br><span class="line">        <span class="keyword">int</span> bs = b; </span><br><span class="line">        <span class="keyword">while</span> (bs &gt;= -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) &amp;&amp; <span class="number">2</span> * bs &gt;= a)</span><br><span class="line">        &#123;</span><br><span class="line">            bs *= <span class="number">2</span>;    <span class="comment">// b的倍数翻倍</span></span><br><span class="line">            count *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a -= bs;</span><br><span class="line">        res += count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a,b异号，结果为负</span></span><br><span class="line">    <span class="keyword">return</span> positive ? res : -res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>自己模仿写了一下，为什么老是没过**-2147483648/1**啊呜呜呜。找到了，是<code>while (abs(a) &gt;= abs(b))</code>这个判断出了问题。原来是因为-2147483648一取绝对值又改成正数了，就溢出了……</p></blockquote><p>【题解2】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (b == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> a == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = -a;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = -b;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="comment">// x：被除数</span></span><br><span class="line">        <span class="comment">// y：除数</span></span><br><span class="line">        <span class="comment">// z：x/y</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">bool</span> check = <span class="built_in">quickAdd</span>(b, mid, a);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这个感觉好难懂……</p></blockquote><h2 id="JZ64-求1-2-3-…-n【短路运算】"><a href="#JZ64-求1-2-3-…-n【短路运算】" class="headerlink" title="JZ64 求1+2+3+…+n【短路运算】"></a>JZ64 求1+2+3+…+n【短路运算】</h2><p>要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。想到的是递归，<code>n += Sum_Solution(n-1);</code>每次都和<code>1~n-1的和</code>相加。但是递归条件也要判断，那该怎么办呢？或者是有限次计算就能算出？不懂。</p><p>【题解】利用短路运算结束递归。<a href="https://blog.csdn.net/bulebin/article/details/79345875">(49条消息) &amp;&amp; || 与或 逻辑运算符的短路运算_&amp;&amp;的运算规则_bulebin的博客-CSDN博客</a></p><p>短路运算：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值。</p><ul><li>表达式1 <strong>&amp;&amp;</strong> 表达式2 &amp;&amp; 表达式3…<br>①如果表达式1的值为真，则继续往后执行<br>②如果表达式1的值为假，则返回表达式1</li><li>表达式1 <strong>||</strong> 表达式2 || 表达式3…<br>①如果表达式1的值为真，则返回表达式1<br>②如果表达式1的值为假，则继续往后执行</li></ul><p>所以如果n==0的时候（也就是为false），刚好返回0。果然很妙啊~~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前者返回一个确定值（为false的时候，即为0）</span></span><br><span class="line">    <span class="comment">// 后者继续递归</span></span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">Sum_Solution</span>(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ49-丑数"><a href="#JZ49-丑数" class="headerlink" title="JZ49 丑数"></a>JZ49 丑数</h2><p><a href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=265&tqId=39247&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=3&judgeStatus=undefined&tags=&title=">丑数_牛客题霸_牛客网 (nowcoder.com)</a></p><p>根据丑数概念可知，</p><ul><li>丑数：只包含2/3/5质数；</li><li>非丑数：不含2/3/5；含2/3/5，但还有其他质数。</li></ul><p>如果求有没有包含2/3/5，那么就要考虑三种情况，变得很复杂。既然题目求的是第n个丑数，而不是判断是不是丑数，就没必要一一遍历，而是直接构建丑数。</p><p>那么哪些是丑数呢，基础的是1/2/3/5，然后由小到大相乘（如果a*b两者都没有其他素数，那么结果肯定也没有其他素数）。那么按照怎么样的顺序相乘呢，可见按照右边这样乘不一定按照从小到大的顺序。</p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402154507020.png" alt="image-20230402154507020"></p><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402154832984.png" alt="image-20230402154832984"></p><p>然后想到既然是每位数字都要乘2/3/5，那么只要取出最小的结果先入数组，就能依次排序了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next2 = <span class="number">0</span>, next3 = <span class="number">0</span>, next5 = <span class="number">0</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中一个指针到达index-1</span></span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() != index) &#123;</span><br><span class="line">        next2 = res[i2] * <span class="number">2</span>;</span><br><span class="line">        next3 = res[i3] * <span class="number">3</span>;</span><br><span class="line">        next5 = res[i5] * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">min</span>(next2, <span class="built_in">min</span>(next3, next5));</span><br><span class="line">        <span class="comment">// 确保不重复</span></span><br><span class="line">        <span class="keyword">if</span> (*(res.<span class="built_in">end</span>()<span class="number">-1</span>) != num) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == next2) &#123;</span><br><span class="line">            i2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == next3) &#123;</span><br><span class="line">            i3++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == next5) &#123;</span><br><span class="line">            i5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[index<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ62-圆圈中最后剩下的数"><a href="#JZ62-圆圈中最后剩下的数" class="headerlink" title="JZ62 圆圈中最后剩下的数"></a>JZ62 圆圈中最后剩下的数</h2><p>开始借用了一个数组来循环遍历。（原来叫模拟法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; array;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        array.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (array.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删去元素的时候，后面的数会前移一位，所以i已经代表了下一个数</span></span><br><span class="line">        <span class="comment">// 而且count也是1个数</span></span><br><span class="line">        <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i = (i+<span class="number">1</span>) % array.<span class="built_in">size</span>();</span><br><span class="line">            count = count+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不借用额外空间的话，那么怎么知道中间删除了哪些？</p><p>【题解】找规律/公式递推。这种方法怎么想到的呢……太抽象太神奇了……</p><p><strong>令f(n,m)表示最后一个人的下标</strong>。</p><p>1.假设有n个人，报数m， 从0 开始报数，易知出圈的人下标为 m-1。</p><p>2.m-1 出圈后，我们对剩余人重新编号 即 第m个人下标为0，第m+1 下标为1 ……以此编号。 那么重新编号之后，那么最后一个人的下标为f(n-1,m)</p><p>问题1： 在重新编号之后的f(n-1,m) 与 重新编号之前的f(n,m)有什么关系？<br>重新编号之前 m, m+1,m+2,….（剩余人的编号）<br>重新编号之后 0 ，1 ，2，….<br>可知 (新编号+m)%n = 旧编号</p><blockquote><p>f(n,m)表示的不是下一个将要删除的人，而是最后一个；可能是因为最后一个人必定是会留下来的，所以只有他的编号是时刻变化着的？</p></blockquote><p>\3. f(n,m) = (f(n-1,m)+m) %n;<br>递归写法复杂度分析：<br>时间复杂度： O(N)<br>空间复杂度： O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//约瑟夫</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">LastRemaining_Solution</span>(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404213229515.png" alt="image-20230404213229515"></p><blockquote><p>绿色是位置，绿三角形是被删除的位置，黑圈是最后的数。</p></blockquote><p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404213240076.png" alt="image-20230404213240076"></p><blockquote><p>分析了才知道，一直描述的都是最后那个留下的时刻变动的位置。最后只剩下那个数时，位置必然为0，此时n=1；每删除一个数，假如更新第m个的位置使之为0，那么其它的数字位置也会变化，都遵循相同的变化规律。总之觉得太抽象了！！</p></blockquote><h2 id="JZ70-矩阵覆盖"><a href="#JZ70-矩阵覆盖" class="headerlink" title="JZ70 矩阵覆盖"></a>JZ70 矩阵覆盖</h2><p>刚开始觉得要硬刚……算图形是什么的，然后想得好复杂，放弃。没想到……竟然是数学归纳法……emmm。</p><blockquote><p>由规律发现，2∗<em>n</em>的矩形的情况数为*f(n)=f(n−1)+f(n−2)*，即这就是一个斐波那契数列，按照斐波那契数列的解法来即可，需要注意不同点在于n小于等于2时，都只有n种。</p></blockquote>]]></content>
    
    
    <summary type="html">虽然很笨，但是也想突破自己学得更好</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统（二）：进程管理</title>
    <link href="https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2023-03-26T16:00:00.000Z</published>
    <updated>2023-06-20T08:35:58.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前驱图、顺序执行与并发执行的特征"><a href="#前驱图、顺序执行与并发执行的特征" class="headerlink" title="前驱图、顺序执行与并发执行的特征"></a>前驱图、顺序执行与并发执行的特征</h1><p><a href="https://blog.csdn.net/qq_43722079/article/details/108033191">(42条消息) 【OS笔记 5】前驱图、顺序执行与并发执行的特征_os 顺序执行 前驱图_Crayon小鱼干的博客-CSDN博客</a></p><p>顺序执行</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center.jpeg" alt="在这里插入图片描述"></p><p>并发执行</p><p><img src="https://img-blog.csdnimg.cn/20200816124803336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>程序并发执行时的特征</li></ul><p>① 间断性<br>也就是一个程序的整个执行过程是“走走停停”的，由于共享资源，这些并发的程序相互制约，有时需要进行等待，造成了 “执行——暂停——执行” 的间断性活动规律。</p><p>② 失去封闭性<br>由于并发的程序之间共享系统资源，导致其中任一程序在运行时，其环境都必然会收到其它程序的影响，所以就失去了运行环境的封闭性。</p><p>③ 不可再现性<br>程序在并发执行时，由于失去了封闭性，从而也失去了不可再现性。换句话说，程序在多次执行后，虽然它们执行的环境和初始条件是相同的，但得到的结果却各不相同。<br>比如 A 和 B 两个程序共享变量N，A 中会让 N+1 ，B 中会让 N=0 。那么 N 最后的数值肯定跟 A 和 B 执行的情况（比如执行顺序什么的）有关系。</p><p>此时还未引入进程的概念。如果每次执行的结果都不同，岂不是失去了程序的意义，因此，人们引入了“进程”的概念，并且设计了相应的进程同步机制，<u>使得程序在并发同时也能独立地运行</u>。【两个进程同时跑，但又可能得占用同样的资源，就会发生冲突】</p><h1 id="——进程是什么？——"><a href="#——进程是什么？——" class="headerlink" title="——进程是什么？——"></a>——进程是什么？——</h1><h1 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h1><ul><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是 / 具有独立功能的程序 / 在一个数据集合上 / 的运行过程，它是<u>系统进行资源分配和调度的一个独立单位</u>。</li><li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立过程。</li></ul><h1 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h1><p><strong>进程实体 = 程序 + 数据 + PCB</strong></p><p>为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之<u>配置一个专门的数据结构</u>，称为<strong>进程控制块</strong>（Process Control Block，<strong>PCB</strong>）。</p><p><strong>PCB 的作用：</strong> 描述进程的基本情况和活动过程，方便系统控制和管理进程。所谓创建进程，实质上是创建进程实体中的 PCB；而撤销进程，实质上是撤销进程的 PCB。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230328122220686.png" alt="image-20230328122220686"></p><blockquote><p>程序段可被多个进程共享：一个应用开启多个线程时，数据不一样，但是程序相同，所以没必要再开辟新的内存来存放程序。</p></blockquote><h2 id="进程控制块PCB详解"><a href="#进程控制块PCB详解" class="headerlink" title="进程控制块PCB详解"></a>进程控制块PCB详解</h2><p>【PCB是什么】</p><p>PCB是用以记录与进程相关信息的<u>主存区</u>，是进程存在的唯一标志。</p><p><img src="https://img-blog.csdnimg.cn/20200816155207727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>【PCB中的信息】</p><ul><li><p><strong>进程标识符</strong>：唯一地标识一个进程；</p><p>进程本身：外标识、内部标识；？<br>家族信息：父进程、子进程信息；？</p></li><li><p><strong>处理机状态</strong></p><p>处理机状态信息也称为处理机的上下文（Context），主要是由处理机的各种<a href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&spm=1001.2101.3001.7020">寄存器</a>中的内容组成的。<br>也就是中断现场的保留区，当进程被切换时，处理机状态信息必须都保存在相应的PCB中，以便该进程在重新执行时能再从断点继续执行。</p></li><li><p><strong>进程调度信息</strong></p><p>在OS进行调度时，必须了解<u>进程的状态</u>以及<u>有关进程调度的信息</u>。这些信息包括：</p><p>① 进程状态<br>就绪、执行、阻塞等，是进程调度和对换的依据</p><p>② 进程优先级<br>是分配CPU的重要依据</p><p>③ 其它信息<br>比如进程已等待CPU的时间总和、已执行的时间总和等</p><p>④ 事件<br>指的是阻塞原因（即程序由执行状态变为阻塞状态的原因）</p></li><li><p><strong>进程控制信息</strong></p><p>① 程序和数据的首地址<br>调度到该进程的时候，可以找到其程序和数据</p><p>② 进程同步和通信机制<br>如消息队列指针、信号量等，以后的进程同步中会学到</p><p>③ 资源清单<br>列出了该进程在运行期间所需的全部资源（CPU除外），另外还有一张该进程已分配的资源清单</p><p>④ 链接指针<br>给出了该进程（PCB）所在队列中下一个进程的PCB首地址，跟链表一样</p></li></ul><p>【PCB的三种组织方式】</p><ul><li><strong>线性方式</strong></li></ul><p>系统中所有PCB都组织在一张线性表中，表的首地址存放在内存专用区</p><p><strong>优点：</strong> 实现简单、开销小</p><p><strong>缺点：</strong> 每次查找时都要扫描一整张表，因此适合进程数目不多的系统</p><p><img src="https://img-blog.csdnimg.cn/20200816202839640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><strong>链接方式</strong></li></ul><p>具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。</p><p><img src="https://img-blog.csdnimg.cn/20200816203026357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>内存存储方式还是线性的，然后通过类似于链表的链接组成一个逻辑上的队列？</p></blockquote><ul><li><strong>索引方式</strong></li></ul><p>系统根据所有进程状态的不同，建立几张索引表，并把索引表的首地址记录在内存的专用单元中。在每个索引表的表目中，记录具有相应状态的PCB在PCB表中的首地址</p><p>（其实就是改进版的线性方式，分类之后，变成了很多子表，不需要把整个PCB表都扫描一遍，只需要先根据进程状态找到对应的子表，然后再扫描子表就行了）</p><p><img src="https://img-blog.csdnimg.cn/20200816203851862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h1><ul><li>动态性。进程的实质是进程实体的执行过程，“它由创建而产生，由撤销而死亡。” 有一定的生命周期，动态性是进程最基本的特征。</li><li>并发性。引入进程后，只有建立了PCB的程序，也就是进程才能并发执行。并发性是进程的另一重要特征。</li><li>独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。 凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li><li>异步性。指进程是按各自独立的、不可预知的速度向前推进的。（是不是想到了操作系统的基本特征也有异步性？二者是一个意思）所以才要配备相应的进程同步机制，让各进程之间独立地运行，使得<u>程序每次运行的结果都是一样的</u>。</li><li>制约性。进程之间由于对资源的征用而相互制约。</li></ul><p><a href="https://blog.csdn.net/qq_43722079/article/details/104874035">(42条消息) 试比较程序和进程的异同（区别与联系）_试比较进程和程序的区别_Crayon小鱼干的博客-CSDN博客</a></p><h1 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h1><p><a href="https://blog.csdn.net/weixin_49199646/article/details/109210547">(43条消息) 进程、线程及协程的区别_协程与线程的区别_clw_18的博客-CSDN博客</a></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>进程：一个具有一定独立功能的程序 / 关于某个数据集合上的 / 一次运行活动，是<strong>系统资源分配和独立运行</strong>的最小单位；为了使多个程序并发执行，提高资源利用率和系统效率，OS引入了进程。</li><li>线程：是进程的 / 一个执行单元，是<strong>任务调度和系统执行</strong>的最小单位；为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好，OS引入了线程。</li><li>协程：协程是一种<strong>用户态的轻量级线程</strong>，协程的调度<strong>完全由用户控制</strong>。</li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li><strong>根本区别</strong>：进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li><li><strong>地址空间区别</strong>： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li><li><strong>上下文切换开销区别：</strong> 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li><li><strong>支持多处理机系统方面</strong>：不管有几个处理机，一个进程只能分配到一个CPU上执行，但同一进程内的多个线程可分配到多个CPU上并行执行。</li><li>为什么要引用线程：提高OS的并发性（如同一个应用程序同时执行多个功能），减少资源的分配；</li></ul><h2 id="进程和线程的联系"><a href="#进程和线程的联系" class="headerlink" title="进程和线程的联系"></a>进程和线程的联系</h2><p>一个进程由<u>共享空间</u>（包括堆、代码区、数据区、进程空间和打开的文件描述符）和<u>一个或多个线程</u>组成，<u>各个线程之间共享进程的内存空间</u>，而<strong>一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成</strong>。<br>进程和线程之间的联系如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20201021221100545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201021221114554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><blockquote><p>多线程的优点：</p><ul><li>响应度高：只需要阻塞部分线程，提高了对用户的响应；</li><li>资源共享：线程默认共享所属进程的内存和资源；</li><li>经济：创建和切换线程的代价更小；</li><li>多处理器体系结构的利用：在多CPU上提高了并行性。</li></ul></blockquote><p>线程的实现方式：</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230329161419124.png" alt="image-20230329161419124"></p><ul><li>用户级线程ULT【User Level Thread】（控制块在用户空间）：多个线程通过一个<strong>进程</strong>来系统调用；对内核不可见有多少个线程；进程内切换，都与内核无关，所以减少切换开销。</li><li>内核级线程KLT【Kernel Level Thread】（控制块在内核空间）：多个处理机处理多个线程-并行。由于控制块在内核，程序在用户空间，所以切换时首先到内核空间进行切换，再切换回用户空间执行程序，线程调度开销较大；</li><li>组合方式：内核的一般比用户少。</li></ul><h2 id="进程与线程的选择"><a href="#进程与线程的选择" class="headerlink" title="进程与线程的选择"></a>进程与线程的选择</h2><p>1、线程的<u>创建或销毁的代价</u>比进程小，需要频繁创建和销毁时应优先选用线程；</p><p>2、线程<u>上下文切换的速度</u>比进程快，需要大量计算时优先选用线程；</p><p>3、线程<u>在CPU上的使用效率</u>更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程；</p><p>4、线程的<u>安全性、稳定性</u>没有进程好，需要更稳定安全时优先使用进程。</p><p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，<u>因此一般情况下优先选择线程进行高并发编程</u>；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此<u>对安全稳定性要求较高时，需要优先选择进程进行高并发编程</u>。</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><a href="https://blog.csdn.net/zheng199172/article/details/88800275">(43条消息) 什么是协程_笑是神的伪装的博客-CSDN博客</a></p><p>协程拥有自己的<strong>寄存器上下文和栈</strong>。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态。这个过程<u>完全由程序控制，不需要内核进行调度</u>。<br><img src="https://img-blog.csdnimg.cn/a550c0974c584398a71c29f783d9b4d9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><p>1、根本区别： 协程是用户态的轻量级线程，不受内核调度；线程是任务调度和系统执行的最小单位，需要内核调度。<br>2、运行机制区别： 线程和进程是同步机制，而协程是异步机制。<br>3、上下文切换开销区别： 线程运行状态切换及上下文切换需要内核调度，会消耗系统资源；而协程完全由程序控制，状态切换及上下文切换不需要内核参与。</p><h1 id="——-进程是怎么运行的？——"><a href="#——-进程是怎么运行的？——" class="headerlink" title="——-进程是怎么运行的？——-"></a>——-进程是怎么运行的？——-</h1><h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p>由于多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现<strong>间断性的运行规律</strong>，所以进程在其<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>内可能具有多种状态。</p><h2 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h2><ul><li><strong>就绪状态</strong></li></ul><p>进程已分配到<u>除CPU之外的所有必要资源</u>，只要再获得CPU，便可立即执行。（可运行但未运行）</p><ul><li><strong>执行状态</strong></li></ul><p>进程<u>已获得CPU</u>，正在执行。（多处理机系统中，则有多个进程处于执行状态）</p><ul><li><strong>阻塞状态</strong></li></ul><p>正在执行的进程由于发生某时间（如I/O请求、申请缓冲区失败等）<u>暂时无法继续执行</u>的状态，即进程的执行受到阻塞。</p><p>引起进程阻塞的事件：</p><p>​    ① 向系统请求共享资源失败<br>​    ② 等待某种操作的完成<br>​    ③ 新数据尚未到达<br>​    ④ 等待新任务的到达</p><p>在执行过程中，如果发生了上述事件，进程便通过阻塞原语 block 将自己阻塞。可见，<strong>阻塞是进程自身的一种主动行为</strong>。 </p><h2 id="三种基本状态的转换"><a href="#三种基本状态的转换" class="headerlink" title="三种基本状态的转换"></a>三种基本状态的转换</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330223850527.png" alt="image-20230330223850527"></p><blockquote><p>I/O请求是广义的资源调度吗？</p></blockquote><h2 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h2><ul><li><p><strong>创建状态（New）</strong>：进程正在创建的状态。创建工作尚未完成（即未进入就绪状态），进程不能被调度运行。</p><ul><li><p>引起进程创建的事件：</p><p><u>（由系统内核创建的三种情况）</u></p><p>① 用户登录<br>在分时系统中，用户登录成功后，系统将为该用户建立一个进程。<br>② 作业调度<br>在多道批处理系统中，从后备队列中选择进程调度时，便为它（们）创建进程，并插入就绪队列中。<br>③ 提供服务<br>比如用户程序要求文件进行打印，操作系统将为它创建一个打印进程。</p><p><u>（用户进程自己创建）</u></p><p>④ 应用请求</p></li><li><p>创建的步骤：</p><p>① 申请<u>空白 PCB</u><br>② 为新进程分配其运行<u>所需的资源</u><br>③ <u>初始化</u>进程控制块 PCB<br>④ 将新进程插入就绪队列</p></li><li><p>进程的层次结构</p><p>在OS中，允许一个进程创建另一个进程，也就是父进程创建子进程，由此便形成了一个进程的层次结构。</p></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/20200818104211935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li><p>终止状态</p><p>进程正常或异常结束，<u>移出就绪队列</u>，但<u>尚未被撤销</u>时的状态。</p><ul><li><p>引起进程终止的事件</p><p>① 正常结束<br>表示进程的任务已经完成，准备退出运行。<br>② 异常结束<br>指进程在运行时发生了某种异常事件，使程序无法继续运行。比如越界错、保护错、非法指令、运行超时等等。<br>③ 外界干预<br>进程应外界的请求而终止运行。比如操作员或操作系统干预、父进程请求、父进程终止时随着父进程而终止。</p></li><li><p>终止需要经过两个步骤：</p><p>① 等待操作系统进行善后处理（标记？）<br>② 将进程的<u>PCB清零</u>，并将PCB空间返还系统</p></li></ul></li></ul><h2 id="五种状态的转换"><a href="#五种状态的转换" class="headerlink" title="五种状态的转换"></a>五种状态的转换</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330224650329.png" alt="image-20230330224650329"></p><h2 id="引入挂起原语"><a href="#引入挂起原语" class="headerlink" title="引入挂起原语"></a>引入挂起原语</h2><p>在许多系统中，为了<u>系统和用户观察分析进程的需要</u>，还引入了挂起操作。</p><p>程序被挂起，意味着进入静止状态。</p><p>如果程序正处于执行状态，它将暂停执行。</p><p>如果程序正处于就绪状态，它将暂不接受调度。</p><ul><li>引入原因<ul><li>终端用户的需要：用户发现自己的程序有可疑问题，希望暂停时，可以使用挂起使之停止。</li><li>父进程请求：有时父进程希望挂起自己的某个子进程，以便考察和修改。</li><li>负荷调节的需要：实时系统中的工作负荷较重时，可以将一些不重要的进程挂起。</li><li>操作系统的需要：操作系统有时需要挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li></ul></li><li>引入挂起操作后的状态转换图</li></ul><p>在 就绪-执行-阻塞 的状态基础上添加以下状态：</p><p>就绪有两种：活动就绪Readya（Ready + active）/ 静止就绪Readys（Ready + suspend）；一旦被挂起就从活动就绪转换到静止就绪；要被激活成活动就绪才能被执行。</p><p>阻塞也有两种：活动阻塞 Blockeda（Blocked + active）/ 静止阻塞 Blockeds（Blocked + suspend）；一旦被挂起就从活动阻塞转换到静止阻塞；要被激活成活动阻塞才能进入活动就绪。</p><p><img src="https://img-blog.csdnimg.cn/20200817200724452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><p>即OS对进程实现有效的管理，包括创建新进程、撤销已有进程、挂起、阻塞和唤醒、进程切换等多种操作。OS通过<strong>原语（Primitive）</strong>操作实现进程控制。</p><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><ul><li>概念：由若干条指令组成（封装成一个程序段），完成特定的功能，是一种<strong>原子操作</strong>（Action Operation）。</li><li>特点<ul><li>原子操作，要么全做，要么全不做，执行过程不会被中断；</li><li>在管态、系统态、内核态下执行，常驻内存；</li><li>是内核三大支撑功能之一（中断处理、时钟管理、原语操作）。</li></ul></li></ul><h2 id="创建-终止-阻塞-唤醒"><a href="#创建-终止-阻塞-唤醒" class="headerlink" title="创建/终止/阻塞/唤醒"></a>创建/终止/阻塞/唤醒</h2><ul><li>创建原语：create</li><li>阻塞原语：block</li><li>唤醒原语：wakeup</li><li>撤销原语：destroy </li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330230746574.png" alt="image-20230330230746574"></p><h2 id="挂起和激活"><a href="#挂起和激活" class="headerlink" title="挂起和激活"></a>挂起和激活</h2><p>为了系统和用户观察和分析进程。</p><ul><li>挂起是放在外存，不在内存中。</li><li>创建=&gt;挂起：创建的时候资源还够，执行的时候要挂起？</li><li>活动阻塞=&gt;挂起：可能因为等待时间过久。</li><li>严格来说”挂起“不算状态。</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230402115106696.png" alt="image-20230402115106696"></p><h1 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h1><h2 id="处理机调度和调度层次"><a href="#处理机调度和调度层次" class="headerlink" title="处理机调度和调度层次"></a>处理机调度和调度层次</h2><p>也叫做处理机调度。根据一定的算法和原则 / 将处理机资源 / 进行重新分配的过程。（上面进程的控制中，控制的对象是进程，对其活动进行干涉；而调度则是面对多个进程）</p><ul><li>前提：作业/进程数 远远大于 处理机数。</li><li>目的：提高资源利用率，减少处理机空闲时间。</li><li>调度程序：一方面要满足特定系统用户的需求（快速响应），另一方面要考虑系统整体效率（系统平均周转时间）和调度算法本身的开销。</li></ul><p>【<strong>调度的层次</strong>】</p><p>多道批处理系统：三级调度模型。</p><p>在多道批处理系统中，一个作业从提交到获得CPU执行，直到作业运行完毕，可能需要经历多级处理机调度。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230402121120477.png" alt="image-20230402121120477"></p><ul><li><p>高级调度（作业调度/长期调度）</p><ul><li>把后备<strong>作业</strong><u>调入内存</u>；</li><li>只调入一次，调出一次（进程的创建和销毁）；</li></ul></li><li><p>中级调度（内存调度/中程调度）</p><ul><li>将<u><strong>进程</strong>调至外存</u>，条件合适再调入内存；</li><li>在内、外存对换区进行进程对换。</li></ul></li><li><p>低级调度（进程调度/短程调度）</p><ul><li>从就绪队列选取<strong>进程</strong>分配给处理机；</li><li>最基本的调度，频率非常高（相当于一个时间片完成）；</li></ul></li></ul><h2 id="进程调度方式（策略）"><a href="#进程调度方式（策略）" class="headerlink" title="进程调度方式（策略）"></a>进程调度方式（策略）</h2><ul><li><p>剥夺式 / 抢占式调度</p><ul><li>立即暂停当前进程；</li><li>分配处理机给另一个进程；</li><li>原则：优先权 / 短进程优先 / 时间片原则。</li></ul></li><li><p>非剥夺式 / 非抢占式调度</p><ul><li>若有进程请求执行；</li><li>等待直到当前进程完成或阻塞；</li><li>缺点：适用于批处理系统，不适用分时/实时系统。</li></ul></li></ul><h2 id="调度的时机、切换与过程（执行）"><a href="#调度的时机、切换与过程（执行）" class="headerlink" title="调度的时机、切换与过程（执行）"></a>调度的时机、切换与过程（执行）</h2><ul><li>调度时机<ul><li>进程运行完毕；</li><li>进程时间片用完；</li><li>进程要求I/O操作；</li><li>执行某种原语操作；</li><li>高优先级进程申请运行（剥夺式调度）。</li></ul></li><li>调度过程（调度策略/保存进程/切换）<ul><li>保存镜像：记录进程现场信息；</li><li>调度算法：确定分配处理机的原则；</li><li>进程切换：分配处理机给其他进程；</li><li>处理机回收：从进程收回处理机。</li></ul></li></ul><h2 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h2><p>调度算法指标：<u>CPU利用率</u>（忙碌时间/总时间）；<u>系统吞吐量</u>（完成作业数/总时间）；周转时间（作业完成时间-提交时间）；等待时间（作业等待处理机调度时间-关注平均值）；响应时间（提交请求到首次响应间隔）……</p><h2 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230403193116458.png" alt="image-20230403193116458"></p><h3 id="先来先服务（FCFS-First-Come-First-Served）"><a href="#先来先服务（FCFS-First-Come-First-Served）" class="headerlink" title="先来先服务（FCFS, First Come First Served）"></a>先来先服务（FCFS, First Come First Served）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230403193607734.png" alt="image-20230403193607734"></p><ul><li>算法内容：调度作业/就绪队列中最先入队者，等待操作完成或阻塞；</li><li>算法原则：按作业/进程到达顺序 服务；</li><li>调度方式：非抢占式调度；</li><li>适用场景：作业/进程调度；</li><li>优缺点：有利于CPU繁忙型作业，充分利用CPU资源；不利于I/O繁忙型作业，操作耗时，其他饥饿。</li></ul><h3 id="短作业优先（SJF，Shortest-Job-First）"><a href="#短作业优先（SJF，Shortest-Job-First）" class="headerlink" title="短作业优先（SJF，Shortest Job First）"></a>短作业优先（SJF，Shortest Job First）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230413165325539.png" alt="image-20230413165325539"></p><ul><li>算法内容：<strong>所需服务时间最短</strong>的作业 / 进程优先服务；</li><li>算法原则：追求最少的平均（带权）周转时间；</li><li>调度方式：SJF / SPF 非抢占式（？还没进CPU？；</li><li>适用场景：作业 / 进程调度；</li><li>优缺点<ul><li>平均等待/周转时间最少；</li><li>长作业周转时间会增加或饥饿；</li><li>估计时间不准确，不能保证紧迫任务及时处理。</li></ul></li></ul><h3 id="高响应比优先（HRRN，Highest-Response-Ratio-Next"><a href="#高响应比优先（HRRN，Highest-Response-Ratio-Next" class="headerlink" title="高响应比优先（HRRN，Highest Response Ratio Next)"></a>高响应比优先（HRRN，Highest Response Ratio Next)</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424194517483.png" alt="image-20230424194517483"></p><ul><li>算法内容：总和FCFS和SJF，综合考虑等待时间和服务时间响应比，高的优先调度；</li><li>算法原则：综合考虑作业 / 进程的等待时间和服务时间；</li><li>调度方式：非抢占式；</li><li>适用场景：作业 / 进程调度；</li><li>响应比计算：<ul><li>响应比 = <strong>（等待时间+服务时间）/服务时间</strong> = 等待时间/服务时间 + 1， ≥1；</li><li>只有当前进程放弃执行权（完成 / 阻塞）时，重新计算所有进程响应比；</li><li><u>长作业</u>等待<u>越久</u>响应比越高，更容易获得处理机。</li></ul></li></ul><h3 id="优先级调度（PSA，Priority-Scheduling-Algorithm）"><a href="#优先级调度（PSA，Priority-Scheduling-Algorithm）" class="headerlink" title="优先级调度（PSA，Priority-Scheduling Algorithm）"></a>优先级调度（PSA，Priority-Scheduling Algorithm）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424195233727.png" alt="image-20230424195233727"></p><ul><li>算法内容：又叫优先权调度，按作业 / 进程 的优先级（紧迫程度）进行调度；</li><li>算法原则：优先级最高（最紧迫）的作业 / 进程先调度；</li><li>调度方式：抢占 / 非抢占式（并不能获得及时执行）</li><li>优先级设置原则：<ul><li>静态（进程创建就确定了） / 动态优先级；</li><li>系统 ＞用户；交互型 ＞ 非交互型；I/O型 ＞计算型；</li><li>低优先级进程可能会产生”饥饿“。</li></ul></li></ul><h3 id="【时间片轮转调度算法】（RR，Round-Robin"><a href="#【时间片轮转调度算法】（RR，Round-Robin" class="headerlink" title="【时间片轮转调度算法】（RR，Round-Robin)"></a>【时间片轮转调度算法】（RR，Round-Robin)</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424195725057.png" alt="image-20230424195725057"></p><blockquote><p>后面的进程必须要等到前面的进程完成时间片，所以严格来说不是实时的，有一定等待时间。</p></blockquote><ul><li>算法内容：按进程到达就绪队列的顺序，轮流分配一个时间片去执行，时间用完则剥夺；</li><li>算法原则：<strong>公平、轮流</strong>为每个进程服务，进程在一定时间内都能得到响应；</li><li>调度方式：抢占式，由<strong>时钟中断</strong>确定时间到；</li><li>适用场景：进程调度；（作业调度是一次性的）</li><li>优缺点：<ul><li>公平，响应快，适用于分时系统；</li><li>时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力；</li><li>时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大。</li></ul></li></ul><h3 id="【多级反馈队列调度】（MFQ，Multileveled-Feedback-Queue）"><a href="#【多级反馈队列调度】（MFQ，Multileveled-Feedback-Queue）" class="headerlink" title="【多级反馈队列调度】（MFQ，Multileveled Feedback Queue）"></a>【多级反馈队列调度】（MFQ，Multileveled Feedback Queue）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230426123415014.png" alt="image-20230426123415014"></p><ul><li>算法内容<ul><li>设置<strong>多个按优先级排序的</strong>就绪队列；</li><li>优先级由高到低，时间片从小到大；</li><li>新进程采用队列降级法（进入第一级队列，按FCFS分时间片）（没有执行完，移到第二级，第三级……）</li><li>前面队列不为空，不执行后续队列进程。</li></ul></li></ul><blockquote><p>无论优先级多少 或者是长短作业，首先都会进入第一个优先级队列，没执行完就进入下一个队列……至少都会执行一下，不至于完全饥饿的状态。</p><p>越往下，优先级越低，但是执行时间越长……</p></blockquote><ul><li>算法原则：集前几种算法优点，相当于PSA+RR</li><li>调度方式：抢占式</li><li>适用场景：进程调度</li><li>优缺点<ul><li>对各类型相对公平；快速响应；</li><li> 终端型作业用户：短作业优先；</li><li>批处理作业用户：周转时间短；</li><li>长批处理作业用户：在前几个队列部分执行。</li></ul></li></ul><h1 id="——进程之间是怎么协作的——"><a href="#——进程之间是怎么协作的——" class="headerlink" title="——进程之间是怎么协作的——-"></a>——进程之间是怎么协作的——-</h1><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427160912451.png" alt="image-20230427160912451"></p><ul><li>概念：进程通信即<strong>进程间的信息交换</strong>。<ul><li>进程是资源分配的基本单位，各进程内存空间彼此独立；</li><li>一个进程不能随意地访问其它进程的地址空间。</li></ul></li><li>特点<ul><li>共享存储（Shared-Memory)</li><li>消息传递（Message-Passing）</li><li>管道通信（Pipe）</li></ul></li></ul><h2 id="共享存储（Shared-Memory"><a href="#共享存储（Shared-Memory" class="headerlink" title="共享存储（Shared-Memory)"></a>共享存储（Shared-Memory)</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427161116063.png" alt="image-20230427161116063"></p><ul><li><p>基于<strong>共享数据结构</strong>（只是存储量小）的通信方式</p><ul><li>多个进程共用某个数据结构（OS提供并控制）；</li><li>由<u>用户（程序员）负责</u>同步处理（读写操作的先后等）；</li><li>低级通信：可以传递少量数据，效率低。（低级：直接操控物理硬件/如内存等</li></ul></li><li><p>基于<strong>共享存储区</strong>的通信方式</p><ul><li>多个进程共用内存中的一块存储区域；</li><li>由<u>进程控制</u>数据的形式和方式（进程自己动态申请）；</li><li>高级通信：可以传递<u>大量数据</u>，效率高（不是调用数据结构的底层操作……？</li></ul></li></ul><blockquote><p>数据收发过程双方不可见，存在安全隐患。</p></blockquote><h2 id="消息传递（Message-Passing）"><a href="#消息传递（Message-Passing）" class="headerlink" title="消息传递（Message-Passing）"></a>消息传递（Message-Passing）</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427161951629.png" alt="image-20230427161951629"></p><ul><li><p>直接通信：点到点发送</p><ul><li>发送和接收时指明<u>双方进程的ID</u>；</li><li>每个进程维护一个<u>消息缓冲</u>队列；</li><li>格式化消息：遵循一定格式，如消息头、进程ID等。</li></ul></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427162351207.png" alt="image-20230427162351207"></p><ul><li><p>间接通信：广播信箱</p><ul><li>以信箱为媒介，作为中间实体；</li><li>发进程将消息发送到信箱，收进程从信箱读取；</li><li>可以广播，容易建立双向通信链。</li></ul><blockquote><p>和共享内存什么区别？操作方式。消息传递是通过send / receive原语……</p></blockquote></li></ul><h2 id="管道通信（Pipe）"><a href="#管道通信（Pipe）" class="headerlink" title="管道通信（Pipe）"></a>管道通信（Pipe）</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230428115510038.png" alt="image-20230428115510038"></p><ul><li>管道<ul><li>用于连接读 / 写进程的共享<strong>文件</strong>，pipe文件；把从一个进程连接到另一个进程的一个数据流称为一个“管道”。</li><li>本质上是<strong>内存中</strong><u>固定大小</u>的缓冲区。</li><li>写满（或者通过结束符标志）才能读(一次性读完)，读完才能写；空的时候不读，空的时候才写；读写两操作互斥</li></ul></li><li><strong>半双工</strong>通信<ul><li>同一时段只能单向通信，双工通信需要两个管道；</li><li>以先进先出（FIFO）方式组织数据传输；</li><li>通过系统调用read()/write()函数进行读写操作。</li></ul></li><li>优点：可传输数据量大，而且安全（对共享存储进行了改进）</li></ul><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>协调</strong>进程间的<strong>相互制约关系</strong>，使它们按照预期的方式执行的过程。（让这些进程按照我们想要的规则/顺序去执行）</p><ul><li>前提<ul><li>进程是并发执行的，进程间存在相互制约关系；</li><li>并发的进程对系统共享资源进行竞争；</li><li>进程通信，过程中相互发送的信号称为消息或事件。</li></ul></li><li>两种相互制约形式<ul><li>间接相互制约关系（<strong>互斥</strong>）：进程<u>排他性</u>地访问共享资源；</li><li>直接相互制约关系（<strong>同步</strong>）：进程间的<u>合作</u>，比如管道通信；</li></ul></li></ul><blockquote><p>理解广义和狭义的同步概念是什么</p></blockquote><h2 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h2><p>进程同步：互斥地访问临界资源（也就是共享资源）。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230501094800100.png" alt="image-20230501094800100"></p><ul><li><p>访问过程</p><ol><li>进入区：尝试进入临界区，成功则【<strong>加锁（lock）</strong>】</li><li>临界区：访问共享资源</li><li>退出区：【<strong>解锁（unlock）</strong>】，唤醒其它阻塞进程</li><li>剩余区：其它代码</li></ol></li><li><p>访问原则</p><ol><li>空闲让进：临界区空闲，允许一个进程进入；</li><li>忙则等待：临界区已有进程，其它进程等待（阻塞状态）；</li><li>有限等待：处于等待的进程，等待时间有限；</li><li>让权等待：等待时应让出CPU执行权，防止“忙等待”（例如死循环</li></ol></li><li><p>软件实现方法</p><ul><li>单标志法：</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230503165357299.png" alt="image-20230503165357299"></p><blockquote><p>对于P0来说：turn≠0的时候（也就是该进入临界区访问共享资源的进程不是它），就一直在进入区（也就是while循环）里面等待；直到别的进程把turn设置为0的时候才会跳出循环，进入下一步临界区进行访问……其它进程以此类推。</p><p>在这里，两个进程是交替访问。</p><p>【问题】当P0在剩余区执行不再返回到进入区的时候（只设置一次turn=1），P1如果想反复进入临界区的话 将一直在进入区等待。临界区没人使用，但是P1却用不了。这违背了【空闲让进】原则。</p></blockquote><ul><li><p>双标志法先检查：</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230503171625478.png" alt="image-20230503171625478"></p><blockquote><p>在临界区的进程对应的元素位就设置成true。就P0来说，如果P1在临界区，就在进入区等待；直到P1退出并唤醒P0。如果P0想反复进入临界区，只要p1不在临界区就能执行。</p><p>【问题】虚线框的代码。如果P0刚刚好执行完<code>while(flag[1]);</code>此时还没执行<code>flag[0]=true</code>也就是仍然是false，若此时p1刚好执行了<code>while(flag[0])</code>，那就误判P0还未进入临界区，此时两线程将一起访问临界区，违背了【忙则等待】原则。</p></blockquote></li><li><p>双标志法后检查：</p></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230504164520333.png" alt="image-20230504164520333"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可能执行的顺序</span><br><span class="line">flag[0] = true;</span><br><span class="line">flag[1] = true;</span><br><span class="line">while(flag[1]);</span><br><span class="line">while(flag[0]);</span><br></pre></td></tr></table></figure><blockquote><p>双方都以为对方在临界区，所以都在进入区等待，违背了【空闲让进】【有限等待】原则。</p></blockquote><ul><li>皮特森算法（在双标志法的基础上加上单标志）</li></ul><p> <img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230504170107437.png" alt="image-20230504170107437"></p></li></ul><ul><li><p>硬件实现方法</p><ul><li><p>中断屏蔽方法：关中断/开中断</p><p><strong>禁止一切中断，CPU执行完临界区之前不会切换</strong>；</p><p>关中断可能会被滥用；</p><p>关中断时间长影响效率；</p><p>不适用于多处理机，无法防止其它处理机调度其它进程访问临界区；（不能锁其它处理机，没有实现效果）</p><p>只适用于内核进程（中断等操作是低级指令，运行在内核态）</p></li><li><p>Test-And-Set（TS指令/TSL指令）</p><p>下图是简要理解。</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230517184530800.png" alt="image-20230517184530800"></p><blockquote><p>先看第二个框，当TestAndSet函数一直返回true的时候，while将在进入临界区之前一直执行循环，也叫自旋、忙等；即该线程还不能进入临界区。</p><p>为什么还不能进入呢，看第一框，old = *lock，也就是lock为true的时候，即其它线程正在锁，该线程只能等待；当lock为false，则跳出循环，进入临界区，直到执行完毕，把lock赋值为false解锁，给其它线程用。</p></blockquote><p>读出标志并设置为true，返回旧值，<strong>原子操作</strong>。 （函数内执行的话不会被打断）；</p><p>也被称为TSL指令（Test-And-Set-Lock)；</p><p>违背“让权等待”，会发生忙等。</p></li><li><p>Swap指令</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230522224425218.png" alt="image-20230522224425218"></p><blockquote><p>只有lock为false的时候，交换后old为false，才会跳出进入临界区之前的循环。</p></blockquote><ul><li>交换两个变量的值，<strong>原子操作</strong>；</li><li>违背“让权等待”（忙等</li></ul></li></ul></li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><ul><li>信号量（Semaphore）机制<ul><li>PV操作：P操作——<strong>wait原语</strong>，进程等待；V操作——<strong>signal原语</strong>，唤醒等待进程；</li><li>整型信号量：表示可用资源数；</li></ul></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523193837115.png" alt="image-20230523193837115"></p><blockquote><p>违背“让权等待”，会发生忙等</p></blockquote><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523194347162.png" alt="image-20230523194347162"></p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523195423701.png" alt="image-20230523195423701"></p><blockquote><ul><li><p>改成用block原语阻塞进程，就不会发生忙等（死循环且在执行）。</p></li><li><p>整个流程：假设有三个进程，一个资源，进程1执行wait的时候，S.value=0，可以进入临界区访问资源；进程2执行wait的时候，S.value=-1, 小于0，进行阻塞；进程3也进来了，S.value=-2，也在阻塞。</p><p>等到进程1访问完到退出区了，执行signal方法，S.value=-1,但还是小于等于0，此时用wakeup原语（重复执行signal方法，直到S.value&gt;0）唤醒等待队列（L）的所有进程。</p></li></ul></blockquote><p>这个是<strong>记录型信号量</strong>：进程进入<strong>阻塞状态</strong>，不会忙等。</p><ul><li>分析进程同步和互斥问题的方法步骤<ul><li>分析关系：进程的数量、进程间的同步或互斥关系、前驱关系；</li><li>整理思路：根据进程的操作流程，确定等待（P）、唤醒（V）的大致顺序；</li><li>设置信号量：根据前两步分析和整理，设置信号量初始值。</li></ul></li></ul><h2 id="管程（Monitor，监视器）"><a href="#管程（Monitor，监视器）" class="headerlink" title="管程（Monitor，监视器）"></a>管程（Monitor，监视器）</h2><ul><li><p>定义</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230525192806235.png" alt="image-20230525192806235"></p><p>“管理进程”，<strong>即用于实现进程同步的工具</strong>。是由代表<u>共享资源的数据结构</u>和<u>一组过程（进行PV操作的函数）组成的管理程序</u>（封装）。【比信号量封装性更高，工作原理和信号量一致；面向对象思想：数据和函数的封装；是被进程调用的程序，本身不是进程】</p></li><li><p>管程的组成</p><ul><li>管程名称；</li><li>局部于管程内部的共享数据结构；【数据私有】</li><li>对该数据结构操作的一组过程（函数）；</li><li>管程内共享数据的初始化语句；</li></ul></li><li><p>管程的基本特性</p><ul><li>是一个模块化的基本程序单位，可以单独编译；（可以对应一个对象实例，有多个管程）；</li><li>是一种抽象数据类型，包含数据和操作；（也就是一个类型；</li><li>信息掩蔽，共享数据只能被管程内的过程访问；</li></ul></li><li><p>条件变量 / 条件对象</p><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230526200939155.png" alt="image-20230526200939155"></p><ul><li>进入管程的进程可能由于条件不满足而阻塞（Wait操作）；</li><li>此时进程应释放管程以便其它进程调用管程；</li><li>进程被阻塞的条件（原因）有多个，移入不同的条件队列；</li><li>进程被移入条件队列后，应释放管程。</li></ul></li></ul><h2 id="经典同步问题（缺）"><a href="#经典同步问题（缺）" class="headerlink" title="经典同步问题（缺）"></a>经典同步问题（缺）</h2><h1 id="——-如何处理死锁问题？——–"><a href="#——-如何处理死锁问题？——–" class="headerlink" title="——-如何处理死锁问题？——–"></a>——-如何处理死锁问题？——–</h1><h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>多个进程由于<strong>竞争资源</strong>而造成的<strong>阻塞现象</strong>，若无外力作用，这些进程将无法继续推进。</p><ul><li>相似概念：饥饿。<strong>等待时间过长</strong>以至于给进程推进和响应带来明显影响，“饿而<strong>不死</strong>”。（能得到执行但效率很低，不至于完全阻塞）</li></ul><h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><ul><li>系统资源的竞争；</li><li>进程推进顺序非法。</li></ul><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>必要条件：条件缺一不可。（?</p><p>【狭义的死锁】</p><ul><li>互斥条件：共享资源的非他性访问 / 独占性访问；（有且只有一个进程访问）</li><li>不剥夺条件：访问时该共享资源不会被剥夺；（只有进程主动释放）</li><li>请求并保持条件：<strong>保持</strong>当前资源时<strong>请求</strong>另一个资源；（某个进程持有某个进程的时候，还想访问另一个资源，但这个资源正在被持有；占有资源一直不出来的一个原因，否则迟早都会出来……？）</li><li>循环等待条件：存在共享资源的<strong>循环等待链</strong>。（你等我，我等你……）</li></ul><h1 id="死锁处理策略"><a href="#死锁处理策略" class="headerlink" title="死锁处理策略"></a>死锁处理策略</h1><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230528144335190.png" alt="image-20230528144335190"></p><ul><li><p>破坏互斥条件</p><ul><li>将只能互斥访问的资源改为<strong>同时共享访问</strong>；</li><li>将独占锁改为共享锁；（信号量＞1）</li><li>不是所有资源都能改成可共享的；</li></ul></li><li><p>破坏不剥夺 / 不可抢占条件</p><ul><li>请求<strong>新资源无法满足</strong>时必须释放已有资源；</li><li>由OS协助<strong>强制剥夺</strong>某进程持有的资源；</li><li>实现复杂，代价高；</li><li>此操作过多导致原进程任务无法推进。</li></ul></li><li><p>破坏请求并保持条件</p><ul><li>进程开始运行时一次性申请所需资源——资源浪费（资源用没用上都被占着）、进程饥饿（其它进程拿不到资源）；【P0】（理解是，进程一直占有很多资源，暂时用不到的资源但其它进程想要请求，就造成了等待；所以阶段性请求和释放就增大资源的利用率，减少等待）</li><li>阶段性请求和释放资源；【P1】</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529084721110.png" alt="image-20230529084721110"></p></li></ul><ul><li>破坏循环等待条件<ul><li>对所有资源现行排序，按序号请求资源；（之前执行的都是乱序的）<ul><li>请求时先低再高；</li><li>释放时先高再低；</li></ul></li><li>对资源的编号应相对稳定，限制了新设备的增加；（预先知道并安排资源）</li><li>进程使用资源的顺序可能与系统编号顺序不同；</li><li>限制了用户编程；（内定好顺序了）</li></ul></li></ul><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>死锁避免：安全性算法。</p><ul><li><p>系统安全状态</p><ul><li>安全状态一定不会出现死锁；</li><li>不安全状态可能出现死锁；</li></ul></li><li><p>银行家算法</p><ul><li>系统预判进程请求是否导致不安全状态；</li><li>是则拒绝请求，否则答应请求；</li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529085923176.png" alt="image-20230529085923176"></p><blockquote><p>进程先让操作系统知道，最大需求是多少；系统判断：申请的数量是否大于所需最大数量、可用数量够不够。</p><p>（如果分配给进程的资源数量 ＋ 进程已分配的资源 ≤ 最大需求，进程未得到满足就继续占有已有资源并等待请求更多的资源——请求并保持，所以要确保满足进程最大需求，好让它用完并释放）</p></blockquote></li></ul><h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><ul><li>死锁检测（判断 死锁产生的条件 是否出现）<ul><li>需要一种数据结构，保存有关资源的请求和分配信息；</li><li>提供一种算法，利用这些信息检测是否形成了死锁。</li></ul></li></ul><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529091141333.png" alt="image-20230529091141333"></p><blockquote><p>【资源分配图】两种资源、两种节点。请求边：进程向资源请求；反之。</p></blockquote><ul><li><p>死锁定理（死锁状态的充分条件；而死锁的四个产生条件是必要条件）：</p><ul><li>当且仅当此状态下资源分配图是不可完全简化的；</li><li>简化过程<strong>类似于</strong>“拓扑排序”算法（先找到没有入边的节点，然后循环找没有入边的节点进行排序）</li></ul><blockquote><p>先看是否为孤点（无两种边）。是否阻塞主要看请求边。请求的是否能得到满足；</p><p>上面示意图中，先取出P0（资源充足，执行完可以释放掉，再轮到P1），再取出P1，简化完成，所以不会阻塞。</p></blockquote></li><li><p>死锁解除</p><ul><li>资源剥夺；（解决资源不够的问题）<ul><li>挂起死锁进程；</li><li>剥夺其资源；</li><li>将资源分配给其它（死锁）进程。</li></ul></li><li>撤销进程；（Destroy）</li><li>进程回退。<ul><li>回退到足以避免死锁的地步；</li><li>需要记录进程历史信息，设置还原点。</li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">关于操作系统的知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huangxinhere.github.io/2023/03/18/Unity%E5%BC%80%E5%8F%91-%E9%80%83%E5%87%BA%E5%9C%B0%E7%90%83/"/>
    <id>https://huangxinhere.github.io/2023/03/18/Unity%E5%BC%80%E5%8F%91-%E9%80%83%E5%87%BA%E5%9C%B0%E7%90%83/</id>
    <published>2023-03-18T02:50:15.984Z</published>
    <updated>2023-03-19T14:08:59.071Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="Tilemap"><a href="#Tilemap" class="headerlink" title="Tilemap"></a>Tilemap</h1><p><a href="https://docs.unity.cn/cn/2018.4/Manual/class-Tilemap.html">Tilemap - Unity 手册</a></p><p><a href="https://blog.csdn.net/weixin_41054345/article/details/109329638">(47条消息) Unity Tilemap动态生成2d地图_tilemap 动态地形_crushKB的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/sanyejun/p/9298592.html">unity2018使用tileMap生成地图 类似泰拉瑞亚创建和销毁地图块 - 三页菌 - 博客园 (cnblogs.com)</a></p><p>开始的想法是用Tilemap，因为可以方便地选择格子来填充或删除。</p><p>但是看了好多资料，却越来越清晰地意识到：Tilemap还是为了地图而存在的，也就是静态的，单元格集成的。所以，几乎不可能移动单个Tile？都是跟随Tilemap一起的刚体属性。</p><h1 id="纯物理"><a href="#纯物理" class="headerlink" title="纯物理"></a>纯物理</h1><p><a href="https://docs.unity.cn/cn/2021.3/Manual/Joints2D.html">2D 关节 - Unity 手册</a></p><p>【例子不全面，好坑】[(47条消息) <a href="https://blog.csdn.net/rickshaozhiheng/article/details/78509632">Unity] Unity2D 中的物理关节_Rickshao1993的博客-CSDN博客</a></p><h1 id="网格系统"><a href="#网格系统" class="headerlink" title="网格系统"></a>网格系统</h1><p><a href="https://www.bilibili.com/video/BV1AY411a7QV/?vd_source=bd424a1eb707161ee6ba2f47e4c49a08">Unity中的网格系统 Grid System in Unity (How to make it and where to use it)_哔哩哔哩_bilibili</a></p><h1 id="用UI直接代替逻辑网格系统"><a href="#用UI直接代替逻辑网格系统" class="headerlink" title="用UI直接代替逻辑网格系统"></a>用UI直接代替逻辑网格系统</h1><p><a href="file:///D:/Unity/2021.3.8f1c1/Editor/Data/Documentation/en/Manual/class-Canvas.html">统一 - 手动：画布</a></p><ul><li><p>先排好Grid按钮，整理好画布</p></li><li><p>接着将点击的UI坐标转化成世界坐标。Button坐标-&gt;屏幕坐标-&gt;世界坐标【关于坐标转换的知识要学习一下】</p><p>获得坐标后，生成砖块【资产获取的知识】；</p><p>生成砖块的时候要检查是否已经存在方块【屏幕射线检查物体[Unity 射线检测（RayCast） - Mr.Cat~ - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/Haha1999/p/13272109.html#:~:text=%E5%B8%B8%E7%94%A8%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95">https://www.cnblogs.com/Haha1999/p/13272109.html#:~:text=常用射线检测方法</a> 1 1. 普通射线检测（一般用于检测某一个物体） 1 Ray ray %3D,2 2. 直线射线检测多个物体 … 3 3. 球形射线检测（一般用于检测周边物体） )】</p></li><li><p>构建砖块搭建的逻辑算法：</p><ul><li><p>砖块start的时候，要执行搭建算法：左边有，扣住左边；右边有，扣住右边；否则自然向下。</p><p>射线检测：方向-检测到的物体判断；RayCast也会检测到自己…【射线检测】<a href="https://docs.unity.cn/cn/current/ScriptReference/Physics2D.Raycast.html">Physics2D-Raycast - Unity 脚本 API</a></p><p>生成固定关节组件：</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Tilemap&quot;&gt;&lt;a href=&quot;#Tilemap&quot; class=&quot;headerlink&quot; title=&quot;Tilemap&quot;&gt;&lt;/a&gt;Tilemap&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.unity.cn/cn/2018.4</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>知识整理-Unity相关知识点</title>
    <link href="https://huangxinhere.github.io/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://huangxinhere.github.io/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2023-03-15T16:00:00.000Z</published>
    <updated>2023-08-15T01:07:57.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h1><p>【详细的解释】<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html#graphs">Introduction to the A* Algorithm (redblobgames.com)</a></p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>按照一定的顺序查找附近的node，呈现规律的扩散。</p><p><img src="/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/hexo_github_blog\source_posts\知识整理-Unity相关知识点.assets\image-20230316152044206.png" alt="image-20230316152044206"></p><h2 id="迪斯卡尔算法"><a href="#迪斯卡尔算法" class="headerlink" title="迪斯卡尔算法"></a>迪斯卡尔算法</h2><p>带权路径查找，局部最优。比如从A点开始，与A相连的有B(1),C(4),B又连着C(2)。</p><p>那么更新B和C，它们分别从A而来，路径分别是1和3；目前最短的路径是B，那么从B开始下一轮；</p><p>B连着C，对于C来说，现在有两条路径到C，一个是从A来，一个是从B来，最短的是从B(1+2)来，那么更新C是从B来。</p><p>从上面可以看到，算法是暂存局部，然后遍历更多的点的时候刷新最短路径，从而获得一个点到所有点的最短路径。</p><ul><li>权（路径）的设计</li></ul><p>迪斯卡尔算法的最大特点是<strong>代价</strong>。如果充分设计代价的分布，那么可以利用这些来规划禁止区域。比如森林或水流代价很大，那就几乎不会走到那去。</p><p><img src="/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/hexo_github_blog\source_posts\知识整理-Unity相关知识点.assets\image-20230316152944956.png" alt="广度优先和迪斯卡尔的区别"></p><h2 id="贪心算法（预估代价）"><a href="#贪心算法（预估代价）" class="headerlink" title="贪心算法（预估代价）"></a>贪心算法（预估代价）</h2><p>目前广度优先算法和迪斯卡尔算法都是要同时搜索（几乎）所有方位来找到 到所有点的最短的路径。</p><blockquote><p>bfs会遍历四周的所有点，迪斯卡尔也是同时开启地毯式搜索。</p></blockquote><p>但如果是只想找一个目标地点呢？或者说缩小搜索范围？朝着有限的、接近目标的方向前进。</p><ul><li>预估代价：计算和目标的距离，然后选择离目标最近的方向前进。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heuristic</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y);</span><br></pre></td></tr></table></figure><ul><li>算法：到达某一个点所需的预估代价。这个代价点会存入到优先队列里面去。只会取出最小的代价点来继续探索。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frontier = PriorityQueue()</span><br><span class="line">frontier.put(start, <span class="number">0</span>)</span><br><span class="line">came_from = <span class="built_in">dict</span>()</span><br><span class="line">came_from[start] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():</span><br><span class="line">   current = frontier.get()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> current == goal:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph.neighbors(current):</span><br><span class="line">      $ 把该代价点附近的未遍历的点纳入其中</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> came_from:</span><br><span class="line">         priority = heuristic(goal, <span class="built_in">next</span>)</span><br><span class="line">         frontier.put(<span class="built_in">next</span>, priority)</span><br><span class="line">         came_from[<span class="built_in">next</span>] = current</span><br></pre></td></tr></table></figure><p><img src="/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/hexo_github_blog\source_posts\知识整理-Unity相关知识点.assets\image-20230316155013729.png" alt="迪斯卡尔和A*算法"></p><ul><li>如果是比较复杂的地形呢？</li></ul><p><img src="/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/hexo_github_blog\source_posts\知识整理-Unity相关知识点.assets\image-20230316155415139.png" alt="image-20230316155415139"></p><blockquote><p>速度更快。</p></blockquote><p><img src="/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/hexo_github_blog\source_posts\知识整理-Unity相关知识点.assets\image-20230316155535121.png" alt="image-20230316155535121"></p><blockquote><p>但是有障碍的时候没有形成最短路径。（只看到局部利益没有考虑全局）。</p></blockquote><h2 id="A-算法-1"><a href="#A-算法-1" class="headerlink" title="A* 算法"></a>A* 算法</h2><p>以上算法都各有缺点：</p><p>迪斯卡尔浪费很多时间在没有可能的路径上；贪心算法没有找到最短路径。</p><p>A*算法就是集合了两者优点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">frontier = PriorityQueue()</span><br><span class="line">frontier.put(start, <span class="number">0</span>)</span><br><span class="line">came_from = <span class="built_in">dict</span>()</span><br><span class="line">cost_so_far = <span class="built_in">dict</span>()</span><br><span class="line">came_from[start] = <span class="literal">None</span></span><br><span class="line">cost_so_far[start] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> frontier.empty():</span><br><span class="line">   current = frontier.get()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> current == goal:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">next</span> <span class="keyword">in</span> graph.neighbors(current):</span><br><span class="line">      //迪斯卡尔计算出的局部最优</span><br><span class="line">      new_cost = cost_so_far[current] + graph.cost(current, <span class="built_in">next</span>)</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">next</span> <span class="keyword">not</span> <span class="keyword">in</span> cost_so_far <span class="keyword">or</span> new_cost &lt; cost_so_far[<span class="built_in">next</span>]:</span><br><span class="line">         cost_so_far[<span class="built_in">next</span>] = new_cost</span><br><span class="line">         //再加上预估代价</span><br><span class="line">         priority = new_cost + heuristic(goal, <span class="built_in">next</span>)</span><br><span class="line">         frontier.put(<span class="built_in">next</span>, priority)</span><br><span class="line">         came_from[<span class="built_in">next</span>] = current</span><br></pre></td></tr></table></figure><p><img src="/2023/03/16/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/hexo_github_blog\source_posts\知识整理-Unity相关知识点.assets\image-20230316161612276.png" alt="image-20230316161612276"></p><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p><a href="https://blog.csdn.net/xinzhilinger/article/details/116240688">(53条消息) Unity 协程(Coroutine)原理与用法详解_unity协程原理_心之凌儿的博客-CSDN博客</a></p><p>在使用<code>Unity</code>进行游戏开发时，一般（注意是一般）不考虑<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>，那么如何处理一些在【主任务之外的需求】呢，<code>Unity</code>给我们提供了协程这种方式。</p><blockquote><p>为什么在Unity中一般不考虑多线程？</p><ul><li>因为在<code>Unity</code>中，只能在主线程中获取物体的组件、方法、对象，如果脱离这些，<code>Unity</code>的很多功能无法实现，那么多线程的存在与否意义就不大了。</li></ul></blockquote><p>既然这样，线程与协程有什么区别呢：</p><ul><li>对于协程而言，<strong>同一时间只能执行一个协程</strong>，而线程则是并发的，可以同时有多个线程在运行</li><li>两者在内存的使用上是相同的，共享堆，不共享栈</li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程，从字面意义上理解就是协助程序的意思，我们在主任务进行的同时，需要一些分支任务配合工作来达到最终的效果。</p><p>稍微形象的解释一下，想象一下，在进行主任务的过程中我们需要一个对资源消耗极大的操作时候，如果在一帧中实现这样的操作，游戏就会变得十分卡顿，这个时候，我们就可以通过协程，在一定帧内完成该工作的处理，同时不影响主任务的进行。</p><h2 id="协程的原理"><a href="#协程的原理" class="headerlink" title="协程的原理"></a>协程的原理</h2><p>首先需要了解协程不是线程，<strong>协程依旧是在主线程中进行</strong>。</p><p>然后要知道协程是通过迭代器来实现功能的，通过关键字<code>IEnumerator</code>来定义一个迭代方法，相关知识查看C#知识整理。</p><p>回顾可知，由于状态机的处理，枚举器什么时候执行MoveNext要看yield return，yield return之后会进入Suspend状态，等待调用MoveNext再进入Running状态。</p><p><code>yield</code> 的使用是实现我们协程功能的主要途径，通过该关键方法，可以使得协程的运行暂停、记录下一次启动的时间与位置等等。</p><ul><li>Unity协程不允许并发？</li></ul><p>在Unity中，协程本身是不支持并发的。这是因为Unity中的所有协程都是在主线程中按顺序执行的。</p><p>虽然不能实现真正的并发，但是可以通过一些技巧来<strong>模拟并发</strong>。一种常见的做法是使用多个协程来分段处理一个任务。例如，将一个耗时的操作分成多个子任务，每个子任务作为一个协程独立执行，并在必要时相互协作完成整个任务。</p><p>另外，可以使用协程延时（yield return new WaitForSeconds）或等待异步操作（yield return www）的方式来让协程在执行过程中暂停一段时间，让其他协程有机会执行。这种方式可以模拟出一定程度的并发效果。</p><p>需要注意的是，由于协程本身是在主线程中运行的，如果在协程中进行了耗时的计算或者阻塞式的IO操作，会<strong>造成主线程的阻塞</strong>，导致UI无响应等问题。因此，在使用协程时需要特别注意避免这种情况的发生。</p><ul><li>Unity协程的底层原理？（有没有具体例子辅助理解？）</li></ul><p>在Unity中，协程的底层实现是基于<strong>迭代器（Iterator）</strong>和<strong>状态机（StateMachine）</strong>的。具体来说，当我们在脚本中使用yield语句创建一个协程时，Unity会将这个协程转化为一个迭代器，每次执行到yield语句时会将当前状态保存下来，并返回yield语句后面的值。</p><p>当协程被启动时，Unity会<u>构建一个状态机来管理协程的状态</u>，根据协程的状态不断地调用迭代器中的MoveNext方法，并获取其中返回的对象，直到迭代器中没有更多的元素或者手动停止协程为止。</p><p>由于协程和迭代器都是轻量级的对象，因此可以在主线程中快速创建、销毁和切换执行，从而实现了高效的协程调度。同时，通过利用状态机的机制，协程可以方便地控制其执行流程，支持暂停、恢复、超时等操作，非常适合处理异步事件和复杂流程的场景。</p><p>需要注意的是，虽然协程看起来像是多线程并发执行的一种方式，但它仍然是单线程的，只是通过状态机的方式模拟出了并发的效果。因此，在使用协程时需要特别注意避免阻塞主线程，以免影响应用的响应性能和稳定性。</p><h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><p>在C#中可枚举类型一般举例都是值类型或自定义类型，在unity中，就用到内置封装好的类型。从语义来说，有几秒钟、几个帧等。这样相当于枚举“时间”，来获得分时进行的效果。</p><ul><li>StartCoroutine（string methodName）：这种是没有参数的情况，直接通过方法名（字符串形式）来开启协程；</li><li>StartCoroutine（IEnumerator routine）：通过方法形式调用；</li><li>StartCoroutine（string methodName，object values)：带参数的通过方法名进行调用；</li></ul><ul><li><code>StopCoroutine（string methodName）</code>：通过方法名（字符串）来进行</li><li><code>StopCoroutine（IEnumerator routine）</code>:通过方法形式来调用</li><li><code>StopCoroutine(Coroutine routine)</code>：通过指定的协程来关闭</li></ul><ul><li>yield return null; 暂停协程等待下一帧继续执行</li><li>yield return 0或其他数字; 暂停协程等待下一帧继续执行</li><li>yield return new WairForSeconds(时间); 等待规定时间后继续执行</li><li>yield return StartCoroutine(“协程方法名”);开启一个协程（嵌套协程)</li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="Update和FixedUpdate"><a href="#Update和FixedUpdate" class="headerlink" title="Update和FixedUpdate"></a>Update和FixedUpdate</h2><p><a href="https://blog.csdn.net/Marine_snow/article/details/117127889">Unity3D Update和FixedUpdate的区别及深入探讨_Marine_snow的博客-CSDN博客</a></p><p>为了保证在两帧间隔较大的时候依然能精准模拟物理之类的运算，一帧之间会运行多次FixedUpdate。将较大的间隔切分成多个固定的小时间段计算。</p><p>但这种切分不能是无节制的，FixedUpdate中的运算也会带来计算负荷，如果为了追上帧间隔而带来太多FixedUpdate调用会让下一帧的时间更长，而更长的帧间距则需要更多的FixedUpdate来追上，这会导致一个恶行循环，所以FixedUpdate的调用会有一个时间限制</p><p>FixedUpdate的固定时间间隔，并不是真正意义的固定的时间差。而是相对Update来说一个类似节拍器的存在。当两帧的时差过大时，Unity会 “缩放” 时间至设定的最大帧间隔（比如这里是0.333秒），在游戏中看起来就像减慢了一样（变得又卡又慢）。这个设定可以有效防止在卡顿时游戏的物理系统彻底暴走的现象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;A-算法&quot;&gt;&lt;a href=&quot;#A-算法&quot; class=&quot;headerlink&quot; title=&quot;A*算法&quot;&gt;&lt;/a&gt;A*算法&lt;/h1&gt;&lt;p&gt;【详细的解释】&lt;a href=&quot;https://www.redblobgames.com/pathfinding/a-sta</summary>
      
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>C++ 知识整理</title>
    <link href="https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++/"/>
    <id>https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++/</id>
    <published>2023-03-02T16:00:00.000Z</published>
    <updated>2023-08-11T05:51:46.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构相关的封装"><a href="#数据结构相关的封装" class="headerlink" title="数据结构相关的封装"></a>数据结构相关的封装</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>STL</li></ul><p>快速排序、插入排序和堆排序；当数据量很大的时候用快排，划分区段比较小的时候用插入排序，当划分有导致最坏情况的倾向的时候使用堆排序。</p><ul><li>sort</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>priority_queue，优先队列。和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面，优先出队。<a href="https://so.csdn.net/so/search?q=%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">优先队列</a>具有队列的所有特性，包括基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的。</p><p><a href="https://blog.csdn.net/weixin_36888577/article/details/79937886">(49条消息) c++优先队列(priority_queue)用法详解_吕白_的博客-CSDN博客</a></p></li></ul><blockquote><p>和队列基本操作相同:</p><ul><li>top 访问队头元素</li><li>empty 队列是否为空</li><li>size 返回队列内元素个数</li><li>push 插入元素到队尾 (并排序)</li><li>emplace 原地构造一个元素并插入队列</li><li>pop 弹出队头元素</li><li>swap 交换内容</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;Type, Container, Functional&gt;</span><br><span class="line"><span class="comment">//Type 就是数据类型;</span></span><br><span class="line"><span class="comment">//Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector）;</span></span><br><span class="line"><span class="comment">//Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于基础类型 默认是大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; a; </span><br><span class="line"><span class="comment">//等同于 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; a;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; c;  <span class="comment">//这样就是小顶堆</span></span><br><span class="line">priority_queue&lt;string&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    a.<span class="built_in">push</span>(i);<span class="comment">// 4 3 2 1 0</span></span><br><span class="line">    c.<span class="built_in">push</span>(i);<span class="comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.<span class="built_in">push</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">b.<span class="built_in">push</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">b.<span class="built_in">push</span>(<span class="string">&quot;cbd&quot;</span>);<span class="comment">// cbd abcd abc</span></span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>底层实现：顺序查找（逐个遍历）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### lower_bound</span><br><span class="line"></span><br><span class="line">底层实现：二分查找，数据处于有序状态。</span><br><span class="line"></span><br><span class="line">用于在指定区域内查找**不小于（≥）目标值的第一个元素**。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</span><br><span class="line"></span><br><span class="line">[C++ <span class="built_in">lower_bound</span>()函数用法详解 (biancheng.net)](http:<span class="comment">//c.biancheng.net/view/7521.html) </span></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 [first, last) 区域内查找不小于 val 的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><p>返回一个正向迭代器。查找成功时，迭代器指向找到的元素；反之，如果查找失败，迭代器的指向和 last 迭代器相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//从 a 数组中找到第一个不小于 3( &gt;= 3)的元素</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">lower_bound</span>(a, a + <span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycomp2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i, <span class="keyword">const</span> <span class="keyword">int</span>&amp; j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; myvector&#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">//根据 mycomp2 规则，从 myvector 容器中找到第一个违背 mycomp2 规则的元素</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator iter = <span class="built_in">lower_bound</span>(myvector.<span class="built_in">begin</span>(), myvector.<span class="built_in">end</span>(),<span class="number">3</span>,<span class="built_in">mycomp2</span>());</span><br></pre></td></tr></table></figure><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><p>在指定范围内查找<strong>大于（＞）</strong>目标值的第一个元素.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找[first, last)区域中第一个大于 val 的元素。</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p><a href="http://c.biancheng.net/view/6834.html">C++ STL vector插入元素（insert()和emplace()）详解 (biancheng.net)</a></p><ul><li>insert</li></ul><table><thead><tr><th align="center">语法格式</th><th align="center">用法说明</th></tr></thead><tbody><tr><td align="center">iterator insert(pos,elem)</td><td align="center">在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。</td></tr><tr><td align="center">iterator insert(pos,n,elem)</td><td align="center">在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td align="center">iterator insert(pos,first,last)</td><td align="center">在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。</td></tr><tr><td align="center">iterator insert(pos,initlist)</td><td align="center">在迭代器 pos 指定的位置之前，插入初始化列表（用大括号{}括起来的多个元素，中间有逗号隔开）中所有的元素，并返回表示第一个新插入元素位置的迭代器。</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; demo&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">//第一种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//&#123;1,3,2&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), <span class="number">2</span>, <span class="number">5</span>);<span class="comment">//&#123;1,3,2,5,5&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种格式用法</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,3&gt;test&#123; <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), test.<span class="built_in">begin</span>(), test.<span class="built_in">end</span>());<span class="comment">//&#123;1,3,2,5,5,7,8,9&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种格式用法</span></span><br><span class="line">    demo.<span class="built_in">insert</span>(demo.<span class="built_in">end</span>(), &#123; <span class="number">10</span>,<span class="number">11</span> &#125;);<span class="comment">//&#123;1,3,2,5,5,7,8,9,10,11&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; demo.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; demo[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>emplace：是 <a href="http://c.biancheng.net/cplus/">C++</a> 11 标准新增加的成员函数，用于在 vector 容器<strong>指定位置之前</strong>插入<strong>一个</strong>新的元素。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator pos, args...)</span></span>;</span><br><span class="line"><span class="comment">//其中，pos 为指定插入位置的迭代器；args... 表示与 /* 新插入元素的构造函数 * /相对应的多个参数；该函数会返回表示新插入元素位置的迭代器。</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; demo1&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//emplace() 每次只能插入一个 int 类型元素</span></span><br><span class="line">demo1.<span class="built_in">emplace</span>(demo1.<span class="built_in">begin</span>(), <span class="number">3</span>);<span class="comment">//3 1 2</span></span><br></pre></td></tr></table></figure><ul><li>emplace 比 insert 的效率更高。 emplace() 在插入元素时，是在容器的指定位置直接构造元素，而不是先单独生成，再将其复制（或移动）到容器中。因此，在实际使用中，推荐大家优先使用 emplace()。</li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>和顺序容器不同，是关联容器。关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p><p>关联容器包括set 和 map。</p><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p><a href="https://blog.csdn.net/Peealy/article/details/116895964">(49条消息) 一文看懂哈希表并学会使用C++ STL 中的哈希表_哈希表end函数_嗯行家啊的博客-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>声明</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;elemType_1, elemType_2&gt; var_name; <span class="comment">//声明一个没有任何元素的哈希表，</span></span><br><span class="line"><span class="comment">//其中elemType_1和elemType_2是模板允许定义的类型，如要定义一个键值对都为Int的哈希表：</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br></pre></td></tr></table></figure><ul><li>初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line"><span class="comment">//如果知道要创建的哈希表的元素个数时，也可以在初始化列表中指定元素个数</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;&#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125;&#125;,<span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当我们想向哈希表中添加元素时也可以直接通过下标运算符添加元素，格式为: mapName[key]=value;</span></span><br><span class="line"><span class="comment">//如：hmap[4] = 14;</span></span><br><span class="line"><span class="comment">//但是这样的添加元素的方式会产生覆盖的问题，也就是当hmap中key为4的存储位置有值时，</span></span><br><span class="line"><span class="comment">//再用hmap[4]=value添加元素，会将原哈希表中key为4存储的元素覆盖</span></span><br><span class="line">hmap[<span class="number">4</span>] = <span class="number">14</span>;</span><br><span class="line">hmap[<span class="number">5</span>] = <span class="number">15</span>;</span><br><span class="line">cout &lt;&lt; hmap[<span class="number">4</span>];  <span class="comment">//结果为15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过insert()函数来添加元素的结果和通过下标来添加元素的结果一样，不同的是insert()可以避免覆盖问题，</span></span><br><span class="line"><span class="comment">//insert()函数在同一个key中插入两次，第二次插入会失败</span></span><br><span class="line">hmap.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="number">15</span> &#125;);</span><br><span class="line">hmap.<span class="built_in">insert</span>(&#123; <span class="number">5</span>,<span class="number">16</span> &#125;);</span><br><span class="line">cout &lt;&lt; hmap[<span class="number">5</span>];  <span class="comment">//结果为15</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line"><span class="function">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">hmap1</span><span class="params">(hmap)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>常用函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// erase()</span></span><br><span class="line">hmap.<span class="built_in">erase</span>(iter_begin);  <span class="comment">//删除开始位置的元素</span></span><br><span class="line">hmap.<span class="built_in">erase</span>(iter_begin, iter_end); <span class="comment">//删除开始位置和结束位置之间的元素</span></span><br><span class="line">hmap.<span class="built_in">erase</span>(<span class="number">3</span>); <span class="comment">//删除key==3的键值对</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line"><span class="comment">// 以key作为参数寻找哈希表中的元素，如果哈希表中存在该key值则返回该位置上的迭代器，否则返回哈希表最后一个元素下一位置上的迭代器</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">iter = hmap.<span class="built_in">find</span>(<span class="number">2</span>); <span class="comment">//返回key==2的迭代器，可以通过iter-&gt;second访问该key对应的元素</span></span><br><span class="line"><span class="keyword">if</span>(iter != hmap.<span class="built_in">end</span>())  cout &lt;&lt; iter-&gt;second;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// at()</span></span><br><span class="line"><span class="comment">// 根据key查找哈希表中的元素</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hmap&#123; &#123;<span class="number">1</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">13</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">int</span> elem = hmap.<span class="built_in">at</span>(<span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>遍历哈希表</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递遍历</span></span><br><span class="line"><span class="keyword">for</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; kv:map)&#123;</span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> kv:map)&#123;<span class="comment">// auto</span></span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; kv:map)&#123;<span class="comment">//&amp;</span></span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; kv:map)&#123;</span><br><span class="line">    cout&lt;&lt;kv.first&lt;&lt;kv.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it=map.<span class="built_in">begin</span>();it!=map.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">    cout&lt;&lt;it-&gt;first&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><p><a href="http://c.biancheng.net/view/7250.html">C++ STL unordered_set容器完全攻略 (biancheng.net)</a></p><ul><li><p>特性</p><ul><li>不再以键值对的形式存储数据，而是直接存储数据的值；</li><li>容器内部存储的各个元素的值都互不相等，且不能被修改；</li><li>不会对内部存储的数据进行排序（这和该容器底层采用哈希表结构存储数据有关，可阅读《<a href="http://c.biancheng.net/view/7235.html">C++ STL无序容器底层实现原理</a>》一文做详细了解）；</li></ul><blockquote><p>对于 unordered_set 容器不以键值对的形式存储数据，读者也可以这样认为，即 unordered_set 存储的都是键和值相等的键值对，为了节省存储空间，该类容器在实际存储时选择只存储每个键值对的值。</p></blockquote></li><li><p>头文件</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>创建</li></ul><p>通过调用 unordered_set 模板类的默认构造函数，可以创建空的 unordered_set 容器。比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;string&gt; uset;</span><br></pre></td></tr></table></figure><p>创建的同时进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unordered_set&lt;string&gt; uset&#123; <span class="string">&quot;string1&quot;</span>,<span class="string">&quot;string2&quot;</span>,<span class="string">&quot;string3&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>利用拷贝构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;string&gt; <span class="title">uset2</span><span class="params">(uset)</span></span>;</span><br></pre></td></tr></table></figure><p>直接用vector构造？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_set&lt;<span class="keyword">int</span>&gt; <span class="title">to_delete_set</span><span class="params">(to_delete.begin(), to_delete.end())</span></span>;</span><br></pre></td></tr></table></figure><ul><li>添加新元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uset.<span class="built_in">insert</span>(x);</span><br></pre></td></tr></table></figure><ul><li>成员方法</li></ul><table><thead><tr><th>成员方法</th><th>功能</th></tr></thead><tbody><tr><td>begin()</td><td>返回指向容器中第一个元素的正向迭代器。</td></tr><tr><td>end();</td><td>返回指向容器中最后一个元素之后位置的正向迭代器。</td></tr><tr><td>cbegin()</td><td>和 begin() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>cend()</td><td>和 end() 功能相同，只不过其返回的是 const 类型的正向迭代器。</td></tr><tr><td>empty()</td><td>若容器为空，则返回 true；否则 false。</td></tr><tr><td>size()</td><td>返回当前容器中存有元素的个数。</td></tr><tr><td>max_size()</td><td>返回容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。</td></tr><tr><td>find(key)</td><td>查找以值为 key 的元素，如果找到，则返回一个指向该元素的正向迭代器；反之，则返回一个指向容器中最后一个元素之后位置的迭代器（如果 end() 方法返回的迭代器）。</td></tr><tr><td>count(key)</td><td>在容器中查找值为 key 的元素的个数。</td></tr><tr><td>equal_range(key)</td><td>返回一个 pair 对象，其包含 2 个迭代器，用于表明当前容器中值为 key 的元素所在的范围。</td></tr><tr><td>emplace()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>emplace_hint()</td><td>向容器中添加新元素，效率比 insert() 方法高。</td></tr><tr><td>insert()</td><td>向容器中添加新元素。</td></tr><tr><td>erase()</td><td>删除指定元素。</td></tr><tr><td>clear()</td><td>清空容器，即删除容器中存储的所有元素。</td></tr><tr><td>swap()</td><td>交换 2 个 unordered_set 容器存储的元素，前提是必须保证这 2 个容器的类型完全相等。</td></tr><tr><td>bucket_count()</td><td>返回当前容器底层存储元素时，使用桶（一个线性链表代表一个桶）的数量。</td></tr><tr><td>max_bucket_count()</td><td>返回当前系统中，unordered_set 容器底层最多可以使用多少桶。</td></tr><tr><td>bucket_size(n)</td><td>返回第 n 个桶中存储元素的数量。</td></tr><tr><td>bucket(key)</td><td>返回值为 key 的元素所在桶的编号。</td></tr><tr><td>load_factor()</td><td>返回 unordered_set 容器中当前的负载因子。负载因子，指的是的当前容器中存储元素的数量（size()）和使用桶数（bucket_count()）的比值，即 load_factor() = size() / bucket_count()。</td></tr><tr><td>max_load_factor()</td><td>返回或者设置当前 unordered_set 容器的负载因子。</td></tr><tr><td>rehash(n)</td><td>将当前容器底层使用桶的数量设置为 n。</td></tr><tr><td>reserve()</td><td>将存储桶的数量（也就是 bucket_count() 方法的返回值）设置为至少容纳 count 个元（不超过最大负载因子）所需的数量，并重新整理容器。</td></tr><tr><td>hash_function()</td><td>返回当前容器使用的哈希函数对象。</td></tr></tbody></table><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><a href="https://blog.csdn.net/yas12345678/article/details/52601454">(53条消息) C++中set用法详解_c++ set_Donny-You的博客-CSDN博客</a></p><ul><li>元素<strong>自动排序</strong>，这为查找元素提供了良好性能，但同时也造成了一个重要限制：不能直接改变元素值，因为这会打乱原本正确的顺序。（unordered_set 里面的元素是无序的）</li><li>底部实现是非常高效的平衡检索二叉树：红黑树（Red-Black Tree）RB树。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin</span>()     　　 ,返回set容器的第一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>() 　　　　 ,返回set容器的最后一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">clear</span>()   　　     ,删除set容器中的所有的元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>() 　　　,判断set容器是否为空</span><br><span class="line"></span><br><span class="line"><span class="built_in">max_size</span>() 　 ,返回set容器可能包含的元素最大个数</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>() 　　　　 ,返回当前set容器中的元素个数</span><br><span class="line"></span><br><span class="line">rbegin　　　　 ,返回的值和<span class="built_in">end</span>()相同</span><br><span class="line"></span><br><span class="line"><span class="built_in">rend</span>()　　　　 ,返回的值和<span class="built_in">rbegin</span>()相同</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p><a href="http://c.biancheng.net/view/480.html">C++ priority_queue(STL priority_queue)用法详解 (biancheng.net)</a></p><h2 id="字符串的操作"><a href="#字符串的操作" class="headerlink" title="字符串的操作"></a>字符串的操作</h2><h3 id="字符串和数字的转换"><a href="#字符串和数字的转换" class="headerlink" title="字符串和数字的转换"></a>字符串和数字的转换</h3><p><a href="https://blog.csdn.net/fengbohello/article/details/115499395">(49条消息) C++：字符串和数字的转换_number 转std::string_miaow~miaow的博客-CSDN博客</a></p><ul><li>数字转字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">int</span> value)</span></span>;   </span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> value)</span></span>;   </span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">float</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">double</span> value)</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>字符串转数字</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">std::stoi</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">std::stol</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>,<span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">std::stof</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> std::string&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">std::stod</span><span class="params">(<span class="keyword">const</span> std::wstring&amp; str,std::<span class="keyword">size_t</span>* pos=<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="增删改查（含vector）"><a href="#增删改查（含vector）" class="headerlink" title="增删改查（含vector）"></a>增删改查（含vector）</h3><p><a href="http://c.biancheng.net/view/2236.html">C++ string详解，C++字符串详解 (biancheng.net)</a></p><p><a href="https://blog.csdn.net/qiancm/article/details/119611928">(49条消息) vector 详解（C++）_vector c++_偏安一隅任逍遥的博客-CSDN博客</a></p><ul><li>提取字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span> <span class="params">(<span class="keyword">size_t</span> pos = <span class="number">0</span>, <span class="keyword">size_t</span> len = npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;first second third&quot;</span>;</span><br><span class="line">string s2;</span><br><span class="line">s2 = s1.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><ul><li>删</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/af58c3d0f1989d3a8e639567a5106028.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// erase</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;demo&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = demo.<span class="built_in">erase</span>(demo.<span class="built_in">begin</span>() + <span class="number">1</span>);<span class="comment">//删除元素 2</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove</span></span><br><span class="line">deque&lt;<span class="keyword">double</span>&gt; samples&#123; <span class="number">1.5</span>, <span class="number">2.6</span>, <span class="number">0.0</span>, <span class="number">3.1</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">4.1</span>, <span class="number">0.0</span>, <span class="number">6.7</span>, <span class="number">0.0</span> &#125;;</span><br><span class="line">samples.<span class="built_in">erase</span>(<span class="built_in">remove</span>(<span class="built_in">begin</span>(samples), <span class="built_in">end</span>(samples), <span class="number">0.0</span>), <span class="built_in">end</span>(samples));</span><br></pre></td></tr></table></figure><blockquote><p>在vector中，remove的时候只是通过迭代器的指针向前移动来删除，将没有被删除的元素放在链表的前面，并返回一个指向新的超尾值的迭代器。由于remove()函数不是vector成员函数，因此不能调整vector容器的长度。<a href="https://blog.csdn.net/qq_37529913/article/details/125568345">(49条消息) C++ remove()函数用法详解(深入了解,一文学会)_双子座断点的博客-CSDN博客</a></p></blockquote><h2 id="判断是否为字母或数字"><a href="#判断是否为字母或数字" class="headerlink" title="判断是否为字母或数字"></a>判断是否为字母或数字</h2><ul><li>范围确定</li></ul><p>判断一个字符是否为：</p><p>小写字母：字符大于等于a，小于等于z；</p><p>大写字母：字符大于等于A，小于等于Z；</p><p>数字：字符大于等于0，小于等于9；</p><ul><li>STL库函数判断</li></ul><p>字母（不区分大小写）：isalpha();</p><p>大写字母：isupper();</p><p>小写字母：islower();</p><p>数字：isdigit();</p><p>字母和数字：isalnum();</p><ul><li><p>大小写字母转化：</p><p>（1）转化为大写：toupper();</p><p>（2）转化为小写：tolower();</p></li></ul>]]></content>
    
    
    <summary type="html">关于C++知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%20%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <id>https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%20%E7%B1%BB%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E5%B7%A5%E5%85%B7/</id>
    <published>2023-03-02T16:00:00.000Z</published>
    <updated>2023-08-07T06:19:32.816Z</updated>
    
    <content type="html"><![CDATA[<h1 id="—–拷贝控制"><a href="#—–拷贝控制" class="headerlink" title="—–拷贝控制"></a>—–拷贝控制</h1><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;<span class="comment">// 两个变量分别占两个独立的内存，复制的只是值，所以互不影响</span></span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类变量同理</span></span><br><span class="line">Vector2 a = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Vector2 b = a;</span><br><span class="line">b.x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>但是类用new创建实例的时候，复制的是指针，指向相同的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector2* a = <span class="keyword">new</span> <span class="built_in">Vector2</span>();</span><br><span class="line">Vector2* b = a;</span><br></pre></td></tr></table></figure><p>所以可见，将一个变量赋值给另一个变量的时候，就是在进行复制操作。把数据复制给另一个变量。</p><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>新增了一个指针指向内存。</p><p>设想一个类里面的一个成员变量是指针，实例化A和B，把A复制给B，那它们的指针变量都会指向同一个内存。当A析构的时候清空了指针指向的内存时，如果B也析构试图清空指针指向的内存，就会导致程序崩溃。因为A的指针被delete掉了，B又试图清除不属于我们的内存。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>把内存也复制了。</p><p>【拷贝构造函数】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己实现的String类</span></span><br><span class="line"><span class="comment">// 有默认拷贝函数</span></span><br><span class="line"><span class="comment">// 手动实现新内存分配</span></span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">const</span> String&amp; other)</span><br><span class="line">    : <span class="built_in">m_Size</span>(other.m_Size)</span><br><span class="line">&#123;</span><br><span class="line">    m_Buffer = <span class="keyword">new</span> <span class="keyword">char</span>[m_Size+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_Buffer, other.m_Buffer, m_Size+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">String string = <span class="string">&quot;Cherno&quot;</span>;</span><br><span class="line">String second = string;<span class="comment">// 隐式构造函数</span></span><br></pre></td></tr></table></figure><p>函数传参也会进行复制，所以为了减少开销可以用引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintString</span><span class="params">(<span class="keyword">const</span> String&amp; string)</span><span class="comment">// const防止修改</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="—–重载运算符与类型转换"><a href="#—–重载运算符与类型转换" class="headerlink" title="—–重载运算符与类型转换"></a>—–重载运算符与类型转换</h1><h2 id="箭头运算符"><a href="#箭头运算符" class="headerlink" title="箭头运算符"></a>箭头运算符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*p).<span class="built_in">Method</span>();</span><br><span class="line">p-&gt;<span class="built_in">Method</span>();<span class="comment">// 解引用的简洁写法</span></span><br></pre></td></tr></table></figure><ul><li>箭头运算符重载</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScopedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity* m_Obj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScopedPtr</span>(Entity* entity)</span><br><span class="line">: <span class="built_in">m_Obj</span>(entity)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">ScopedPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Entity* <span class="title">GetObject</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Obj; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ScopedPtr entity = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line">entity.<span class="built_in">GetObject</span>()-&gt;<span class="built_in">Print</span>();<span class="comment">// 如果要访问类的指针成员变量，这样写不太优雅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以重载运算符：有点神奇。箭头原本的含义是，访问指针指向的对象 的成员，现在是 访问指针指向的对象的对象变量 ，也就是自定义返回的对象……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entity* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">entity-&gt;<span class="built_in">Print</span>();</span><br></pre></td></tr></table></figure><p>更加严谨的话可以加上const，访问的时候禁止修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Entity* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二个const是访问这个类的方法时禁止修改类的成员，第一个const是返回一个常量？那么<code>entity-&gt;Print();</code>此时entity是一个常量，【常量只能调用const方法】……所以可见Print（）方法自动加上了const</p><p><code>void Print() const &#123; std::cout &lt;&lt; &quot;Hello!&quot; &lt;&lt; endl; &#125;</code></p></blockquote><h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>不同于强制类型转换，什么情况下可以根据上下文来进行自动转换呢？</p><ul><li>隐式构造函数：只提供构造的参数，就能默认转换成对应的构造器。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="keyword">const</span> std::string&amp; name)</span><br><span class="line">        : <span class="built_in">m_Name</span>(name), <span class="built_in">m_Age</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Entity</span>(<span class="keyword">int</span> age)</span><br><span class="line">        : <span class="built_in">m_Name</span>(<span class="string">&quot;Unknown&quot;</span>), <span class="built_in">m_Age</span>(age) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 写法1</span></span><br><span class="line">    Entity a = <span class="built_in">Entity</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    Entity b = <span class="built_in">Entity</span>(<span class="number">22</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写法2</span></span><br><span class="line">    <span class="function">Entity <span class="title">a</span><span class="params">(<span class="string">&quot;Cherno&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Entity <span class="title">b</span><span class="params">(<span class="number">22</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写法3</span></span><br><span class="line">    Entity a = std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>);</span><br><span class="line">    Entity a = <span class="string">&quot;Cherno&quot;</span>; <span class="comment">// 错误。const char*=&gt;string=&gt;Entity 只能进行一次隐式转换</span></span><br><span class="line">    Entity b = <span class="number">22</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法3，是因为有Entity的构造函数，一个接受整数的参数，另一个接受string。C#和Java不可以这样搞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">(<span class="keyword">const</span> Entity&amp; entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Printing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PrintName</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Cherno&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>虽然使代码更简洁，但是可读性不是很好。</p></blockquote><ul><li>explicit：禁止隐式调用构造函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Entity</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">        : m_Name(<span class="string">&quot;Unknown&quot;</span>), m_Age(age) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h2><h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><h3 id="标准库调用的函数对象"><a href="#标准库调用的函数对象" class="headerlink" title="标准库调用的函数对象"></a>标准库调用的函数对象</h3><h3 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h3><h1 id="—–面向对象程序设计"><a href="#—–面向对象程序设计" class="headerlink" title="—–面向对象程序设计"></a>—–面向对象程序设计</h1><h2 id="虚函数【继承-amp-amp-多态】"><a href="#虚函数【继承-amp-amp-多态】" class="headerlink" title="虚函数【继承&amp;&amp;多态】"></a>虚函数【继承&amp;&amp;多态】</h2><p>为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表（下文简称虚表）。本文介绍虚函数表是如何实现动态绑定的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_Name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Player</span>(<span class="keyword">const</span> std::string&amp; name) : <span class="built_in">m_Name</span>(name) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::out &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Entity&quot;</span></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Entity&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>可见没有用虚函数的时候，是直接根据对象的类型来进行调用的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span><span class="comment">//virtual</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span><span class="comment">// override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// func</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">(Entity* entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::out &lt;&lt; entity-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Entity&quot;</span></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Player&quot;</span></span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/75172640">C++ 虚函数表剖析 - 知乎 (zhihu.com)</a></p><h3 id="类的虚表（含有函数指针的指针数组）"><a href="#类的虚表（含有函数指针的指针数组）" class="headerlink" title="类的虚表（含有函数指针的指针数组）"></a>类的虚表（含有函数指针的指针数组）</h3><p>每个包含了虚函数的类都包含一个虚表。</p><p>当一个类（B）继承另一个类（A）时，类B会继承类A的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。</p></blockquote><p><img src="https://pic3.zhimg.com/80/v2-e864f4fe6a480b3230a5c9aebd7df996_1440w.webp" alt="img"></p><p><strong>虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针</strong>。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。</p><p>虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了。</p><h3 id="对象的虚表指针（指向虚表-数组）"><a href="#对象的虚表指针（指向虚表-数组）" class="headerlink" title="对象的虚表指针（指向虚表/数组）"></a>对象的虚表指针（指向虚表/数组）</h3><p><strong>虚表是属于类的，而不是属于某个具体的对象</strong>，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表。</p><p>为了指定对象的虚表，<strong>对象内部包含一个虚表的指针，来指向自己所使用的虚表</strong>。为了让每个包含虚表的类的对象都拥有一个虚表指针，编译器在类中添加了一个指针，<code>*__vptr</code>，用来指向虚表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p><p><img src="https://pic2.zhimg.com/80/v2-0fceb07713e411d48b4c361452129585_1440w.webp" alt="对象和它的虚表"></p><p>上面指出，一个继承类的基类如果包含虚函数，那个这个继承类也有拥有自己的虚表，故这个继承类的对象也包含一个虚表指针，用来指向它的虚表。（子类也有不同于父类的虚表，所以子类对象也有自己的虚表指针）</p><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//-------------------</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_data1, m_data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://pic3.zhimg.com/80/v2-dfe4aefdee7e06cf3151b57492ed42a2_1440w.webp" alt="img"></p><p>由于这三个类都有虚函数，故编译器为每个类都创建了一个<strong>虚表</strong>，即类A的虚表（A vtbl），类B的虚表（B vtbl），类C的虚表（C vtbl）。类A，类B，类C的对象都拥有一个<strong>虚表指针</strong>，<code>*__vptr</code>，用来指向自己所属类的虚表。</p><ul><li>类A包括两个虚函数，故A vtbl包含两个指针，分别指向<code>A::vfunc1()</code>和<code>A::vfunc2()</code>。</li><li>类B继承于类A，故类B可以调用类A的函数，但由于类B重写了<code>B::vfunc1()</code>函数，故B vtbl的两个指针分别指向<code>B::vfunc1()</code>和<code>A::vfunc2()</code>。</li><li>类C继承于类B，故类C可以调用类B的函数，但由于类C重写了<code>C::vfunc2()</code>函数，故C vtbl的两个指针分别指向<code>B::vfunc1()</code>（指向继承的最近的一个类的函数）和<code>C::vfunc2()</code>。</li></ul><blockquote><p>核心：<strong>对象的虚表指针</strong>用来指向自己所属类的虚表；<strong>虚表中的指针</strong>会指向其<u>继承的最近的</u>一个类的虚函数。</p></blockquote><p>声明一个类A的指针p来指向对象<code>bObject</code>。虽然<code>p</code>是基类的指针只能指向基类的部分，但是虚表指针亦属于基类部分，所以<code>p</code>可以访问到对象<code>bObject</code>的虚表指针（？）。<code>bObject</code>的虚表指针指向类B的虚表，所以<code>p</code>可以访问到B vtbl。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B bObject;</span><br><span class="line">    A *p = &amp; bObject;</span><br><span class="line">    p-&gt;<span class="built_in">vfunc1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在执行<code>p-&gt;vfunc1()</code>时，会发现<code>p</code>是个指针，且调用的函数是虚函数，接下来便会进行以下的步骤。</p><ul><li>发现是虚函数，访问虚表。根据虚表指针<code>p-&gt;__vptr</code>来访问对象<code>bObject</code>对应的虚表。虽然指针<code>p</code>是基类<code>A*</code>类型，但是<code>*__vptr</code>也是基类的一部分，所以可以通过<code>p-&gt;__vptr</code>可以访问到对象对应的虚表。</li><li>在虚表中查找所调用的函数对应的条目。由于虚表在编译阶段就可以构造出来了，所以可以根据所调用的函数定位到虚表中的对应条目。对于<code>p-&gt;vfunc1()</code>的调用，B vtbl的第一项即是<code>vfunc1</code>对应的条目。</li><li>最后，根据虚表中找到的函数指针，调用函数。从图3可以看到，B vtbl的第一项指向<code>B::vfunc1()</code>，所以<code>p-&gt;vfunc1()</code>实质会调用<code>B::vfunc1()</code>函数。</li></ul><p>我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。动态绑定区别于传统的函数调用，传统的函数调用我们称之为静态绑定，即函数的调用在编译阶段就可以确定下来了。</p><p>那么，什么时候会执行函数的动态绑定？这需要符合以下三个条件。</p><ul><li>通过指针来调用函数</li><li>指针upcast向上转型（继承类向基类的转换称为upcast，关于什么是upcast，可以参考本文的参考资料）</li><li>调用的是虚函数</li></ul><p>如果一个函数调用符合以上三个条件，编译器就会把该函数调用编译成动态绑定，其函数的调用过程走的是上述通过虚表的机制。</p><h2 id="纯虚函数（抽象方法-接口"><a href="#纯虚函数（抽象方法-接口" class="headerlink" title="纯虚函数（抽象方法/接口"></a>纯虚函数（抽象方法/接口</h2><p>还是上面的例子。这次把父类的函数改成纯虚函数。纯虚函数允许在父类定义一个没有实现的函数，然后强制子类去实现该函数（类似于抽象类）。所以如果子类想实例化的话就必须实现这个方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//=0在本质上使之为纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span><span class="comment">// override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();<span class="comment">// Entity不能被实例化了</span></span><br><span class="line"><span class="built_in">PrintName</span>(e);</span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"><span class="built_in">PrintName</span>(e);<span class="comment">// &quot;Player&quot;</span></span><br></pre></td></tr></table></figure><p>接口类：添加一个接口，由于C++没有interface关键字，所以用class，接口本质上也是只有纯虚函数的类，因此不能被实例化。Player类和Entity类都继承了接口，所以只有实现了纯虚函数才能被实例化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetClassName</span><span class="params">()</span> </span>= <span class="number">0</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span> :</span> <span class="keyword">public</span> Printable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">GetName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Entity&quot;</span>; &#125;<span class="comment">// 重写接口函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> :</span> <span class="keyword">public</span> Entity</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Name; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">GetClassName</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Player&quot;</span>; &#125;<span class="comment">// 重写接口函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口类型。本质上也是类的继承、虚函数表，来实现多态。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(Printable* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; obj-&gt;<span class="built_in">GetClassName</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entity* e = <span class="keyword">new</span> <span class="built_in">Entity</span>();</span><br><span class="line"></span><br><span class="line">Player* p = <span class="keyword">new</span> <span class="built_in">Player</span>(<span class="string">&quot;Player&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Print</span>(e);</span><br><span class="line"><span class="built_in">Print</span>(p);</span><br></pre></td></tr></table></figure><h1 id="—–模板泛型编程"><a href="#—–模板泛型编程" class="headerlink" title="—–模板泛型编程"></a>—–模板泛型编程</h1><p>模板是C++ 中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者公式。</p><h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>关键字<code>template</code>＋模板参数列表<code>&lt;typename/class  参数名&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Print</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">Print</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">Print</span>(<span class="number">5.15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实例化函数模板</li></ul><p>当调用一个函数模板时，编译器（通常）用函数实参（如int、float）来推断模板实参（typename T）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以显式声明</span></span><br><span class="line">Print&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>); </span><br></pre></td></tr></table></figure><p>再用推断出的模板参数来实例化一个特定版本的函数。</p><p>这些编译器生成的版本通常被称为<strong>模板的实例</strong>。</p><ul><li>非类型模板参数</li></ul><p>一个非类型参数表示一个值而非一个类型。绑定到非类型<strong>整型</strong>参数的<strong>实参</strong>必须是一个<strong>常量表达式</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T m_Array[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T <span class="title">GetSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Array&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; array;</span><br><span class="line">std::cout &lt;&lt; array.<span class="built_in">GetSize</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">关于C++知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>C++（二） - C++标准库</title>
    <link href="https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>https://huangxinhere.github.io/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/</id>
    <published>2023-03-02T16:00:00.000Z</published>
    <updated>2023-08-19T03:47:34.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="—–C-中使用库"><a href="#—–C-中使用库" class="headerlink" title="—–C++中使用库"></a>—–C++中使用库</h1><blockquote><p>目前使用的库iostream、string、vector那些都是C++标准库。如果想使用第三方库该怎么办呢？</p></blockquote><p>库通常包含两个部分，includes和library，包含目录和库目录。</p><ul><li>包含目录：一堆头文件。实际使用预构建的二进制文件中的函数？应该只有<strong>函数声明</strong>。（<u>编译</u>时检查是否存在这个函数）</li><li>库目录：有那些预先构建的二进制文件？为了使用函数，还需要<strong>函数定义</strong>（<u>链接</u>时检查是否有定义）。一般含有动态链接（dll）和静态链接 （dll.lib）</li></ul><p><a href="https://blog.csdn.net/freestyle4568world/article/details/49817799">(50条消息) 静态链接库与动态链接库－－－－C/C++_静态链接库 动态链接库_光速跑者21的博客-CSDN博客</a></p><p><img src="https://img-blog.csdn.net/20151113153003874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><blockquote><p>静态和动态的区别就是<u>在链接时</u>如何处理库函数，将它加入到应用程序中。</p><p>静态链接是在<u>编译的时候加入</u>到程序中，而动态链接，是<u>在运行时</u>【加载DLL的可执行代码】加入到程序中。</p></blockquote><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>即在链接阶段，将源文件中用到的库函数与汇编生成的目标文件.o合并生成可执行文件。该可执行文件可能会比较大。</p><p>这种链接方式的好处是：方便程序移植，因为可执行程序与库函数再无关系，放在如何环境当中都可以执行。</p><p>缺点是：文件太大，一个全静态方式生成的简单print文件都有857K。而动态链接生成的一样的可执行文件却只要8.４Ｋ。</p><p><img src="https://img-blog.csdn.net/20151113164127683?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>以VS为例：</p><p>先设置include头文件的位置（让编译器知道可以在这找到头文件编译）；</p><p><img src="/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/hexo_github_blog\source_posts\知识整理-C++标准库.assets\image-20230427150902582.png" alt="image-20230427150902582"></p><p>然后是lib库，告诉linker在哪里可以链接函数定义之类；</p><p><img src="/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/hexo_github_blog\source_posts\知识整理-C++标准库.assets\image-20230427151042527.png" alt="image-20230427151042527"></p><p><img src="/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/hexo_github_blog\source_posts\知识整理-C++标准库.assets\image-20230427151158961.png" alt="image-20230427151158961"></p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>链接发生在运行时 / 真正启动可执行文件时，动态链接库才会被加载。</p><p><img src="https://img-blog.csdn.net/20151113164444980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><blockquote><p>我们看到在这种模型中，两个程序只应用一个库，这个目标文件在内存中只有一份，供所有程序使用。</p><p>并且在程序运行过程中动态调用库文件，很方便，又不占空间，但是动态链接有一个缺点就是可移植性太差，如果两台电脑运行环境不同，动态库存放的位置不一样，很可能导致程序运行失败。</p></blockquote><p>还是在VS，先把添加依赖项改成：</p><p><img src="/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/hexo_github_blog\source_posts\知识整理-C++标准库.assets\image-20230427152015215.png" alt="image-20230427152015215"></p><p><img src="/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/hexo_github_blog\source_posts\知识整理-C++标准库.assets\image-20230427152050439.png" alt="image-20230427152050439"></p><p>第二个箭头处的文件，基本上就是一堆指向dll（第一个箭头处的文件）的指针，这样就不用在运行时去检索所有东西的位置；还要同时编译这两个文件。它们是直接相关的，不能把它们分开。</p><p>编译的时候没有问题，运行的时候出错了。说是没找到dll文件。</p><p><img src="/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/hexo_github_blog\source_posts\知识整理-C++标准库.assets\image-20230427152624167.png" alt="image-20230427152624167"></p><p>将dll文件复制粘贴到和可执行文件(.exe)同一个文件夹中。接着就能运行成功了。</p><p><img src="/2023/03/03/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E6%A0%87%E5%87%86%E5%BA%93/hexo_github_blog\source_posts\知识整理-C++标准库.assets\OR4V[[@J_E[}SSTGJ{6LR97.png" alt="img"></p><blockquote><p>总结：除了要链接静态库之外，还要确保在一个可访问的地方有dll文件（可执行文件的根目录下）</p></blockquote><h1 id="—–IO库"><a href="#—–IO库" class="headerlink" title="—–IO库"></a>—–IO库</h1><h1 id="—–顺序容器"><a href="#—–顺序容器" class="headerlink" title="—–顺序容器"></a>—–顺序容器</h1><h1 id="—–泛型算法"><a href="#—–泛型算法" class="headerlink" title="—–泛型算法"></a>—–泛型算法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>引入：顺序容器只定义了很少的操作：添加删除元素、访问首尾元素、确定容器是否为空以及获得首元素或尾元素之后的迭代器。除此之外我们可能还想做其它有用的操作，比如查找、替换或删除特定元素，重排元素顺序等。</p><p>标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组<strong>泛型算法</strong>。</p><ul><li>“算法”：实现了一些经典算法的公共接口，如排序和搜索；</li><li>“泛型”：可用于不同类型的元素和多种容器类型。</li></ul></blockquote><ul><li><p>大多数算法都定义在头文件<code>algorithm</code>中。一般情况下，这些算法并不直接操作容器，而是<strong>遍历由两个迭代器指定的一个元素范围</strong>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), val);</span><br><span class="line"><span class="keyword">if</span> (result == vec.<span class="built_in">cend</span>())</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找不到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果找不到，将返回第二个参数。</p><p>由于find操作的是迭代器，因此可以用find在任何容器查找值。</p></blockquote></li><li><p>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。</p></li></ul><h2 id="初始泛型算法"><a href="#初始泛型算法" class="headerlink" title="初始泛型算法"></a>初始泛型算法</h2><ul><li>只读算法：只读取输入范围内的元素，从不改变元素。</li><li>写容器操作的算法</li></ul><h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><p>重载默认的行为（例如比较）</p><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>以重载过的sort为例，它接受第三个参数，此参数是一个谓词。</p><ul><li>谓词：一个可调用的表达式，其返回结果是一个能用作条件的值。分为两类：一元谓词（只接受单一参数）；二元谓词</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数，用来按长度排序单词</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> string &amp;s1, <span class="keyword">const</span> string &amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><ul><li>介绍</li></ul><p>可以理解为未命名的内联函数。具有一个返回类型、一个参数列表和一个函数体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中捕获列表和函数体是必须的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;<span class="comment">// 定义一个可调用对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;<span class="comment">// 打印42</span></span><br></pre></td></tr></table></figure><ul><li>向lambda传递参数</li></ul><ul><li>常用的做法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历容器元素，传给lambda，作为value判断，返回第一个符合条件的值</span></span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="keyword">int</span> value) &#123; <span class="keyword">return</span> value &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><h1 id="—–关联容器"><a href="#—–关联容器" class="headerlink" title="—–关联容器"></a>—–关联容器</h1><h1 id="—–标准模板库（STL）"><a href="#—–标准模板库（STL）" class="headerlink" title="—–标准模板库（STL）"></a>—–标准模板库（STL）</h1><p><a href="https://zhuanlan.zhihu.com/p/344558356">【C++】标准模板库（STL）：超快入门！算法竞赛必看！ - 知乎 (zhihu.com)</a></p><p>C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的<strong>数据结构及其算法</strong>都实现了一遍，并且做到了<strong>数据结构和算法的分离</strong>。</p><h2 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h2><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h1 id="—–动态内存"><a href="#—–动态内存" class="headerlink" title="—–动态内存"></a>—–动态内存</h1><h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>本质上是一个原始指针的包装，自动new 分配内存，并在某一个时刻自动释放。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>作用域指针。超出作用域时自动销毁。为什么叫unique？如果复制了一个unique_ptr，这两个指针将指向同一个内存，如果其中一个指针释放掉内存，那么另外一个指针将无效。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Created Entity&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Entity</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Destroyed Entity&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Entity&gt; <span class="title">entity</span><span class="params">(<span class="keyword">new</span> Entity())</span></span>;<span class="comment">// 包装类规定不能使用隐式构造函数</span></span><br><span class="line">    std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;();<span class="comment">// Cpp14特性，防止构造抛出异常，造成没有引用的悬空指针，从而造成内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>用来实现“复制unique_ptr“，本质上是引用计数，可以跟踪指针有多少个引用。如果计数为0就被删除了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Entity 同上</span></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面unique_ptr创建不用new是因为防止构造抛出异常，而shared_ptr不用new是因为，shared_ptr需要分配另一块内存，叫做控制块，用来存储引用计数。new的话需要进行两次内存分配，一次是new Entity，一次是控制块……而make_unique可以一次性完成……（先浅浅了解一下</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接着</span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125;<span class="comment">// 离开作用域后，sharedEntity销毁，但是引用计数为1，指针指向的内存并没有销毁</span></span><br><span class="line">&#125;<span class="comment">// e0，最后一个计数，也销毁了，所以shared指针分配的内存释放</span></span><br></pre></td></tr></table></figure><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>可以被复制，但是不会增加额外的控制块来计数，仅仅声明这个指针还活着（？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::weak_ptr&lt;Entity&gt; e0;</span><br><span class="line">    &#123;</span><br><span class="line">        std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_unique&lt;Entity&gt;();</span><br><span class="line">        e0 = sharedEntity;</span><br><span class="line">    &#125;<span class="comment">// 离开作用域后，sharedEntity销毁，指针指向的内存也清理掉；（唯一的区别是能够知道弱指针是否还有效？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：相对于普通指针来说，栈大小不够时可以用unique_ptr来堆分配；unique_ptr开销小，尽可能使用；需要在对象之间共享，则用shared指针；</p>]]></content>
    
    
    <summary type="html">关于C++知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://huangxinhere.github.io/2023/02/28/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://huangxinhere.github.io/2023/02/28/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-02-27T16:00:00.000Z</published>
    <updated>2023-04-02T04:04:52.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p><a href="https://zhuanlan.zhihu.com/p/179110367">操作系统：操作系统概述 - 知乎 (zhihu.com)</a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>定义一：</strong> 操作系统（Operating System, OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。（之前只是一个裸机）</p><p><strong>定义二：</strong> 操纵系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的合集。</p><h2 id="目标和功能"><a href="#目标和功能" class="headerlink" title="目标和功能"></a>目标和功能</h2><ul><li><p>目标</p><p>其主要目标是：**方便性（方便用户使用）、有效性(提高系统资源利用率&amp;提高系统的吞吐量)**、可扩充性（适应硬件的发展）和开放性（更多的兼容）。</p><p>有效性的两层含义：<br>① 提高系统资源的利用率（因为以前各种设备都经常处于空闲状态）<br>② 提高系统的<a href="https://so.csdn.net/so/search?q=%E5%90%9E%E5%90%90%E9%87%8F&spm=1001.2101.3001.7020">吞吐量</a>（合理组织计算机的工作流程，加速程序运行）</p></li><li><p>功能（为了实现目标）</p><p>（1） 作为用户与计算机硬件系统之间的<strong>接口</strong></p><p>​            【程序接口（应用程序）/ 命令接口（用户直接操作，底层命令） /  GUI图形用户（命令可视化 ）】</p><p>（2） 作为计算机系统资源的<strong>管理者</strong></p><p>​           【处理机管理 / 存储器管理 / I/O设备管理 / 文件管理】</p><p>（3） 实现了对计算机（硬件）资源的<strong>抽象</strong>（没有OS的时候，用户必须对物理接口的实现细节有充分了解，有了OS之后，用户通过硬件上铺设的软件，可以更容易地使用计算机硬件资源）</p></li></ul><h2 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h2><p><img src="https://pic2.zhimg.com/80/v2-5ee5fc9da8edbe5bfd72ebb1f9bc13d1_1440w.webp" alt="img"></p><h2 id="操作系统内核的重要特性"><a href="#操作系统内核的重要特性" class="headerlink" title="操作系统内核的重要特性"></a>操作系统内核的重要特性</h2><p><a href="https://blog.csdn.net/qq_43722079/article/details/107996519">(42条消息) 【OS笔记 3】操作系统的基本特性_Crayon小鱼干的博客-CSDN博客</a></p><ul><li>并发（共享、虚拟、异步的前提）</li></ul><p>指<strong>多个事件</strong>在同一时刻<strong>间隔</strong>发生（要与<strong>并行</strong>相区别），通过分时实现，以达到公平的目的。</p><p>①单处理机系统的程序是并发执行；②多处理机系统（多个CPU）的程序是 并行+并发执行。</p><ul><li>共享</li></ul><p>在OS环境下的资源共享或称为资源复用，是指<strong>系统中的资源</strong>可供<u>内存中</u><strong>多个并发执行的进程</strong>共同使用。因为系统中的资源远少于多道程序需求的总和，会形成它们对共享资源的争夺。 所以，必须对资源共享进行妥善管理。</p><p><u>目前实现资源共享的方式</u>： </p><p>① 互斥共享方式 ：也叫独占式，允许多个程序在<u>同一个共享资源</u>上<u>独立而互不干扰</u>的工作；</p><p>② 同时访问方式：同一个时间段允许多个程序<u>同时访问共享资源</u>；</p><blockquote><p>并发和共享可理解为互为前提：</p><ul><li>共享性要求OS中同时运行着多道程序；</li><li>若只有单道程序正在运行，则不存在共享的可能；</li><li>并发性难以避免地导致多道程序同时访问同一个资源；</li><li>若多道程序无法共享部分资源（如磁盘），则无法并发。</li></ul></blockquote><ul><li>虚拟</li></ul><p>一种管理技术，特点在于将物理实体转变为逻辑对应物，方便上层用户使用。</p><p>①时分复用技术</p><p>“时分”就是分割时间，将很短的时间分割成多份去做不同的事情，宏观上就是同时在做这些事情。</p><p>将某物理设备虚拟为 N 台虚拟逻辑设备，则：每台虚拟逻辑设备的平均速度 &lt;= 原物理设备<strong>速度</strong>的 1 / N。</p><p>②空分复用技术</p><p>“空分”就是分割空间，比如分割物理信道。将某物理设备虚拟为 N 台虚拟逻辑设备，则：每台虚拟逻辑设备平均占用的空间 &lt;= 原物理设备所拥有<strong>空间</strong>的 1 / N。</p><ul><li>异步</li></ul><p>进程是以人们<strong>不可预知的速度</strong>向前推进的，此即进程的异步性。</p><p><strong>解释：</strong> 其实意思就是每个进程什么时候能能获得CPU执行、什么时候暂停、什么时候完成等等都是我们无法计算的，但是没关系，只要每次运行的结果相同就行了。</p><h2 id="几个重要功能"><a href="#几个重要功能" class="headerlink" title="几个重要功能"></a>几个重要功能</h2><blockquote><p>接 OS作为计算机系统资源的管理者：</p></blockquote><ul><li>处理器管理：进程控制，<strong>进程同步</strong>，进程通信，<strong>作业进程调度</strong>；</li><li>存储器管理：内存分配，内存保护，<strong>地址映射</strong>，内存扩充；</li><li>I/O设备管理：缓冲管理，设备分配，设备处理；</li><li>文件管理：存储管理，目录管理，读写管理和保护；</li><li>提供接口：<strong>系统调用</strong>，<strong>命令接口</strong>和<strong>GUI</strong>。</li></ul><h1 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h1><p><a href="https://blog.csdn.net/qq_43722079/article/details/107955747">(42条消息) 【OS笔记 1】操作系统的目标和作用、发展过程_操作系统的目标是什么_Crayon小鱼干的博客-CSDN博客</a></p><ul><li>未配置操作系统的计算机系统<ul><li>人工操作方式</li><li>脱机输入/输出方式</li></ul></li><li>单道批处理系统：内存始终保持一道作业；还要等I/O（低速性）运行。</li><li>多道批处理系统：多道程序交替地运行；可以利用其因 I/O 操作而暂停执行的CPU空档时间，再调度另一道程序运行。【高资源利用率和系统吞吐量】</li></ul><p><img src="/2023/02/28/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hexo_github_blog\source_posts\知识整理-操作系统.assets\image-20230319164707506.png" alt="image-20230319164707506"></p><blockquote><p>左：单道批处理系统；右：多道批处理系统。前者每次输入-执行-输出都是一个程序，每个程序依次走流程；而后者是输入-执行-输出都可能同时运行。</p></blockquote><ul><li><p>分时系统：作业直接进入内存与用户交互；时间片；共享主机……</p><p>多路性：时间片轮转机制；</p><p>独立性：用户彼此独立；</p><p>及时性：用户能在<u>短时间内</u>（不是实时）获得响应；</p><p>交互性：用户可以请求多种服务；</p><p>缺点：作业/用户优先级相同，不能优先处理紧急任务。</p></li><li><p>实时系统：系统能<u>及时响应</u>外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p><p>多路性/独立性/交互性；</p><p>及时性：以用户能接受的等待时间为准；</p><p>可靠性：多级容错，保障系统和数据的安全。</p></li></ul><ul><li>微机操作系统：个人操作系统等。</li><li>其它操作系统：网络（支持网络的）操作系统（资源共享，远程通信）；分布式操作系统（分布性、并行性）-多台计算机完成同一个任务。</li></ul><h1 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h1><p><a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统（计算机管理控制程序）_百度百科 (baidu.com)</a></p><h2 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h2><p>计算机操作系统诞生初期，其体系结构就属于简单体系结构，由于当时各式各样影响因素的作用，如硬件性能、平台、软件水平等方面的限制，使得当时的计算机操作系统结构呈现出一种混乱且结构模糊的状态…</p><h2 id="单体内核结构"><a href="#单体内核结构" class="headerlink" title="单体内核结构"></a>单体内核结构</h2><p>一般情况下，单体内核结构的操作系统主要具备以下几种功能，分别是文件及内存管理、设备驱动、<a href="https://baike.baidu.com/item/CPU/120556?fromModule=lemma_inlink">CPU</a>调度以及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/328636?fromModule=lemma_inlink">网络协议</a>处理等。由于<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8/108410?fromModule=lemma_inlink">内核</a>的复杂性不断加深，相关的开发设计人员为了实现对其良好的控制，逐渐开始使用了一些较为成熟的<strong>模块化方法</strong>，并根据其不同的功能将其进行结构化，进而将其划分为诸多的模块，例如文件及内存管理模块、驱动模块、CPU调度模块及网络协议处理等……</p><p><img src="https://img-blog.csdnimg.cn/20200815145016836.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="层次式结构"><a href="#层次式结构" class="headerlink" title="层次式结构"></a>层次式结构</h2><p>uCore则是使用这一结构。其特点在于<u>层层搭建，每一层都为上一层提供服务，尽可能减少僭越的情况</u>。<strong>分层策略</strong>的好处其实从计算机网络的设计也可以看出，其优点在于可以每一层都屏蔽掉大量技术细节，使得上层的操作尽可能简单，当然缺点就是有的时候不可能分得非常层次鲜明，有时候就会可能出现不同层实现了重复的功能等问题使得效率降低。当然，对于上层的使用者来说，能简单当然还是要简单，要不然就不会出现高级语言这种东西了。</p><p><img src="https://img-blog.csdnimg.cn/2020081514532160.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h2><p>其实际上就是一种将系统中的代码转移到更高层次当中，尽可能地减少操作系统中的东西，仅仅保留一个小体积的内核，一般情况下其使用的主要方法就是<u>通过用户进程来实现操作系统所具备的各项功能</u>，</p><p>具体来说就是用户进程可以将相关的请求和要求发送到服务器当中，然后由服务器完成相关的操作以后在通过某种渠道反馈到用户进程当中。</p><p><img src="https://img-blog.csdnimg.cn/20200815145502433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="/2023/02/28/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hexo_github_blog\source_posts\知识整理-操作系统.assets\image-20230324230948662.png" alt="image-20230324230948662"></p><h2 id="外核结构"><a href="#外核结构" class="headerlink" title="外核结构"></a>外核结构</h2><p>这种结构的内核部分甚至要更少，内核只负责分配机器的物理资源给多个应用程序，并让每个应用程序决定如何使用资源。</p><h2 id="虚拟机结构VMM"><a href="#虚拟机结构VMM" class="headerlink" title="虚拟机结构VMM"></a>虚拟机结构VMM</h2><p>这种结构的特点在于在硬件层和操作系统层之间加了一层虚拟机管理器，将硬件与操作系统隔离开来。</p><p><img src="https://img-blog.csdnimg.cn/202008152048169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h1 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a>操作系统的运行机制</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>内核程序、应用程序</li><li>核心态、用户态</li><li>特权指令、非特权指令</li></ul><p><img src="/2023/02/28/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hexo_github_blog\source_posts\知识整理-操作系统.assets\image-20230321124648691.png" alt="image-20230321124648691"></p><h2 id="时钟管理"><a href="#时钟管理" class="headerlink" title="时钟管理"></a>时钟管理</h2><ul><li>计时：提供系统时间；</li><li>时钟中断：比如进程切换。</li></ul><p>（1）设置目的： 防止用户程序<u>陷入死循环</u> 或 <u>霸占控制权</u>（不将控制返给操作系统）。</p><p>（2）简单来说就是：在交给用户程序之前就设置好时间，然后倒计时，时间一到中断计算机。</p><p>（3）详细介绍：</p><p>定时器可设置为在指定周期后中断计算机，指定周期可以是固定或可变的。</p><p>可变定时器（variable timer）—般通过一个固定速率的时钟和计数器来实现。操作系统设置计数器每次时钟滴答时，计数器都要递减。当计数器的值为 0 时，就会产生中断 。</p><p>（4）修改定时器的指令是特权指令。</p><h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><ul><li><p>目的：提高多道程序环境下CPU利用率；</p></li><li><p>外中断：中断信号来源于外部设备（被迫）</p></li><li><p>内中断：当前指令（自愿）</p><ul><li>陷阱/陷入：由应用程序<u>主动</u>引发（让内核执行特权指令）。</li><li>故障：由<u>错误条件</u>引发。</li><li>终止：由<u>致命错误</u>引发（直接终止）。</li></ul></li><li><p>中断处理过程</p><p><img src="/2023/02/28/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/hexo_github_blog\source_posts\知识整理-操作系统.assets\image-20230321130423754.png" alt="image-20230321130423754"></p><blockquote><p>大致三步：保存-执行-恢复；</p><p>虚线框内：内核处理中断不会被打断；</p></blockquote></li></ul><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><ul><li>运行在内核空间；</li><li>由若干条指令组成（是一个程序段）；</li><li>用来完成某个特定的功能；</li><li>执行过程不会被中断（具有“原子性”）=&gt;底层是关中断开中断……？。</li></ul><h2 id="系统数据结构"><a href="#系统数据结构" class="headerlink" title="系统数据结构"></a>系统数据结构</h2><ul><li>进程管理：作业控制块、进程控制块；</li><li>存储器管理：存储器分配与回收；</li><li>设备管理：缓冲区、设备控制块。</li></ul><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用的处理运行在核心态；反复切换用户空间、内核空间会有一定消耗；</p><ul><li>由操作系统实现，给应用程序调用；</li><li>是<u>一套接口</u>的集合；</li><li>应用程序访问内核服务的方式。</li></ul><h1 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a>操作系统运行环境</h1><ul><li>运行环境：操作系统的核心部分（内核）在<strong>内核态（管态）</strong>下运行，而其它部分通常在<strong>用户态（目态）</strong>下运行；</li><li>权限：<strong>内核态</strong>比起<strong>用户态</strong>不同的地方在于可以访问的地方更多（取决于要访问的空间的优先级），可以执行的指令更多（比方说特权指令），从而起到一个保护的作用——用户不能随便更改操作系统，这使得操作系统具有稳定性；</li><li><strong>用户态</strong>到<strong>内核态</strong>需要通过<strong>中断</strong>，而<strong>中断</strong>会将CPU控制权交还给操作系统，故操作系统具有最高的优先级；</li></ul><h1 id="操作系统内核的功能"><a href="#操作系统内核的功能" class="headerlink" title="操作系统内核的功能"></a>操作系统内核的功能</h1><h2 id="内核是什么"><a href="#内核是什么" class="headerlink" title="内核是什么"></a>内核是什么</h2><p>现代操作系统设计采用<strong>层次结构</strong>，往往将一些<u>与硬件紧密相关的模块</u>或<u>运行频率较高的模块</u>设置在<u>第一层软件</u>中，称为操作系统的内核。</p><h2 id="内核的功能"><a href="#内核的功能" class="headerlink" title="内核的功能"></a>内核的功能</h2><ul><li><p>支撑功能</p><p>是指内核可以提供给OS的其它众多模块所需要一些基本功能，以便支撑这些模块工作。下面是三种最基本的支撑功能：</p><ul><li><p><strong>中断处理</strong>：此功能是内核<u>最基本的功能</u>，是整个操作系统活动的基础。OS中许多重要的活动无不依赖于中断，比如系统调用、IO操作、进程调度、设备驱动等；</p></li><li><p><strong>时钟管理</strong>：比如在时间片轮转调度中，每当时间片用完时，便由时钟管理产生一个中断信号，促使调度程序重新进行调度。还有实时系统的截止时间控制等。</p></li><li><p><strong>原语操作</strong>：原语（Primitive）是由若干条指令组成的，用于完成一定功能的一个过程。<br>它与一般过程的区别在于：它们是 <u>原子操作</u>。所谓原子操作就是，一个操作中的动作要么全做，要么全不做。也就是，它是一个不可分割的基本单位。因此，原语在执行过程中不允许被中断。</p><p><strong>原语的作用：</strong> 在内核中有许多原语，比如用于对链表进行操作的原语、用于实现进程同步的原语等。</p></li></ul></li><li><p>管理功能</p><ul><li>进程管理：进程的调度与分派、创建与撤销等；实现进程同步、进程通信的原语等；</li><li>存储器管理：如将逻辑地址转换为物理地址、内存的分配与回收等；</li><li>设备管理：各类设备的驱动程序等。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">关于操作系统的知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2023-02-22T16:00:00.000Z</published>
    <updated>2023-06-24T00:34:18.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-IP协议栈各个层次及分别的功能"><a href="#TCP-IP协议栈各个层次及分别的功能" class="headerlink" title="TCP/IP协议栈各个层次及分别的功能"></a>TCP/IP协议栈各个层次及分别的功能</h1><p><img src="https://img-blog.csdnimg.cn/d1adcd8356f248f1945646dbbb74bb2b.png" alt="img"></p><ul><li>应用层：用来处理特定的应用，<u>针对不同的应用提供了不同的协议</u>， 例如进行文件传输时用到的FTP协议，发送email用到的 SMTP等。对应协议：FTP、HTTP、SMTP、DNS等。</li><li>传输层:  主要功能是提供<u>应用程序之间的通信</u>，这一层主要是TCP/UDP协议。</li><li>网络层:  处理分组在<u>网络中的活动</u>，例如路由选择和转发等，这一 层主要包括IP协议、ARP、ICMP协议等。</li><li>网络接口层：这是协议栈的最低层，对应OSI的物理层和数据链路层，  主要完成<u>数据帧的实际发送和接收</u>。</li></ul><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><table><thead><tr><th align="center">区别</th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">不连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠</td><td align="center">可靠传输；使用流量控制和拥塞控制</td></tr><tr><td align="center">连接对象个数</td><td align="center">支持一对一，一对多，多对一，多对多交互通信</td><td align="center">仅支持一对一通信</td></tr><tr><td align="center">传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td align="center">数据边界</td><td align="center">保存数据边界</td><td align="center">不保存数据边界</td></tr><tr><td align="center">速度</td><td align="center">快</td><td align="center">慢</td></tr><tr><td align="center">发送消耗</td><td align="center">轻量级（UDP的传输信息不承担任何间接创造连接</td><td align="center">重量级</td></tr><tr><td align="center">首部开销</td><td align="center">小，仅8个字节</td><td align="center">大，最小20字节，最大60字节</td></tr><tr><td align="center">有序性</td><td align="center">不保证</td><td align="center">TCP 保证了消息的有序性，即使到达客户端顺序不同，TCP 也会排序。</td></tr><tr><td align="center">应用场景</td><td align="center">IP电话，视频会议，直播，以及FPS竞技类的使用UDP帧同步</td><td align="center">要求可靠传输的应用例如文件传输，以及MMO类的TCP状态同步</td></tr></tbody></table><h2 id="TCP运输连接管理：三握四挥"><a href="#TCP运输连接管理：三握四挥" class="headerlink" title="TCP运输连接管理：三握四挥"></a>TCP运输连接管理：三握四挥</h2><p><a href="https://blog.csdn.net/qq_33426324/article/details/105344168">(42条消息) 为什么TCP需要三次握手，四次挥手？_小菜鸡的日常问题的博客-CSDN博客_计算机网络 三次握手、四次挥手、为啥要四次</a></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>概念</li></ul><p><img src="https://img-blog.csdnimg.cn/30c2c4802d0b4622a3ecee2a2e66bd8c.png" alt="img"></p><blockquote><p>三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过 “确认号（Ack）”字段实现的。<strong>计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测 “确认号（Ack）字段”，看 Ack = Seq + 1 是否成立</strong>，如果成立说明对方 正确收到了自己的数据包。</p></blockquote><p>-首先Client端<strong>发送连接请求</strong>报文（只是请求，没有建立连接？）；</p><blockquote><p>客户端的发送能力 和 服务器的接受能力没有问题。</p><p>”客户端：我只知道我发送出去了。“</p></blockquote><p>-Server 段<strong>接收链接后回复</strong>ACK 报文，并为这次连接<strong>分配资源</strong>；</p><blockquote><p>服务器的发送能力和接收能力没有问题；</p><p>客户端的发送和接收能力没有问题；</p><p>但此时服务器不能确认客户端的接受能力有没有问题。</p><p>”客户端：我发送出去了；而且我收到了回复。“</p><p>”服务器：我收到了；我告诉客户端我收到了，还想问他：你是真的想和我连接吗？“</p></blockquote><p>-Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并<strong>分配资源</strong>，这样 TCP 连接就建立了。</p><blockquote><p>通过这次接收，服务器确认客户端的接收能力和发送能力没有问题；</p><p>本身的发送和接收能力也没有问题。</p><p>”服务器/客户端：都要确定发送出去，收到并且对方回复“</p></blockquote><p><strong>因此需要三次握手才能确认客户端和服务器的发送、接收能力是否正常</strong></p><ul><li><p>为什么要三次握手？</p><ul><li>如果只有一次握手，Client不能确定与Server的单向连接，更加不能确定Server与Client单向连接；</li><li>如果只有两次握手，Client确定与Server的单向连接，但是Sevrer不能确定与Client的单向连接；</li><li>只有三次握手，Client与Server才能相互确认双向连接，实现双方的数据传输。</li></ul></li><li><p>两次握手不行吗？</p><p>三次握手是为了<strong>防止当已失效的连接请求报文段</strong>突然又传到服务端，造成双方的不一致，导致资源的浪费</p><p>“已失效的链接请求报文段”是指：当客户端发送一个SYN报文，由于阻塞或某些原因在网络中滞留，导致客户端认为丢包了(其实没有丢)，于是又重新发送一个新的SYN报文，若这次顺利完成，双方建立的链接。</p><p>此时网络中存在隐患那个滞留的SYN文，若这个SYN在连接期间被服务接收到，服务器会无视它，</p><p>但若在连接释放之后接收到此SYN报文，服务器会认为客户端又向他发出连接请求，于是并返回一个SYNACK报文回应。若此时不采用三次握手，就建立新的连接。<br>这时服务器认为已完成连接，向客户端发送数据，而客户端处于Closed状态会丢弃这些数据，<br>也不发送数据，则服务端一直等待客户端发送数据，导致浪费资源。</p></li><li><p>三次握手过程中可以携带数据吗？</p><p>第三次握手的时候，可以携带数据，但是第一二次握手不可以携带数据。</p><p>第一握手不可以存放数据，其中简单的原因是会让服务器更加容易受到攻击。<br>而对于第三次握手的话，因为此时的客户端ESTABLISHED状态，对于客户端来讲，它已经建立起来了连接，并且也已经知道服务器的接受、发送能力没有问题，所以携带数据也没有问题</p></li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul><li><p>关闭连接时，服务端收到客户端的 FIN 报文时，仅表示对方不再发送数据，但仍然能够接收数据。此时，服务端不一定将全部数据都发送给了客户端。</p></li><li><p>因此服务端关闭有两种方式：</p><ul><li>立即关闭；</li><li><u>继续发送一些数据给客户端</u>后，再发送 FIN 报文给客户端（表示同意关闭连接），是否立刻关闭发送数据通道，需交由上层应用决定;</li></ul></li></ul><p>所以，客户端的 ACK 和 FIN 一般都会分开发送，这里就会导致次数增加一</p><p>数据传输完毕后，双方均可释放连接。起初，客户端和服务端均处于 ESTABLISHED 状态，然后是客户端主动关闭，服务器被动关闭.<br><img src="https://img-blog.csdnimg.cn/7d3aa066c42843d9b03f0be303cd172c.png" alt="img"></p><ul><li><p>客户端发送第一次挥手，之后由 ESTABLISHED 状态转为 FIN_WAIT1 状态</p></li><li><p>服务器收到客户端的第一次挥手之后，发送第二次挥手给服务器，服务器进入 CLOSE_WAIT 状态，等待服务器自身的 SOCKET 关闭等处理</p></li><li><p>客户端收到服务器的第二次挥手，进入 FIN_WAIT2 状态，等待服务器关闭</p></li><li><p>服务器发送第三次挥手，然后进入 LAST_ACK 状态</p></li><li><p>客户端收到第三次挥手，发送第四次挥手，客户端进入 TIME_WAIT 状态；</p></li><li><p>服务器收到第四次挥手，进入 CLOSED 状态，客户端等待 2MSL 后，进入 CLOSED 状态</p></li></ul><ul><li><strong>为什么要四次挥手（常问）</strong></li></ul><p>服务端在收到客户端的释放报文时，可能自己的数据报还没有发完，所以不会直接返回FIN+ACK，而只先返回一个ACK，表示自己收到了客户端的释放请求（第二次挥手）。等到服务端报文发完以后，在返回FIN（第三次挥手）。</p><ul><li><strong>那么，我们是否可以在服务器端数据传送完成后，再返回FIN+ACK呢？中间就可以省略一次ACK了？（省略第二次挥手）</strong></li></ul><p>​    试想一下，如果服务端还有很多数据需要传送，耗时长，客户端在发送释放报文后，一直没有收到反馈，那么他会认为服务端没有收到我的FIN，因此就会不停的重发FIN。（第一次挥手）</p><p>​    所以最好的办法就是，客户端发送FIN，服务端回复ACK，表示我已经收到了，但是我在忙，你等等，我处理完成后联系你。服务端数据传送完成后，发送FIN给客户端，客户端再回复ACK。</p><ul><li><strong>为什么不能直接CLOSE状态，必须要先设置TIME_WAIT(2个MSL）状态</strong>(???)</li></ul><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能客户端发送给服务的的最后一个ACK丢失。一段时间后，服务端收不到最后的ACK，认为客户端没有收到FIN请求（第三次挥手），进行超时重发，但是客户端已经关闭了，不会给响应。（理论上来说 服务器超时重发5次后，就会主动断开连接，这样数据既不会丢失也不会错乱，是可以的，但是这样不符合可靠连接。）</p><p>此时若旧的客户端直接CLOSE没有TIME_WAIT状态，新的客户端建立与服务端之间的连接，如果新连接和老连接的端口是一样的。假设老连接还有一些数据，因为网络或者其他原因，一直滞留没有发送成功，新连接建立后，就直接发送到新连接里面去了，造成数据的紊乱，因此，我们需要2*MSL的TIMEWAIT状态，让滞留在网络中的报文失效，再去建立新的连接。</p><p>所以简单来说TIME_WAIT状态中的2个MSL(TIME_WAIT状态作用)</p><ol><li>用来重发可能丢失（第四次挥手）的ACK报文</li><li>避免服务器有了新的数据需要发送给客户端。</li></ol><h2 id="TCP-为什么稳定"><a href="#TCP-为什么稳定" class="headerlink" title="TCP 为什么稳定"></a>TCP 为什么稳定</h2><p>与 乱序重排、应答确认、报文重传 和 流量控制 四种机制有关。</p><h3 id="乱序重排"><a href="#乱序重排" class="headerlink" title="乱序重排"></a>乱序重排</h3><p>由于网络或“多线程”等因素，接收方收到的数据段很可能是乱序的，不过因为每个 TCP 封装都有序号，接收方重组起来非常容易。</p><h3 id="应答确认"><a href="#应答确认" class="headerlink" title="应答确认"></a>应答确认</h3><p>计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测 “确认号（Ack）字段”，看 Ack = Seq + 1 是否成立，如果成立说明对方正确收到了自己的数据包。</p><p>不过为了提高效率，客户端一次有可能发送上千条数据，根据服务端返回客户端的确认号，判断是否为这上千条中最后一条的序列号+1，即发送5000条数据包，判断服务器发送给客户端的Ack是否为5001，等式成立即为接受完整。</p><h3 id="报文重传"><a href="#报文重传" class="headerlink" title="报文重传"></a>报文重传</h3><p>TCP 的报文重传有两种独立的办法。一种是超时重传，一种是快速重传。</p><p><strong>【超时重传】</strong></p><p>因为网速 并不是稳定的，传输时的每个报文的延时也不一样。TCP 会根据报文的往返时间（RTT）自动调整超时重传时间（RTO）。发送方每发一个报文段都会开始计时，如果时间超过 RTO 还没收到这个报文段的确认，就重传该报文段。</p><p><strong>【快速重传】</strong></p><p>接收方收到序号X 后，回复X+1的确认号，希望收到X+1序号报文，但没有收到，却收到了比X+1还要大的报文，就连续发出确认号X+1的报文，如果发送方连续三次收到重复的确认号，立即重发该报文段，而不管是否超时。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>首先要明白一点，应用程序不论发送还是接收数据，都会先把数据放入缓冲区，再从缓冲区中发出或读取数据。</p><p>这个缓冲区大小，反映了应用程序一次能处理数据的能力。如果接收方应用程序处理速度比发送方的发送速度慢，就会造成接收方缓冲区“溢出”。实际上，发送方发送速度和接收方处理速度很难一致。 这就需要 window 来调整了。 TCP 在三次握手建立连接时，会协商双方缓冲区 window 大小。如果因为接收方处理速度较慢，接收方会通过 window 告知发送方，实现动态调整，避免“溢出”。</p><p>所谓流量控制就是<u>让发送方发送速率不要过快，让接收方来得及接收</u>。利用滑动窗口机制就可以实施流量控制。原理这就是运用 TCP 报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</p><p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。解决这个问题，TCP 为每一个连接设置一个持续计时（persistence timer）。只要 TCP 的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小。</p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>拥塞的发生是因为路由器缓存溢出，拥塞会导致丢包，但丢包不一定触发拥塞。<a href="https://so.csdn.net/so/search?q=%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">拥塞控制</a>是快速传输的基础。一个拥塞控制算法一般包括慢启动算法、拥塞避免算法、快速重传算法、快速恢复算法四部分。</p><h2 id="粘包和分包"><a href="#粘包和分包" class="headerlink" title="粘包和分包"></a>粘包和分包</h2><p><a href="https://blog.csdn.net/YYL_Debug/article/details/79414095">(53条消息) Unity3D笔记——Socket粘包分包的理解和最简单的处理方式_YYL_Debug的博客-CSDN博客</a></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>该现象主要发生在TCP协议中：如果发送的数据很小，那么会自动把一些小的数据合并在一起发送出去；但是接收端就没办法自己分开了，这就是粘包现象(接收方不知道接收的数据间的界限，不知道接收多长的数据。)；而当一次发送的数据又过长的时候，TCP就会把该数据分成几部分发送出去，每次接收方就只会接受部分的数据，这就是分包现象；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粘包现象：</span></span><br><span class="line">客户端发送：hello</span><br><span class="line">客户端发送：aaaaa</span><br><span class="line">服务器收到：helloaaaaa</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分包现象：</span></span><br><span class="line">客户端发送：helloxiaoming</span><br><span class="line">服务器收到：hell</span><br><span class="line">服务器收到：oxiaoming</span><br></pre></td></tr></table></figure><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p> 1.发送端需要等缓冲区满才发送出去，造成粘包(发送端出现粘包)？？</p><p> 2.接收端没有及时接收缓冲区包数据，造成一次性接收多个包，出现粘包(接收端出现粘包)</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>1.缓冲区过大造成了粘包，所以在发送/接收消息时<strong>先将消息的长度作为消息的一部分发出去</strong>，这样接收方就可以根据接收到的消息长度来<u>动态定义缓冲区的大小</u>。(这种方法就是所谓的自定义协议，这种方法是最常用的)</p><p>2.对发送的数据进行处理，每条消息的首尾加上特殊字符，然后再把要发送的所有消息放入一个字符串中，最后将这个字符串发送出去，接收方接收到这个字符串之后，再通过特殊标记操作字符串，把每条消息截出来。(这种方法只适合数据量较小的情况)</p><h2 id="Socket的封包、拆包"><a href="#Socket的封包、拆包" class="headerlink" title="Socket的封包、拆包"></a>Socket的封包、拆包</h2><p><strong>基于TCP的通信程序需要封包、拆包的原因</strong></p><p>TCP是流协议，所谓流，就是没有界限的一串数据。但是程序中却有多种不同的数据包，那就很可能会出现如上所说的粘包问题，所以就需要在发送端封包，在接收端拆包。</p><p><strong>那么如何封包、拆包</strong></p><p>封包就是给一段数据加上包头或者包尾。比如说我们上面为解决粘包所使用的两种方法，其实就是封包与拆包的具体实现。</p><h2 id="断线重连（缺详细"><a href="#断线重连（缺详细" class="headerlink" title="断线重连（缺详细"></a>断线重连（缺详细</h2><p>当检测到客户端断线时，断开当前客户端 Socket；重新根据IP和端口号重建新的 Socket。当连接上服务器网关后，携带 token，向服务器发送断线重连协议。</p><h1 id="帧同步与状态同步"><a href="#帧同步与状态同步" class="headerlink" title="帧同步与状态同步"></a>帧同步与状态同步</h1><h2 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h2><p> 让每个客户端在<u>相同的时刻</u>发送游戏数据到服务端，服务器广播分发所有客户端的数据，然后客户端根据服务端发来的数据做出相应的逻辑处理，保证每个客户端在同一时刻所有的数据都是一致同步的。<strong>客户端做游戏逻辑处理。</strong></p><ul><li><p><strong>核心思想</strong>：相同的输入＋相同的时机=相同的表现</p></li><li><p><strong>同步的实现</strong></p><ol><li>同步随机种子</li><li>客户端上传<u>当前逻辑帧</u>的<u>操作</u>(帧索引+游戏操作)</li><li>服务器广播客户端操作</li></ol></li></ul><p>帧同步可以说同步的是操作(输入)，服务器收到每个客户端当前的输入，将数据广播到所有客户端，客户端针对其他客户端的操作，做出逻辑处理，使得所有客户端在每一时刻的数据都是一致的。</p><ul><li><p>优点</p><ol><li>单次同步数据很小，传输速率快，因为数据的逻辑处理主要是在客户端，服务器只起到分发同步的作用。<br>服务端压力小。</li><li>更容易实现录像功能，因为是帧同步，每一个时刻的帧序列都有记录，可以很好的还原游戏过程。</li><li>开发效率高，可以部分当作单机游戏来开发。</li><li>游戏精准度更高，能呈现更好的打击感、音效、特效等反馈、以及动作的反馈、动作的频率也可以更高。</li><li>流量消耗小，因为传输的数据量更少。大部分逻辑处理都在客户端处理好了。</li></ol></li><li><p>缺点</p><ol><li><p>反外挂能力弱。因为主要的数据处理是在客户端。</p></li><li><p>网络要求更高，因为是实时同步，一旦客户端网络延迟过高，很容易影响用户体验，产生网络抖动。</p></li><li><p>断线重连难度很大，因为一旦掉线，本地数据丢失了，需要从服务器逐帧来读取游戏进度，直到与当前游戏进度一致。如果直接从当前游戏进度开始进行同步，是很容易出现数据错误的。</p></li></ol></li></ul><h2 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h2><p>客户端将数据发送到服务端，服务端根据每个<u>客户端发来的数据</u>做出处理，再将<u>处理完的数据</u>广播发送到所有客户端，客户端根据数据进行数据表现。<strong>服务端做游戏逻辑处理</strong>。</p><ul><li>优点<ol><li>反外挂能力强，因为大部分数据处理都是在服务端。</li><li>网络要求不高。(?)</li><li>玩家可以随时加入到一个开始的战局，只需要同步当前战局内的所有玩家当前的状态即可。</li></ol></li><li>缺点:<ol><li>传输数据大，传输速度慢。因为客户端会将大量数据传输给服务端，再由服务端进行逻辑处理，再分发给所有客户端。</li><li>服务端压力大</li><li>回放较难还原</li></ol></li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><img src="https://img-blog.csdnimg.cn/f8554782706743a3ba92b8f5aa3dcf04.png" alt="img"></p><p> 状态同步：比较多的MMO</p><p> 帧同步：Dota，红警  RTS（战略）类游戏，Moba类。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程：一个应用程序相当于一个进程，是操作系统资源分配的基本单位。 一个进程拥有多个线程。更安全。</p><p>线程：是程序的实际执行者。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，一个线程只有一个进程。效率高。</p><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><h2 id="什么是线程争用"><a href="#什么是线程争用" class="headerlink" title="什么是线程争用"></a>什么是线程争用</h2><p>因为进程中可存在多个线程，线程间均可访问主线程资源。所以若线程间争抢资源，可能导致数据混乱。 </p><h2 id="如何解决线程争用-？"><a href="#如何解决线程争用-？" class="headerlink" title="如何解决线程争用(？ )"></a>如何解决线程争用(？ )</h2><p>  只要避免同一时间只有一个线程来访问共享数据就OK了。</p><p>​    1.Monitor（监控器）</p><p>​    2.Lock，是对Monitor的封装，简单易用。</p><h2 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h2><p><img src="https://img-blog.csdnimg.cn/a420b296934a4d389c1bce542fba3929.png" alt="img"></p><h2 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h2><ul><li><p>线程有两种：前台线程和后台线程。</p><p>区别是：应用程序必须运行完所有的前台线程才可以退出；而对于后台线程，应用程序则可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时都会自动结束。</p></li><li><p>.net环境使用Thread 建立的线程默认情况下是前台线程，即线程属性IsBackground=false。</p><p><u>在进程中</u>，只要有一个前台线程未退出，进程就不会终止。<strong>主线程</strong>就是一个<strong>前台线程</strong>。</p><p> 而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。</p></li><li><p>使用方法</p><p>一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。</p><p>而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序。</p></li><li><p>注意</p><p>在调用Start方法之前设置线程的类型，否则一但线程运行，将无法改变其类型。（还没在unity弄过线程？）</p></li></ul><h2 id="针对于效率与安全方面，两者区别"><a href="#针对于效率与安全方面，两者区别" class="headerlink" title="针对于效率与安全方面，两者区别"></a><strong>针对于效率与安全方面，两者区别</strong></h2><p>线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。</p><p>进程执行开销大，但是能够很好的进行资源管理和保护。进程 可以跨机器前移。</p><p><strong>使用场景</strong>：</p><p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程；</p><p>对算力要求高的使用多进程，因为<u>操作系统分配的算力是按进程分配的</u>，一个进程内即使有再多的线程，也只能得到一个CPU核心的算力；</p><p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p><h1 id="并发-并行-异步-同步"><a href="#并发-并行-异步-同步" class="headerlink" title="并发/并行/异步/同步"></a><strong>并发/并行/异步/同步</strong></h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>一个处理器“同时”处理多个任务，CPU通过时间片切换轮流执行不同的任务。</p><p>进程的调度实际上就是实现了并发，相当于吃饭吃一半，停下来去接电话，接完再吃饭，只是过程很快，做到了像同时运行。</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>“多个”处理器或者多核处理器同时处理多个任务，两个线程<strong>互不抢占CPU资源</strong>，可以同时执行任务。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>比如我上手机店买手机，服务员去仓库拿手机，要花一分钟，我趁这一分钟才去买水喝，然后回来刚好拿到手机。</p><p>这个过程就是当程序遇到阻塞，需要等待的时候，程序会先执行其他任务，完成任务后回来，刚好上个任务也已经完成，可以提高效率。</p><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>比如我上手机店买手机，服务员去仓库拿手机，要花一分钟，我等了一分钟后拿到手机才去买水喝。这个过程就是当程序遇到阻塞，需要等待的时候，程序会一直等待阻塞解除或者运行完后才进行下一步执行。</p><h1 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h1><h2 id="什么是网络抖动"><a href="#什么是网络抖动" class="headerlink" title="什么是网络抖动"></a>什么是网络抖动</h2><p>如果网络发生拥塞，排队延迟将影响端到端的延迟，并导致通过同一连接传输的分组延迟各不相同，而抖动，就是用来描述这样一延迟变化的程度。</p><p>他是网络延时变化，最大延迟与最小延迟的时间差；</p><p>如最大延迟是20毫秒，最小延迟为5毫秒，那么网络抖动就是15毫秒，它主要标识一个网络的稳定性。</p>]]></content>
    
    
    <summary type="html">关于计算机网络知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法 知识整理</title>
    <link href="https://huangxinhere.github.io/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://huangxinhere.github.io/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-21T16:00:00.000Z</published>
    <updated>2023-08-15T01:03:11.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>前驱和后继：前驱就是指逻辑上前一个结点，后继就是逻辑上后一个结点，如果用位号的观点看，前驱就是当前结点的位号-1，后继就是当前结点的位号+1。</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树的概念和性质"><a href="#二叉树的概念和性质" class="headerlink" title="二叉树的概念和性质"></a>二叉树的概念和性质</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>先序遍历：左根右；</p><p>中序遍历：根左右；</p><p>后序遍历：左右根；</p><ul><li><p>哪两种遍历方式可以确定一棵树？</p><ol><li>先序遍历 + 中序遍历</li><li>后序遍历 + 中序遍历</li><li>先序遍历 + 后序遍历（不可行）</li></ol><p>先序遍历和后序遍历对于我们组建一个二叉树所能提供的信息都只是根节点，我们依次拿着根节点去中序遍历分割左子树和右子树，在通过递归组成整颗树。</p></li></ul><h3 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h3><ul><li>创建</li><li>查找</li><li>寻找左右孩子</li><li>求高度</li><li>输出二叉树</li></ul><h3 id="二叉树的构造"><a href="#二叉树的构造" class="headerlink" title="二叉树的构造"></a>二叉树的构造</h3><ul><li><p>序列还原二叉树</p></li><li><p>二叉树表达式</p></li><li><p>线索二叉树</p></li><li><p>哈夫曼树 <a href="https://zhuanlan.zhihu.com/p/415467000">数据结构——哈夫曼树（Huffman Tree） - 知乎 (zhihu.com)</a></p><ul><li><p>最小带权路径长度的二叉树（路径×结点值），较大的结点离根较近；</p></li><li><p><strong>结点的带权路径长度</strong>为：从根结点到该结点之间的路径长度 / 与该结点的权 / 的乘积。</p><p><img src="https://pic2.zhimg.com/80/v2-561bb507a8adcbbed29281abac1d3485_1440w.webp" alt="img"></p></li><li><p><strong>树的带权路径长度</strong>规定为所有<strong>叶子结点</strong>的带权路径长度之和，记为WPL。</p><p>如上图：数的带权路径长度为：WPL = (2+3) * 3 + 4 * 2 + 6 * 1 = 29</p></li><li><p>构造方法：选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；从森林中删除选取的两棵树，并将新树加入森林……</p><p><img src="https://pic3.zhimg.com/80/v2-5c5bdbcdbfbacf4565bb5e99445b964a_1440w.webp" alt="img"></p></li><li><p>哈夫曼编码：是一种压缩编码的编码算法。对于不同字符的出现频率其使用的编码是不一样的。其会对频率较高的字符使用较短的编码，频率低的字符使用较高的编码。这样保证总体使用的编码长度会更少，从而实现到了数据压缩的目的。</p></li></ul></li></ul><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h1 id="位运算与应用"><a href="#位运算与应用" class="headerlink" title="位运算与应用"></a>位运算与应用</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="负数怎么表示？"><a href="#负数怎么表示？" class="headerlink" title="负数怎么表示？"></a>负数怎么表示？</h3><p>计算机中的负数表示，是以补码的形式呈现的。</p><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230221152901899.png" alt="image-20230221152901899"></p><p>这样方便计算机进行直接运算。</p><h2 id="基本运算-1"><a href="#基本运算-1" class="headerlink" title="基本运算"></a>基本运算</h2><ul><li>按位与：0&amp;0=0，0&amp;1=0，1&amp;1=0    全为0才是0</li><li>按位或：0|0=0，0|1=1，1|1=1       全为1才是1</li><li>按位异或：0^0=0，0^1=1，1^1=0    相同为0，相异为1</li><li>按位非：<del>1=0，</del>0=1</li><li>有符号右移：&gt;&gt;（若正数，高位补0，负数则高位补1）</li><li>有符号左移：&lt;&lt;</li><li>无符号右移：&gt;&gt;&gt;（不论正负，高位均补0）</li></ul><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>按位与计算比取模运算快；哈希表；记录状态值（比如int有32位，每一位都可以记录0，1两个状态值，这样节省空间）；可逆加密……</p><ul><li>优势：计算快，节约空间</li><li>劣势：不直观</li></ul><h2 id="常见简单面试题"><a href="#常见简单面试题" class="headerlink" title="常见简单面试题"></a>常见简单面试题</h2><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p>a%(2^n) = a&amp;(2^n-1)</p><h3 id="判断奇偶数"><a href="#判断奇偶数" class="headerlink" title="判断奇偶数"></a>判断奇偶数</h3><p>4 = 100</p><p>5 = 101</p><p>6 = 110</p><p>7 = 111</p><p>分别&amp;1（也就是00000001），最后一位判断</p><h3 id="实现数字翻倍或减半"><a href="#实现数字翻倍或减半" class="headerlink" title="实现数字翻倍或减半"></a>实现数字翻倍或减半</h3><p>右移或左移1位</p><h3 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h3><p>a = a ^ b</p><p>b = a ^ b (= (a ^ b) ^ b = a ^ (b ^ b) = a)    //符合交换律，自己异或自己就是1</p><p>a = a ^ b (= (a ^ b) ^ a = (a ^ a) ^ b = b)</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li><p>二进制体现的特点</p><ul><li>末尾为1就是奇数，是0则为偶数；</li><li>其中偶数n比n/2的二进制多一个0，奇数比前一个偶数多一个1</li></ul></li><li><p>按位与的特点</p><ul><li>只有1&amp;1才为1，其余为0；用来保留1，抹去其它位（如判断奇偶数）</li><li>n&amp;(n-1)能去掉二进制表示的最后一个“1”；例如21&amp;20=20(3个1)，20&amp;19=16(2个1),16&amp;15=0(1个1)，那么分别得16有1个1，20有2个1,21有3个1</li></ul></li><li><p>按位或的特点-*+</p><ul><li>只有0|0才为0，其余为1；或许也是能保留0，</li></ul></li><li><p>按位异或的特点</p><ul><li>一个数和本身异或一次为0；结合交换律；（利用或消去重复数字）</li><li>比对两个位是否相同</li></ul></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="BF算法（暴力算法"><a href="#BF算法（暴力算法" class="headerlink" title="BF算法（暴力算法"></a>BF算法（暴力算法</h3><h3 id="BP算法"><a href="#BP算法" class="headerlink" title="BP算法"></a>BP算法</h3><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p><a href="https://zhuanlan.zhihu.com/p/132396715">渐进时间复杂度分析 - 知乎 (zhihu.com)</a></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>多阶段决策问题</li><li>将过程分为若干个互相联系的阶段，在每一个阶段都要作出决策；而本阶段的决策常常影响到下一个阶段的决策，从而完全确定了一个过程的活动路线</li></ul><p>（相比于递归，递归划分的小问题都是固定的解决模式，而动态规划有多种策略要找出最优）</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><h3 id="确定状态转移公式"><a href="#确定状态转移公式" class="headerlink" title="确定状态转移公式"></a>确定状态转移公式</h3><ul><li>当前的状态是怎么由前面的状态变化而来</li><li>与之相关联的辅助的dp数组以及下标的含义</li><li>（往往是最难的一步）</li></ul><h3 id="初始化dp数组"><a href="#初始化dp数组" class="headerlink" title="初始化dp数组"></a>初始化dp数组</h3><h3 id="根据题目条件确定遍历顺序，并实现状态转移公式"><a href="#根据题目条件确定遍历顺序，并实现状态转移公式" class="headerlink" title="根据题目条件确定遍历顺序，并实现状态转移公式"></a>根据题目条件确定遍历顺序，并实现状态转移公式</h3><h2 id="什么问题适合动态规划？"><a href="#什么问题适合动态规划？" class="headerlink" title="什么问题适合动态规划？"></a>什么问题适合动态规划？</h2><p>多阶段决策最优解模型</p><ul><li>最优子结构</li><li>无后效性（只关心前面状态的值；前者状态确定后和后者无关）</li><li>重复子问题  </li></ul><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><a href="https://blog.csdn.net/yuxin6866/article/details/52771739">八大常用排序算法详细分析 包括复杂度，原理和实现_厚积_薄发的博客-CSDN博客</a></p><p><img src="https://img-blog.csdn.net/20161009171515225" alt="img"></p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="https://feihu.me/img/posts/stl-insertion-sort.gif" alt="插入排序"></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="https://pic2.zhimg.com/v2-ea6f2a8470c198bc603258239ad281c1_r.jpg" alt="漫画：什么是希尔排序？ - 知乎"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><a href="https://zhuanlan.zhihu.com/p/39615266">数据结构与算法(4)——优先队列和堆 - 知乎 (zhihu.com)</a>【图文比较详细不过是Java版的】</p><p><a href="https://blog.csdn.net/weixin_45292794/article/details/119599923">(53条消息) 【C++】优先队列、priority_queue（大顶堆，小顶堆）_c++优先队列默认是小顶堆吗_张林克的博客-CSDN博客</a></p><h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><p>有时候不需要一次性全部有序，只需取最大值最小值等。</p><p>堆就是解决一个动态数据集合中的 topK 问题的利器。最小堆经常用来求取数据集合中 k 个值最大的元素，而最大堆经常用来求取数据集合中 k 个值最小的元素。【为什么？？】</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>完全二叉树：由于完全二叉树的特性，可以用数组表示。</li></ul><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-数据结构与算法.assets\image-20230709091059475.png" alt="image-20230709091059475"></p><ul><li><p>规律：</p><p>对于位置为k的节点，左子节点 = 2 * k + 1，右子节点 = 2 * （k+1);</p><p><strong>最后一个非叶子节点</strong>的位置是 （N/2）-1，N为数组长度；</p></li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul><li>排成完全二叉树</li></ul><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-数据结构与算法.assets\image-20230709091411756.png" alt="image-20230709091411756"></p><ul><li>找到最后一个非叶子节点：8/2-1=3，第三个也就是9；</li><li>9和叶子节点进行比较交换：</li></ul><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-数据结构与算法.assets\image-20230709091750829.png" alt="image-20230709091750829"></p><ul><li>剩下的非叶子节点倒序地进行比较排序</li></ul><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-数据结构与算法.assets\image-20230709091858897.png" alt="image-20230709091858897"></p><ul><li><p>调整48：48比右子树小，和53交换。</p><blockquote><p>也就是不符合大根堆的，就和子树最大值交换。有种竖直方向上冒泡的感觉</p></blockquote></li><li><p>把非叶子节点调整完后，发现第一个数比第四个数小。</p><blockquote><p>其实也就是小的数下沉的过程，要沉到底。只交换一次不一定保证就是比子树都大的。</p></blockquote></li></ul><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-数据结构与算法.assets\image-20230709092427554.png" alt="image-20230709092427554"></p><ul><li><p>符合堆的条件后，开始排序：已知根节点是最大值，取了之后如何维护堆呢？</p><p>和最后一个叶子节点交换，这样能维护堆的结构（把最大值当作最后叶子节点去掉即可）；然后再进行“下沉”，维护堆的基本关系。</p></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/hexo_github_blog\source_posts\知识整理-数据结构与算法.assets\image-20230709150635824.png" alt="image-20230709150635824"></p><p>可见堆排序，和快速排序比较，则在最坏情况下仍能保持nlogn；和归并排序来说，空间复杂度为1.</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><img src="https://pic4.zhimg.com/v2-7e2f062f6b2cf87502f0b84794f2600f_r.jpg" alt="笔面试准备（2）——常见十大基本排序算法汇总 - 知乎"></p>]]></content>
    
    
    <summary type="html">关于数据结构与算法知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>C#知识整理</title>
    <link href="https://huangxinhere.github.io/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://huangxinhere.github.io/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2023-02-19T16:00:00.000Z</published>
    <updated>2023-08-14T23:28:31.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象（OOP）的三大特征：继承、封装、多态"><a href="#面向对象（OOP）的三大特征：继承、封装、多态" class="headerlink" title="面向对象（OOP）的三大特征：继承、封装、多态"></a>面向对象（OOP）的三大特征：继承、封装、多态</h1><p>面向对象编程（Object-Oriented Programming）与面向过程（Procedure Oriented ）。</p><ul><li>面向过程：面向过程的思想是把一个项目、一件事情按照一定的顺序，从头到尾一步一步地做下去，先做什么，后做什么，一直到结束。这种思想比较好理解，其实这也是一个人做事的方法。</li><li>面向对象：面向对象的思想是把一个项目、一件事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。这种思想比较适合多人的分工合作，就像一个大的机关，分成各个部门，每个部门分别负责某样职能，各个部门可以充分发挥自己的特色，只要符合一定前提就行了。</li></ul><blockquote><p>个人理解：OOP是按照“人的逻辑语义”来进行划分的，就产生了类的思想，同类数据或行为就封装成一个类，为了实现不同类之间互不干涉，密切分工合作，就对各自的数据进行保护，产生了封装；</p><p>划分成一个统一的类可能还不够，不满足一些个性化的需求，所以产生继承；</p><p>继承类有完全个性化的实现，也有对父类方法的“重写”，可以选择实现子类还是父类的相同行为但不同表现形式，就叫多态。（既满足了行为的抽象，又满足了具体表现的个性化……？）</p></blockquote><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>提高代码重用度，增强软件可维护性的重要手段；</li><li>符合开闭原则（软件中的对象扩展是开放的，修改是关闭的）；</li><li>继承就是把子类的公共属性集合起来（变量，方法等）共同管理，这些公共属性设置为父类，C#的继承是单继承，但继承有传递性：A继承B，B继承C，A可以调用C#中的方法。</li></ul><h3 id="派生类继承基类"><a href="#派生类继承基类" class="headerlink" title="派生类继承基类"></a>派生类继承基类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">int</span> id</span>) : <span class="title">base</span>(<span class="params">name, age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><ul><li><p>override：对基类中<u>同名方法</u>的<strong>新实现</strong>；同时基类中的同名方法必须声明为 virtual 或 abstract 类型</p><ul><li>默认的 C# 方法并非 virtual ，因此不能重写。</li><li>基类方法的可访问级别并不因重写它的方法而改变，他们的访问修饰符相同。</li><li>new 、 static 和 virtual 关键字不能与 override 访问修饰符一同使用</li></ul></li><li><p>virtual：用于对一个类中<strong>可修改的方法</strong>的声明，这种方法称为虚拟方法；比如当某个类实现了方法A，并将它声明为virtual，那么A还能被子类方法修改成A‘。编译的时候才会判定要执行的是A还是A’，这体现了多态。而abstract修饰的方法没有方法体，且一定要被继承实现。</p><ul><li><p>详细过程</p><ul><li><p>当调用一个对象的函数时，系统会直接去检查这个对象声明定义的类，即声明类，看所调用的函数是否为虚函数。如果不是虚函数，那么它就直接执行该函数。</p></li><li><p>而如果有virtual关键字，也就是一个虚函数，那么这个时候它就不会立刻执行该函数了，而是转去检查对象的【实例类】。</p></li><li><p>在这个实例类里，他会检查这个实例类的定义中是否有重新实现该虚函数（通过override关键字），如果有，则马上执行该实例类中的这个重新实现的函数。而如果没有，系统会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载了该虚函数的父类为止，然后执行该父类里重载后的函数。</p></li></ul></li><li><p>virtual访问修饰符不能与static和override等访问修饰符一同使用；</p></li><li><p>实现原理：每个虚函数都会有一个与之对应的虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个对象的虚函数入口地址。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。 </p></li></ul><blockquote><ul><li>如果是声明类 &amp; 实例类的话：先检查声明类这个函数是不是虚函数, 如果不是虚函数就直接执行函数. 如果是虚函数的话再去检查这个对象的实例类, 看看实例类中有没有重写这个虚函数, 如果有的话就直接执行该函数, 否则就去找这个实例类的父类, 看看他的父类中有没有重写这个虚函数,有的话就执行, 没有的话就继续找直到找遍所有父类, 如果没有override关键字, 最后会执行申明类里的虚函数.<br>————————————————<br><a href="https://blog.csdn.net/lx2054807/article/details/102703775">https://blog.csdn.net/lx2054807/article/details/102703775</a></li><li>如果是基类的引用访问派生类的话：那么直接访问最高（最年幼的）级别的派生类的方法。书p138</li></ul></blockquote></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PrintFields();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintFields</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> y;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrintFields</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;,y=&#123;1&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> B();             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出的是x=1，y=0。先隐式调用父类A的无参构造函数，执行PrintFields()方法，检查到是虚方法，转去检查实例类B，有重载方法，执行重载方法，输出x=1,y=0</p></blockquote><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是将<u>数据和行为相结合</u>，通过行为约束代码修改数据的程度，增强<u>数据的安全性</u>，属性是C#封装实现的最好体现。</p><p>将一些复杂的逻辑包装起来，程序员不管内部是如何实现的，只负责使用里面的数据或者逻辑，目的是<u>保护或者防止代码被无意修改</u>。</p><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>【简要介绍】<a href="https://www.runoob.com/csharp/csharp-polymorphism.html">C# 多态性 | 菜鸟教程 (runoob.com)</a></p><p>【详细分析】<a href="https://www.cnblogs.com/qixinbo/p/8244583.html">C#面向对象（三）：多态 - SeedQi - 博客园 (cnblogs.com)</a></p><ul><li><p>在继承关系的前提下，实例化出不同的对象，这些对象调用相同的方法，但是却表现出不同的行为，这就叫做多态。</p></li><li><p><strong>多态性</strong>意味着有多重形式。在面向对象编程范式中，多态性往往表现为”一个接口，多个功能”。</p></li><li><p>多态性可以是静态的或动态的。在<strong>静态多态性</strong>中，<u>函数的响应</u>是在编译时发生的。在<strong>动态多态性</strong>中，函数的响应是在运行时发生的。</p><ul><li><p>静态多态性：在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：函数重载 &amp; 运算符重载。</p><ul><li><p>函数重载：对相同的函数名有多个定义；不能修改返回类型。</p></li><li><p>运算符重载：<a href="https://www.runoob.com/csharp/csharp-operator-overloading.html">C# 运算符重载 | 菜鸟教程 (runoob.com)</a></p></li><li><p>C++：重载和模板（传入template T才实例化一个函数）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="comment">// opterator+</span></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Box <span class="keyword">operator</span>+ (Box b, Box c)</span><br><span class="line">&#123;</span><br><span class="line">    Box box = <span class="keyword">new</span> Box();</span><br><span class="line">    box.length = b.length + c.length;</span><br><span class="line">    box.breadth = b.breadth + c.breadth;</span><br><span class="line">    box.height = b.height + c.height;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>动态多态性：抽象类 &amp; 虚方法。</p></li></ul></li></ul><h1 id="引用类型，值类型"><a href="#引用类型，值类型" class="headerlink" title="引用类型，值类型"></a>引用类型，值类型</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>值类型<code>继承自System.ValueType</code>：byte、short、int、long、float、 double、bool、char / struct、 enum…;</li><li>引用类型<code>继承自System.Object</code>：string、object、delegate、interface、class、array…</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>存储</p><ul><li><p>地方：值类型存储在栈中，引用类型存储在堆中；</p></li><li><p>方式：值类型变量声明后，不管是否已经赋值，编译器为其分配内存；当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时<strong>并没有为其分配堆上的内存空间</strong>。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配）。</p></li><li><p>速度：值类型存储快，引用类型存储慢</p></li></ul></li><li><p>意义：值类型表示实际数据，引用类型表示指向在内存堆中的指针和引用</p></li><li><p>释放：值类型在栈中可以自动释放，引用类型在堆中需要GC来释放</p></li><li><p>父类：值类型继承于 System.ValueType，（System.ValueType继承于System.Object)，引用类型继承于System.Object</p></li></ul><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><ul><li>引用类型在实例化时，先<u>在栈内开辟空间</u>，用于存储堆中对象的地址，然后<u>在堆内开辟空间</u>，存储引用对象。</li><li>而值类型直接在栈中开辟空间存储对象。值类型也有引用地址，但都在栈内的同一空间。</li><li>修改：在参数对象进入方法体内，实则是在栈中开辟了<u>新的临时空间</u>。（也就是参数对象的副本）栈内值类型的修改，由于栈中地址不同，所以值类型不会影响到主体。而引用类型的存储数据是一个堆内的地址，所以对于引用类型的修改是直接修改堆内的对象。</li><li>值类型对象中的引用类型在堆中（struct中定义的string等）；引用类型对象中的值类型也在堆中（class中的int等。</li></ul><p>拓展传送门：</p><p><a href="https://dpc520.blog.csdn.net/article/details/119285430?spm=1001.2014.3001.5506">(42条消息) C# “值类型“和“引用类型“在内存的分配_生产队的驴.的博客-CSDN博客_c# 值类型和引用类型的内存分配</a></p><p><a href="https://blog.csdn.net/qiaoquan3/article/details/51202926">(42条消息) C#详解值类型和引用类型区别_HawkJony的博客-CSDN博客_值类型 引用类型 区别</a>【超详细，待研究】</p><h2 id="赋值、浅赋值、深复制"><a href="#赋值、浅赋值、深复制" class="headerlink" title="赋值、浅赋值、深复制"></a>赋值、浅赋值、深复制</h2><ul><li>赋值：值类型成员和引用类型成员共用（都会改变</li><li>浅复制：值类型成员不共用</li><li>深复制：引用类型成员也不共用</li></ul><p><a href="https://blog.csdn.net/qq_27825451/article/details/81274668">(50条消息) 一文搞懂C#中的赋值、深复制、浅复制_c# 函数赋值_LoveMIss-Y的博客-CSDN博客</a>【含类的拷贝方法】</p><p>【数组的深拷贝方法】<a href="https://www.cnblogs.com/tang-skillhunter/p/8529570.html">C# 数组深拷贝 - 追问图 - 博客园 (cnblogs.com)</a></p><p>【类的深拷贝方法】<a href="https://www.cnblogs.com/zhaoqingqing/p/14800759.html">C#对象属性浅拷贝和深拷贝 - 赵青青 - 博客园 (cnblogs.com)</a></p><h1 id="String引用类型的特殊性"><a href="#String引用类型的特殊性" class="headerlink" title="String引用类型的特殊性"></a>String引用类型的特殊性</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>字符串每重新赋值，不会覆盖原值，而是开辟新空间存储；</p><p>如果内容相同，不同栈地址会指向同一个堆地址；</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>若对字符串频繁修改的时候，利用StringBuilder代替String；</p><h2 id="StringBuilder的底层实现"><a href="#StringBuilder的底层实现" class="headerlink" title="StringBuilder的底层实现"></a>StringBuilder的底层实现</h2><p>StringBuilder不在内存中创建新对象，而是动态扩展内存以容纳修改后的字符串。在扩容的期间，会丢弃原数组内的内容，将内容拷贝到新数组。</p><p><a href="https://zhuanlan.zhihu.com/p/556672400">C# StringBuilder 使用 - 知乎 (zhihu.com)</a></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>StringBuffer是线程安全，一般用于多线程（？？</p><p>StringBuilder是非线程安全，所以性能略好，一般用于单线程</p><h2 id="用StringBuilder拼接字符串就一定比string要好吗？"><a href="#用StringBuilder拼接字符串就一定比string要好吗？" class="headerlink" title="用StringBuilder拼接字符串就一定比string要好吗？"></a>用StringBuilder拼接字符串就一定比string要好吗？</h2><p>答：不一定，stringbuilder有自身的GC消耗</p><p>​    极少拼接（或者短字符串）的情况下 String甚至优于StringBuilder，因为String是公用API，通用性好，用途广泛，读取性能高，占用内存较小，Stringbuilder初始化花费时间更大。</p><h2 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h2><p>字符串池有什么用，原理是什么？</p><ul><li>字符串池是CLR一种针对于反复修改字符串对象的优化措施，作用能够一定程度减少内存消耗。</li><li>原理是内部开辟容器通过键值对的形式注册字符串对象，键是字符串对象的内容，值是字符串在托管堆上的引用。这样当新创建的时候，会去检查，如果不存在就在这个容器中开辟空间存放字符串。</li></ul><p><a href="https://blog.csdn.net/qq826364410/article/details/87994993">(42条消息) C#–字符串常量池_鹅厂程序小哥的博客-CSDN博客_常量池 c#</a></p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>unity内部有两个内存管理池：堆内存和栈内存。</p></li><li><p>存储的数据：栈内存(stack)主要用来存储<u>较小的和短暂的</u>数据，堆内存(heap)主要用来存储<u>较大的和存储时间较长的</u>数据。unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。</p></li><li><p>标记</p><ul><li><p>状态：只要变量处于激活状态，则其占用的内存会被标记为使用状态，该部分的内存处于被分配的状态。<br>一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。</p></li><li><p>处理效率：处于栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。不再使用的内存只会在GC的时候才会被回收。</p></li></ul></li><li><p>垃圾回收<u>主要是指<strong>堆上的</strong></u><u>内存分配和回收</u>，unity中会定时对堆内存进行GC操作。</p></li></ul><h2 id="GC算法介绍"><a href="#GC算法介绍" class="headerlink" title="GC算法介绍"></a>GC算法介绍</h2><p>​    C#：分代算法，有内存整理，避免碎片化。有压缩。</p><p>​    0代，未被标记回收的新分配对象</p><p>​    1代，上次垃圾回收中没有被回收的对象</p><p>​    2代，在一次以上的垃圾回收之后仍然没有被回收的对象</p><p><a href="https://blog.csdn.net/qq_41719595/article/details/121016454">(42条消息) C#——垃圾回收(GC)_面向大象编程的博客-CSDN博客_c# gc</a></p><h2 id="简易流程"><a href="#简易流程" class="headerlink" title="简易流程"></a>简易流程</h2><ul><li><p>GC会检查堆内存上的每个存储变量;</p></li><li><p>对每个变量会检测其引用<u>是否处于激活状态</u>;</p></li><li><p>如果变量的引用不再处于激活状态，则会被标记为可<u>回收</u>;</p></li><li><p>被标记的变量会<u>被移除</u>，其所占有的内存会被回收到堆内存上。</p></li></ul><h2 id="流程详细介绍"><a href="#流程详细介绍" class="headerlink" title="流程详细介绍"></a>流程详细介绍</h2><ul><li><p>当新建立引用类型对象时，检查0代储存空间<u>是否有充足的空间</u>使得新的引用类型对象存储。若没有，将0代对象进行<u>遍历检查</u>，是否有被调用（激活），没有被调用的对象被标记“可回收”。</p></li><li><p>遍历完成后，将所有被“可回收”的对象进行垃圾<strong>回收</strong>，释放的空间返回给0代储存区，其他的对象的对象<strong>迁移</strong> 到1代储存区，标记为“1代对象”，此时该对象是分散分布的，要进行 压缩 操作，使得1代对象顺序紧密排列。新对象存储于0代储存空间，标记为0代对象。</p></li><li><p>当1代空间满了时，将1代对象按照上述操作遍历，迁移，压缩到2代储存区，标记为2代对象，同时0代迁移压缩到1代。</p></li></ul><h2 id="GC带来的问题"><a href="#GC带来的问题" class="headerlink" title="GC带来的问题"></a>GC带来的问题</h2><p>GC在unity内存管理中，会带来以下问题：</p><ul><li><p>游戏性能：GC操作是一个极其耗费事件的操作，<u>堆内存上的变量或者引用越多</u> 则导致<u>遍历检查时的操作变得十分缓慢</u>，使得游戏运行缓慢，例如当CUP处于游戏性能的关键时刻，任何一个操作就会导致游戏帧率下降，造成极大的影响。</p></li><li><p>游戏内存：（unityGC采用的是<strong>非分代非压缩的标记清除算法</strong>）GC操作会产生“<strong>内存碎片化</strong>”。当一个单元内存从堆中分配出来，其大小取决于存储变量的大小。当内存被回收到堆上时，有可能被堆内存分割成碎片化的单元。（就是说总容量大小时固定的，但是单元内存较小。例如房子很大，房间很小，找不到合适的房间）即下次分配时找不到合适的储存单元，<u>就会触发GC操作，或者堆内存扩容操作</u>，导致GC频发发生和游戏内存越来越大。</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/265217138">Unity GC 学习总结 - 知乎 (zhihu.com)</a>（看得不是特别仔细，待进一步深究；有GC的优化，特别技巧等）</p><h2 id="何时触发"><a href="#何时触发" class="headerlink" title="何时触发"></a>何时触发</h2><ul><li><p>在堆内存上进行内存分配操作，而<u>内存不够的时候</u>都会触发垃圾回收来利用闲置的内存;</p></li><li><p>GC会<u>自动地触发</u>，不同平台运行频率不—样;</p></li><li><p>GC可以<u>被强制执行</u>。</p></li></ul><h2 id="如何避免GC？（装箱拆箱介绍-对象池介绍-泛型介绍）"><a href="#如何避免GC？（装箱拆箱介绍-对象池介绍-泛型介绍）" class="headerlink" title="如何避免GC？（装箱拆箱介绍/对象池介绍/泛型介绍）"></a>如何避免GC？（装箱拆箱介绍/对象池介绍/泛型介绍）</h2><ul><li><u>减少临时变量的使用</u>，多使用公共对象，多利用缓存机制。（将容器定义到函数外，用到容器的时候进行修改即可）</li><li>减少new对象的次数</li><li>对于<u>大量字符串拼接</u>时，将StringBuilder代替String。（string不可修改性，修改即创建一个新的string对象，旧的直接抛弃等待GC，但少量字符串拼接用string，性能优于stringbuilder）</li><li>使用扩容的容器时，例如：List，StringBuilder等，定义时尽量根据存储变量的内存大小定义储存空间，<u>减少扩容的操作</u>。（扩容后，旧的容器直接抛弃等待GC）</li><li><u>代码逻辑优化</u>：例如计时器当大于1s后才进行文本修改，而不是每帧都修改，或者禁止在关键时候GC，影响游戏性能，可以在加载页面或者进度条的时候GC</li><li><u>利用对象池</u>：对象池是一种Unity经常用到的内存管理服务，<strong>针对经常消失生成的对象</strong>，例如子弹，怪物等，作用在于<strong>减少创建每个对象的系统开销</strong>。在我们想要对象消除时，不直接Destory，而是隐藏起来SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。</li><li><u>减少装箱拆箱操作</u>。<ul><li>装箱拆箱介绍：将值类型转换为 object 类型 或由此值类型实现的任何接口类型的过程</li><li>装箱的底层操作：去堆内存<strong>new一个Object类对象</strong>——把值类型的<strong>数据存入</strong>到堆中的Object对象中——将堆上创建的对象的<strong>地址返回</strong>给引用类型变量；拆箱是从 object 类型到值类型或从接口类型 到实现该接口的值类型的显式转换</li><li>拆箱的底层操作：获取已装箱的对象的地址检查对象实例，以<strong>确保</strong>它是给定值类型的装箱值——将该值从实例<strong>复制</strong>到值类型变量中</li><li>产生GC的原因：</li><li>在Unity的装箱操作中，对于值类型会在堆内存上分配一个System.Object类型的引用来封装该值类型变量，其<strong>对应的缓存就会产生内存垃圾</strong>。装箱操作是<u>非常普遍的一种产生内存垃圾的行为</u>，即使代码中没有直接的对变量进行装箱操作，在插件或者其他的函数中也有可能会产生。最好的解决办法是尽可能的避免或者移除造成装箱操作的代码。</li><li>泛型介绍：处理多个代码对不同的数据类型执行相同指令的操作。也可以理解为：多个类型共享一组代码。<ul><li>泛型类不是实际的类，而是类的模板。</li><li>泛型不会进行装箱拆箱，所以性能很高，且规定了变量类型的限制，编译器可以在一定程度上验证类 型的假设，提高了程序类型的安全性，因此在使用容器时多使用 带有泛型的容器例如（ArrayList与List<int>)。</int></li></ul></li></ul></li><li>协程：yeild return 0 会产生装箱拆箱，可以替换为 yeild return null；</li><li>减少不必要的Log；</li></ul><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><ul><li><p>public:对任何类和成员都公开，无限制访问</p></li><li><p>private:仅对该类公开</p></li><li><p>protected:对该类和其派生类公开</p></li><li><p>internal:只能在包含该类的程序集中访问该类</p><p> protected internal: protected + internal</p></li></ul><h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><p>关键字sealed，类声明时<u>可防止其他类继承此类</u>，在方法中声明则可防止派生类重写此方法。与override一起使用。</p><p><img src="https://img-blog.csdnimg.cn/d60d565c7fcc4877aa67f54c4a54e52d.png" alt="img"></p><p><a href="https://blog.csdn.net/qq_40323256/article/details/86771078?ops_request_misc=&request_id=&biz_id=102&utm_term=sealed%E7%9A%84%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86771078.142%5Ev42%5Enew_blog_pos_by_title,185%5Ev2%5Econtrol&spm=1018.2226.3001.4187">(42条消息) C#中sealed的用法_疆~的博客-CSDN博客_c# sealed</a></p><h1 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h1><h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><ul><li>类型：结构体是值类型，类是引用类型。</li><li>存储：结构体存在栈中，类存在堆中。</li><li>值传递：结构体变量和类对象进行类型传递时，结构体变量进行的就是值传递，而类对象进行的是引用传递，或者说传递的是指针，这样在函数中改变参数值，结构体对象的值是不变的，而类对象的值是变化了。</li><li>成员变量初始化：在C#中<strong>结构体类型定义</strong>时，成员是不能初始化的，这样就导致了，定义结构体变量时，<u>变量的所有成员都要自己赋值初始化</u>。但对于类，在<strong>定义类时</strong>，就可以初始化<u>其中的成员变量</u>，所以在定义对象时，对象本身就已经有了初始值，你可以自己在重新给个别变量赋值。(注意在C++中，类的定义中是不能初始化的，初始化要放在构造函数中)</li><li>构造函数和析构函数<ul><li>结构体不能申明无参的构造函数，而类可以。</li><li>结构体需要在构造函数中初始化<u>所有成员变量</u>，而类随意。</li><li>声明了结构类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。</li><li>结构体申明有参构造函数后，无参构造不会被顶掉。</li><li>结构体不能申明析构函数，而类可以。</li></ul></li><li>继承：结构体不能被继承，而类可以。</li><li>静态：结构体不能被静态static修饰(不存在静态结构体)，而类可以。</li></ul><blockquote><p>对于C++来说，类和结构体的唯一区别只是：类的成员默认为private，结构体成员默认为public；因为为了兼容C，所以保留了结构体。在C里面结构体不能有成员函数。C++中类和结构体都可互换使用。</p></blockquote><h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><ul><li><p>结构体</p><ul><li>结构是值类型在栈中，栈的存取速度比堆快，但是容量小，<u>适合轻量级的对象</u>，比如点、矩形、颜色。</li><li>如果对象是<u>数据集合</u>时，优先考虑接结构体（位置，坐标）；</li><li>在<u>变量传值</u>的时候，希望传递对象的是拷贝，而不是对象的引用地址，这个时候就可以使用结构体。</li><li>结构使用简单,并且很有用,但是要牢记:结构在堆栈中创建，是值类型，而类是引用类型。每当需要一种经常使用的类型，而且大多数情况下该类型只是一些数据时，使用结构能比使用类获得更佳性能。</li></ul></li><li><p>类</p><ul><li>类是引用类型，存储在堆中，堆的容量大，适合重量级的对象，栈的空间不大，大量的对应当存在于堆中。</li><li>如果对象需要继承和多态特征，用类（玩家、怪物）</li></ul></li></ul><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><h2 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h2><ul><li>实例化：接口不是类（无构造函数和析构函数），<strong>不能被实例化</strong>，抽象类可以<strong>间接实例化</strong>（可以被继承，有构造函数，可以实例化子类的同时间接实例化抽象类这个父类）。</li><li>方法申明和实现：接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。</li><li>抽象的范围：抽象类中可以有实现成员，接口只能包含抽象成员。因此接口是完全抽象，抽象类是部分抽象。</li><li>继承和实现<ul><li>抽象类要被子类继承，接口要被类实现；</li><li>接口可以实现多继承，抽象类只能实现单继承，一个类只能继承一个类但可以实现多个接口；</li><li>抽象方法要被实现，所以不能是静态的，也不能是私有的。</li></ul></li><li>成员修饰符：抽象类中所有的成员修饰符都能使用，接口中的成员都是对外的，所以不需要修饰符修饰。</li></ul><ul><li>按照个人理解来说，接口更注重方法的设计，以供其他类扩展，而抽象类就是一个抽象的模板，让子类都按照这个来做。</li></ul><h2 id="使用环境-1"><a href="#使用环境-1" class="headerlink" title="使用环境"></a>使用环境</h2><ul><li><p>使用抽象类是为了<strong>代码的复用</strong>，而使用接口的动机是为了<strong>实现多态性</strong>。</p></li><li><p>抽象类适合用来定义某个领域的<strong>固有属性</strong>，也就是本质，接口适合用来定义某个领域的<strong>扩展功能</strong>。</p></li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>当2个或多个类中有重复部分的时候，我们可以抽象出来一个基类，如果希望这个基类<strong>不能被实例化</strong>，就可以把这个基类设计成抽象类。</li><li>当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>当注重代码的扩展性跟可维护性时，应当优先采用接口。</p><ul><li><p>接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用<strong>更加方便灵活</strong>；</p></li><li><p>接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p></li></ul><h1 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h1><p>静态构造函数用于初始化任何<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static">静态</a>数据(动态初始化)，或执行仅需执行一次的特定操作。</p><p>将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数。 </p><p>静态构造函数最多调用一次。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SimpleClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Static variable that must be initialized at run time.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">long</span> baseline;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Static constructor is called at most one time, before any</span></span><br><span class="line">    <span class="comment">// instance constructor is invoked or member is accessed.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">SimpleClass</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        baseline = DateTime.Now.Ticks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态构造函数既没有访问修饰符，也没有参数。</li><li>在创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类。</li><li>一个类只能有一个静态构造函数。</li><li>无参数的构造函数可以与静态构造函数共存。</li><li>最多只运行一次。</li><li>静态构造函数不可以被继承。</li><li>如果没有写静态构造函数，而类中包含带有初始值设定的静态成员，那么编译器会<u>自动生成默认的静态构造函数</u>。</li><li>如果静态构造函数引发异常，运行时将不会再次调用该构造函数，并且在程序运行所在的应用程序域的生存期内，类型将保持未初始化。</li></ul><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>引用传递可以理解为就是对象本身传递，而非一个<strong>副本或者地址</strong>，一般使用 in、out、ref 关键字声明参数是引用传递。</p><table><thead><tr><th align="center"></th><th align="center">in</th><th align="center">out</th><th align="center">ref</th></tr></thead><tbody><tr><td align="center">传递类型</td><td align="center">引用传递</td><td align="center">引用传递</td><td align="center">引用传递</td></tr><tr><td align="center">含义</td><td align="center">引用传进（只读</td><td align="center">引用传出（必写</td><td align="center">可读可写</td></tr><tr><td align="center">需要提前初始化</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td align="center">调用/传参关键字是否可以省</td><td align="center">Y/N</td><td align="center">N/N</td><td align="center">N/N</td></tr></tbody></table><p><a href="https://www.cnblogs.com/shanfeng1000/p/15043795.html">C#中的值传递与引用传递（in、out、ref） - 没有星星的夏季 - 博客园 (cnblogs.com)</a>（具体可查看里面的例子）</p><h2 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h2><p>ref关键字表示变量是引用，或是另一个对象的别名。有五种使用的情况：</p><p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference">ref 关键字 - C# 参考 | Microsoft Learn</a></p><h3 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h3><p>在<u>方法签名</u>和<u>方法调用</u>中，按引用将参数传递给方法。</p><ul><li><p>方法签名：在方法的参数列表中使用 <code>ref</code> 关键字时，它指示参数按引用传递，而非按值传递。 <code>ref</code> 关键字让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。</p></li><li><p>方法定义和调用方法：若要使用 <code>ref</code> 参数，方法定义和调用方法均必须显式使用 <code>ref</code> 关键字，如下面的示例所示。 （除了在进行 COM 调用时，调用方法可忽略 <code>ref</code>。）</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按引用传递【值类型】*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> refArgument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    refArgument = refArgument + <span class="number">44</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> number = <span class="number">1</span>;</span><br><span class="line">Method(<span class="keyword">ref</span> number);</span><br><span class="line">Console.WriteLine(number);</span><br><span class="line"><span class="comment">// Output: 45</span></span><br></pre></td></tr></table></figure><blockquote><p> 传递到 <code>ref</code> 或 <code>in</code> 形参的实参必须先经过初始化，然后才能传递；</p></blockquote><ul><li>重载方法能生效的情况</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CS0663_Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compiler error CS0663: &quot;Cannot define overloaded</span></span><br><span class="line">    <span class="comment">// methods that differ only on ref and out&quot;.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">RefOverloadExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;<span class="comment">//要有值传递与之区别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按引用传递【值类型】或【引用类型】<ul><li><a href="https://blog.csdn.net/liudongdong19/article/details/83758830">(42条消息) c#引用（&amp;）的用法和应用实例_路途…的博客-CSDN博客_c# 引用</a>【有详细图解】</li><li>不要混淆通过引用传递的概念与引用类型的概念。 这两种概念是不同的。 无论方法参数是值类型还是引用类型，均可由 <code>ref</code> 修改。 当通过引用传递时，不会对值类型装箱。</li><li>总结<ul><li>如果传递的参数是基元类型（int，float等）或结构体（struct），那么就是传值调用。</li><li>如果传递的参数前有ref或者out关键字，那么就是传引用调用。</li><li>如果传递的参数是类（class）并且没有ref或out关键字：<ul><li>如果调用的函数中对参数重新进行了地址分配(new操作)，那么执行结果类似传值调用；</li><li>如果调用的函数中没有对参数重新进行了地址分配，直接就是使用了传递的参数，那么执行结果类似传引用调用。</li></ul></li></ul></li></ul></li></ul><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>C#在有限的范围内支持指针；</p><p>指针只能指向非托管类型，包括所有基本数据类型、<a href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">枚举类型</a>、其他指针类型和只包含非托管类型的结构。</p><ul><li>能否为空：引用不能为空，即不存在对空对象的引用，指针可以为空，指向空对象。</li><li>初始化：引用必须初始化，指定对哪个对象的引用，指针不需要。</li><li>值更改：引用初始化后不能改变，指针可以改变所指对象的值。（？</li><li>引用访问对象是直接访问，指针访问对象是间接访问。</li><li>引用的大小是所引用对象的大小，指针的大小，是指针本身大小，通常是4字节。</li><li>引用没有const，指针有const。</li><li>引用和指针的+自增运算符意义不同。</li><li>引用不需要分配内存空间，指针需要。</li></ul><h1 id="不安全代码和非托管代码"><a href="#不安全代码和非托管代码" class="headerlink" title="不安全代码和非托管代码"></a>不安全代码和非托管代码</h1><p><a href="https://blog.csdn.net/sibaison/article/details/72675257">(42条消息) C#的三大难点之二：托管与非托管_游子2022的博客-CSDN博客_c#托管</a></p><h2 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h2><p>​    源代码首先经过预处理器，对头文件以及宏进行解析，然后经过编译器，生成汇编代码，接着，经过汇编，生成机器指令，最后将所有文件连接起来。</p><p>​    这种编译方式的优点在于，最终<strong>直接生成了机器码</strong>，可以直接被计算机识别和运行，<strong>无需任何中间运行环境</strong>，但缺点也在于，由于不同平台能够识别的机器码不同，因此程序的跨平台能力较差。</p><h2 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h2><p>​    而在Java语言中，源代码并没有被直接翻译成机器码，而是编译成了一种<strong>中间代码</strong>（字节码Bytecode）。因此，运行Java程序需要一个额外的JRE（Java Runtime Enviromental）运行环境，在JRE中存在着JVM（Java Virtual Mechinal，Java虚拟机），在程序运行的时候，会将中间代码进一步<strong>解释</strong>为机器码，并在机器上运行。</p><p>​    使用中间代码的好处在于，程序的跨平台性比较好，一次编译，可以在不同的设备上运行。</p><p>​    <strong>托管/非托管</strong>是微软的.net framework中特有的概念，其中，非托管代码也叫本地（native）代码。托管代码与Java中的机制类似，也是先将源代码编译成中间代码（MSIL，Microsoft Intermediate Language），然后再由.net中的<code>CLR</code>将中间代码<strong>编译</strong>成机器代码。</p><p>​    而C#与Java的区别在于，Java是先编译后解释，C#是两次编译。<br>​    托管的方式除了拥有跨平台的优点之外，对程序的性能也产生一定的影响。</p><h2 id="托管与非托管资源"><a href="#托管与非托管资源" class="headerlink" title="托管与非托管资源"></a>托管与非托管资源</h2><p>在C/C++中，资源都是需要手动释放的，比如，你new了一个指针，用过之后就需要delete掉，否则就会造成内存泄露。</p><p>而在Java中，不必考虑资源释放的问题，Java的垃圾回收机制（GC，Garbage Collection）会保证失效的资源被自动释放。</p><p>而C#的机制与Java类似，运行于.net平台上的代码，分配的资源一般会<strong>自动由平台的垃圾回收器释放</strong>，这样的资源就是<strong>托管资源</strong>。</p><p>但是一些例外的资源，如System.IO.StreamReader等各种流、各种连接所分配的资源，需要显式调用Close()或Dispose()释放，这种资源就叫做<strong>非托管资源</strong>。</p><h2 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h2><p>不安全代码可以被认为是介于托管代码和非托管代码之间的。不安全代码<strong>仍然在公共语言运行时(CLR)控制下运行</strong>，但它将允许您直接<strong>通过指针访问内存</strong>。</p><h1 id="第14章-委托"><a href="#第14章-委托" class="headerlink" title="第14章 委托"></a>第14章 委托</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>可以把delegate看作一个包含有序方法列表的对象，这些方法具有相同的签名和返回类型。</p><ul><li>方法的列表叫做调用列表；</li><li>委托持有的方法可以来自任何类或结构，只要他们的【委托的返回类型】&amp;【委托的签名（包括ref和out修饰符）】相同；</li><li>调用列表中的方法可以是实例方法也可以是静态方法；</li><li>调用委托会调用列表中的所有方法。</li></ul><h3 id="声明委托类型"><a href="#声明委托类型" class="headerlink" title="声明委托类型"></a>声明委托类型</h3><p>看上去和方法的声明很类似，有返回类型和签名（没有方法主体）；指定了委托接受方法的形式。</p><p>不需要在类内部声明，因为它是类型声明。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="创建委托对象"><a href="#创建委托对象" class="headerlink" title="创建委托对象"></a>创建委托对象</h3><ul><li>new 运算符</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyDel mydel = <span class="keyword">new</span> MyDel(<span class="comment">/*实例方法*/</span>myInsObj.MyM1);</span><br><span class="line">MyDel dVar = <span class="keyword">new</span> dVar(<span class="comment">/*静态方法*/</span>SClass.OtherM2);</span><br></pre></td></tr></table></figure><ul><li>=（存在隐式转换）</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyDel mydel = myInsObj.MyM1;</span><br><span class="line">MyDel dVar = SClass.OtherM2;</span><br></pre></td></tr></table></figure><h3 id="给委托赋值"><a href="#给委托赋值" class="headerlink" title="给委托赋值"></a>给委托赋值</h3><p>委托是引用类型，给它赋值可改变包含在委托变量中的引用；旧的委托对象会被垃圾回收器回收。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel mydel;</span><br><span class="line">mydel = myInsObj.MyM1;<span class="comment">//被回收</span></span><br><span class="line">mydel = SClass.OtherM2;</span><br></pre></td></tr></table></figure><h3 id="组合委托"><a href="#组合委托" class="headerlink" title="组合委托"></a>组合委托</h3><p>用运算符组合；</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel delA = myInsObj.MyM1;</span><br><span class="line">MyDel delB = SClass.OtherM2;</span><br><span class="line">MyDel delC = delA + delB;</span><br></pre></td></tr></table></figure><p>运算最终会创建一个新的委托，其调用列表连接了两个委托的列表副本。委托对象被创建后就不能被改变。</p><p><img src="https://img-blog.csdnimg.cn/ed1d971fa2964e71a31baaef50d8c0be.png" alt="img"></p><h3 id="为委托添加-移除方法"><a href="#为委托添加-移除方法" class="headerlink" title="为委托添加/移除方法"></a>为委托添加/移除方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel delVar = inst.MyM1;</span><br><span class="line">delVar += SCl.m3;</span><br><span class="line">delVar += SCl.m4;</span><br></pre></td></tr></table></figure><p>委托其实是不变的，实际上是创建了新的委托，然后将新的委托赋值给delVar。</p><p><img src="https://img-blog.csdnimg.cn/24f5b881a8a846a3ab4e29a54b36059f.png" alt="img"></p><p>删除委托的一些注意事项：</p><ul><li>-=运算符从列表末尾开始搜索，并移除第一个匹配的实例；</li></ul><h3 id="调用委托"><a href="#调用委托" class="headerlink" title="调用委托"></a>调用委托</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像方法一样调用</span></span><br><span class="line"><span class="keyword">if</span>(delVar != <span class="literal">null</span>) delVar(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用委托的Invoke方法</span></span><br><span class="line">delVar?.Invoke();</span><br></pre></td></tr></table></figure><h3 id="调用带有返回值的委托"><a href="#调用带有返回值的委托" class="headerlink" title="调用带有返回值的委托"></a>调用带有返回值的委托</h3><p><img src="https://img-blog.csdnimg.cn/534f66710017454b9ccaee3fa6abcedb.png" alt="img"></p><h3 id="调用带有引用参数的委托"><a href="#调用带有引用参数的委托" class="headerlink" title="调用带有引用参数的委托"></a>调用带有引用参数的委托</h3><p><img src="https://img-blog.csdnimg.cn/f00ffde37101478382d8c663237d572a.png" alt="img"></p><h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line"></span><br><span class="line">MyDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (<span class="comment">/*参数列表*/</span>) &#123;<span class="comment">/*语句块*/</span>&#125;</span><br></pre></td></tr></table></figure><ul><li><p> 不会显式地声明返回值；</p></li><li><p>匿名方法可以访问外围作用域的局部变量和环境（方法捕获）；</p></li><li><p>捕获变量的生命周期的扩展：</p><p><img src="https://img-blog.csdnimg.cn/36a253bcbd734b38963d6196bf8ffec7.png" alt="img"></p></li></ul><h2 id="通过委托执行方法"><a href="#通过委托执行方法" class="headerlink" title="通过委托执行方法"></a>通过委托执行方法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">DelegateExample</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DoDelegate</span>(<span class="params"><span class="built_in">string</span> valueStr</span>)</span>;<span class="comment">//委托声明</span></span><br><span class="line">     <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">DoFunction</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//声明一个委托变量，并把已知方法作为构造函数的参数</span></span><br><span class="line">         DoDelegate doDelegate = <span class="keyword">new</span> DoDelegate(Test);</span><br><span class="line">         <span class="comment">//通过委托的静态方法Invoke触发委托</span></span><br><span class="line">         doDelegate?.Invoke(<span class="string">&quot;传入委托的值！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">string</span> valueStr</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.Write(<span class="string">$&quot;valueStr=<span class="subst">&#123;valueStr&#125;</span>&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">DelegateExample delegateExample = <span class="keyword">new</span> DelegateExample();</span><br><span class="line">delegateExample.DoFunction();</span><br></pre></td></tr></table></figure><blockquote><ul><li>在CLR运行时，DoDelegate实际上是一个类，该类的构造函数有一个<u>参数类型</u>，这个参数类型就是Test方法；并且提供了一个<u>实例Invoke方法</u>，用来触发委托执行；</li><li>委托DoDelegate定义了方法的参数和返回值类型；</li><li>通过委托DoDelegate的构造函数，可以将符合的方法赋值给委托；</li><li>调用委托的实例方法Invoke执行方法。</li></ul></blockquote><h2 id="委托执行方法的另外一种方式：委托变量（参数列表）"><a href="#委托执行方法的另外一种方式：委托变量（参数列表）" class="headerlink" title="委托执行方法的另外一种方式：委托变量（参数列表）"></a><strong>委托执行方法的另外一种方式：委托变量（参数列表）</strong></h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DelegateExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DoDelegate</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">DoFunction</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个委托变量，并将已知方法作为构造函数的参数</span></span><br><span class="line">        DoDelegate doDelegate = <span class="keyword">new</span> DoDelegate(Test);</span><br><span class="line">        <span class="built_in">object</span> sender = <span class="number">888</span>;</span><br><span class="line">        EventArgs e = <span class="keyword">new</span> EventArgs();</span><br><span class="line">        doDelegate(sender, e);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">$&quot;valueStr=<span class="subst">&#123;sender&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>委托DoDelegate中的参数object sender通常表示动作的发起者，EventArgs e表示动作所带的参数。</p><p>实际上，事件就是采用委托变量（参数列表）形式执行方法。</p></blockquote><h2 id="委托和接口的区别"><a href="#委托和接口的区别" class="headerlink" title="委托和接口的区别"></a>委托和接口的区别</h2><p>接口是约束类应该具备功能的集合，约束了类应该具备哪些功能，使类从复杂的逻辑中解脱出来，方便类的管理和拓展，同时解决类的单继承问题。</p><p>接口：无法继承的场所；完全抽象的场所；多人协作的场所；</p><p>委托：多用于事件的处理。只是方法集合的管理</p><h2 id="委托和事件的区别"><a href="#委托和事件的区别" class="headerlink" title="委托和事件的区别"></a>委托和事件的区别</h2><p>通过事件注册、取消多个<u>委托</u>和<u>方法</u>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DelegateExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DoDelegate</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> DoDelegate DoEvent;<span class="comment">//类型是DoDelegate</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">DoFunction</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DoDelegate doDelegate = <span class="keyword">new</span> DoDelegate(Test);</span><br><span class="line">        <span class="built_in">object</span> sender = <span class="number">888</span>;</span><br><span class="line">        EventArgs e = <span class="keyword">new</span> EventArgs();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//事件添加委托</span></span><br><span class="line">        DoEvent += <span class="keyword">new</span> DoDelegate(doDelegate);</span><br><span class="line">        DoEvent(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">$&quot;valueStr=<span class="subst">&#123;sender&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件可以看做成委托中的一个变量。</p><p>事件是基于委托的存在，事件是委托的安全包裹 让委托的使用更具有安全性。</p><ol><li>委托可以用“=”来赋值，事件不可以。</li><li>委托是一个类型，事件是类或结构的成员。</li><li>委托可以在声明它的类外部进行调用，而事件只能在类的内部进行调用。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>委托是一个类，可以实例化，通过委托的构造函数把方法赋值给委托实例；</li><li>触发委托有两种方式：委托实例.Invoke(参数列表)和委托实例（参数列表）；</li><li>事件可看作是一个委托类型的变量；</li><li>+=为事件注册多个委托实例或多个方法；</li><li>-=为事件减少多个委托实例或多个方法；</li></ul><h2 id="委托原理"><a href="#委托原理" class="headerlink" title="委托原理"></a>委托原理</h2><h2 id="和Delegate的区别"><a href="#和Delegate的区别" class="headerlink" title="和Delegate的区别"></a>和Delegate的区别</h2><p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/delegate-class">System.Delegate 和“delegate”关键字 | Microsoft Learn</a></p><p>[<a href="https://blog.csdn.net/alexander_xfl/article/details/45695657">C#-2] delegate和Delegate的区别_石圣的博客-CSDN博客</a></p><p>简单的来说就是：Delegate是个类，基类，抽象类。delegate是一个关键字</p><p>更深入一点则可以这样理解：</p><p>Delegate 类是委托类型的基类。 然而，只有系统和编译器可以显式地从 Delegate 类或 <a href="https://msdn.microsoft.com/zh-cn/library/system.multicastdelegate(v=vs.110).aspx">MulticastDelegate</a> 类派生。 此外，还不允许从委托类型派生新类型。 Delegate 类不是委托类型，该类<strong>用于派生委托类型</strong>。</p><p>大多数语言实现 <strong>delegate</strong> 关键字，这些语言的编译器能够从 <a href="https://msdn.microsoft.com/zh-cn/library/system.multicastdelegate(v=vs.110).aspx">MulticastDelegate</a> 类进行派生；所以，用户应当使用语言所提供的 <strong>delegate</strong> 关键字。</p><h1 id="C-中基本类型占用的字节数"><a href="#C-中基本类型占用的字节数" class="headerlink" title="C#中基本类型占用的字节数"></a>C#中基本类型占用的字节数</h1><table><thead><tr><th>类型</th><th>字节数</th></tr></thead><tbody><tr><td>bool -&gt; System.Boolean</td><td>布尔型，其值为 true 或者 false</td></tr><tr><td>byte -&gt; System.Byte</td><td>字节型，占 1 字节，表示 8 位正整数，范围 0 ~ 255</td></tr><tr><td>sbyte -&gt; System.SByte</td><td>带符号字节型，占 1 字节，表示 8 位整数，范围 -128 ~ 127</td></tr><tr><td>char -&gt; System.Char</td><td>字符型，占有两个字节，表示 1 个 Unicode 字符</td></tr><tr><td>short -&gt; System.Int16</td><td>短整型，占 2 字节，表示 16 位整数，范围 -32,768 ~ 32,767</td></tr><tr><td>ushort -&gt; System.UInt16</td><td>无符号短整型，占 2 字节，表示 16 位正整数，范围 0 ~ 65,535</td></tr><tr><td>uint -&gt; System.UInt32</td><td>无符号整型，占 4 字节，表示 32 位正整数，范围 0 ~ 4,294,967,295</td></tr><tr><td>int -&gt; System.Int32</td><td>整型，占 4 字节，表示 32 位整数，范围 -2,147,483,648 到 2,147,483,647</td></tr><tr><td>float -&gt; System.Single</td><td>单精度浮点型，占 4 个字节</td></tr><tr><td>ulong -&gt; System.UInt64</td><td>无符号长整型，占 8 字节，表示 64 位正整数，范围 0 ~ 大约 10 的 20 次方</td></tr><tr><td>long -&gt; System.Int64</td><td>长整型，占 8 字节，表示 64 位整数，范围大约 -(10 的 19) 次方 到 10 的 19 次方</td></tr><tr><td>double -&gt; System.Double</td><td>双精度浮点型，占8 个字节</td></tr></tbody></table><h1 id="协变与逆变"><a href="#协变与逆变" class="headerlink" title="协变与逆变??"></a>协变与逆变??</h1><h2 id="协变-out"><a href="#协变-out" class="headerlink" title="协变(out)"></a>协变(out)</h2><p>和谐、自然的变化。里式替换原则中，父类容器可以装载子类对象，子类可以转换成父类。比如string转object，感受是和谐的。</p><h2 id="逆变-in"><a href="#逆变-in" class="headerlink" title="逆变(in)"></a>逆变(in)</h2><p>逆常规、不正常的变化。里式替换原则中，父类容器可以装载子类对象，但是子类对象不能装载父类。所以父类转换为子类，比如object转string，感受是不和谐的。</p><p>协变和逆变是用来修饰泛型的，用于泛型中修饰字母，只有泛型接口和泛型委托能使用.</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.返回值与参数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用out修饰的泛型，只能作为返回值</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">Testout</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用in修饰的泛型，只能作为参数</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="反射-大概需要从书本慢慢看起，先了解前面的概念"><a href="#反射-大概需要从书本慢慢看起，先了解前面的概念" class="headerlink" title="反射(大概需要从书本慢慢看起，先了解前面的概念)"></a>反射(大概需要从书本慢慢看起，先了解前面的概念)</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>反射指程序可以访问、 检测和修改它本身状态或行为的一种能力。</p><p>程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。</p><p>可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>优点：<ul><li>反射提高了程序的灵活性和扩展性；</li><li>降低耦合性，提高自适应能力；</li><li>它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li></ul></li><li>缺点：<ul><li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要<strong>远慢于直接代码</strong>。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li><li>使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码<strong>比相应的直接代码更复杂</strong>。</li></ul></li></ul><h2 id="用途（？"><a href="#用途（？" class="headerlink" title="用途（？"></a>用途（？</h2><ul><li>它允许在运行时查看特性（attribute）信息。</li><li>它允许审查集合中的各种类型，以及实例化这些类型。</li><li>它允许延迟绑定的方法和属性（property）。</li><li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li></ul><h2 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h2><p>使用反射（Reflection）可以查看特性（attribute）信息。</p><p><strong>System.Reflection</strong> 类的 <strong>MemberInfo</strong> 对象需要被初始化，用于发现与类相关的特性（attribute）。为了做到这点，您可以定义目标类的一个对象，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Reflection.MemberInfo info = <span class="keyword">typeof</span>(MyClass);</span><br></pre></td></tr></table></figure><h1 id="第19章-枚举器和迭代器"><a href="#第19章-枚举器和迭代器" class="headerlink" title="第19章 枚举器和迭代器"></a>第19章 枚举器和迭代器</h1><h2 id="枚举器和可枚举类型"><a href="#枚举器和可枚举类型" class="headerlink" title="枚举器和可枚举类型"></a>枚举器和可枚举类型</h2><p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623171428364.png" alt="image-20230623171428364"></p><ul><li>①可枚举类型：带有<code>GetEnumerator</code>方法的类，返回用于项的枚举器。</li><li>②枚举器：<code>GetEnumerator</code>方法返回的实例。③可以依次返回（可枚举类型对象的）集合中项的类对象。</li></ul><p>foreach结构的本质就是：</p><ul><li>调用<code>GetEnumerator</code>方法获取对象的枚举器；</li><li>从枚举器中请求每一项并且把它作为迭代变量，代码可以读取但不可改变该变量。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (Type VarName <span class="keyword">in</span> EnumerableObject)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IEnumerator接口"><a href="#IEnumerator接口" class="headerlink" title="IEnumerator接口"></a>IEnumerator接口</h2><p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623172405819.png" alt="image-20230623172405819"></p><blockquote><p>枚举器的内容：</p><ul><li>当前项的位置；</li><li>Current：返回序列中当前位置项的（只读）<strong>属性</strong>；返回<u>object类型的引用</u>，所以可以返回任何类型的对象。</li><li>MoveNext()：把枚举器位置前进一位的方法。返回布尔值，反映新的位置是否有效。</li><li>Reset()：把位置重置为原始状态的方法。</li></ul></blockquote><p>模仿foreach循环遍历：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">IEnumerator ie = arr.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span>(ie.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> item = (<span class="built_in">int</span>) ie.Current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IEnumerable接口"><a href="#IEnumerable接口" class="headerlink" title="IEnumerable接口"></a>IEnumerable接口</h2><p> 可枚举类是指实现了IEnumerable接口的类。IEnumerable接口只有一个成员——GetEnumerator方法，返回对象的枚举器。</p><ul><li>使用IEnumerable和IEnumerator实例：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ColorEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] colors;</span><br><span class="line">    <span class="built_in">int</span>  position = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//...分别实现三个方法，详情见书P359</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] colors = &#123;...&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator(colors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach迭代</span></span><br><span class="line">Spectrum spectrum = <span class="keyword">new</span> Spectrum();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> color <span class="keyword">in</span> spectrum)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h2><p>最重要区别是非泛型接口的实现不是类型安全的。Current返回的是Object，必须转化为实际类型。</p><p>而泛型接口的枚举器是类型安全的，返回实际类型的引用。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>C#2.0版本提供的更简单的 创建枚举器和可枚举类型的 方式，可以把手动编码的可枚举类型和枚举器替换为由迭代器生成的可<del>和枚举</del>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br></pre></td></tr></table></figure><p>【<strong>迭代器块</strong>】</p><p>迭代器块是有一个或多个yield语句的代码块。</p><p>有两个特殊语句：</p><ul><li>yield return 语句指定了序列中要返回的下一项。</li><li>yield break 语句指定了在序列中没有其它项。</li></ul><p><u>编译器</u>得到有关如何<u>枚举项的描述</u>后，使用它来构建 包含所有需要的方法和属性实现的 <u>枚举器类</u>。</p><p>【<strong>使用迭代器来创建枚举器</strong>】</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用的是迭代器的方法，返回枚举器</span></span><br><span class="line">        <span class="comment">// 编译器根据迭代器自动创建了一个枚举器类</span></span><br><span class="line">        <span class="keyword">return</span> BlackAndWhite();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>(<span class="params"></span>)<span class="comment">// 迭代器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foreach</span></span><br><span class="line">MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【使用迭代器来创建可枚举类型】</strong></p><p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623183650444.png" alt="image-20230623183650444"></p><p>左边：迭代器返回类型是IEnumerable<string>;</string></p><p>右边：编译器生成的类有一个嵌套类实现了IEnumerable<string>和IEnumerator<string>。</string></string></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的实例，因为实现了GetEnumerator方法。这个方法获取了嵌套类的GetEnumerator...</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接获取嵌套类（迭代器返回的可枚举类型）</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> shade <span class="keyword">in</span> mc.BlackAndWhite())</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有点绕啊…</p><h2 id="常见迭代器模式"><a href="#常见迭代器模式" class="headerlink" title="常见迭代器模式"></a>常见迭代器模式</h2><ul><li>实现返回【枚举器】的迭代器：必须通过实现【GetEnumerator方法（不一定要实现接口）】让类可枚举，返回迭代器的枚举器。</li><li>实现返回【可枚举类型】的迭代器：<ul><li>让类实现GetEnumerator让类本身可枚举：通过方法获取嵌套类</li><li>不实现GetEnumerator让类不可枚举：直接由迭代器返回。</li></ul></li></ul><h2 id="产生多个可枚举类型"><a href="#产生多个可枚举类型" class="headerlink" title="产生多个可枚举类型"></a>产生多个可枚举类型</h2><p>让迭代器返回可枚举类型，直接使用嵌套类（书本P367）</p><h2 id="迭代器的实质"><a href="#迭代器的实质" class="headerlink" title="迭代器的实质"></a>迭代器的实质</h2><p>重要事项：</p><ul><li>编译器生成的枚举器中，不支持Reset方法。</li></ul><p>在后台，由编译器生成的枚举器类是包含4个状态的状态机。</p><p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623185456266.png" alt="image-20230623185456266"></p><h1 id="字典"><a href="#字典" class="headerlink" title="-字典"></a>-字典</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://www.cnblogs.com/InCerry/p/10325290.html">浅析C# Dictionary实现原理 - InCerry - 博客园 (cnblogs.com)</a>[更清晰]</p><p><a href="https://zhuanlan.zhihu.com/p/96633352">【C#】浅析C# Dictionary实现原理 - 知乎 (zhihu.com)</a></p><p>主要是拉链法。</p><p><img src="https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144436-391161641.png" alt="1548494357566"></p><h2 id="Hash桶算法"><a href="#Hash桶算法" class="headerlink" title="Hash桶算法"></a>Hash桶算法</h2><p>说到Hash算法大家就会想到<strong>Hash表</strong>，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。</p><p>因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个<strong>Bucket（桶）</strong>，一般常见的Hash桶就是直接对结果取余。</p><blockquote><p>假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用<strong>8</strong>个桶来映射，那么就可以通过<code>bucketIndex = HashFunc(key1) % 8</code>这样一个算法来确定这个hashCode映射到具体的哪个桶中。</p></blockquote><p>大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。</p>]]></content>
    
    
    <summary type="html">关于C#知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity的游戏框架搭建</title>
    <link href="https://huangxinhere.github.io/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    <id>https://huangxinhere.github.io/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/</id>
    <published>2023-01-05T16:00:00.000Z</published>
    <updated>2023-02-20T03:59:05.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li><p>树结构</p></li><li><p>对象之间的交互（低耦合）和模块化（高内聚）是整个框架搭建系列的终极问题</p><ul><li><p>对象交互三种方法</p><p>方法调用；</p><p>委托或者回调；</p><p>消息或事件。</p></li><li><p>模块化也有三种：</p><p>单例；</p><p>IOC；</p><p>分层，如MVC，三层架构，领域驱动分层等。</p></li></ul></li><li><p>表现和数据的分离</p></li><li><p>交互逻辑和表现逻辑</p></li></ul><h1 id="父子对象和跨模块初探"><a href="#父子对象和跨模块初探" class="headerlink" title="父子对象和跨模块初探"></a>父子对象和跨模块初探</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110170952423.png" alt="image-20230110170952423"></p><ul><li>目前有UI和Game两个模块，通信都是用事件。</li><li>Panel的父子对象则用委托通信。</li></ul><h1 id="表现和数据分离"><a href="#表现和数据分离" class="headerlink" title="表现和数据分离"></a>表现和数据分离</h1><h2 id="Event的抽象"><a href="#Event的抽象" class="headerlink" title="Event的抽象"></a>Event的抽象</h2><p>上面的GameStartEvent和GamePassEvent都是单独写的，但重复性很高，可以通过 泛型＋继承 来提取，继承解决扩展问题，泛型解决实现代码一致、类不一致的问题，是一个重构技巧。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Event</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action mOnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent += onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent -= onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameStartEvent</span> : <span class="title">Event</span>&lt;<span class="title">GameStartEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110172045530.png" alt="image-20230110172045530"></p><h2 id="数据分离"><a href="#数据分离" class="headerlink" title="数据分离"></a>数据分离</h2><p>使用GameModel来进行分离。静态变量。</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110172522022.png" alt="image-20230110172522022"></p><h2 id="属于Game而不是个体的总体逻辑判断"><a href="#属于Game而不是个体的总体逻辑判断" class="headerlink" title="属于Game而不是个体的总体逻辑判断"></a>属于Game而不是个体的总体逻辑判断</h2><ul><li>杀掉一个敌人，就通知Game来判断；用事件而不用委托，因为委托要有多个子对象的引用。</li></ul><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110173221574.png" alt="image-20230110173221574"></p><blockquote><p>简化了图示；单个Enemy交给Game来判断敌人总数。</p></blockquote><h1 id="交互逻辑和表现逻辑"><a href="#交互逻辑和表现逻辑" class="headerlink" title="交互逻辑和表现逻辑"></a>交互逻辑和表现逻辑</h1><p>交互逻辑：玩家操作界面使得数据发生变化；</p><p>表现逻辑：数据变化反馈到界面上。</p><h2 id="两者都在controller导致臃肿"><a href="#两者都在controller导致臃肿" class="headerlink" title="两者都在controller导致臃肿"></a>两者都在controller导致臃肿</h2><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110173618010.png" alt="image-20230110173618010"></p><h2 id="实现两者的分离"><a href="#实现两者的分离" class="headerlink" title="实现两者的分离"></a>实现两者的分离</h2><p>交互的逻辑并不关心数据变化的逻辑，反之亦是，所以要想办法把两者分开处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line"></span><br><span class="line">Btn.onClick.AddListener(&#123;</span><br><span class="line">    //使数据变化</span><br><span class="line">    Count++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//数据展示</span><br><span class="line">Text.text = Count.ToString();</span><br></pre></td></tr></table></figure><blockquote><p>数据（Count）变化的时候可以自动通知text更新，实现分开处理。</p></blockquote><ul><li>委托调用处理：交互逻辑持有表现逻辑的引用，通知其更新。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//数据类</span><br><span class="line">public static class CounterModel</span><br><span class="line">&#123;</span><br><span class="line">    private static int mCount = 1;</span><br><span class="line">    </span><br><span class="line">    public static Action&lt;int&gt; OnCountChanged;</span><br><span class="line">    </span><br><span class="line">    public static int Count</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; mCount;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            if(value != mCount)</span><br><span class="line">            &#123;</span><br><span class="line">                mCount = value;</span><br><span class="line">                OnCountChanged?.Invoke(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据一旦发生变动，通知View执行 OnCountChanged</span><br><span class="line">CounterModel.OnCountChanged += UpdateView;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110175208278.png" alt="image-20230110175208278"></p><ul><li>对数据类的进一步抽象。假如有很多共享数据比如金币、生命值等，如果每个数据都按照上面这么写就会很麻烦，所以抽象一个BindableProperty类。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BindableProperty</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IEquatable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T mValue = <span class="literal">default</span>(T);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Action&lt;T&gt; OnValueChanged;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T Value</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; mValue;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">value</span>.Equals(mValue))</span><br><span class="line">            &#123;</span><br><span class="line">                mValue = <span class="keyword">value</span>;</span><br><span class="line">                OnValueChanged?.Invoke(mValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CounterModel.Count.Value++;</span><br></pre></td></tr></table></figure><blockquote><p>CounterModel类里面本来是一个int类型Count的数据，但相当于扩展了Count的内容（类型）。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据一般是项目的底层，而Model和View也相当于一个底层和上层的关系，所以自底向上的逻辑可以用委托或者事件，自顶向下可以用方法调用。</p><h2 id="交互逻辑优化-引入Command"><a href="#交互逻辑优化-引入Command" class="headerlink" title="交互逻辑优化-引入Command"></a>交互逻辑优化-引入Command</h2><ul><li>交互逻辑有很多各种执行的逻辑（比如请求服务器、通知等），会导致Controller比较臃肿。</li><li>很多Unity框架的交互逻辑都是由Command实现的。</li><li>Command模式可以让逻辑的调用和执行在空间和时间上分离。<ul><li>空间分离：调用和执行实现地方不一样。</li><li>时间分离：执行比调用稍微慢一些。</li></ul></li><li>Command分担Controller的交互逻辑。</li><li>struct比class由更好的内存管理效率。</li><li>CQRS读写分离。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令执行逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CounterModel.Count.Value++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AbstractCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CounterModel.Count.Value--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用命令</span></span><br><span class="line"><span class="keyword">new</span> AddCountCommand().Execute();</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110232804574.png" alt="image-20230110232804574"></p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110233554506.png" alt="image-20230110233554506"></p><h2 id="表现层和底层的分离"><a href="#表现层和底层的分离" class="headerlink" title="表现层和底层的分离"></a>表现层和底层的分离</h2><ul><li>大致理解表现层就是View相关的，其他就是底层，分离也就是底层的逻辑可以直接应用到其他种View层上。</li><li>好处：<ul><li>一般交互逻辑和表现层没啥关系，所以如果将负责操作数据的交互逻辑剥离出来，可以提高底层系统代码的复用率。</li><li>一个Command可以理解成用户的一个操作，独立出来分类可以清晰地展现所有的功能/操作。</li><li>项目前期由于更多的是做数值和玩法上的验证，所以可以弄个粗略的视图，测试好后再换视图模型。</li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>表现层到底层系统层用Command</li><li>底层系统到表现层用委托或者事件</li><li>表现层是可以替换的————-</li></ul><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230109210658137.png" alt="image-20230109210658137"></p><h2 id="使用Command"><a href="#使用Command" class="headerlink" title="使用Command"></a>使用Command</h2><ul><li><strong>表现层只能往系统层发送Command或数据查询</strong>，并没有可以发送事件这一说，而且事件只能由底层系统层向表现层发送……（待论证。这样的话，如上图所示，开始菜单点击开始，则不能使用event，要用命令了。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> StartGameCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameStartEvent.Trigger();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前开始菜单的逻辑大概是：</span></span><br><span class="line">transform.Find(<span class="string">&quot;BtnStart&quot;</span>).GetComponent&lt;Button&gt;().OnClick.AddListener(</span><br><span class="line">    () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> StartGameCommand().Execute();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>消灭敌人数量统计的逻辑优化。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来是在Game（表现层）里实现</span></span><br><span class="line">...Class Game...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnemyKilled</span>(<span class="params"><span class="built_in">int</span> killedCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(killedCount == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> PassGameCommand().Execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将判断逻辑放到命令里面（底层）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> KillEnemyCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameModel.KillCount.Value++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(killedCount == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> PassGameCommand().Execute();</span><br><span class="line">            <span class="comment">//或直接 GamePassEvent.Trigger();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110131824399.png" alt="image-20230110131824399"></p><blockquote><ul><li>表现层-&gt;底层 用命令；</li><li>底层-&gt;表现层 用事件；</li><li>命令可以触发事件。</li></ul><p>命令和事件的区别？命令本质上是逻辑的执行，被包裹在对象的方法里面，通过对象去随时随地调用；事件是发送信号，通知其他地方执行。那么为什么表现层和底层要分开使用两者呢？？（待思考</p></blockquote><h1 id="模块化优化"><a href="#模块化优化" class="headerlink" title="模块化优化"></a>模块化优化</h1><p>表现层主要是根据语义来分模块，不做详解；重点是底层的模块。</p><h2 id="方式一：单例"><a href="#方式一：单例" class="headerlink" title="方式一：单例"></a>方式一：单例</h2><ul><li>静态类的问题：<ul><li>没有访问限制</li><li>使用static去扩展模块，模块的识别度不高</li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//反射</span></span><br><span class="line">                <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">                <span class="keyword">var</span> ctors = type.GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">                <span class="keyword">var</span> ctor = Array.Find(ctors, c =&gt; c.GetParameters().Length == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ctor == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Non public constructor not found in: &quot;</span> + type.Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mInstance = ctor.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> T;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameModel</span> : <span class="title">Singleton</span>&lt;<span class="title">GameModel</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GameModel</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; KillCount</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对单例的理解是，一个类有一个静态实例，而不是整个类都是静态的……究竟是如何体现出两者优劣呢？待深入理解。</p><ul><li>实现的单例的问题：单例类没有访问限制</li></ul><h2 id="方式二：引入IOC容器"><a href="#方式二：引入IOC容器" class="headerlink" title="方式二：引入IOC容器"></a>方式二：引入IOC容器</h2><p>相当于字典一样，键是类型，对应一个相应的实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IOCContainer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">Type</span>, <span class="title">object</span>&gt; mInstances</span> = <span class="keyword">new</span> Dictionary&lt;Type, <span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInstances.ContainsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            mInstances[key] = instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mInstances.Add(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInstances.TryGetValue(key, <span class="keyword">out</span> <span class="keyword">var</span> retInstance))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> retInstance <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if (mInstances.ContainsKey(key))</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                return mInstances[key] as T;</span></span><br><span class="line"><span class="comment">            &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IOC内部操作</p></blockquote><ul><li>应用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IOCContainer mContainer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论是增加还是获取都先检查IOC是否为空（类似单例）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureContainer</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mContainer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mContainer.Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureContainer();</span><br><span class="line">        <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似于一个IOC的单例。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> <span class="comment">//: Singleton&lt;CounterModel&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//private CounterModel()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span>   <span class="comment">//可以直接对字段初始化？？</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先数据类不再是单例，为了起单例作用都给了IOC来托管。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CounterModel mCounterModel;</span><br><span class="line">mCounterModel = Countapp.Get&lt;CounterModel&gt;();        </span><br><span class="line">mCounterModel.Count.OnValueChanged += OnCountChanged;</span><br></pre></td></tr></table></figure><blockquote><p>所以使用的时候，要从IOC容器获取，增加了访问的限制。</p></blockquote><h2 id="IOC的工具类Architecture"><a href="#IOC的工具类Architecture" class="headerlink" title="IOC的工具类Architecture"></a>IOC的工具类Architecture</h2><p>不同项目可能有好几个IOCContainer，代码重复率比较高，所以抽象出一个工具类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和之前不同的是，这个工具类有自己的静态实例，然后直接持有一个IOCContainer实例，所以获取IOC容器又多了一层单例；</p><p>那继承的子类如何根据需求来Init IOC呢？子类通过Register方法间接注册IOC容器。所以可见，虽然IOC容器是直接附属于工具类的单例的字段的，但提供了方法来使子类间接操作容器。写子类的时候只需要关注注册什么就行了，其他逻辑不需要展现，因此减轻了工作量。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>IOC容器比单例麻烦很多，而且每次从容器里面查询字典也造成更多的性能消耗。</li><li>使用IOC容器的意义：<ul><li>增加模块访问的限制。比如访问CounterModel要通过Countapp；</li><li>在统一的地方注册模块，有利于让开发人员有宏观的视角，充当一个“架构草图”，省去了维护一个“架构草图”的麻烦。</li><li>更符合SOLID原则、可以增加层级等等</li></ul></li></ul><h2 id="IOC-的隐藏功能：注册接口模块"><a href="#IOC-的隐藏功能：注册接口模块" class="headerlink" title="IOC 的隐藏功能：注册接口模块"></a>IOC 的隐藏功能：注册接口模块</h2><ul><li><p>除了<strong>注册和获取</strong>模块，IOC容器一般还有一个隐藏功能，即：注册<strong>接口</strong>模块</p></li><li><p><strong>抽象-实现</strong> 这种形式注册和获取对象的方式是符合<strong>依赖倒置原则</strong>的。</p></li><li><p>依赖倒置原则：程序要依赖于抽象接口，不要依赖于具体实现。</p></li><li><p>好处：</p><ul><li>接口设计和实现分成两个步骤，设计时可以专注于设计，减少干扰，实现专注于实现；</li><li>实现是可以替换的，比如一个接口是IStorage，实现可以是PlayerPrefsStorage、EasySaveStorage等；</li><li>比较容易测试（单元测试等）；</li><li>实现细节发生变化时，引用接口不会改变，降低耦合……</li></ul></li><li><p>DICExample.cs（DIP是依赖倒置原则的意思）</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DIPExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.设计模块接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> PlayerPrefs.GetString(key, defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">                <span class="keyword">return</span> EditorPrefs.GetString(key, defaultValue);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//避免打包出错</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">                EditorPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> container = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">        container.Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">        <span class="keyword">var</span> storage = container.Get&lt;IStorage&gt;();</span><br><span class="line">        storage.SaveString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;运行时存储&quot;</span>);</span><br><span class="line">        Debug.Log(storage.LoadString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用另一个实现类来直接替换 容器里同接口的实例</span></span><br><span class="line">        container.Register&lt;IStorage&gt;(<span class="keyword">new</span> EditorPrefsStorage());</span><br><span class="line">        storage = container.Get&lt;IStorage&gt;();</span><br><span class="line">        Debug.Log(storage.LoadString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>依赖倒置原则是SOLID中的字母D；单一职责原则是SOLID中的字母D。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>CounterModel继承了一个接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    BindableProperty&lt;<span class="built_in">int</span>&gt; Count &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span> <span class="comment">//: Singleton&lt;CounterModel&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后注册的时候使用的是接口类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用CountModel的时候就是通过接口类型来获取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddNumCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112165507242.png" alt="image-20230112165507242"></p><blockquote><p>可见CounterModel改成了ICounterModel。虽然改动很小，但是看这张图的时候不用考虑CountModel的具体实现，减轻了心智负担。</p></blockquote><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112171057291.png" alt="image-20230112171057291"></p><h1 id="引入数据存储功能"><a href="#引入数据存储功能" class="headerlink" title="引入数据存储功能"></a>引入数据存储功能</h1><p>首先基础实现：数据存储和更改的时候，存储在PlayerPrefs，从PlayerPrefs读取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterModel</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只是初始化的时候，才从存储读取数据</span></span><br><span class="line">        <span class="comment">//而每一次数据变更都改变存储</span></span><br><span class="line">        Count.Value = PlayerPrefs.GetInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个事件本来就要接受一个int参数，</span></span><br><span class="line">        <span class="comment">//count就是那个参数了？不太懂这个语法糖</span></span><br><span class="line">        Count.OnValueChanged += count =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, count);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的存储"><a href="#不同的存储" class="headerlink" title="不同的存储"></a>不同的存储</h2><p>目前EditorCounterApp和CounterApp都是用同一套存储（同一个CounterModel，而Model都是用PlayerPrefs）。回忆一下，两个项目都是在同一个工程，都是通过CounterModel来操作数据。那么如何实现两者的存储不同呢？上回学到IOC的隐藏功能：注册接口模块，同一个接口有多个类实现，假设用EditorPrefs和PlayerPrefs来分别存储；也已经实现类似的例子。注册想要的实现的类。</p><ul><li>和上次一样</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.设计模块接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PlayerPrefs.GetString(key, defaultValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            <span class="keyword">return</span> EditorPrefs.GetString(key, defaultValue);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//避免打包出错</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            EditorPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用。相当于存储也存储在单例容器里。model和存储都有各自的接口。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterModel</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> storage = Countapp.Get&lt;IStorage&gt;();</span><br><span class="line"></span><br><span class="line">        Count.Value = storage.LoadInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Count.OnValueChanged += count =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            storage.SaveInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, count);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span> </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见调用了容器里面的storage实例来间接调用它的方法。</p></blockquote><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113100133148.png" alt="image-20230113100133148"></p><h2 id="单例初始化可能造成的循环递归调用的问题"><a href="#单例初始化可能造成的循环递归调用的问题" class="headerlink" title="单例初始化可能造成的循环递归调用的问题"></a>单例初始化可能造成的循环递归调用的问题</h2><p>首先分析一下代码实现的逻辑。model类和存储类都是在此类中注册的，那么Countapp在什么时候调用Init（）方法呢？回到Architecture类看一下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;<span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见Init方法是mArchitecture为空的时候调用的。而Get方法和Register方法都可能调用MakeSureArchitecture方法，当第一次调用的时候。所以不是在某个地方Init，而是第一次注册或者get的时候才会初始化。</p><p>所以，整个流程是：</p><ul><li>某个功能要用到数据类Model的时候，首先执行get方法：<code>mCounterModel = Countapp.Get&lt;ICounterModel&gt;();</code></li><li>然后Model才开始初始化，执行<code>mArchitecture.Init();</code> </li><li>而Init是由子类来实现的，又回到了<code>Register&lt;ICounterModel&gt;(new CounterModel());</code></li><li>回到model的构造方法里面，又有<code>var storage = Countapp.Get&lt;IStorage&gt;();</code></li><li>这时候<code>mArchitecture</code>还没有初始化完成，所以又回到了子类的init……依次类推循环。</li></ul><p>【复盘遇到了一个问题：调用CountModel的时候已经MakeSure了一下，执行到代码<code> mArchitecture.Init();</code>，然后开始注册CountModel，在其构造器中尝试Get工具时，虽然又MakeSure了一次，但是此时的mArchitecture已经实例化过，不会执行Init方法了吧？那这样的话Get返回的就是空值了……因为整个代码就是一个静态变量mArchitecture，MakeSure的是mArchitecture】</p><p>究其原因，一个类A要成为容器里的一个实例，必须要构造方法实例化一下；而类B的容器注册又在A的构造方法里面；</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112194556474.png" alt="image-20230112194556474"></p><h2 id="Architecture类的分析"><a href="#Architecture类的分析" class="headerlink" title="Architecture类的分析"></a>Architecture类的分析</h2><p>【和上文有点重复了，但不要紧，这个是更详细的复盘】首先回忆一下为什么会有Architecture类。开始是直接用IOC容器的，IOC容器就是用字典把某个类型对应的一个实例存储下来，这样一个IOC容器可以有多种模块类的对象实例，而统一管理模块类的类就只需拥有一个静态IOC容器变量就行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IOCContainer mContainer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论是增加还是获取都先检查IOC是否为空（类似单例）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureContainer</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mContainer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mContainer.Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureContainer();</span><br><span class="line">        <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113165437148.png" alt="image-20230113165437148"></p><p>这样的话访问Model1就要经过Countapp来访问，达到了限制访问的目的，而不是用静态类随时随地都可以调用。</p><p>那么如果有多种管理模块类的类呢？Countapp1，Countapp2……？这时候就必须得抽象一部分代码出来，抽象的关键是：每一个管理类有一个静态的对象来方便访问（可以是IOC或者管理类本身）；IOC可以注册和获取对应的实例；从IOC获取的前提是已经有静态变量而且已经注册过；</p><p>所以，抽象出来的Architecture如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;<span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113171440638.png" alt="image-20230113171440638"></p><blockquote><p>可见抽象的部分大同小异，只不过静态变量是mArchitecture，传入的T就是管理类（如Countapp），整个过程就是当某个地方需要访问model的数据时，如<code>Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</code>就会调用Countapp的Get方法，里面首先检查是否有<code>mArchitecture</code>实例，没有的话就创建一个实例，并且执行Init方法（此方法就是给子类调用来注册各种模块），注册完后就可以直接调用了。</p><p>！！！一定要分清，<code>mArchitecture = new T();</code>就是已经创建了单例，<code>mArchitecture.Init();</code>就是把各模块实例存进来。</p></blockquote><p>【此处是解决单例循环调用的思路，空白ing】</p><h2 id="Architecture类2-0版的分析"><a href="#Architecture类2-0版的分析" class="headerlink" title="Architecture类2.0版的分析"></a>Architecture类2.0版的分析</h2><p>工具层Utility是要通过Model层来进行访问，而System层也可能要访问Model层。也就是说，Model实例化的时候可能要得到Utility，等等。</p><p>再回顾一下逻辑执行流程：某处要调用Model（Get它一下），然后检查是否初始化了Architecture，没有就new一个并且执行子类的Init方法，把要注册的都注册一下。注册的时候要调用构造方法，而构造方法可能包含其它层，那如何确保构造的时候其他层已经存在了呢？（不存在的话还得初始化，这样就会重复初始化容易出问题？）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RegisterSystem&lt;IAchievementSystem&gt;(<span class="keyword">new</span> AchievementSystem());</span><br><span class="line">        RegisterModel&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        RegisterUtility&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就是这块注册，把优先级最高的先注册了，然后再注册次优先的。解决的代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">        mArchitecture.Init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Model初始化</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> architectureModel <span class="keyword">in</span> mArchitecture.mModels)</span><br><span class="line">        &#123;</span><br><span class="line">            architectureModel.Init();</span><br><span class="line">        &#125;</span><br><span class="line">        mArchitecture.mModels.Clear();</span><br><span class="line">        <span class="comment">//System初始化(在Model之后)</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> architectureSystem <span class="keyword">in</span> mArchitecture.mSystems)</span><br><span class="line">        &#123;</span><br><span class="line">            architectureSystem.Init();</span><br><span class="line">        &#125;</span><br><span class="line">        mArchitecture.mSystems.Clear();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mInited = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见执行完<code>mArchitecture.Init();</code>之后，才进行model和System的初始化（相当于构造方法）。Init的时候把要注册的Model和System都存起来，Init完后再逐一初始化。具体处理如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterModel</span>&lt;<span class="title">T</span>&gt;(<span class="params">T model</span>) <span class="keyword">where</span> T : IModel</span></span><br><span class="line">&#123;</span><br><span class="line">    model.Architecture = <span class="keyword">this</span>;</span><br><span class="line">    mContainer.Register&lt;T&gt;(model);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInited)</span><br><span class="line">    &#123;</span><br><span class="line">        mModels.Add(model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        model.Init();</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterSystem</span>&lt;<span class="title">T</span>&gt;(<span class="params">T system</span>) <span class="keyword">where</span> T : ISystem</span></span><br><span class="line">&#123;</span><br><span class="line">    system.Architecture = <span class="keyword">this</span>;</span><br><span class="line">    mContainer.Register&lt;T&gt;(system);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInited)</span><br><span class="line">    &#123;</span><br><span class="line">        mSystems.Add(system);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        system.Init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params">T utility</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mContainer.Register&lt;T&gt;(utility);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了最底层的工具类直接注册，其他都是先进缓存变量待着。</p></blockquote><p>总之初始化和注册都是一次性就完成的，并且按照顺序逐一实例化，解决互相引用的冲突，所以不会重复调用Init方法。为做到这点还有一个地方要考虑：如果Model直接从<code>Countapp.Get&lt;IStorage&gt;()</code>获取工具类的话，还会调用MakeSure方法……（可能静态变量还是空的？）</p><p>反正又进行了很绕的操作：</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113191234392.png" alt="image-20230113191234392"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>/CounterModel.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> storage = Architecture.GetUtility&lt;IStorage&gt;();  <span class="comment">//保证Architecture是赋值好的</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>Architecture.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>model是通过Architecture来GetUtility……为了绕过初始化？也就是获取有两种方法，一种是层级之间（Model/System/Utility）的调用用GetXXX方法（与Init方法无关），这都是继承<code>IBelongToArchitecture</code>来获得的方法，第二种是其他地方调用层级的话直接用Get方法（与Init方法有关）……反正是很绕，滚去多学习语法了。</p><h1 id="接口的显式实现"><a href="#接口的显式实现" class="headerlink" title="接口的显式实现"></a>接口的显式实现</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayOther</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InterfaceDesignExample</span> : <span class="title">MonoBehaviour</span>, <span class="title">ICanSayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接口的隐式实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接口的显式实现，不能带访问权限（均无法访问）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">void</span> ICanSayHello.SayOther()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.SayHello();   </span><br><span class="line"></span><br><span class="line">        (<span class="keyword">this</span> <span class="keyword">as</span> ICanSayHello).SayOther();  <span class="comment">//转成接口对象才能调用,增加了成本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口-抽象类-实现类"><a href="#接口-抽象类-实现类" class="headerlink" title="接口-抽象类-实现类"></a>接口-抽象类-实现类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CustomScript</span> : <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScript</span> : <span class="title">CustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，子类可以调用接口的<code>Start()</code>方法，那么就会造成循环调用。所以可以限制抽象类的接口方法的访问权限：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CustomScript</span> : <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Start()</span><br><span class="line">    &#123;</span><br><span class="line">        OnStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Update()</span><br><span class="line">    &#123;</span><br><span class="line">        OnUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Destroy()</span><br><span class="line">    &#123;</span><br><span class="line">        OnDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样子类就无法访问抽象类的接口方法，只能继承抽象方法。</p></blockquote><h2 id="接口-静态扩展时用于限制方法的访问规则"><a href="#接口-静态扩展时用于限制方法的访问规则" class="headerlink" title="接口+静态扩展时用于限制方法的访问规则"></a>接口+静态扩展时用于限制方法的访问规则</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CanDoEveryThing</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething3</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 总接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing CanDoEveryThing &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口1</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething1</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口1的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething1Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取接口1继承的总接口持有的基本类，并调用其方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething1</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething1 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口2</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething2</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口2的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething2Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething2</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething2 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口3</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething3</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口3的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething3Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething3</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething3 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo1</span> : <span class="title">ICanDoSomething1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> CanDoEveryThing CanDoEveryThing &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo1 = <span class="keyword">new</span> OnlyCanDo1();</span><br><span class="line">    onlyCanDo1.CanDoEveryThing.DoSomething2();<span class="comment"><span class="doctag">///</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见<code>OnlyCanDo1</code>对象可以通过接口持有的实例来访问其他的方法（做事件2和3）.上一种情况是把接口的方法给显式掉，但这次接口是持有其他类的对象。所以，继承接口的类要把接口持有的对象给显式掉。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo1</span> : <span class="title">ICanDoSomething1</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing IHasEverything.CanDoEveryThing &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> CanDoEveryThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo1 = <span class="keyword">new</span> OnlyCanDo1();</span><br><span class="line">    onlyCanDo1.DoSomething1();<span class="comment">//只能调用接口的方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个接口相当于一个使用规则</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo23</span> : <span class="title">ICanDoSomething2</span>, <span class="title">ICanDoSomething3</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing IHasEverything.CanDoEveryThing &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> CanDoEveryThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo23 = <span class="keyword">new</span> OnlyCanDo23();</span><br><span class="line">    onlyCanDo23.DoSomething2();</span><br><span class="line">    onlyCanDo23.DoSomething3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul><li>核心知识是接口的显式实现，用于控制C#成员方法的访问权限</li><li>接口-抽象类-实现类 时，不想被乱调用一些方法时可以用</li><li>接口+静态扩展 时，想通过实现某个接口来获得具体方法的访问权限</li></ul><h1 id="方式三：引入系统层"><a href="#方式三：引入系统层" class="headerlink" title="方式三：引入系统层"></a>方式三：引入系统层</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113100249105.png" alt="image-20230113100249105"></p><p>目前项目可以分为三个层级：</p><ul><li>表现层：即ViewController或者MonoBehaviour脚本等；</li><li>Model层：管理数据，提供数据的增删改查</li><li>Utility层：工具层，提供一些必要的基础工具，比如数据存储、网络链接、蓝牙、序列化反序列化等等</li></ul><p>而QFramework系统设计架构最终是有四个层级，第四层级叫System层，系统层。目前Command分担了Controller的交互逻辑的部分逻辑，但其实还有一部分交互逻辑是需要给System层分担的。</p><p>首先要理解的是，Command是没有状态的，因为Command相当于一个方法，只要调用一次就可以不用了，所以Command是没有状态的。那什么是有状态的？比如角色控制脚本，在里面创建了一些角色数据，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Walking;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> JumpCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxJumpCount;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断有没有状态，可以理解为这个对象要不要维护数据。比如之前写的<code>AddCountCommand</code>只是更改了ICountModel中的Count的值，没 有状态。但是现实情况下，Command除了要更改Model的值，还有可能是开启了某些服务，而这些服务是有状态的，比如计时服务、蓝牙链接服务等，如果将它们写成对象必是有状态的对象，而这些服务既包含<strong>要维护的数据</strong>，也包含一些<strong>对外提供的方法</strong>，所以放Model层和Utility层都是不合适的。</p><p>如果放在表现层，会造成大量的重复代码；Command只是表现层和底层系统层交互方式的一种，且不能有状态；所以这部分代码只能再创建一个层级来负责了，那就是System层。</p><p>所以四个层次的梳理如下：</p><ul><li>表现层：即ViewController或者MonoBehaviour脚本等；</li><li>System层：系统层，<strong>有状态</strong>，负责既提供API又有状态的对象，比如网络服务、蓝牙服务、商城系统等</li><li>Model层：管理数据，<strong>有状态</strong>，提供数据的增删改查</li><li>Utility层：工具层，<strong>无状态</strong>，提供一些必要的基础工具API，比如数据存储、网络链接、蓝牙、序列化反序列化等等</li></ul><p>其中表现层改变System、Model层的状态用Command；</p><p>System层和Model层通知表现层用事件或委托；</p><p>表现层查询状态时可以直接获取System和Model层。</p><p>一般情况下，表现层根本不用访问Utility层，同样Utility层也不用通知表现层。</p><p>模块化的三种方式：</p><ul><li>单例</li><li>IOC容器</li><li>分层</li></ul><h2 id="实现系统层"><a href="#实现系统层" class="headerlink" title="实现系统层"></a>实现系统层</h2><p>和Model层差不多，但是init的时候要放在model的后面，因为可能要引用到model</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Model初始化</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> architectureModel <span class="keyword">in</span> mArchitecture.mModels)</span><br><span class="line">&#123;</span><br><span class="line">    architectureModel.Init();</span><br><span class="line">&#125;</span><br><span class="line">mArchitecture.mModels.Clear();</span><br><span class="line"><span class="comment">//System初始化(在Model之后)</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> architectureSystem <span class="keyword">in</span> mArchitecture.mSystems)</span><br><span class="line">&#123;</span><br><span class="line">    architectureSystem.Init();</span><br><span class="line">&#125;</span><br><span class="line">mArchitecture.mSystems.Clear();</span><br></pre></td></tr></table></figure><ul><li>实现例子：成就系统</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAchievementSystem</span> : <span class="title">ISystem</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AchievementSystem</span> : <span class="title">IAchievementSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IArchitecture Architecture &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取model的数据</span></span><br><span class="line">        <span class="keyword">var</span> counterModel = Architecture.GetModel&lt;ICounterModel&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> previousCount = counterModel.Count.Value;</span><br><span class="line"></span><br><span class="line">        counterModel.Count.OnValueChanged += newCount =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (previousCount &lt; <span class="number">10</span> &amp;&amp; newCount &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;解锁点击10次的成就&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (previousCount &lt; <span class="number">20</span> &amp;&amp; newCount &gt;= <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;解锁点击20次的成就&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousCount = newCount;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>ICommand</li><li>ISystem</li><li>IModel</li><li>（IController）</li><li>（IUtility）</li></ul><h2 id="IController"><a href="#IController" class="headerlink" title="IController"></a>IController</h2><p>与MVC的Controller是同一个意思。</p><p>在表现层需要向底层系统层发送Command，也需要监听底层系统层发送的事件，还需要通过底层系统层的Model或System来查询一些数据，这些功能最好用一个IController来定义一下。目前能够实现的就是查询数据的功能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IController</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于表现层的对象会时常进行创建和销毁，所以表现层的对象注册到Architecture是没有意义的，而这里定义的IController的意义就是标记一下这个表现层的对象是属于表现层的（不能和系统层、数据层相提并论，都存在IOC中）；而在表现层对象中，去访问Architecture中的System或Model就不需要使用单例的形式获取了。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//CounterViewController.cs</span></span><br><span class="line">mCounterModel = Countapp.Get&lt;ICounterModel&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>//改为层之间的调用</span></span><br><span class="line"><span class="comment">//继承IController，并且</span></span><br><span class="line">mCounterModel = Architecture.GetModel&lt;ICounterModel&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> IArchitecture Architecture &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = Countapp.Interface;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>//Architecture.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IArchitecture Interface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MakeSureArchitecture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于Controller是连接Mono（一直运行的）和层级之间的桥梁，如果直接调用<code>Architecture</code>将为空值，所以要加一个方法来获取初始化好的<code>Architecture</code>.</p></blockquote><h2 id="解决Controller类不能在Mono执行构造方法"><a href="#解决Controller类不能在Mono执行构造方法" class="headerlink" title="解决Controller类不能在Mono执行构造方法"></a>解决Controller类不能在Mono执行构造方法</h2><p>但是在<code>CounterViewController : MonoBehaviour, IController</code>类中，</p><p><code>public IArchitecture Architecture &#123; get; set; &#125; = Countapp.Interface;</code>这个构造方法并没有在Mono的方法里面执行，所以会报错。</p><p>修改如下：Architecture 的set和get分离。 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSetArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetArchitecture</span>(<span class="params">IArchitecture architecture</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于IModel和ISystem都是和Architecture相互持有的，所以IModel和ISysem两者都要实现两个接口。</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114113357202.png" alt="image-20230114113357202"></p><blockquote><p>可见IController是直接从Architecture获取，其他层由于和Architecture相互持有，所以还有抽象类来存储Architecture变量。</p></blockquote><h2 id="IUtility接口"><a href="#IUtility接口" class="headerlink" title="IUtility接口"></a>IUtility接口</h2><p>IUtility并不持有Architecture对象，只是Architecture单向持有它。此时接口似乎只是一个标识（限制类型）作用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span>: <span class="title">IUtility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">LoadInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> defaultValue = <span class="number">0</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span>/IArchitecture.cs</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>) <span class="keyword">where</span> T : IUtility</span></span><br><span class="line"><span class="function">T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span>, IUtility</span>; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114155707059.png" alt="image-20230114155707059"></p><h2 id="ICommand接口"><a href="#ICommand接口" class="headerlink" title="ICommand接口"></a>ICommand接口</h2><p>目前是通过单例的方式来访问Architecture对象。如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddNumCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而其他层比如Model、System都是与Architecture互相持有的，所以ICommand也要保持一致。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IArchitecture mArchitecture;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetArchitecture</span>(<span class="params">IArchitecture architecture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = architecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICommand.Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        OnExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddNumCommand</span> : <span class="title">AbstractCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetArchitecture().GetModel&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114163358549.png" alt="c"></p><blockquote><p>重点看ICommand对应的内容。目前ICommand只是实现使用Architecture，接下来更改Command的调用方式。不同于目前已经实现的Model层和System层，它们是提供外界访问和内置触发事件（在Init已经安排好）；而Command需要别人主动来调用它。</p></blockquote><h3 id="Command-的调用"><a href="#Command-的调用" class="headerlink" title="Command 的调用"></a>Command 的调用</h3><p>解决：将Command发送给Architecture，让Architecture去执行Command。（Command已经和Architecture互相持有了，所以意味着Command必须执行SetArchitecture方法？）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : ICommand, <span class="keyword">new</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : ICommand</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//Architecture.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : ICommand, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = <span class="keyword">new</span> T();</span><br><span class="line">    command.SetArchitecture(<span class="keyword">this</span>);</span><br><span class="line">    command.Execute();</span><br><span class="line">    <span class="comment">//command.SetArchitecture(null);  //执行完去掉双向引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    command.SetArchitecture(<span class="keyword">this</span>);</span><br><span class="line">    command.Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里完善了command对<code>Architecture</code>的持有以及方法调用。这样就可以通过Architecture来执行command的了。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span>, <span class="title">IController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PointGame.Interface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* new KillEnemyCommand()</span></span><br><span class="line"><span class="comment">                    .Execute(); */</span></span><br><span class="line">        GetArchitecture().SendCommand&lt;KillEnemyCommand&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Controller层的，首先继承<code>IController</code>，然后实现<code>GetArchitecture</code>方法来获取Architecture对象以便调用Command层的命令。</p></blockquote><h1 id="架构使用规则完善一"><a href="#架构使用规则完善一" class="headerlink" title="架构使用规则完善一"></a>架构使用规则完善一</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114172433239.png" alt="image-20230114172433239"></p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114172510398.png" alt="image-20230114172510398"></p><h2 id="改进一：限制Model层对IArchitecture方法的使用"><a href="#改进一：限制Model层对IArchitecture方法的使用" class="headerlink" title="改进一：限制Model层对IArchitecture方法的使用"></a>改进一：限制Model层对IArchitecture方法的使用</h2><p>model层由于可以使用GetArchitecture()方法来执行IArchitecture接口内设计的所有方法，所以它可以访问Command层，这是不合理的。因为Command是表现层和底层交互的方式。</p><p>而在接口的显式实现章节中提到过”接口+静态扩展用于限制方法的访问“，所以可以对Model访问接口的方法做出一些限制。</p><ul><li>限制model对Set和Get方法的使用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//AbstractModel.class</span></span><br><span class="line"><span class="keyword">void</span> ICanSetArchitecture.SetArchitecture(IArchitecture architecture)</span><br><span class="line">&#123;</span><br><span class="line">    mArchitecture = architecture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IArchitecture IBelongToArchitecture.GetArchitecture()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mArchitecture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我对这种方式的理解是，用一个额外的接口来继承”可以做全部事情的“接口，但是用一个静态类来扩展这个额外的接口，”扩展“的过程中限制了这个接口的继承下来的方法，所以继承这个”被阉割的“接口的类就只能访问特定的方法了。</p><ul><li>被阉割的接口：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanGetUtility</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanGetUtilityExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanGetUtility self</span>) <span class="keyword">where</span> T : <span class="keyword">class</span>, IUtility</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self.GetArchitecture().GetUtility&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承这个接口：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IModel</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span>, <span class="title">ICanGetUtility</span><span class="comment">///</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractModel</span> : <span class="title">IModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IArchitecture mArchitecture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICanSetArchitecture.SetArchitecture(IArchitecture architecture)<span class="comment"><span class="doctag">///</span>子类被禁用的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = architecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IArchitecture IBelongToArchitecture.GetArchitecture()<span class="comment"><span class="doctag">///</span>子类被禁用的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IModel.Init()</span><br><span class="line">    &#123;</span><br><span class="line">        OnInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现接口</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">AbstractModel</span>, <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> storage = <span class="keyword">this</span>.GetUtility&lt;IStorage&gt;();  <span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>[静态类扩展接口的语法要回头好好看看]</p><h2 id="限制System层"><a href="#限制System层" class="headerlink" title="限制System层"></a>限制System层</h2><p>和Model差不多,多继承了一个被阉割掉的ICanGetModel</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISystem</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span>, <span class="title">ICanGetModel</span>, <span class="title">ICanGetUtility</span><span class="comment">////</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制Command层"><a href="#限制Command层" class="headerlink" title="限制Command层"></a>限制Command层</h2><p>Command只能访问System、Model、Utility；做法同上。</p><h2 id="限制Controller"><a href="#限制Controller" class="headerlink" title="限制Controller"></a>限制Controller</h2><p>IController可以获取Model、获取System、发送Command。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>限制的范围可以看接口后者能使用的方法就能明白，可以减少说明性的文档，或者规范项目。</p><h1 id="架构使用规则完善二"><a href="#架构使用规则完善二" class="headerlink" title="架构使用规则完善二"></a>架构使用规则完善二</h1><h2 id="基于类型的事件机制"><a href="#基于类型的事件机制" class="headerlink" title="基于类型的事件机制"></a>基于类型的事件机制</h2><p>事件是底层系统层向表现层发送的，但是目前还没有限制其使用。</p><p>目前的事件基类是一个静态类，一是不能传递参数，二是事件管理对象无法分组。</p><p>基于类型……是根据某种类型来统一注册执行事件？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Event</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action mOnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent += onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent -= onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>TypeEventSystem.cs</code></strong></p><ul><li>与事件操作相关的方法的接口：注册、广播、注销</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITypeEventSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span>;<span class="comment">//执行无传参的事件集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span>;<span class="comment">//执行传参为T类型的事件集</span></span><br><span class="line">    <span class="function">IUnRegister <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span>; <span class="comment">//注册传参为T类型的事件，返回IUnRegister接口类型的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegister</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span>;<span class="comment">//注销传参为T类型的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于注销，这里用了统一注销的思路，避免逐一手动注销。这样的话，要被注销的事件就得被存储下来，并且可以调用此事件相关的注销方法。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnRegister</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TypeEventSystemUnRegister&lt;T&gt; : IUnRegister</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ITypeEventSystem TypeEventSystem;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;T&gt; OnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TypeEventSystem.UnRegister&lt;T&gt;(OnEvent);</span><br><span class="line"></span><br><span class="line">        TypeEventSystem = <span class="literal">null</span>;</span><br><span class="line">        OnEvent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为事件是以字典的形式存储在对应的TypeEventSystem实例的字典变量中的，所以既要记录事件本身，还得记录对应的TypeEventSystem实例，并且调用TypeEventSystem实例的UnRegister方法，所以用类或者结构体来存储这些信息和方法。当new 一个TypeEventSystemUnRegister时，传入字段，并且在相应地方调用实例方法，就能注销掉了。</p><p>所以<code>IUnRegister Register&lt;T&gt;(Action&lt;T&gt; onEvent);</code>可以说是返回了记录待注销事件相关信息的变量，然后存在某个地方，等待被注销。</p></blockquote><ul><li>统一注销的实现。这个类继承了Mono，说明可以与物体挂钩，当对应的游戏对象销毁时，自动逐一注销事件</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnRegisterOnDestoryTrigger</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HashSet</span>&lt;<span class="title">IUnRegister</span>&gt; mUnRegisters</span> = <span class="keyword">new</span> HashSet&lt;IUnRegister&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUnRegister</span>(<span class="params">IUnRegister unRegister</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mUnRegisters.Add(unRegister);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> unRegister <span class="keyword">in</span> mUnRegisters)</span><br><span class="line">        &#123;</span><br><span class="line">            unRegister.UnRegister();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mUnRegisters.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关键是怎么调用AddUnRegister方法。视频又用了接口扩展的高级方法，，，👇</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UnRegisterExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterWhenGameObjectDestoryed</span>(<span class="params"><span class="keyword">this</span> IUnRegister unRegister, GameObject gameObject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> trigger = gameObject.GetComponent&lt;UnRegisterOnDestoryTrigger&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!trigger)</span><br><span class="line">        &#123;</span><br><span class="line">            trigger = gameObject.AddComponent&lt;UnRegisterOnDestoryTrigger&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trigger.AddUnRegister(unRegister);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IUnRegister接口以及实现的TypeEventSystemUnRegister类都是为待注销事件服务。一个待注销的事件经历了以下阶段：记录事件以及被管理的方法和实例——存储记录到物体挂载的脚本上——物体销毁事件注销。所以，可以将待注销的事件直接理解成<code>TypeEventSystemUnRegister</code>实例，那么如何进行第二步呢？</p><p>而且明明一个结构体就能记录的，为啥还要弄一个<code>IUnRegister</code>接口呢？接口可以使用静态类进行扩展，如以上这个类所体现的，<code>UnRegisterExtension类</code>扩展了<code>IUnRegister接口</code>，为其添加了<code>UnRegisterWhenGameObjectDestoryed方法</code>，这样所有实现接口的类的实例都能直接调用已经被静态类实现好的接口方法。</p><p>所以，继承了<code>IUnRegister接口</code>的<code>TypeEventSystemUnRegister类</code>的实例能直接调用此方法，也就是说待注销的事件能调用这个方法把自己存储好。</p><p>为什么要设计接口静态类扩展？直接全放在一个类里面不行吗？🤨</p></blockquote><ul><li>实现接口里的事件的相关方法。这里是一个事件系统，也就是说各种类型的事件都是统一管理。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeEventSystem</span> : <span class="title">ITypeEventSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRegisterations</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Registerations</span>&lt;<span class="title">T</span>&gt; : <span class="title">IRegisterations</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Action&lt;T&gt; OnEvents = e =&gt; &#123;&#125;;<span class="comment">//同类型的注册的事件集</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;Type, IRegisterations&gt; mEventRegisterations = <span class="keyword">new</span> Dictionary&lt;Type, IRegisterations&gt;();<span class="comment">//一个类型对应一个相应传参类型的事件集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="keyword">new</span> T();</span><br><span class="line">        Send&lt;T&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line">            (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents(e);  <span class="comment">//执行了方法？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUnRegister <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册的时候，先看看有没有传参类型相同的大部队</span></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            registerations = <span class="keyword">new</span> Registerations&lt;T&gt;();</span><br><span class="line">            mEventRegisterations.Add(type, registerations);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在大部队里面加入自己的个体信息</span></span><br><span class="line">        (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents += onEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回待注销的事件信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TypeEventSystemUnRegister&lt;T&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            OnEvent = onEvent,</span><br><span class="line">            TypeEventSystem = <span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line">            (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents -= onEvent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用例子。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeEventSystemExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventA</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventB</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ParamB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventGroup</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventC : IEventGroup</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventD : IEventGroup</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TypeEventSystem mTypeEventSystem = <span class="keyword">new</span> TypeEventSystem();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mTypeEventSystem.Register&lt;EventA&gt;(OnEventA);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem.Register&lt;EventB&gt;(b =&gt; </span><br><span class="line">                                          &#123;</span><br><span class="line">                                              Debug.Log(<span class="string">&quot;OnEventB: &quot;</span> + b.ParamB);</span><br><span class="line">                                          &#125;).UnRegisterWhenGameObjectDestoryed(gameObject);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem.Register&lt;IEventGroup&gt;(e =&gt;</span><br><span class="line">                                               &#123;</span><br><span class="line">                                                   Debug.Log(e.GetType());</span><br><span class="line">                                               &#125;).UnRegisterWhenGameObjectDestoryed(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;EventA&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;EventB&gt;(<span class="keyword">new</span> EventB()</span><br><span class="line">                                          &#123;</span><br><span class="line">                                              ParamB = <span class="number">123</span></span><br><span class="line">                                          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;IEventGroup&gt;(<span class="keyword">new</span> EventC());</span><br><span class="line">            mTypeEventSystem.Send&lt;IEventGroup&gt;(<span class="keyword">new</span> EventD());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEventA</span>(<span class="params">EventA obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnEventA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当没有直接执行扩展方法时，就要手动注销</span></span><br><span class="line">        mTypeEventSystem.UnRegister&lt;EventA&gt;(OnEventA);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230116123132177.png" alt="image-20230116123132177"></p><p>如果一个接口有多个类实现，虽然注册的时候是按照接口类型来存入字典的，但是添加事件却是用实现子类的类型……所以就是IEventGroup的效果？</p><h2 id="约束事件的使用"><a href="#约束事件的使用" class="headerlink" title="约束事件的使用"></a>约束事件的使用</h2><p>事件是<strong>自底向上</strong>通知的时候用的，在底层内部事件也可以监听。</p><p>所以将规则定义为：</p><ul><li>IController可以监听事件</li><li>ICommand可以发送事件</li><li>ISytem可以发送和监听事件</li><li>IModel可以发送事件</li></ul><p>定好规则后，先在<code>Architecture类</code>增加<strong>注册和发送事件的支持</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...在IArchitecture写一下方法然后实现</span></span><br><span class="line"><span class="keyword">private</span> ITypeEventSystem mTypeEventSystem = <span class="keyword">new</span> TypeEventSystem();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.Send&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.Send&lt;T&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IUnRegister <span class="title">RegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mTypeEventSystem.Register&lt;T&gt;(onEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.UnRegister&lt;T&gt;(onEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写规则脚本，限制接口的方法（本质是空接口再扩展方法）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSendEvent</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanSendEventExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self</span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().SendEvent&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self, T e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().SendEvent&lt;T&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanRegisterEvent</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanRegisterEventExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUnRegister <span class="title">RegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanRegisterEvent self, Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self.GetArchitecture().RegisterEvent&lt;T&gt;(onEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self, Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().UnRegisterEvent&lt;T&gt;(onEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：注册事件。通过Architecture来间接执行事件的相关方法；一个模块管理类拥有一个事件系统。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UI</span> : <span class="title">MonoBehaviour</span>, <span class="title">IController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GamePassEvent.Register(OnGamePass);</span></span><br><span class="line">        <span class="keyword">this</span>.RegisterEvent&lt;GamePassEvent&gt;(OnGamePass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGamePass</span>(<span class="params">GamePassEvent e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;Canvas/EndPanel&quot;</span>).gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GamePassEvent.UnRegister(OnGamePass);</span></span><br><span class="line">        <span class="keyword">this</span>.RegisterEvent&lt;GamePassEvent&gt;(OnGamePass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PointGame.Interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：触发事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KillEnemyCommand</span> : <span class="title">AbstractCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gameModel = <span class="keyword">this</span>.GetModel&lt;IGameModel&gt;();</span><br><span class="line">        gameModel.KillCount.Value++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gameModel.KillCount.Value == <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SendEvent&lt;GamePassEvent&gt;(); <span class="comment"><span class="doctag">///</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="架构演化小结"><a href="#架构演化小结" class="headerlink" title="架构演化小结"></a>架构演化小结</h1><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>问题：对象之间的引用无规则。</p><p>先使用树结构整理了场景结构，然后引入对象之间交互的概念。</p><p>对象之间的交互方式：</p><ul><li>方法</li><li>委托</li><li>事件</li></ul><p>模块化的三种常规方式：</p><ul><li>单例</li><li>IOC</li><li>分层</li></ul><p>最后总结得出：</p><ul><li>自底向上用事件或者委托</li><li>自顶向下用方法</li></ul><p>这个过程中积累了一个工具类：Event基类</p><p>学习理论：</p><ul><li>表现和数据要分离</li><li>交互逻辑（Command模式）和表现逻辑（数据+事件）</li></ul><p>然后是模块化：</p><p>Model——静态类——单例——</p><p>IOC容器（访问模块对象不能是无任何规则和限制）——模块接口（访问模块对象）——</p><p>四个层级——接口的阉割技术（为层级接口增加了限制）——</p><p>增加了事件的使用规则</p><p><strong>层级之间的规则：</strong></p><ul><li>表现层<ul><li>可以获取System、Model</li><li>可以发送Command</li><li>可以监听Event</li></ul></li><li>系统层<ul><li>可以获取System、Model、Utility</li><li>可以监听、发送Event</li></ul></li><li>数据层<ul><li>可以获取Utility</li><li>可以发送Event</li></ul></li><li>工具层<ul><li>啥都不用干，可以集成第三方库，或者封装API</li></ul></li><li>Command（四个层级之外的一个重要概念）<ul><li>可以获取System、Model、Utility</li><li>可以发送Event、Command</li></ul></li></ul><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230116135422837.png" alt="image-20230116135422837"></p><p>设计方法：</p><ul><li>总览图：包含整个项目的所有System、Model、Utility对象，以及大致的表现层流程</li><li>功能实现图：针对单个业务或操作，绘制表现层对象 或 界面图、相关的System、Model、Utility对象、Command、Event的流向以及简单的引用关系。</li></ul><h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230128171630873.png" alt="image-20230128171630873"></p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230128171745351.png" alt="image-20230128171745351"></p><blockquote><p>简洁图的表现</p></blockquote>]]></content>
    
    
    <summary type="html">Unity的游戏框架搭建</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity的Input System</title>
    <link href="https://huangxinhere.github.io/2023/01/03/Unity%E7%9A%84InputSystem/"/>
    <id>https://huangxinhere.github.io/2023/01/03/Unity%E7%9A%84InputSystem/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-02-20T04:01:45.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>在Package Manager下载。</p><h1 id="获取Input"><a href="#获取Input" class="headerlink" title="获取Input"></a>获取Input</h1><h2 id="直接从输入设备获取"><a href="#直接从输入设备获取" class="headerlink" title="直接从输入设备获取"></a>直接从输入设备获取</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;<span class="comment">//命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlayerScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gamepad = Gamepad.current;</span><br><span class="line">        <span class="keyword">if</span> (gamepad == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// No gamepad connected.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gamepad.rightTrigger.wasPressedThisFrame)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &#x27;Use&#x27; code here</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector2 move = gamepad.leftStick.ReadValue();</span><br><span class="line">        <span class="comment">// &#x27;Move&#x27; code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The same approach works for other Device types (for example, <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/api/UnityEngine.InputSystem.Keyboard.html"><code>Keyboard.current</code></a> or <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/api/UnityEngine.InputSystem.Mouse.html"><code>Mouse.current</code></a>).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Keyboard.current.aKey.wasPressedThisFrame;//相当于</span><br><span class="line">Input.GetKeyDown()</span><br></pre></td></tr></table></figure><h2 id="Player-Input"><a href="#Player-Input" class="headerlink" title="Player Input"></a>Player Input</h2><p>直接获取虽然方便，但是需要分别地指定对应获取路径，而且如果响应的事件更改按键的话也很难统一更改。</p><ul><li>概念理解</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//按键（信号）——&gt;触发事件或动作（Action）——&gt;动作归类成集</span><br><span class="line">//也就是，一个动作可能由多个信号触发，一个角色有多个动作</span><br></pre></td></tr></table></figure><ul><li>Unity实现方式<ul><li>用户设置面板-asset：可视化设置动作及信号；</li><li>根据asset生成脚本以供调用。</li></ul></li></ul><h3 id="添加PlayerInput组件"><a href="#添加PlayerInput组件" class="headerlink" title="添加PlayerInput组件"></a>添加PlayerInput组件</h3><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/AddPlayerInput.png" alt="Add Player Input Component"></p><h3 id="创建Input-Actions"><a href="#创建Input-Actions" class="headerlink" title="创建Input Actions"></a>创建Input Actions</h3><p>最快的可使用默认的Actions。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/PlayerInputCreateActions.png" alt="Create Actions from Player Input Component"></p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/MyGameActions.png" alt="MyGameActions"></p><p>编辑窗口详见：<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/ActionAssets.html#editing-input-action-assets">Input Action Assets | Input System | 1.4.4 (unity3d.com)</a></p><blockquote><p>最左边栏是map，动作的集合，可以抽象为玩家的动作集合、或者UI点击等等；中间栏是Actions，首先是自定义动作，然后子内容是触发信号，可以有键盘、手柄等；右侧栏是属性，对动作或信号的具体属性进行调整。</p><p>例如：Player有一系列受玩家操作的动作，比如Move、Look、Fire，如何触发Move呢？有触摸屏的leftStick、WASD、箭头。但是在这里Move只是一个动作名称而已，如果要实现Move的具体逻辑，还要知道如何获取信号并实现逻辑。</p></blockquote><h3 id="设置Action的具体逻辑"><a href="#设置Action的具体逻辑" class="headerlink" title="设置Action的具体逻辑"></a>设置Action的具体逻辑</h3><p>其中PlayerInput有Behavior的设置，有多种响应方法。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/PlayerInputNotificationBehaviors.png" alt="PlayerInput Notification Behavior"></p><p>Behavior的选择详见：<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Components.html#notification-behaviors">GameObject components for input | Input System | 1.4.4 (unity3d.com)</a></p><p>以下这个方法用了Invoke Unity Event，就像为UI设置响应事件一样，拖脚本实现其中的方法。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/MyPlayerActionEvents.png" alt="PlayerInput Action Events"></p><ul><li>如果响应事件需要用到信号相关内容，可以使用传参</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyPlayerScript : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public void Fire(InputAction.CallbackContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Fire!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参数说明详见：<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#action-callbacks">Actions | Input System | 1.4.4 (unity3d.com)</a></p><h2 id="更灵活的方法"><a href="#更灵活的方法" class="headerlink" title="更灵活的方法"></a>更灵活的方法</h2><h1 id="Maps、Actions与Binding详解"><a href="#Maps、Actions与Binding详解" class="headerlink" title="Maps、Actions与Binding详解"></a>Maps、Actions与Binding详解</h1><p>Input Actions是为了将输入信号（物理）和对应的逻辑语义分离。比如角色有Run这个响应事件，不需要知道是按AD键还是触摸屏还是手柄的什么键，只需要知道这个Run被触发了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//传统方法：对每一种可能的按键进行检查 其是否触发动作</span><br><span class="line">var look = new Vector2();</span><br><span class="line"></span><br><span class="line">var gamepad = Gamepad.current;</span><br><span class="line">if (gamepad != null)</span><br><span class="line">    look = gamepad.rightStick.ReadValue();</span><br><span class="line"></span><br><span class="line">var mouse = Mouse.current;</span><br><span class="line">if (mouse != null)</span><br><span class="line">    look = mouse.delta.ReadValue();</span><br><span class="line"></span><br><span class="line">//改进：只看Look是否被触发</span><br><span class="line">myControls.gameplay.look.performed +=</span><br><span class="line">    context =&gt; look = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line">//而对应信号直接手动设置便可</span><br></pre></td></tr></table></figure><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/LookActionBinding.png" alt="Look Action Binding"></p><ul><li>一些要用到的名词及概念</li></ul><table><thead><tr><th align="center">名词</th><th align="center">概念</th></tr></thead><tbody><tr><td align="center">Action</td><td align="center"></td></tr><tr><td align="center">Binding</td><td align="center"></td></tr><tr><td align="center">Interaction</td><td align="center">input的模式</td></tr></tbody></table><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Actions的API中有三种关键的类：InputActionAsset、InputActionMap、InputAction。</p><p>其中每一个Action、Map在同类里面的名字必须是唯一的，也有id（改了名字也不会变）。<code>InputAction.name</code>,<code>InputAction.actionMap</code>,<code>InputAction.id</code>;</p><p><code>InputActionMap.name</code>,<code>InputActionMap.asset</code>,<code>InputActionMap.id</code>;</p><h2 id="创建Actions"><a href="#创建Actions" class="headerlink" title="创建Actions"></a>创建Actions</h2><h3 id="用Action编辑器"><a href="#用Action编辑器" class="headerlink" title="用Action编辑器"></a>用Action编辑器</h3><h3 id="在MonoBehaviours中嵌入"><a href="#在MonoBehaviours中嵌入" class="headerlink" title="在MonoBehaviours中嵌入"></a>在MonoBehaviours中嵌入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public MyBehavior : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public InputAction fireAction;</span><br><span class="line">    public InputAction lookAction;</span><br><span class="line"></span><br><span class="line">    public InputActionMap gameplayActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在编辑器可以直观更改：</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/MyBehaviorInspector.png" alt="MyBehavior Inspector"></p><ul><li>除此之外还要手动enable和disable</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MyBehavior : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        fireAction.performed += OnFire;</span><br><span class="line">        lookAction.performed += OnLook;</span><br><span class="line"></span><br><span class="line">        gameplayActions[&quot;fire&quot;].performed += OnFire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        fireAction.Enable();</span><br><span class="line">        lookAction.Enable();</span><br><span class="line"></span><br><span class="line">        gameplayActions.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnDisable()</span><br><span class="line">    &#123;</span><br><span class="line">        fireAction.Disable();</span><br><span class="line">        lookAction.Disable();</span><br><span class="line"></span><br><span class="line">        gameplayActions.Disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>涉及到Json和代码创建，暂不了解。</p><h2 id="使用Actions"><a href="#使用Actions" class="headerlink" title="使用Actions"></a>使用Actions</h2><ul><li>首先必须启用。一组启用比单个启用效率更高</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable a single action.</span></span><br><span class="line">lookAction.Enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable an en entire action map.</span></span><br><span class="line">gameplayActions.Enable();</span><br></pre></td></tr></table></figure><ul><li>启用时，Actions就能动态监听输入；根据输入设置中的更新模式来更新（Update等）</li></ul><h3 id="响应Actions"><a href="#响应Actions" class="headerlink" title="响应Actions"></a>响应Actions</h3><p>Actions并不会自动处理响应，而是通知你相应的输入信号已发生。响应的途径有以下几种：（前两种重点）</p><ul><li>每个Action有<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#action-callbacks"><code>started</code>, <code>performed</code>,<code>canceled</code> callback</a></li><li>每个Action Map有 <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#inputactionmapactiontriggered-callback"><code>actionTriggered</code> callback</a>.</li><li>The Input System has a global <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#inputsystemonactionchange-callback"><code>InputSystem.onActionChange</code> callback</a>.</li><li>You can <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#polling-actions">poll the current state</a> of an Action whenever you need it.</li><li><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#inputactiontrace"><code>InputActionTrace</code></a> can record changes happening on Actions.</li></ul><p><strong><u>Action callbacks</u></strong></p><h1 id="Input-Action-Assets-详解"><a href="#Input-Action-Assets-详解" class="headerlink" title="Input Action Assets 详解"></a>Input Action Assets 详解</h1><ul><li><p>内容：Input Actions以及对应的Bindings和Control Schemes。以<code>.inputactions</code>为文件扩展名，JSON格式。</p><blockquote><p>binding：</p></blockquote></li></ul><h2 id="创建asset"><a href="#创建asset" class="headerlink" title="创建asset"></a>创建asset</h2><p>在Project 创建，Input Actions。</p><h2 id="编辑asset"><a href="#编辑asset" class="headerlink" title="编辑asset"></a>编辑asset</h2><h2 id="使用asset"><a href="#使用asset" class="headerlink" title="使用asset"></a>使用asset</h2>]]></content>
    
    
    <summary type="html">新输入系统</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity的状态机实现</title>
    <link href="https://huangxinhere.github.io/2022/12/18/Unity%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/"/>
    <id>https://huangxinhere.github.io/2022/12/18/Unity%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-26T11:26:08.754Z</updated>
    
    <content type="html"><![CDATA[<p>上次接触状态机还是项目中用的插件，现在就从头到尾来捋一遍状态机。</p><h1 id="什么是状态机"><a href="#什么是状态机" class="headerlink" title="什么是状态机"></a>什么是状态机</h1><ul><li>当前只能有一个状态</li><li>状态可以进行切换</li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="概念抽象化"><a href="#概念抽象化" class="headerlink" title="概念抽象化"></a>概念抽象化</h2><p>从代码实现的目的来思考，首先想一下怎么抽象这个概念。可以先从两个方面来概括状态机：一个是某个独立的状态，一个是控制状态变换的东西。</p><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/1c5346cc9c45a3bb.png" alt="image-20221218102556949"></p><blockquote><p>对于每个状态来说，都有状态开始-进行中-结束这三种阶段，所以是每个状态独自处理的；而控制机就是控制状态切换，比如跑步状态Exit，则待机状态Enter。</p></blockquote><h2 id="代码思路设计"><a href="#代码思路设计" class="headerlink" title="代码思路设计"></a>代码思路设计</h2><ul><li>首先设计状态类。因为暂时没有逻辑控制，只是负责实现方法，没有方法的调用，所以相对简单。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/070f114163b13226.png" alt="image-20221218110352498"></p><blockquote><p>（第一次画类图有很多错误，接下来会逐步改正）但还有一个问题是，每个具体状态，其实还要相关的组件来进行控制。所以要获取组件的变量。如果这些类都不继承Monobehaviour的话，就需要通过方法来获得组件变量。所以更改参考PlayerState如下：</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/6448af0f1ed0b868.png" alt="image-20221218111830564"></p><blockquote><p>可见父类通过Initialize方法获得了组件变量作为字段，那么子类就可以直接用了。</p><p>对于父子类继承个人理解还不够深入。刚开始想为什么子类每个都要执行Initialize方法，执行一次父类不就有初始化的字段来供子类使用了吗？这个想法是错误的，首先实例化的是子类，父类并没有实例化，子类只是可以直接使用父类的模板（声明好的字段和方法）罢了。</p></blockquote><ul><li><p>然后是控制机的设计。控制机就是负责状态类方法的调用，来实现状态的执行和转换，所以控制机方法有：启动一个状态、转换状态；还有执行状态的各个阶段。</p><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/779d1d07a42df21e.png" alt="image-20221218115730714"></p><blockquote><p>到目前为止，初步的思路已经进行到这，但是实际能跑通吗？很明显不行，缺少了状态转换的关键步骤。从概念图来看控制机似乎独立于状态之外，其实要执行控制机的转换状态方法，还需要状态自身来调用控制机方法，为了实现这个，状态还得拥有控制机的实例来调用方法。</p></blockquote></li></ul><p>那么进一步思考，每个具体状态（Run、Idle等）都要用State Machine的实例，怎么获得呢？就如刚刚所言用Initialize方法获得。那么Initialize方法在哪调用呢？很明显归于控制机管理。State所需的组件变量就由控制机提供，这就进一步延申控制机的功能：综合组织状态变量，并提供相应的组件变量。</p><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/5b812dfca3ece921.png" alt="image-20221218120854571"></p><p>综合以上，控制机就是实现状态阶段执行方法、状态转换方法（父类）；获取所有状态实例，并传给它们所需的变量以及自身来供它们调用（子类）。</p><p>进一步理解父子类继承的特点应用：父类抽象方法，子类获得更具体的字段来执行方法……</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="IState"><a href="#IState" class="headerlink" title="IState"></a>IState</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IState</span><br><span class="line">&#123;</span><br><span class="line">    public void Enter();</span><br><span class="line">    public void Exit();</span><br><span class="line">    public void LoginUpdate();</span><br><span class="line">    public void PhysicsUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerState : ScriptableObject, IState</span><br><span class="line">&#123;</span><br><span class="line">    protected Animator animator;</span><br><span class="line">    protected PlayerInput input;</span><br><span class="line">    protected PlayerStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">    public void Initialize(Animator animator, PlayerInput input, PlayerStateMachine stateMachine)</span><br><span class="line">    &#123;</span><br><span class="line">        this.animator = animator;</span><br><span class="line">        this.input = input;</span><br><span class="line">        this.stateMachine = stateMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void Enter()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void Exit()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void LoginUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void PhysicsUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PlayerState-Idle"><a href="#PlayerState-Idle" class="headerlink" title="PlayerState_Idle"></a>PlayerState_Idle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]</span><br><span class="line">public class PlayerState_Idle : PlayerState</span><br><span class="line">&#123;</span><br><span class="line">    public override void Enter()</span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(&quot;Idle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void LoginUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        if (input.Move)</span><br><span class="line">        &#123;</span><br><span class="line">            stateMachine.SwitchState(typeof(PlayerState_Run));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="StateMachine"><a href="#StateMachine" class="headerlink" title="StateMachine"></a>StateMachine</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class StateMachine : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    IState currentState;</span><br><span class="line">    protected Dictionary&lt;System.Type, IState&gt; stateTable;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.LoginUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void FixedUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void SwitchOn(IState newState)</span><br><span class="line">    &#123;</span><br><span class="line">        currentState = newState;</span><br><span class="line">        currentState.Enter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SwitchState(IState newState)</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.Exit();</span><br><span class="line">        SwitchOn(newState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SwitchState(System.Type newStateType)</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.Exit();</span><br><span class="line">        SwitchOn(stateTable[newStateType]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PlayerStateMachine"><a href="#PlayerStateMachine" class="headerlink" title="PlayerStateMachine"></a>PlayerStateMachine</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerStateMachine : StateMachine</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField] PlayerState[] states;</span><br><span class="line">    Animator animator;</span><br><span class="line">    PlayerInput input;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponentInChildren&lt;Animator&gt;();</span><br><span class="line">        input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line"></span><br><span class="line">        stateTable = new Dictionary&lt;System.Type, IState&gt;(states.Length);</span><br><span class="line"></span><br><span class="line">        foreach (PlayerState state in states)</span><br><span class="line">        &#123;</span><br><span class="line">            state.Initialize(animator, input, this);</span><br><span class="line">            stateTable.Add(state.GetType(), state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        SwitchOn(stateTable[typeof(PlayerState_Idle)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码实现过程中的一些技巧"><a href="#代码实现过程中的一些技巧" class="headerlink" title="代码实现过程中的一些技巧"></a>代码实现过程中的一些技巧</h1><h2 id="字典管理"><a href="#字典管理" class="headerlink" title="字典管理"></a>字典管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//前提是每个状态都独立不同（类型不同）</span><br><span class="line">Dictionary&lt;System.Type, IState&gt; stateTable;</span><br><span class="line"></span><br><span class="line">//取键方便</span><br><span class="line">stateTable[typeof(PlayerState_Idle)]</span><br></pre></td></tr></table></figure><p>System.Type是类的类型。</p><h2 id="私有但是可以在编辑器修改的变量"><a href="#私有但是可以在编辑器修改的变量" class="headerlink" title="私有但是可以在编辑器修改的变量"></a>私有但是可以在编辑器修改的变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SerializeField] float resetTime = 3.0f;</span><br></pre></td></tr></table></figure><h2 id="OnTriggerEnter检查碰撞的是否是玩家"><a href="#OnTriggerEnter检查碰撞的是否是玩家" class="headerlink" title="OnTriggerEnter检查碰撞的是否是玩家"></a>OnTriggerEnter检查碰撞的是否是玩家</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这种写法直接获得了对方的组件</span><br><span class="line">private void OnTriggerEnter(Collider other)</span><br><span class="line">&#123;</span><br><span class="line">    if (other.TryGetComponent&lt;PlayerController&gt;(out PlayerController player))</span><br><span class="line">    &#123;</span><br><span class="line">       //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Invoke和协程"><a href="#Invoke和协程" class="headerlink" title="Invoke和协程"></a>Invoke和协程</h2><ul><li>Invoke</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke(nameof(MethodName),time);//nameof()又比直接字符串好用</span><br></pre></td></tr></table></figure><p>短时间内调用次数较多的时候，Invoke性能较差。用协程比较好。</p><h2 id="OnGUI来进行调试"><a href="#OnGUI来进行调试" class="headerlink" title="OnGUI来进行调试"></a>OnGUI来进行调试</h2><p>将调试信息显示在游戏运行画面上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void OnGUI()</span><br><span class="line">&#123;</span><br><span class="line">    Rect rect = new Rect(200, 200, 200, 200);</span><br><span class="line">    string message = &quot;...&quot;;</span><br><span class="line">    GUIStyle style = new GUIStyle();</span><br><span class="line"></span><br><span class="line">    style.fontSize = 20;</span><br><span class="line">    style.fontStyle = FontStyle.Bold;</span><br><span class="line"></span><br><span class="line">    GUI.Label(rect, message, style);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="碰撞层"><a href="#碰撞层" class="headerlink" title="碰撞层"></a>碰撞层</h2><p>如果不想每次碰撞都检测是否为玩家对象那么麻烦的话，可以将Interactable的对象设置成只和Player层碰撞。</p><p><img src="/2022/12/18/Unity%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/hexo_github_blog\source_posts\Unity的状态机实现.assets\image-20221225102722467.png" alt="image-20221225102722467"></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h2 id="获取脚本实例的方法"><a href="#获取脚本实例的方法" class="headerlink" title="获取脚本实例的方法"></a>获取脚本实例的方法</h2><ul><li><p>声明public或SerializeField，在编辑器里面赋予</p></li><li><p>组件或脚本：GetComponent </p></li><li><p>类的静态字段（如单例等）</p></li><li><p>Scriptable，可在资产中直接创建实例</p><ul><li>这样可以将多种实例作为数据保存下来，也可以方便在编辑器里面编辑</li></ul></li><li><p>一些API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.GameObject.Find() 通过名字或路径</span><br><span class="line">GameObject.Find(&quot;...&quot;)//方便但效率低；无法找隐藏物体</span><br><span class="line"></span><br><span class="line">//2.Transform.Find()</span><br><span class="line">GameObject root = GameObject.Find(&quot;MapRoot&quot;);//根下面的（非）隐藏物体都可找到；路径/名字</span><br><span class="line"></span><br><span class="line">GameObject map =  root.transform.Find(&quot;map&quot;).gameObject;       </span><br><span class="line">map.SetActive(true);</span><br><span class="line"></span><br><span class="line">//3.通过类型查找（FindWithTag方法）</span><br><span class="line">GameObject.FindGameObjectsWithTag()</span><br><span class="line">Resources.FindObjectsOfTypeAll()</span><br><span class="line">    </span><br><span class="line">//4.通过标签查找（FindObjectOfType方法）</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/s1314_JHC/article/details/80811834">(40条消息) Unity中各种查找物体的方法_s1314_JHC的博客-CSDN博客</a></p></li></ul><h2 id="退出应用"><a href="#退出应用" class="headerlink" title="退出应用"></a>退出应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//可以退出编辑器或实际应用</span><br><span class="line">public static void QuitGame()</span><br><span class="line">&#123;</span><br><span class="line">    #if UNITY_EDITOR</span><br><span class="line">        UnityEditor.EditorApplication.isPlaying = false;</span><br><span class="line">    #else </span><br><span class="line">        Application.Quit();</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>非常方便方法的归类和管理。一些重复被使用的方法，可以在类里面（继承或不继承Mono..）声明静态方法。</p><h2 id="控制UI的显示和关闭"><a href="#控制UI的显示和关闭" class="headerlink" title="控制UI的显示和关闭"></a>控制UI的显示和关闭</h2><p>以前都是习惯直接把物体SetActive的，这样的问题是不方便挂载脚本也就不能独立实现功能了。所以可以把Canvas组件关闭，这样就方便许多，不容易出错。</p>]]></content>
    
    
    <summary type="html">关于Unity2D物理系统的深入学习</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hx&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/32690cfd58b9093251b720ee371b49ad</icon>
  <subtitle>aha</subtitle>
  <link href="https://huangxinhere.github.io/atom.xml" rel="self"/>
  
  <link href="https://huangxinhere.github.io/"/>
  <updated>2023-02-23T12:05:38.626Z</updated>
  <id>https://huangxinhere.github.io/</id>
  
  <author>
    <name>(●ˇ∀ˇ●)</name>
    <email>1159390360@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2023-02-22T16:00:00.000Z</published>
    <updated>2023-02-23T12:05:38.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><table><thead><tr><th align="center">区别</th><th align="center">UDP</th><th align="center">TCP</th></tr></thead><tbody><tr><td align="center">是否连接</td><td align="center">不连接</td><td align="center">面向连接</td></tr><tr><td align="center">是否可靠</td><td align="center">不可靠</td><td align="center">可靠传输；使用流量控制和拥塞控制</td></tr><tr><td align="center">连接对象个数</td><td align="center">支持一对一，一对多，多对一，多对多交互通信</td><td align="center">仅支持一对一通信</td></tr><tr><td align="center">传输方式</td><td align="center">面向报文</td><td align="center">面向字节流</td></tr><tr><td align="center">数据边界</td><td align="center">保存数据边界</td><td align="center">不保存数据边界</td></tr><tr><td align="center">速度</td><td align="center">快</td><td align="center">慢</td></tr><tr><td align="center">发送消耗</td><td align="center">轻量级（UDP的传输信息不承担任何间接创造连接</td><td align="center">重量级</td></tr><tr><td align="center">首部开销</td><td align="center">小，仅8个字节</td><td align="center">大，最小20字节，最大60字节</td></tr><tr><td align="center">有序性</td><td align="center">不保证</td><td align="center">TCP 保证了消息的有序性，即使到达客户端顺序不同，TCP 也会排序。</td></tr><tr><td align="center">应用场景</td><td align="center">IP电话，视频会议，直播，以及FPS竞技类的使用UDP帧同步</td><td align="center">要求可靠传输的应用例如文件传输，以及MMO类的TCP状态同步</td></tr></tbody></table><h1 id="TCP-IP协议栈各个层次及分别的功能"><a href="#TCP-IP协议栈各个层次及分别的功能" class="headerlink" title="TCP/IP协议栈各个层次及分别的功能"></a>TCP/IP协议栈各个层次及分别的功能</h1><p><img src="https://img-blog.csdnimg.cn/d1adcd8356f248f1945646dbbb74bb2b.png" alt="img"></p><ul><li>应用层：用来处理特定的应用，<u>针对不同的应用提供了不同的协议</u>， 例如进行文件传输时用到的FTP协议，发送email用到的 SMTP等。对应协议：FTP、HTTP、SMTP、DNS等。</li><li>传输层:  主要功能是提供<u>应用程序之间的通信</u>，这一层主要是TCP/UDP协议。</li><li>网络层:  处理分组在<u>网络中的活动</u>，例如路由选择和转发等，这一 层主要包括IP协议、ARP、ICMP协议等。</li><li>网络接口层：这是协议栈的最低层，对应OSI的物理层和数据链路层，  主要完成<u>数据帧的实际发送和接收</u>。</li></ul><h1 id="TCP的三握四挥"><a href="#TCP的三握四挥" class="headerlink" title="TCP的三握四挥"></a>TCP的三握四挥</h1><p><a href="https://blog.csdn.net/qq_33426324/article/details/105344168">(42条消息) 为什么TCP需要三次握手，四次挥手？_小菜鸡的日常问题的博客-CSDN博客_计算机网络 三次握手、四次挥手、为啥要四次</a></p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ul><li>概念</li></ul><p><img src="https://img-blog.csdnimg.cn/30c2c4802d0b4622a3ecee2a2e66bd8c.png" alt="img"></p><p>-首先Client端<strong>发送连接请求</strong>报文（只是请求，没有建立连接？）；</p><blockquote><p>客户端的发送能力 和 服务器的接受能力没有问题。</p><p>”客户端：我只知道我发送出去了。“</p></blockquote><p>-Server 段<strong>接收链接后回复</strong>ACK 报文，并为这次连接<strong>分配资源</strong>；</p><blockquote><p>服务器的发送能力和接收能力没有问题；</p><p>客户端的发送和接收能力没有问题；</p><p>但此时服务器不能确认客户端的接受能力有没有问题。</p><p>”客户端：我发送出去了；而且我收到了回复。“</p><p>”服务器：我收到了；我告诉客户端我收到了，还想问他：你是真的想和我连接吗？“</p></blockquote><p>-Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并<strong>分配资源</strong>，这样 TCP 连接就建立了。</p><blockquote><p>通过这次接收，服务器确认客户端的接收能力和发送能力没有问题；</p><p>本身的发送和接收能力也没有问题。</p><p>”服务器/客户端：都要确定发送出去，收到并且对方回复“</p></blockquote><p><strong>因此需要三次握手才能确认客户端和服务器的发送、接收能力是否正常</strong></p><ul><li><p>为什么要三次握手？</p><ul><li><p>如果只有一次握手，Client不能确定与Server的单向连接，更加不能确定Server与Client单向连接；</p></li><li><p>如果只有两次握手，Client确定与Server的单向连接，但是Sevrer不能确定与Client的单向连接；</p></li><li><p>只有三次握手，Client与Server才能相互确认双向连接，实现双方的数据传输。</p></li></ul></li><li><p>两次握手不行吗？</p><p>三次握手是为了<strong>防止当已失效的连接请求报文段</strong>突然又传到服务端，造成双方的不一致，导致资源的浪费</p><p>“已失效的链接请求报文段”是指：当客户端发送一个SYN报文，由于阻塞或某些原因在网络中滞留，导致客户端认为丢包了(其实没有丢)，于是又重新发送一个新的SYN报文，若这次顺利完成，双方建立的链接。</p><p>此时网络中存在隐患那个滞留的SYN文，若这个SYN在连接期间被服务接收到，服务器会无视它，</p><p>但若在连接释放之后接收到此SYN报文，服务器会认为客户端又向他发出连接请求，于是并返回一个SYNACK报文回应。若此时不采用三次握手，就建立新的连接。<br>这时服务器认为已完成连接，向客户端发送数据，而客户端处于Closed状态会丢弃这些数据，<br>也不发送数据，则服务端一直等待客户端发送数据，导致浪费资源。</p></li><li><p>三次握手过程中可以携带数据吗？</p><p>第三次握手的时候，可以携带数据，但是第一二次握手不可以携带数据。</p><p>第一握手不可以存放数据，其中简单的原因是会让服务器更加容易受到攻击。<br>而对于第三次握手的话，因为此时的客户端ESTABLISHED状态，对于客户端来讲，它已经建立起来了连接，并且也已经知道服务器的接受、发送能力没有问题，所以携带数据也没有问题</p></li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ul><li><p>关闭连接时，服务端收到客户端的 FIN 报文时，仅表示对方不再发送数据，但仍然能够接收数据。此时，服务端不一定将全部数据都发送给了客户端。</p></li><li><p>因此服务端关闭有两种方式：</p><ul><li>立即关闭；</li><li><u>继续发送一些数据给客户端</u>后，再发送 FIN 报文给客户端（表示同意关闭连接），是否立刻关闭发送数据通道，需交由上层应用决定;</li></ul></li></ul><p>所以，客户端的 ACK 和 FIN 一般都会分开发送，这里就会导致次数增加一</p><p>数据传输完毕后，双方均可释放连接。起初，客户端和服务端均处于 ESTABLISHED 状态，然后是客户端主动关闭，服务器被动关闭.<br><img src="https://img-blog.csdnimg.cn/7d3aa066c42843d9b03f0be303cd172c.png" alt="img"></p><ul><li><p>客户端发送第一次挥手，之后由 ESTABLISHED 状态转为 FIN_WAIT1 状态</p></li><li><p>服务器收到客户端的第一次挥手之后，发送第二次挥手给服务器，服务器进入 CLOSE_WAIT 状态，等待服务器自身的 SOCKET 关闭等处理</p></li><li><p>客户端收到服务器的第二次挥手，进入 FIN_WAIT2 状态，等待服务器关闭</p></li></ul><p>服务器发送第三次挥手，然后进入 LAST_ACK 状态</p><p>客户端收到第三次挥手，发送第四次挥手，客户端进入 TIME_WAIT 状态；</p><p>服务器收到第四次挥手，进入 CLOSED 状态，客户端等待 2MSL 后，进入 CLOSED 状态</p><ul><li><strong>为什么要四次挥手（常问）</strong></li></ul><p>服务端在收到客户端的释放报文时，可能自己的数据报还没有发完，所以不会直接返回FIN+ACK，而只先返回一个ACK，表示自己收到了客户端的释放请求（第二次挥手）。等到服务端报文发完以后，在返回FIN（第三次挥手）。</p><p><strong>那么，我们是否可以在服务器端数据传送完成后，再返回FIN+ACK呢？中间就可以省略一次ACK了？（省略第二次挥手）</strong></p><p>​    试想一下，如果服务端还有很多数据需要传送，耗时长，客户端在发送释放报文后，一直没有收到反馈，那么他会认为服务端没有收到我的FIN，因此就会不停的重发FIN。（第一次挥手）</p><p>​    所以最好的办法就是，客户端发送FIN，服务端回复ACK，表示我已经收到了，但是我在忙，你等等，我处理完成后联系你。服务端数据传送完成后，发送FIN给客户端，客户端再回复ACK。</p>]]></content>
    
    
    <summary type="html">关于计算机网络知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构与算法 知识整理</title>
    <link href="https://huangxinhere.github.io/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://huangxinhere.github.io/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2023-02-21T16:00:00.000Z</published>
    <updated>2023-02-27T12:55:55.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算与应用"><a href="#位运算与应用" class="headerlink" title="位运算与应用"></a>位运算与应用</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="负数怎么表示？"><a href="#负数怎么表示？" class="headerlink" title="负数怎么表示？"></a>负数怎么表示？</h3><p>计算机中的负数表示，是以补码的形式呈现的。</p><p><img src="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20230221152901899.png" alt="image-20230221152901899"></p><p>这样方便计算机进行直接运算。</p><h2 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h2><ul><li>按位与：0&amp;0=0，0&amp;1=0，1&amp;1=0    全为0才是0</li><li>按位或：0|0=0，0|1=1，1|1=1       全为1才是1</li><li>按位异或：0^0=0，0^1=0，1^1=1    异己为0</li><li>按位非：<del>1=0，</del>0=1</li><li>有符号右移：&gt;&gt;（若正数，高位补0，负数则高位补1）</li><li>有符号左移：&lt;&lt;</li><li>无符号右移：&gt;&gt;&gt;（不论正负，高位均补0）</li></ul><h2 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h2><p>按位与计算比取模运算快；哈希表；记录状态值（比如int有32位，每一位都可以记录0，1两个状态值，这样节省空间）；可逆加密……</p><ul><li>优势：计算快，节约空间</li><li>劣势：不直观</li></ul><h2 id="常见简单面试题"><a href="#常见简单面试题" class="headerlink" title="常见简单面试题"></a>常见简单面试题</h2><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p>a%(2^n) = a&amp;(2^n-1)</p><h3 id="判断奇偶数"><a href="#判断奇偶数" class="headerlink" title="判断奇偶数"></a>判断奇偶数</h3><p>4 = 100</p><p>5 = 101</p><p>6 = 110</p><p>7 = 111</p><p>分别&amp;1（也就是00000001），最后一位判断</p><h3 id="实现数字翻倍或减半"><a href="#实现数字翻倍或减半" class="headerlink" title="实现数字翻倍或减半"></a>实现数字翻倍或减半</h3><p>右移或左移1位</p><h3 id="交换两数"><a href="#交换两数" class="headerlink" title="交换两数"></a>交换两数</h3><p>a = a ^ b</p><p>b = a ^ b (= (a ^ b) ^ b = a ^ (b ^ b) = a)    //符合交换律，自己异或自己就是1</p><p>a = a ^ b (= (a ^ b) ^ a = (a ^ a) ^ b = b)</p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><ul><li><p>二进制体现的特点</p><ul><li>末尾为1就是奇数，是0则为偶数；其中偶数n比n/2的二进制多一个0，奇数比前一个偶数多一个1</li></ul></li><li><p>按位与的特点</p><ul><li>只有1&amp;1才为1，其余为0；用来保留1，抹去其它位（如判断奇偶数）</li><li>n&amp;(n-1)能去掉二进制表示的最后一个“1”；例如21&amp;20=20(3个1)，20&amp;19=16(2个1),16&amp;15=0(1个1)，那么分别得16有1个1，20有2个1,21有3个1</li></ul></li><li><p>按位或的特点</p><ul><li>只有0|0才为0，其余为1；或许也是能保留0，</li></ul></li><li><p>按位异或的特点</p><ul><li>一个数和本身异或一次为0；结合交换律；（利用或消去重复数字）</li><li>比对两个位是否相同</li></ul></li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="BF算法（暴力算法"><a href="#BF算法（暴力算法" class="headerlink" title="BF算法（暴力算法"></a>BF算法（暴力算法</h3><h3 id="BP算法"><a href="#BP算法" class="headerlink" title="BP算法"></a>BP算法</h3><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>多阶段决策问题</li><li>将过程分为若干个互相联系的阶段，在每一个阶段都要作出决策；而本阶段的决策常常影响到下一个阶段的决策，从而完全确定了一个过程的活动路线</li></ul><p>（相比于递归，递归划分的小问题都是固定的解决模式，而动态规划有多种策略要找出最优）</p><h2 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h2><h3 id="确定状态转移公式"><a href="#确定状态转移公式" class="headerlink" title="确定状态转移公式"></a>确定状态转移公式</h3><ul><li>当前的状态是怎么由前面的状态变化而来</li><li>与之相关联的辅助的dp数组以及下标的含义</li><li>（往往是最难的一步）</li></ul><h3 id="初始化dp数组"><a href="#初始化dp数组" class="headerlink" title="初始化dp数组"></a>初始化dp数组</h3><h3 id="根据题目条件确定遍历顺序，并实现状态转移公式"><a href="#根据题目条件确定遍历顺序，并实现状态转移公式" class="headerlink" title="根据题目条件确定遍历顺序，并实现状态转移公式"></a>根据题目条件确定遍历顺序，并实现状态转移公式</h3><h2 id="什么问题适合动态规划？"><a href="#什么问题适合动态规划？" class="headerlink" title="什么问题适合动态规划？"></a>什么问题适合动态规划？</h2><p>多阶段决策最优解模型</p><ul><li>最优子结构</li><li>无后效性（只关心前面状态的值；前者状态确定后和后者无关）</li><li>重复子问题  </li></ul>]]></content>
    
    
    <summary type="html">关于数据结构与算法知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>C#知识整理</title>
    <link href="https://huangxinhere.github.io/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://huangxinhere.github.io/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2023-02-19T16:00:00.000Z</published>
    <updated>2023-02-27T03:05:43.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引用类型，值类型"><a href="#引用类型，值类型" class="headerlink" title="引用类型，值类型"></a>引用类型，值类型</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>值类型：byte、short、int、long、float、 double、bool、char / struct、 enum…;</li><li>引用类型：string、object、delegate、interface、class、array…</li></ul><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>存储</p><ul><li><p>地方：值类型存储在栈中，引用类型存储在堆中；</p></li><li><p>方式：值类型变量声明后，不管是否已经赋值，编译器为其分配内存；当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时<strong>并没有为其分配堆上的内存空间</strong>。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配）。</p></li><li><p>速度：值类型存储快，引用类型存储慢</p></li></ul></li><li><p>意义：值类型表示实际数据，引用类型表示指向在内存堆中的指针和引用</p></li><li><p>释放：值类型在栈中可以自动释放，引用类型在堆中需要GC来释放</p></li><li><p>父类：值类型继承于 System.ValueType，（System.ValueType继承于System.Object)，引用类型继承于System.Object</p></li></ul><h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><ul><li>引用类型在实例化时，先<u>在栈内开辟空间</u>，用于存储堆中对象的地址，然后<u>在堆内开辟空间</u>，存储引用对象。</li><li>而值类型直接在栈中开辟空间存储对象。值类型也有引用地址，但都在栈内的同一空间。</li><li>在参数对象进入方法体内，实则是在栈中开辟了<u>新的临时空间</u>。（也就是参数对象的副本）栈内值类型的修改，由于栈中地址不同，所以值类型不会影响到主体。而引用类型的存储数据是一个堆内的地址，所以对于引用类型的修改是直接修改堆内的对象。</li><li>值类型对象中的引用类型在堆中（struct中定义的string等）；引用类型对象中的值类型也在堆中（class中的int等。</li></ul><p>拓展传送门：</p><p><a href="https://dpc520.blog.csdn.net/article/details/119285430?spm=1001.2014.3001.5506">(42条消息) C# “值类型“和“引用类型“在内存的分配_生产队的驴.的博客-CSDN博客_c# 值类型和引用类型的内存分配</a></p><p><a href="https://blog.csdn.net/qiaoquan3/article/details/51202926">(42条消息) C#详解值类型和引用类型区别_HawkJony的博客-CSDN博客_值类型 引用类型 区别</a>【超详细，待研究】</p><h1 id="String引用类型的特殊性"><a href="#String引用类型的特殊性" class="headerlink" title="String引用类型的特殊性"></a>String引用类型的特殊性</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>字符串每重新赋值，不会覆盖原值，而是开辟新空间存储；</p><p>如果内容相同，不同栈地址会指向同一个堆地址；</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>若对字符串频繁修改的时候，利用StringBuilder代替String；</p><h2 id="StringBuilder的底层实现"><a href="#StringBuilder的底层实现" class="headerlink" title="StringBuilder的底层实现"></a>StringBuilder的底层实现</h2><p>StringBuilder不在内存中创建新对象，而是动态扩展内存以容纳修改后的字符串。在扩容的期间，会丢弃原数组内的内容，将内容拷贝到新数组。</p><p><a href="https://zhuanlan.zhihu.com/p/556672400">C# StringBuilder 使用 - 知乎 (zhihu.com)</a></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>StringBuffer是线程安全，一般用于多线程（？？</p><p>StringBuilder是非线程安全，所以性能略好，一般用于单线程</p><h2 id="用StringBuilder拼接字符串就一定比string要好吗？"><a href="#用StringBuilder拼接字符串就一定比string要好吗？" class="headerlink" title="用StringBuilder拼接字符串就一定比string要好吗？"></a>用StringBuilder拼接字符串就一定比string要好吗？</h2><p>答：不一定，stringbuilder有自身的GC消耗</p><p>​    极少拼接（或者短字符串）的情况下 String甚至优于StringBuilder，因为String是公用API，通用性好，用途广泛，读取性能高，占用内存较小，Stringbuilder初始化花费时间更大。</p><h2 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h2><p>字符串池有什么用，原理是什么？</p><ul><li>字符串池是CLR一种针对于反复修改字符串对象的优化措施，作用能够一定程度减少内存消耗。</li><li>原理是内部开辟容器通过键值对的形式注册字符串对象，键是字符串对象的内容，值是字符串在托管堆上的引用。这样当新创建的时候，会去检查，如果不存在就在这个容器中开辟空间存放字符串。</li></ul><p><a href="https://blog.csdn.net/qq826364410/article/details/87994993">(42条消息) C#–字符串常量池_鹅厂程序小哥的博客-CSDN博客_常量池 c#</a></p><h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>unity内部有两个内存管理池：堆内存和栈内存。</p></li><li><p>存储的数据：栈内存(stack)主要用来存储<u>较小的和短暂的</u>数据，堆内存(heap)主要用来存储<u>较大的和存储时间较长的</u>数据。unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。</p></li><li><p>标记</p><ul><li><p>状态：只要变量处于激活状态，则其占用的内存会被标记为使用状态，该部分的内存处于被分配的状态。<br>一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。</p></li><li><p>处理效率：处于栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。不再使用的内存只会在GC的时候才会被回收。</p></li></ul></li><li><p>垃圾回收<u>主要是指<strong>堆上的</strong></u><u>内存分配和回收</u>，unity中会定时对堆内存进行GC操作。</p></li></ul><h2 id="GC算法介绍"><a href="#GC算法介绍" class="headerlink" title="GC算法介绍"></a>GC算法介绍</h2><p>​    C#：分代算法，有内存整理，避免碎片化。有压缩。</p><p>​    0代，未被标记回收的新分配对象</p><p>​    1代，上次垃圾回收中没有被回收的对象</p><p>​    2代，在一次以上的垃圾回收之后仍然没有被回收的对象</p><p><a href="https://blog.csdn.net/qq_41719595/article/details/121016454">(42条消息) C#——垃圾回收(GC)_面向大象编程的博客-CSDN博客_c# gc</a></p><h2 id="简易流程"><a href="#简易流程" class="headerlink" title="简易流程"></a>简易流程</h2><ul><li><p>GC会检查堆内存上的每个存储变量;</p></li><li><p>对每个变量会检测其引用<u>是否处于激活状态</u>;</p></li><li><p>如果变量的引用不再处于激活状态，则会被标记为可<u>回收</u>;</p></li><li><p>被标记的变量会<u>被移除</u>，其所占有的内存会被回收到堆内存上。</p></li></ul><h2 id="流程详细介绍"><a href="#流程详细介绍" class="headerlink" title="流程详细介绍"></a>流程详细介绍</h2><ul><li><p>当新建立引用类型对象时，检查0代储存空间<u>是否有充足的空间</u>使得新的引用类型对象存储。若没有，将0代对象进行<u>遍历检查</u>，是否有被调用（激活），没有被调用的对象被标记“可回收”。</p></li><li><p>遍历完成后，将所有被“可回收”的对象进行垃圾<strong>回收</strong>，释放的空间返回给0代储存区，其他的对象的对象<strong>迁移</strong> 到1代储存区，标记为“1代对象”，此时该对象是分散分布的，要进行 压缩 操作，使得1代对象顺序紧密排列。新对象存储于0代储存空间，标记为0代对象。</p></li><li><p>当1代空间满了时，将1代对象按照上述操作遍历，迁移，压缩到2代储存区，标记为2代对象，同时0代迁移压缩到1代。</p></li></ul><h2 id="GC带来的问题"><a href="#GC带来的问题" class="headerlink" title="GC带来的问题"></a>GC带来的问题</h2><p>GC在unity内存管理中，会带来以下问题：</p><ul><li><p>游戏性能：GC操作是一个极其耗费事件的操作，<u>堆内存上的变量或者引用越多</u> 则导致<u>遍历检查时的操作变得十分缓慢</u>，使得游戏运行缓慢，例如当CUP处于游戏性能的关键时刻，任何一个操作就会导致游戏帧率下降，造成极大的影响。</p></li><li><p>游戏内存：（unityGC采用的是<strong>非分代非压缩的标记清除算法</strong>）GC操作会产生“<strong>内存碎片化</strong>”。当一个单元内存从堆中分配出来，其大小取决于存储变量的大小。当内存被回收到堆上时，有可能被堆内存分割成碎片化的单元。（就是说总容量大小时固定的，但是单元内存较小。例如房子很大，房间很小，找不到合适的房间）即下次分配时找不到合适的储存单元，<u>就会触发GC操作，或者堆内存扩容操作</u>，导致GC频发发生和游戏内存越来越大。</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/265217138">Unity GC 学习总结 - 知乎 (zhihu.com)</a>（看得不是特别仔细，待进一步深究；有GC的优化，特别技巧等）</p><h2 id="何时触发"><a href="#何时触发" class="headerlink" title="何时触发"></a>何时触发</h2><ul><li><p>在堆内存上进行内存分配操作，而<u>内存不够的时候</u>都会触发垃圾回收来利用闲置的内存;</p></li><li><p>GC会<u>自动地触发</u>，不同平台运行频率不—样;</p></li><li><p>GC可以<u>被强制执行</u>。</p></li></ul><h2 id="如何避免GC？（装箱拆箱介绍-对象池介绍-泛型介绍）"><a href="#如何避免GC？（装箱拆箱介绍-对象池介绍-泛型介绍）" class="headerlink" title="如何避免GC？（装箱拆箱介绍/对象池介绍/泛型介绍）"></a>如何避免GC？（装箱拆箱介绍/对象池介绍/泛型介绍）</h2><ul><li><u>减少临时变量的使用</u>，多使用公共对象，多利用缓存机制。（将容器定义到函数外，用到容器的时候进行修改即可）</li><li>减少new对象的次数</li><li>对于<u>大量字符串拼接</u>时，将StringBuilder代替String。（string不可修改性，修改即创建一个新的string对象，旧的直接抛弃等待GC，但少量字符串拼接用string，性能优于stringbuilder）</li><li>使用扩容的容器时，例如：List，StringBuilder等，定义时尽量根据存储变量的内存大小定义储存空间，<u>减少扩容的操作</u>。（扩容后，旧的容器直接抛弃等待GC）</li><li><u>代码逻辑优化</u>：例如计时器当大于1s后才进行文本修改，而不是每帧都修改，或者禁止在关键时候GC，影响游戏性能，可以在加载页面或者进度条的时候GC</li><li><u>利用对象池</u>：对象池是一种Unity经常用到的内存管理服务，<strong>针对经常消失生成的对象</strong>，例如子弹，怪物等，作用在于<strong>减少创建每个对象的系统开销</strong>。在我们想要对象消除时，不直接Destory，而是隐藏起来SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。</li><li><u>减少装箱拆箱操作</u>。<ul><li>装箱拆箱介绍：将值类型转换为 object 类型 或由此值类型实现的任何接口类型的过程</li><li>装箱的底层操作：去堆内存<strong>new一个Object类对象</strong>——把值类型的<strong>数据存入</strong>到堆中的Object对象中——将堆上创建的对象的<strong>地址返回</strong>给引用类型变量；拆箱是从 object 类型到值类型或从接口类型 到实现该接口的值类型的显式转换</li><li>拆箱的底层操作：获取已装箱的对象的地址检查对象实例，以<strong>确保</strong>它是给定值类型的装箱值——将该值从实例<strong>复制</strong>到值类型变量中</li><li>产生GC的原因：</li><li>在Unity的装箱操作中，对于值类型会在堆内存上分配一个System.Object类型的引用来封装该值类型变量，其<strong>对应的缓存就会产生内存垃圾</strong>。装箱操作是<u>非常普遍的一种产生内存垃圾的行为</u>，即使代码中没有直接的对变量进行装箱操作，在插件或者其他的函数中也有可能会产生。最好的解决办法是尽可能的避免或者移除造成装箱操作的代码。</li><li>泛型介绍：处理多个代码对不同的数据类型执行相同指令的操作。也可以理解为：多个类型共享一组代码。<ul><li>泛型类不是实际的类，而是类的模板。</li><li>泛型不会进行装箱拆箱，所以性能很高，且规定了变量类型的限制，编译器可以在一定程度上验证类 型的假设，提高了程序类型的安全性，因此在使用容器时多使用 带有泛型的容器例如（ArrayList与List<int>)。</int></li></ul></li></ul></li><li>协程：yeild return 0 会产生装箱拆箱，可以替换为 yeild return null；</li><li>减少不必要的Log；</li></ul><h1 id="面向对象的三大特征：继承、封装、多态"><a href="#面向对象的三大特征：继承、封装、多态" class="headerlink" title="面向对象的三大特征：继承、封装、多态"></a>面向对象的三大特征：继承、封装、多态</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>提高代码重用度，增强软件可维护性的重要手段；</li><li>符合开闭原则（软件中的对象扩展是开放的，修改是关闭的）；</li><li>继承就是把子类的公共属性集合起来（变量，方法等）共同管理，这些公共属性设置为父类，C#的继承是单继承，但继承有传递性：A继承B，B继承C，A可以调用C#中的方法。</li></ul><h3 id="派生类继承基类"><a href="#派生类继承基类" class="headerlink" title="派生类继承基类"></a>派生类继承基类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">int</span> id</span>) : <span class="title">base</span>(<span class="params">name, age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><ul><li><p>override：对基类中<u>同名方法</u>的<strong>新实现</strong>；同时基类中的同名方法必须声明为 virtual 或 abstract 类型</p><ul><li>默认的 C# 方法并非 virtual ，因此不能重写。</li><li>基类方法的可访问级别并不因重写它的方法而改变，他们的访问修饰符相同。</li><li>new 、 static 和 virtual 关键字不能与 override 访问修饰符一同使用</li></ul></li><li><p>virtual：用于对一个类中<strong>可修改的方法</strong>的声明，这种方法称为虚拟方法；比如当某个类实现了方法A，并将它声明为virtual，那么A还能被子类方法修改成A‘。编译的时候才会判定要执行的是A还是A’，这体现了多态。而abstract修饰的方法没有方法体，且一定要被继承实现。</p><ul><li><p>详细过程</p><ul><li><p>当调用一个对象的函数时，系统会直接去检查这个对象声明定义的类，即声明类，看所调用的函数是否为虚函数。如果不是虚函数，那么它就直接执行该函数。</p></li><li><p>而如果有virtual关键字，也就是一个虚函数，那么这个时候它就不会立刻执行该函数了，而是转去检查对象的【实例类】。</p></li><li><p>在这个实例类里，他会检查这个实例类的定义中是否有重新实现该虚函数（通过override关键字），如果有，则马上执行该实例类中的这个重新实现的函数。而如果没有，系统会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载了该虚函数的父类为止，然后执行该父类里重载后的函数。</p></li></ul></li><li><p>virtual访问修饰符不能与static和override等访问修饰符一同使用；</p></li><li><p>实现原理：每个虚函数都会有一个与之对应的虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个对象的虚函数入口地址。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。 </p></li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PrintFields();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintFields</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> y;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrintFields</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;,y=&#123;1&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> B();             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出的是x=1，y=0。先隐式调用父类A的无参构造函数，执行PrintFields()方法，检查到是虚方法，转去检查实例类B，有重载方法，执行重载方法，输出x=1,y=0</p></blockquote><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是将<u>数据和行为相结合</u>，通过行为约束代码修改数据的程度，增强<u>数据的安全性</u>，属性是C#封装实现的最好体现。</p><p>将一些复杂的逻辑包装起来，程序员不管内部是如何实现的，只负责使用里面的数据或者逻辑，目的是<u>保护或者防止代码被无意修改</u>。</p><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>多态性是指同名的方法在不同环境下，自适应的反应出不同得表现，是<u>方法动态展示的重要手段</u>。例如叫声，在鸟这个类中是“鸣啼”在狗这个类中是“犬吠”。</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><ul><li><p>public:对任何类和成员都公开，无限制访问</p></li><li><p>private:仅对该类公开</p></li><li><p>protected:对该类和其派生类公开</p></li><li><p>internal:只能在包含该类的程序集中访问该类</p><p> protected internal: protected + internal</p></li></ul><h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><p>关键字sealed，类声明时<u>可防止其他类继承此类</u>，在方法中声明则可防止派生类重写此方法。与override一起使用。</p><p><img src="https://img-blog.csdnimg.cn/d60d565c7fcc4877aa67f54c4a54e52d.png" alt="img"></p><p><a href="https://blog.csdn.net/qq_40323256/article/details/86771078?ops_request_misc=&request_id=&biz_id=102&utm_term=sealed%E7%9A%84%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86771078.142%5Ev42%5Enew_blog_pos_by_title,185%5Ev2%5Econtrol&spm=1018.2226.3001.4187">(42条消息) C#中sealed的用法_疆~的博客-CSDN博客_c# sealed</a></p><h1 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h1><h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><ul><li>类型：结构体是值类型，类是引用类型。</li><li>存储：结构体存在栈中，类存在堆中。</li><li>值传递：结构体变量和类对象进行类型传递时，结构体变量进行的就是值传递，而类对象进行的是引用传递，或者说传递的是指针，这样在函数中改变参数值，结构体对象的值是不变的，而类对象的值是变化了。</li><li>成员变量初始化：在C#中<strong>结构体类型定义</strong>时，成员是不能初始化的，这样就导致了，定义结构体变量时，<u>变量的所有成员都要自己赋值初始化</u>。但对于类，在<strong>定义类时</strong>，就可以初始化<u>其中的成员变量</u>，所以在定义对象时，对象本身就已经有了初始值，你可以自己在重新给个别变量赋值。(注意在C++中，类的定义中是不能初始化的，初始化要放在构造函数中)</li><li>构造函数和析构函数<ul><li>结构体不能申明无参的构造函数，而类可以。</li><li>结构体需要在构造函数中初始化<u>所有成员变量</u>，而类随意。</li><li>声明了结构类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。</li><li>结构体申明有参构造函数后，无参构造不会被顶掉。</li><li>结构体不能申明析构函数，而类可以。</li></ul></li><li>继承：结构体不能被继承，而类可以。</li><li>静态：结构体不能被静态static修饰(不存在静态结构体)，而类可以。</li></ul><h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><ul><li><p>结构体</p><ul><li>结构是值类型在栈中，栈的存取速度比堆快，但是容量小，<u>适合轻量级的对象</u>，比如点、矩形、颜色。</li><li>如果对象是<u>数据集合</u>时，优先考虑接结构体（位置，坐标）；</li><li>在<u>变量传值</u>的时候，希望传递对象的是拷贝，而不是对象的引用地址，这个时候就可以使用结构体。</li><li>结构使用简单,并且很有用,但是要牢记:结构在堆栈中创建，是值类型，而类是引用类型。每当需要一种经常使用的类型，而且大多数情况下该类型只是一些数据时，使用结构能比使用类获得更佳性能。</li></ul></li><li><p>类</p><ul><li>类是引用类型，存储在堆中，堆的容量大，适合重量级的对象，栈的空间不大，大量的对应当存在于堆中。</li><li>如果对象需要继承和多态特征，用类（玩家、怪物）</li></ul></li></ul><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><h2 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h2><ul><li>实例化：接口不是类（无构造函数和析构函数），<strong>不能被实例化</strong>，抽象类可以<strong>间接实例化</strong>（可以被继承，有构造函数，可以实例化子类的同时间接实例化抽象类这个父类）。</li><li>方法申明和实现：接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。</li><li>抽象的范围：抽象类中可以有实现成员，接口只能包含抽象成员。因此接口是完全抽象，抽象类是部分抽象。</li><li>继承和实现<ul><li>抽象类要被子类继承，接口要被类实现；</li><li>接口可以实现多继承，抽象类只能实现单继承，一个类只能继承一个类但可以实现多个接口；</li><li>抽象方法要被实现，所以不能是静态的，也不能是私有的。</li></ul></li><li>成员修饰符：抽象类中所有的成员修饰符都能使用，接口中的成员都是对外的，所以不需要修饰符修饰。</li></ul><ul><li>按照个人理解来说，接口更注重方法的设计，以供其他类扩展，而抽象类就是一个抽象的模板，让子类都按照这个来做。</li></ul><h2 id="使用环境-1"><a href="#使用环境-1" class="headerlink" title="使用环境"></a>使用环境</h2><ul><li><p>使用抽象类是为了<strong>代码的复用</strong>，而使用接口的动机是为了<strong>实现多态性</strong>。</p></li><li><p>抽象类适合用来定义某个领域的<strong>固有属性</strong>，也就是本质，接口适合用来定义某个领域的<strong>扩展功能</strong>。</p></li></ul><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>当2个或多个类中有重复部分的时候，我们可以抽象出来一个基类，如果希望这个基类<strong>不能被实例化</strong>，就可以把这个基类设计成抽象类。</li><li>当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>当注重代码的扩展性跟可维护性时，应当优先采用接口。</p><ul><li><p>接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用<strong>更加方便灵活</strong>；</p></li><li><p>接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p></li></ul><h1 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h1><p>静态构造函数用于初始化任何<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static">静态</a>数据(动态初始化)，或执行仅需执行一次的特定操作。</p><p>将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数。 </p><p>静态构造函数最多调用一次。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SimpleClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Static variable that must be initialized at run time.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">long</span> baseline;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Static constructor is called at most one time, before any</span></span><br><span class="line">    <span class="comment">// instance constructor is invoked or member is accessed.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">SimpleClass</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        baseline = DateTime.Now.Ticks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态构造函数既没有访问修饰符，也没有参数。</li><li>在创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类。</li><li>一个类只能有一个静态构造函数。</li><li>无参数的构造函数可以与静态构造函数共存。</li><li>最多只运行一次。</li><li>静态构造函数不可以被继承。</li><li>如果没有写静态构造函数，而类中包含带有初始值设定的静态成员，那么编译器会<u>自动生成默认的静态构造函数</u>。</li><li>如果静态构造函数引发异常，运行时将不会再次调用该构造函数，并且在程序运行所在的应用程序域的生存期内，类型将保持未初始化。</li></ul><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>引用传递可以理解为就是对象本身传递，而非一个<strong>副本或者地址</strong>，一般使用 in、out、ref 关键字声明参数是引用传递。</p><table><thead><tr><th align="center"></th><th align="center">in</th><th align="center">out</th><th align="center">ref</th></tr></thead><tbody><tr><td align="center">传递类型</td><td align="center">引用传递</td><td align="center">引用传递</td><td align="center">引用传递</td></tr><tr><td align="center">含义</td><td align="center">引用传进（只读</td><td align="center">引用传出（必写</td><td align="center">可读可写</td></tr><tr><td align="center">需要提前初始化</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td align="center">调用/传参关键字是否可以省</td><td align="center">Y/N</td><td align="center">N/N</td><td align="center">N/N</td></tr></tbody></table><p><a href="https://www.cnblogs.com/shanfeng1000/p/15043795.html">C#中的值传递与引用传递（in、out、ref） - 没有星星的夏季 - 博客园 (cnblogs.com)</a>（具体可查看里面的例子）</p><h2 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h2><p>ref关键字表示变量是引用，或是另一个对象的别名。有五种使用的情况：</p><p><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference">ref 关键字 - C# 参考 | Microsoft Learn</a></p><h3 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h3><p>在<u>方法签名</u>和<u>方法调用</u>中，按引用将参数传递给方法。</p><ul><li><p>方法签名：在方法的参数列表中使用 <code>ref</code> 关键字时，它指示参数按引用传递，而非按值传递。 <code>ref</code> 关键字让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。</p></li><li><p>方法定义和调用方法：若要使用 <code>ref</code> 参数，方法定义和调用方法均必须显式使用 <code>ref</code> 关键字，如下面的示例所示。 （除了在进行 COM 调用时，调用方法可忽略 <code>ref</code>。）</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按引用传递【值类型】*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> refArgument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    refArgument = refArgument + <span class="number">44</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> number = <span class="number">1</span>;</span><br><span class="line">Method(<span class="keyword">ref</span> number);</span><br><span class="line">Console.WriteLine(number);</span><br><span class="line"><span class="comment">// Output: 45</span></span><br></pre></td></tr></table></figure><blockquote><p> 传递到 <code>ref</code> 或 <code>in</code> 形参的实参必须先经过初始化，然后才能传递；</p></blockquote><ul><li>重载方法能生效的情况</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CS0663_Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compiler error CS0663: &quot;Cannot define overloaded</span></span><br><span class="line">    <span class="comment">// methods that differ only on ref and out&quot;.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">RefOverloadExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;<span class="comment">//要有值传递与之区别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按引用传递【值类型】或【引用类型】<ul><li><a href="https://blog.csdn.net/liudongdong19/article/details/83758830">(42条消息) c#引用（&amp;）的用法和应用实例_路途…的博客-CSDN博客_c# 引用</a>【有详细图解】</li><li>不要混淆通过引用传递的概念与引用类型的概念。 这两种概念是不同的。 无论方法参数是值类型还是引用类型，均可由 <code>ref</code> 修改。 当通过引用传递时，不会对值类型装箱。</li><li>总结<ul><li>如果传递的参数是基元类型（int，float等）或结构体（struct），那么就是传值调用。</li><li>如果传递的参数前有ref或者out关键字，那么就是传引用调用。</li><li>如果传递的参数是类（class）并且没有ref或out关键字：<ul><li>如果调用的函数中对参数重新进行了地址分配(new操作)，那么执行结果类似传值调用；</li><li>如果调用的函数中没有对参数重新进行了地址分配，直接就是使用了传递的参数，那么执行结果类似传引用调用。</li></ul></li></ul></li></ul></li></ul><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>C#在有限的范围内支持指针；</p><p>指针只能指向非托管类型，包括所有基本数据类型、<a href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">枚举类型</a>、其他指针类型和只包含非托管类型的结构。</p><p><a href="https://blog.csdn.net/sibaison/article/details/72675257">(42条消息) C#的三大难点之二：托管与非托管_游子2022的博客-CSDN博客_c#托管</a></p><ul><li>能否为空：引用不能为空，即不存在对空对象的引用，指针可以为空，指向空对象。</li><li>初始化：引用必须初始化，指定对哪个对象的引用，指针不需要。</li><li>值更改：引用初始化后不能改变，指针可以改变所指对象的值。（？</li><li>引用访问对象是直接访问，指针访问对象是间接访问。</li><li>引用的大小是所引用对象的大小，指针的大小，是指针本身大小，通常是4字节。</li><li>引用没有const，指针有const。</li><li>引用和指针的+自增运算符意义不同。</li><li>引用不需要分配内存空间，指针需要。</li></ul>]]></content>
    
    
    <summary type="html">关于C#知识点整理</summary>
    
    
    
    <category term="知识点梳理" scheme="https://huangxinhere.github.io/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity的游戏框架搭建</title>
    <link href="https://huangxinhere.github.io/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"/>
    <id>https://huangxinhere.github.io/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/</id>
    <published>2023-01-05T16:00:00.000Z</published>
    <updated>2023-02-20T03:59:05.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul><li><p>树结构</p></li><li><p>对象之间的交互（低耦合）和模块化（高内聚）是整个框架搭建系列的终极问题</p><ul><li><p>对象交互三种方法</p><p>方法调用；</p><p>委托或者回调；</p><p>消息或事件。</p></li><li><p>模块化也有三种：</p><p>单例；</p><p>IOC；</p><p>分层，如MVC，三层架构，领域驱动分层等。</p></li></ul></li><li><p>表现和数据的分离</p></li><li><p>交互逻辑和表现逻辑</p></li></ul><h1 id="父子对象和跨模块初探"><a href="#父子对象和跨模块初探" class="headerlink" title="父子对象和跨模块初探"></a>父子对象和跨模块初探</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110170952423.png" alt="image-20230110170952423"></p><ul><li>目前有UI和Game两个模块，通信都是用事件。</li><li>Panel的父子对象则用委托通信。</li></ul><h1 id="表现和数据分离"><a href="#表现和数据分离" class="headerlink" title="表现和数据分离"></a>表现和数据分离</h1><h2 id="Event的抽象"><a href="#Event的抽象" class="headerlink" title="Event的抽象"></a>Event的抽象</h2><p>上面的GameStartEvent和GamePassEvent都是单独写的，但重复性很高，可以通过 泛型＋继承 来提取，继承解决扩展问题，泛型解决实现代码一致、类不一致的问题，是一个重构技巧。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Event</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action mOnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent += onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent -= onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameStartEvent</span> : <span class="title">Event</span>&lt;<span class="title">GameStartEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110172045530.png" alt="image-20230110172045530"></p><h2 id="数据分离"><a href="#数据分离" class="headerlink" title="数据分离"></a>数据分离</h2><p>使用GameModel来进行分离。静态变量。</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110172522022.png" alt="image-20230110172522022"></p><h2 id="属于Game而不是个体的总体逻辑判断"><a href="#属于Game而不是个体的总体逻辑判断" class="headerlink" title="属于Game而不是个体的总体逻辑判断"></a>属于Game而不是个体的总体逻辑判断</h2><ul><li>杀掉一个敌人，就通知Game来判断；用事件而不用委托，因为委托要有多个子对象的引用。</li></ul><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110173221574.png" alt="image-20230110173221574"></p><blockquote><p>简化了图示；单个Enemy交给Game来判断敌人总数。</p></blockquote><h1 id="交互逻辑和表现逻辑"><a href="#交互逻辑和表现逻辑" class="headerlink" title="交互逻辑和表现逻辑"></a>交互逻辑和表现逻辑</h1><p>交互逻辑：玩家操作界面使得数据发生变化；</p><p>表现逻辑：数据变化反馈到界面上。</p><h2 id="两者都在controller导致臃肿"><a href="#两者都在controller导致臃肿" class="headerlink" title="两者都在controller导致臃肿"></a>两者都在controller导致臃肿</h2><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110173618010.png" alt="image-20230110173618010"></p><h2 id="实现两者的分离"><a href="#实现两者的分离" class="headerlink" title="实现两者的分离"></a>实现两者的分离</h2><p>交互的逻辑并不关心数据变化的逻辑，反之亦是，所以要想办法把两者分开处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line"></span><br><span class="line">Btn.onClick.AddListener(&#123;</span><br><span class="line">    //使数据变化</span><br><span class="line">    Count++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//数据展示</span><br><span class="line">Text.text = Count.ToString();</span><br></pre></td></tr></table></figure><blockquote><p>数据（Count）变化的时候可以自动通知text更新，实现分开处理。</p></blockquote><ul><li>委托调用处理：交互逻辑持有表现逻辑的引用，通知其更新。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//数据类</span><br><span class="line">public static class CounterModel</span><br><span class="line">&#123;</span><br><span class="line">    private static int mCount = 1;</span><br><span class="line">    </span><br><span class="line">    public static Action&lt;int&gt; OnCountChanged;</span><br><span class="line">    </span><br><span class="line">    public static int Count</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; mCount;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            if(value != mCount)</span><br><span class="line">            &#123;</span><br><span class="line">                mCount = value;</span><br><span class="line">                OnCountChanged?.Invoke(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据一旦发生变动，通知View执行 OnCountChanged</span><br><span class="line">CounterModel.OnCountChanged += UpdateView;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110175208278.png" alt="image-20230110175208278"></p><ul><li>对数据类的进一步抽象。假如有很多共享数据比如金币、生命值等，如果每个数据都按照上面这么写就会很麻烦，所以抽象一个BindableProperty类。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BindableProperty</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IEquatable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T mValue = <span class="literal">default</span>(T);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Action&lt;T&gt; OnValueChanged;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T Value</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; mValue;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">value</span>.Equals(mValue))</span><br><span class="line">            &#123;</span><br><span class="line">                mValue = <span class="keyword">value</span>;</span><br><span class="line">                OnValueChanged?.Invoke(mValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CounterModel.Count.Value++;</span><br></pre></td></tr></table></figure><blockquote><p>CounterModel类里面本来是一个int类型Count的数据，但相当于扩展了Count的内容（类型）。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据一般是项目的底层，而Model和View也相当于一个底层和上层的关系，所以自底向上的逻辑可以用委托或者事件，自顶向下可以用方法调用。</p><h2 id="交互逻辑优化-引入Command"><a href="#交互逻辑优化-引入Command" class="headerlink" title="交互逻辑优化-引入Command"></a>交互逻辑优化-引入Command</h2><ul><li>交互逻辑有很多各种执行的逻辑（比如请求服务器、通知等），会导致Controller比较臃肿。</li><li>很多Unity框架的交互逻辑都是由Command实现的。</li><li>Command模式可以让逻辑的调用和执行在空间和时间上分离。<ul><li>空间分离：调用和执行实现地方不一样。</li><li>时间分离：执行比调用稍微慢一些。</li></ul></li><li>Command分担Controller的交互逻辑。</li><li>struct比class由更好的内存管理效率。</li><li>CQRS读写分离。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令执行逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CounterModel.Count.Value++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AbstractCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CounterModel.Count.Value--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用命令</span></span><br><span class="line"><span class="keyword">new</span> AddCountCommand().Execute();</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110232804574.png" alt="image-20230110232804574"></p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110233554506.png" alt="image-20230110233554506"></p><h2 id="表现层和底层的分离"><a href="#表现层和底层的分离" class="headerlink" title="表现层和底层的分离"></a>表现层和底层的分离</h2><ul><li>大致理解表现层就是View相关的，其他就是底层，分离也就是底层的逻辑可以直接应用到其他种View层上。</li><li>好处：<ul><li>一般交互逻辑和表现层没啥关系，所以如果将负责操作数据的交互逻辑剥离出来，可以提高底层系统代码的复用率。</li><li>一个Command可以理解成用户的一个操作，独立出来分类可以清晰地展现所有的功能/操作。</li><li>项目前期由于更多的是做数值和玩法上的验证，所以可以弄个粗略的视图，测试好后再换视图模型。</li></ul></li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>表现层到底层系统层用Command</li><li>底层系统到表现层用委托或者事件</li><li>表现层是可以替换的————-</li></ul><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230109210658137.png" alt="image-20230109210658137"></p><h2 id="使用Command"><a href="#使用Command" class="headerlink" title="使用Command"></a>使用Command</h2><ul><li><strong>表现层只能往系统层发送Command或数据查询</strong>，并没有可以发送事件这一说，而且事件只能由底层系统层向表现层发送……（待论证。这样的话，如上图所示，开始菜单点击开始，则不能使用event，要用命令了。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> StartGameCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameStartEvent.Trigger();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前开始菜单的逻辑大概是：</span></span><br><span class="line">transform.Find(<span class="string">&quot;BtnStart&quot;</span>).GetComponent&lt;Button&gt;().OnClick.AddListener(</span><br><span class="line">    () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> StartGameCommand().Execute();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>消灭敌人数量统计的逻辑优化。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来是在Game（表现层）里实现</span></span><br><span class="line">...Class Game...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnemyKilled</span>(<span class="params"><span class="built_in">int</span> killedCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(killedCount == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> PassGameCommand().Execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将判断逻辑放到命令里面（底层）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> KillEnemyCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameModel.KillCount.Value++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(killedCount == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> PassGameCommand().Execute();</span><br><span class="line">            <span class="comment">//或直接 GamePassEvent.Trigger();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110131824399.png" alt="image-20230110131824399"></p><blockquote><ul><li>表现层-&gt;底层 用命令；</li><li>底层-&gt;表现层 用事件；</li><li>命令可以触发事件。</li></ul><p>命令和事件的区别？命令本质上是逻辑的执行，被包裹在对象的方法里面，通过对象去随时随地调用；事件是发送信号，通知其他地方执行。那么为什么表现层和底层要分开使用两者呢？？（待思考</p></blockquote><h1 id="模块化优化"><a href="#模块化优化" class="headerlink" title="模块化优化"></a>模块化优化</h1><p>表现层主要是根据语义来分模块，不做详解；重点是底层的模块。</p><h2 id="方式一：单例"><a href="#方式一：单例" class="headerlink" title="方式一：单例"></a>方式一：单例</h2><ul><li>静态类的问题：<ul><li>没有访问限制</li><li>使用static去扩展模块，模块的识别度不高</li></ul></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//反射</span></span><br><span class="line">                <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">                <span class="keyword">var</span> ctors = type.GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">                <span class="keyword">var</span> ctor = Array.Find(ctors, c =&gt; c.GetParameters().Length == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ctor == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Non public constructor not found in: &quot;</span> + type.Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mInstance = ctor.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> T;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameModel</span> : <span class="title">Singleton</span>&lt;<span class="title">GameModel</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GameModel</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; KillCount</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对单例的理解是，一个类有一个静态实例，而不是整个类都是静态的……究竟是如何体现出两者优劣呢？待深入理解。</p><ul><li>实现的单例的问题：单例类没有访问限制</li></ul><h2 id="方式二：引入IOC容器"><a href="#方式二：引入IOC容器" class="headerlink" title="方式二：引入IOC容器"></a>方式二：引入IOC容器</h2><p>相当于字典一样，键是类型，对应一个相应的实例。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IOCContainer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">Type</span>, <span class="title">object</span>&gt; mInstances</span> = <span class="keyword">new</span> Dictionary&lt;Type, <span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInstances.ContainsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            mInstances[key] = instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mInstances.Add(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInstances.TryGetValue(key, <span class="keyword">out</span> <span class="keyword">var</span> retInstance))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> retInstance <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if (mInstances.ContainsKey(key))</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                return mInstances[key] as T;</span></span><br><span class="line"><span class="comment">            &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IOC内部操作</p></blockquote><ul><li>应用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IOCContainer mContainer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论是增加还是获取都先检查IOC是否为空（类似单例）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureContainer</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mContainer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mContainer.Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureContainer();</span><br><span class="line">        <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似于一个IOC的单例。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> <span class="comment">//: Singleton&lt;CounterModel&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//private CounterModel()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span>   <span class="comment">//可以直接对字段初始化？？</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先数据类不再是单例，为了起单例作用都给了IOC来托管。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CounterModel mCounterModel;</span><br><span class="line">mCounterModel = Countapp.Get&lt;CounterModel&gt;();        </span><br><span class="line">mCounterModel.Count.OnValueChanged += OnCountChanged;</span><br></pre></td></tr></table></figure><blockquote><p>所以使用的时候，要从IOC容器获取，增加了访问的限制。</p></blockquote><h2 id="IOC的工具类Architecture"><a href="#IOC的工具类Architecture" class="headerlink" title="IOC的工具类Architecture"></a>IOC的工具类Architecture</h2><p>不同项目可能有好几个IOCContainer，代码重复率比较高，所以抽象出一个工具类。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和之前不同的是，这个工具类有自己的静态实例，然后直接持有一个IOCContainer实例，所以获取IOC容器又多了一层单例；</p><p>那继承的子类如何根据需求来Init IOC呢？子类通过Register方法间接注册IOC容器。所以可见，虽然IOC容器是直接附属于工具类的单例的字段的，但提供了方法来使子类间接操作容器。写子类的时候只需要关注注册什么就行了，其他逻辑不需要展现，因此减轻了工作量。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul><li>IOC容器比单例麻烦很多，而且每次从容器里面查询字典也造成更多的性能消耗。</li><li>使用IOC容器的意义：<ul><li>增加模块访问的限制。比如访问CounterModel要通过Countapp；</li><li>在统一的地方注册模块，有利于让开发人员有宏观的视角，充当一个“架构草图”，省去了维护一个“架构草图”的麻烦。</li><li>更符合SOLID原则、可以增加层级等等</li></ul></li></ul><h2 id="IOC-的隐藏功能：注册接口模块"><a href="#IOC-的隐藏功能：注册接口模块" class="headerlink" title="IOC 的隐藏功能：注册接口模块"></a>IOC 的隐藏功能：注册接口模块</h2><ul><li><p>除了<strong>注册和获取</strong>模块，IOC容器一般还有一个隐藏功能，即：注册<strong>接口</strong>模块</p></li><li><p><strong>抽象-实现</strong> 这种形式注册和获取对象的方式是符合<strong>依赖倒置原则</strong>的。</p></li><li><p>依赖倒置原则：程序要依赖于抽象接口，不要依赖于具体实现。</p></li><li><p>好处：</p><ul><li>接口设计和实现分成两个步骤，设计时可以专注于设计，减少干扰，实现专注于实现；</li><li>实现是可以替换的，比如一个接口是IStorage，实现可以是PlayerPrefsStorage、EasySaveStorage等；</li><li>比较容易测试（单元测试等）；</li><li>实现细节发生变化时，引用接口不会改变，降低耦合……</li></ul></li><li><p>DICExample.cs（DIP是依赖倒置原则的意思）</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DIPExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.设计模块接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> PlayerPrefs.GetString(key, defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">                <span class="keyword">return</span> EditorPrefs.GetString(key, defaultValue);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//避免打包出错</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">                EditorPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> container = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">        container.Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">        <span class="keyword">var</span> storage = container.Get&lt;IStorage&gt;();</span><br><span class="line">        storage.SaveString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;运行时存储&quot;</span>);</span><br><span class="line">        Debug.Log(storage.LoadString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用另一个实现类来直接替换 容器里同接口的实例</span></span><br><span class="line">        container.Register&lt;IStorage&gt;(<span class="keyword">new</span> EditorPrefsStorage());</span><br><span class="line">        storage = container.Get&lt;IStorage&gt;();</span><br><span class="line">        Debug.Log(storage.LoadString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>依赖倒置原则是SOLID中的字母D；单一职责原则是SOLID中的字母D。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>CounterModel继承了一个接口。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    BindableProperty&lt;<span class="built_in">int</span>&gt; Count &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span> <span class="comment">//: Singleton&lt;CounterModel&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后注册的时候使用的是接口类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用CountModel的时候就是通过接口类型来获取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddNumCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112165507242.png" alt="image-20230112165507242"></p><blockquote><p>可见CounterModel改成了ICounterModel。虽然改动很小，但是看这张图的时候不用考虑CountModel的具体实现，减轻了心智负担。</p></blockquote><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112171057291.png" alt="image-20230112171057291"></p><h1 id="引入数据存储功能"><a href="#引入数据存储功能" class="headerlink" title="引入数据存储功能"></a>引入数据存储功能</h1><p>首先基础实现：数据存储和更改的时候，存储在PlayerPrefs，从PlayerPrefs读取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterModel</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只是初始化的时候，才从存储读取数据</span></span><br><span class="line">        <span class="comment">//而每一次数据变更都改变存储</span></span><br><span class="line">        Count.Value = PlayerPrefs.GetInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个事件本来就要接受一个int参数，</span></span><br><span class="line">        <span class="comment">//count就是那个参数了？不太懂这个语法糖</span></span><br><span class="line">        Count.OnValueChanged += count =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, count);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的存储"><a href="#不同的存储" class="headerlink" title="不同的存储"></a>不同的存储</h2><p>目前EditorCounterApp和CounterApp都是用同一套存储（同一个CounterModel，而Model都是用PlayerPrefs）。回忆一下，两个项目都是在同一个工程，都是通过CounterModel来操作数据。那么如何实现两者的存储不同呢？上回学到IOC的隐藏功能：注册接口模块，同一个接口有多个类实现，假设用EditorPrefs和PlayerPrefs来分别存储；也已经实现类似的例子。注册想要的实现的类。</p><ul><li>和上次一样</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.设计模块接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PlayerPrefs.GetString(key, defaultValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            <span class="keyword">return</span> EditorPrefs.GetString(key, defaultValue);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//避免打包出错</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            EditorPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用。相当于存储也存储在单例容器里。model和存储都有各自的接口。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterModel</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> storage = Countapp.Get&lt;IStorage&gt;();</span><br><span class="line"></span><br><span class="line">        Count.Value = storage.LoadInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Count.OnValueChanged += count =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            storage.SaveInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, count);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span> </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见调用了容器里面的storage实例来间接调用它的方法。</p></blockquote><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113100133148.png" alt="image-20230113100133148"></p><h2 id="单例初始化可能造成的循环递归调用的问题"><a href="#单例初始化可能造成的循环递归调用的问题" class="headerlink" title="单例初始化可能造成的循环递归调用的问题"></a>单例初始化可能造成的循环递归调用的问题</h2><p>首先分析一下代码实现的逻辑。model类和存储类都是在此类中注册的，那么Countapp在什么时候调用Init（）方法呢？回到Architecture类看一下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;<span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见Init方法是mArchitecture为空的时候调用的。而Get方法和Register方法都可能调用MakeSureArchitecture方法，当第一次调用的时候。所以不是在某个地方Init，而是第一次注册或者get的时候才会初始化。</p><p>所以，整个流程是：</p><ul><li>某个功能要用到数据类Model的时候，首先执行get方法：<code>mCounterModel = Countapp.Get&lt;ICounterModel&gt;();</code></li><li>然后Model才开始初始化，执行<code>mArchitecture.Init();</code> </li><li>而Init是由子类来实现的，又回到了<code>Register&lt;ICounterModel&gt;(new CounterModel());</code></li><li>回到model的构造方法里面，又有<code>var storage = Countapp.Get&lt;IStorage&gt;();</code></li><li>这时候<code>mArchitecture</code>还没有初始化完成，所以又回到了子类的init……依次类推循环。</li></ul><p>【复盘遇到了一个问题：调用CountModel的时候已经MakeSure了一下，执行到代码<code> mArchitecture.Init();</code>，然后开始注册CountModel，在其构造器中尝试Get工具时，虽然又MakeSure了一次，但是此时的mArchitecture已经实例化过，不会执行Init方法了吧？那这样的话Get返回的就是空值了……因为整个代码就是一个静态变量mArchitecture，MakeSure的是mArchitecture】</p><p>究其原因，一个类A要成为容器里的一个实例，必须要构造方法实例化一下；而类B的容器注册又在A的构造方法里面；</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112194556474.png" alt="image-20230112194556474"></p><h2 id="Architecture类的分析"><a href="#Architecture类的分析" class="headerlink" title="Architecture类的分析"></a>Architecture类的分析</h2><p>【和上文有点重复了，但不要紧，这个是更详细的复盘】首先回忆一下为什么会有Architecture类。开始是直接用IOC容器的，IOC容器就是用字典把某个类型对应的一个实例存储下来，这样一个IOC容器可以有多种模块类的对象实例，而统一管理模块类的类就只需拥有一个静态IOC容器变量就行。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IOCContainer mContainer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论是增加还是获取都先检查IOC是否为空（类似单例）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureContainer</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mContainer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mContainer.Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureContainer();</span><br><span class="line">        <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113165437148.png" alt="image-20230113165437148"></p><p>这样的话访问Model1就要经过Countapp来访问，达到了限制访问的目的，而不是用静态类随时随地都可以调用。</p><p>那么如果有多种管理模块类的类呢？Countapp1，Countapp2……？这时候就必须得抽象一部分代码出来，抽象的关键是：每一个管理类有一个静态的对象来方便访问（可以是IOC或者管理类本身）；IOC可以注册和获取对应的实例；从IOC获取的前提是已经有静态变量而且已经注册过；</p><p>所以，抽象出来的Architecture如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;<span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113171440638.png" alt="image-20230113171440638"></p><blockquote><p>可见抽象的部分大同小异，只不过静态变量是mArchitecture，传入的T就是管理类（如Countapp），整个过程就是当某个地方需要访问model的数据时，如<code>Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</code>就会调用Countapp的Get方法，里面首先检查是否有<code>mArchitecture</code>实例，没有的话就创建一个实例，并且执行Init方法（此方法就是给子类调用来注册各种模块），注册完后就可以直接调用了。</p><p>！！！一定要分清，<code>mArchitecture = new T();</code>就是已经创建了单例，<code>mArchitecture.Init();</code>就是把各模块实例存进来。</p></blockquote><p>【此处是解决单例循环调用的思路，空白ing】</p><h2 id="Architecture类2-0版的分析"><a href="#Architecture类2-0版的分析" class="headerlink" title="Architecture类2.0版的分析"></a>Architecture类2.0版的分析</h2><p>工具层Utility是要通过Model层来进行访问，而System层也可能要访问Model层。也就是说，Model实例化的时候可能要得到Utility，等等。</p><p>再回顾一下逻辑执行流程：某处要调用Model（Get它一下），然后检查是否初始化了Architecture，没有就new一个并且执行子类的Init方法，把要注册的都注册一下。注册的时候要调用构造方法，而构造方法可能包含其它层，那如何确保构造的时候其他层已经存在了呢？（不存在的话还得初始化，这样就会重复初始化容易出问题？）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RegisterSystem&lt;IAchievementSystem&gt;(<span class="keyword">new</span> AchievementSystem());</span><br><span class="line">        RegisterModel&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        RegisterUtility&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心就是这块注册，把优先级最高的先注册了，然后再注册次优先的。解决的代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">        mArchitecture.Init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Model初始化</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> architectureModel <span class="keyword">in</span> mArchitecture.mModels)</span><br><span class="line">        &#123;</span><br><span class="line">            architectureModel.Init();</span><br><span class="line">        &#125;</span><br><span class="line">        mArchitecture.mModels.Clear();</span><br><span class="line">        <span class="comment">//System初始化(在Model之后)</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> architectureSystem <span class="keyword">in</span> mArchitecture.mSystems)</span><br><span class="line">        &#123;</span><br><span class="line">            architectureSystem.Init();</span><br><span class="line">        &#125;</span><br><span class="line">        mArchitecture.mSystems.Clear();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mInited = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见执行完<code>mArchitecture.Init();</code>之后，才进行model和System的初始化（相当于构造方法）。Init的时候把要注册的Model和System都存起来，Init完后再逐一初始化。具体处理如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterModel</span>&lt;<span class="title">T</span>&gt;(<span class="params">T model</span>) <span class="keyword">where</span> T : IModel</span></span><br><span class="line">&#123;</span><br><span class="line">    model.Architecture = <span class="keyword">this</span>;</span><br><span class="line">    mContainer.Register&lt;T&gt;(model);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInited)</span><br><span class="line">    &#123;</span><br><span class="line">        mModels.Add(model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        model.Init();</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterSystem</span>&lt;<span class="title">T</span>&gt;(<span class="params">T system</span>) <span class="keyword">where</span> T : ISystem</span></span><br><span class="line">&#123;</span><br><span class="line">    system.Architecture = <span class="keyword">this</span>;</span><br><span class="line">    mContainer.Register&lt;T&gt;(system);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInited)</span><br><span class="line">    &#123;</span><br><span class="line">        mSystems.Add(system);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        system.Init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params">T utility</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mContainer.Register&lt;T&gt;(utility);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了最底层的工具类直接注册，其他都是先进缓存变量待着。</p></blockquote><p>总之初始化和注册都是一次性就完成的，并且按照顺序逐一实例化，解决互相引用的冲突，所以不会重复调用Init方法。为做到这点还有一个地方要考虑：如果Model直接从<code>Countapp.Get&lt;IStorage&gt;()</code>获取工具类的话，还会调用MakeSure方法……（可能静态变量还是空的？）</p><p>反正又进行了很绕的操作：</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113191234392.png" alt="image-20230113191234392"></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>/CounterModel.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> storage = Architecture.GetUtility&lt;IStorage&gt;();  <span class="comment">//保证Architecture是赋值好的</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>Architecture.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>model是通过Architecture来GetUtility……为了绕过初始化？也就是获取有两种方法，一种是层级之间（Model/System/Utility）的调用用GetXXX方法（与Init方法无关），这都是继承<code>IBelongToArchitecture</code>来获得的方法，第二种是其他地方调用层级的话直接用Get方法（与Init方法有关）……反正是很绕，滚去多学习语法了。</p><h1 id="接口的显式实现"><a href="#接口的显式实现" class="headerlink" title="接口的显式实现"></a>接口的显式实现</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayOther</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InterfaceDesignExample</span> : <span class="title">MonoBehaviour</span>, <span class="title">ICanSayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接口的隐式实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接口的显式实现，不能带访问权限（均无法访问）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">void</span> ICanSayHello.SayOther()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.SayHello();   </span><br><span class="line"></span><br><span class="line">        (<span class="keyword">this</span> <span class="keyword">as</span> ICanSayHello).SayOther();  <span class="comment">//转成接口对象才能调用,增加了成本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口-抽象类-实现类"><a href="#接口-抽象类-实现类" class="headerlink" title="接口-抽象类-实现类"></a>接口-抽象类-实现类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CustomScript</span> : <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScript</span> : <span class="title">CustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这种情况下，子类可以调用接口的<code>Start()</code>方法，那么就会造成循环调用。所以可以限制抽象类的接口方法的访问权限：</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CustomScript</span> : <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Start()</span><br><span class="line">    &#123;</span><br><span class="line">        OnStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Update()</span><br><span class="line">    &#123;</span><br><span class="line">        OnUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Destroy()</span><br><span class="line">    &#123;</span><br><span class="line">        OnDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样子类就无法访问抽象类的接口方法，只能继承抽象方法。</p></blockquote><h2 id="接口-静态扩展时用于限制方法的访问规则"><a href="#接口-静态扩展时用于限制方法的访问规则" class="headerlink" title="接口+静态扩展时用于限制方法的访问规则"></a>接口+静态扩展时用于限制方法的访问规则</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CanDoEveryThing</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething3</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 总接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing CanDoEveryThing &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口1</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething1</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口1的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething1Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取接口1继承的总接口持有的基本类，并调用其方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething1</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething1 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口2</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething2</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口2的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething2Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething2</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething2 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口3</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething3</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口3的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething3Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething3</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething3 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo1</span> : <span class="title">ICanDoSomething1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> CanDoEveryThing CanDoEveryThing &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo1 = <span class="keyword">new</span> OnlyCanDo1();</span><br><span class="line">    onlyCanDo1.CanDoEveryThing.DoSomething2();<span class="comment"><span class="doctag">///</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见<code>OnlyCanDo1</code>对象可以通过接口持有的实例来访问其他的方法（做事件2和3）.上一种情况是把接口的方法给显式掉，但这次接口是持有其他类的对象。所以，继承接口的类要把接口持有的对象给显式掉。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo1</span> : <span class="title">ICanDoSomething1</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing IHasEverything.CanDoEveryThing &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> CanDoEveryThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo1 = <span class="keyword">new</span> OnlyCanDo1();</span><br><span class="line">    onlyCanDo1.DoSomething1();<span class="comment">//只能调用接口的方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个接口相当于一个使用规则</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo23</span> : <span class="title">ICanDoSomething2</span>, <span class="title">ICanDoSomething3</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing IHasEverything.CanDoEveryThing &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> CanDoEveryThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo23 = <span class="keyword">new</span> OnlyCanDo23();</span><br><span class="line">    onlyCanDo23.DoSomething2();</span><br><span class="line">    onlyCanDo23.DoSomething3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul><li>核心知识是接口的显式实现，用于控制C#成员方法的访问权限</li><li>接口-抽象类-实现类 时，不想被乱调用一些方法时可以用</li><li>接口+静态扩展 时，想通过实现某个接口来获得具体方法的访问权限</li></ul><h1 id="方式三：引入系统层"><a href="#方式三：引入系统层" class="headerlink" title="方式三：引入系统层"></a>方式三：引入系统层</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113100249105.png" alt="image-20230113100249105"></p><p>目前项目可以分为三个层级：</p><ul><li>表现层：即ViewController或者MonoBehaviour脚本等；</li><li>Model层：管理数据，提供数据的增删改查</li><li>Utility层：工具层，提供一些必要的基础工具，比如数据存储、网络链接、蓝牙、序列化反序列化等等</li></ul><p>而QFramework系统设计架构最终是有四个层级，第四层级叫System层，系统层。目前Command分担了Controller的交互逻辑的部分逻辑，但其实还有一部分交互逻辑是需要给System层分担的。</p><p>首先要理解的是，Command是没有状态的，因为Command相当于一个方法，只要调用一次就可以不用了，所以Command是没有状态的。那什么是有状态的？比如角色控制脚本，在里面创建了一些角色数据，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Walking;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> JumpCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxJumpCount;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断有没有状态，可以理解为这个对象要不要维护数据。比如之前写的<code>AddCountCommand</code>只是更改了ICountModel中的Count的值，没 有状态。但是现实情况下，Command除了要更改Model的值，还有可能是开启了某些服务，而这些服务是有状态的，比如计时服务、蓝牙链接服务等，如果将它们写成对象必是有状态的对象，而这些服务既包含<strong>要维护的数据</strong>，也包含一些<strong>对外提供的方法</strong>，所以放Model层和Utility层都是不合适的。</p><p>如果放在表现层，会造成大量的重复代码；Command只是表现层和底层系统层交互方式的一种，且不能有状态；所以这部分代码只能再创建一个层级来负责了，那就是System层。</p><p>所以四个层次的梳理如下：</p><ul><li>表现层：即ViewController或者MonoBehaviour脚本等；</li><li>System层：系统层，<strong>有状态</strong>，负责既提供API又有状态的对象，比如网络服务、蓝牙服务、商城系统等</li><li>Model层：管理数据，<strong>有状态</strong>，提供数据的增删改查</li><li>Utility层：工具层，<strong>无状态</strong>，提供一些必要的基础工具API，比如数据存储、网络链接、蓝牙、序列化反序列化等等</li></ul><p>其中表现层改变System、Model层的状态用Command；</p><p>System层和Model层通知表现层用事件或委托；</p><p>表现层查询状态时可以直接获取System和Model层。</p><p>一般情况下，表现层根本不用访问Utility层，同样Utility层也不用通知表现层。</p><p>模块化的三种方式：</p><ul><li>单例</li><li>IOC容器</li><li>分层</li></ul><h2 id="实现系统层"><a href="#实现系统层" class="headerlink" title="实现系统层"></a>实现系统层</h2><p>和Model层差不多，但是init的时候要放在model的后面，因为可能要引用到model</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Model初始化</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> architectureModel <span class="keyword">in</span> mArchitecture.mModels)</span><br><span class="line">&#123;</span><br><span class="line">    architectureModel.Init();</span><br><span class="line">&#125;</span><br><span class="line">mArchitecture.mModels.Clear();</span><br><span class="line"><span class="comment">//System初始化(在Model之后)</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> architectureSystem <span class="keyword">in</span> mArchitecture.mSystems)</span><br><span class="line">&#123;</span><br><span class="line">    architectureSystem.Init();</span><br><span class="line">&#125;</span><br><span class="line">mArchitecture.mSystems.Clear();</span><br></pre></td></tr></table></figure><ul><li>实现例子：成就系统</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAchievementSystem</span> : <span class="title">ISystem</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AchievementSystem</span> : <span class="title">IAchievementSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IArchitecture Architecture &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取model的数据</span></span><br><span class="line">        <span class="keyword">var</span> counterModel = Architecture.GetModel&lt;ICounterModel&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> previousCount = counterModel.Count.Value;</span><br><span class="line"></span><br><span class="line">        counterModel.Count.OnValueChanged += newCount =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (previousCount &lt; <span class="number">10</span> &amp;&amp; newCount &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;解锁点击10次的成就&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (previousCount &lt; <span class="number">20</span> &amp;&amp; newCount &gt;= <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;解锁点击20次的成就&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousCount = newCount;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li>ICommand</li><li>ISystem</li><li>IModel</li><li>（IController）</li><li>（IUtility）</li></ul><h2 id="IController"><a href="#IController" class="headerlink" title="IController"></a>IController</h2><p>与MVC的Controller是同一个意思。</p><p>在表现层需要向底层系统层发送Command，也需要监听底层系统层发送的事件，还需要通过底层系统层的Model或System来查询一些数据，这些功能最好用一个IController来定义一下。目前能够实现的就是查询数据的功能。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IController</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于表现层的对象会时常进行创建和销毁，所以表现层的对象注册到Architecture是没有意义的，而这里定义的IController的意义就是标记一下这个表现层的对象是属于表现层的（不能和系统层、数据层相提并论，都存在IOC中）；而在表现层对象中，去访问Architecture中的System或Model就不需要使用单例的形式获取了。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//CounterViewController.cs</span></span><br><span class="line">mCounterModel = Countapp.Get&lt;ICounterModel&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>//改为层之间的调用</span></span><br><span class="line"><span class="comment">//继承IController，并且</span></span><br><span class="line">mCounterModel = Architecture.GetModel&lt;ICounterModel&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> IArchitecture Architecture &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = Countapp.Interface;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>//Architecture.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IArchitecture Interface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MakeSureArchitecture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于Controller是连接Mono（一直运行的）和层级之间的桥梁，如果直接调用<code>Architecture</code>将为空值，所以要加一个方法来获取初始化好的<code>Architecture</code>.</p></blockquote><h2 id="解决Controller类不能在Mono执行构造方法"><a href="#解决Controller类不能在Mono执行构造方法" class="headerlink" title="解决Controller类不能在Mono执行构造方法"></a>解决Controller类不能在Mono执行构造方法</h2><p>但是在<code>CounterViewController : MonoBehaviour, IController</code>类中，</p><p><code>public IArchitecture Architecture &#123; get; set; &#125; = Countapp.Interface;</code>这个构造方法并没有在Mono的方法里面执行，所以会报错。</p><p>修改如下：Architecture 的set和get分离。 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSetArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetArchitecture</span>(<span class="params">IArchitecture architecture</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于IModel和ISystem都是和Architecture相互持有的，所以IModel和ISysem两者都要实现两个接口。</p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114113357202.png" alt="image-20230114113357202"></p><blockquote><p>可见IController是直接从Architecture获取，其他层由于和Architecture相互持有，所以还有抽象类来存储Architecture变量。</p></blockquote><h2 id="IUtility接口"><a href="#IUtility接口" class="headerlink" title="IUtility接口"></a>IUtility接口</h2><p>IUtility并不持有Architecture对象，只是Architecture单向持有它。此时接口似乎只是一个标识（限制类型）作用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span>: <span class="title">IUtility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">LoadInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> defaultValue = <span class="number">0</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span>/IArchitecture.cs</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>) <span class="keyword">where</span> T : IUtility</span></span><br><span class="line"><span class="function">T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span>, IUtility</span>; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114155707059.png" alt="image-20230114155707059"></p><h2 id="ICommand接口"><a href="#ICommand接口" class="headerlink" title="ICommand接口"></a>ICommand接口</h2><p>目前是通过单例的方式来访问Architecture对象。如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddNumCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而其他层比如Model、System都是与Architecture互相持有的，所以ICommand也要保持一致。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IArchitecture mArchitecture;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetArchitecture</span>(<span class="params">IArchitecture architecture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = architecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICommand.Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        OnExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddNumCommand</span> : <span class="title">AbstractCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetArchitecture().GetModel&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114163358549.png" alt="c"></p><blockquote><p>重点看ICommand对应的内容。目前ICommand只是实现使用Architecture，接下来更改Command的调用方式。不同于目前已经实现的Model层和System层，它们是提供外界访问和内置触发事件（在Init已经安排好）；而Command需要别人主动来调用它。</p></blockquote><h3 id="Command-的调用"><a href="#Command-的调用" class="headerlink" title="Command 的调用"></a>Command 的调用</h3><p>解决：将Command发送给Architecture，让Architecture去执行Command。（Command已经和Architecture互相持有了，所以意味着Command必须执行SetArchitecture方法？）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : ICommand, <span class="keyword">new</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : ICommand</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//Architecture.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : ICommand, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = <span class="keyword">new</span> T();</span><br><span class="line">    command.SetArchitecture(<span class="keyword">this</span>);</span><br><span class="line">    command.Execute();</span><br><span class="line">    <span class="comment">//command.SetArchitecture(null);  //执行完去掉双向引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    command.SetArchitecture(<span class="keyword">this</span>);</span><br><span class="line">    command.Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里完善了command对<code>Architecture</code>的持有以及方法调用。这样就可以通过Architecture来执行command的了。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span>, <span class="title">IController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PointGame.Interface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* new KillEnemyCommand()</span></span><br><span class="line"><span class="comment">                    .Execute(); */</span></span><br><span class="line">        GetArchitecture().SendCommand&lt;KillEnemyCommand&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Controller层的，首先继承<code>IController</code>，然后实现<code>GetArchitecture</code>方法来获取Architecture对象以便调用Command层的命令。</p></blockquote><h1 id="架构使用规则完善一"><a href="#架构使用规则完善一" class="headerlink" title="架构使用规则完善一"></a>架构使用规则完善一</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114172433239.png" alt="image-20230114172433239"></p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114172510398.png" alt="image-20230114172510398"></p><h2 id="改进一：限制Model层对IArchitecture方法的使用"><a href="#改进一：限制Model层对IArchitecture方法的使用" class="headerlink" title="改进一：限制Model层对IArchitecture方法的使用"></a>改进一：限制Model层对IArchitecture方法的使用</h2><p>model层由于可以使用GetArchitecture()方法来执行IArchitecture接口内设计的所有方法，所以它可以访问Command层，这是不合理的。因为Command是表现层和底层交互的方式。</p><p>而在接口的显式实现章节中提到过”接口+静态扩展用于限制方法的访问“，所以可以对Model访问接口的方法做出一些限制。</p><ul><li>限制model对Set和Get方法的使用</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//AbstractModel.class</span></span><br><span class="line"><span class="keyword">void</span> ICanSetArchitecture.SetArchitecture(IArchitecture architecture)</span><br><span class="line">&#123;</span><br><span class="line">    mArchitecture = architecture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IArchitecture IBelongToArchitecture.GetArchitecture()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mArchitecture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我对这种方式的理解是，用一个额外的接口来继承”可以做全部事情的“接口，但是用一个静态类来扩展这个额外的接口，”扩展“的过程中限制了这个接口的继承下来的方法，所以继承这个”被阉割的“接口的类就只能访问特定的方法了。</p><ul><li>被阉割的接口：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanGetUtility</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanGetUtilityExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanGetUtility self</span>) <span class="keyword">where</span> T : <span class="keyword">class</span>, IUtility</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self.GetArchitecture().GetUtility&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>继承这个接口：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IModel</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span>, <span class="title">ICanGetUtility</span><span class="comment">///</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractModel</span> : <span class="title">IModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IArchitecture mArchitecture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICanSetArchitecture.SetArchitecture(IArchitecture architecture)<span class="comment"><span class="doctag">///</span>子类被禁用的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = architecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IArchitecture IBelongToArchitecture.GetArchitecture()<span class="comment"><span class="doctag">///</span>子类被禁用的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IModel.Init()</span><br><span class="line">    &#123;</span><br><span class="line">        OnInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现接口</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">AbstractModel</span>, <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> storage = <span class="keyword">this</span>.GetUtility&lt;IStorage&gt;();  <span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>[静态类扩展接口的语法要回头好好看看]</p><h2 id="限制System层"><a href="#限制System层" class="headerlink" title="限制System层"></a>限制System层</h2><p>和Model差不多,多继承了一个被阉割掉的ICanGetModel</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISystem</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span>, <span class="title">ICanGetModel</span>, <span class="title">ICanGetUtility</span><span class="comment">////</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制Command层"><a href="#限制Command层" class="headerlink" title="限制Command层"></a>限制Command层</h2><p>Command只能访问System、Model、Utility；做法同上。</p><h2 id="限制Controller"><a href="#限制Controller" class="headerlink" title="限制Controller"></a>限制Controller</h2><p>IController可以获取Model、获取System、发送Command。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>限制的范围可以看接口后者能使用的方法就能明白，可以减少说明性的文档，或者规范项目。</p><h1 id="架构使用规则完善二"><a href="#架构使用规则完善二" class="headerlink" title="架构使用规则完善二"></a>架构使用规则完善二</h1><h2 id="基于类型的事件机制"><a href="#基于类型的事件机制" class="headerlink" title="基于类型的事件机制"></a>基于类型的事件机制</h2><p>事件是底层系统层向表现层发送的，但是目前还没有限制其使用。</p><p>目前的事件基类是一个静态类，一是不能传递参数，二是事件管理对象无法分组。</p><p>基于类型……是根据某种类型来统一注册执行事件？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Event</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action mOnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent += onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent -= onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>TypeEventSystem.cs</code></strong></p><ul><li>与事件操作相关的方法的接口：注册、广播、注销</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITypeEventSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span>;<span class="comment">//执行无传参的事件集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span>;<span class="comment">//执行传参为T类型的事件集</span></span><br><span class="line">    <span class="function">IUnRegister <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span>; <span class="comment">//注册传参为T类型的事件，返回IUnRegister接口类型的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegister</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span>;<span class="comment">//注销传参为T类型的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于注销，这里用了统一注销的思路，避免逐一手动注销。这样的话，要被注销的事件就得被存储下来，并且可以调用此事件相关的注销方法。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnRegister</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TypeEventSystemUnRegister&lt;T&gt; : IUnRegister</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ITypeEventSystem TypeEventSystem;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;T&gt; OnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TypeEventSystem.UnRegister&lt;T&gt;(OnEvent);</span><br><span class="line"></span><br><span class="line">        TypeEventSystem = <span class="literal">null</span>;</span><br><span class="line">        OnEvent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为事件是以字典的形式存储在对应的TypeEventSystem实例的字典变量中的，所以既要记录事件本身，还得记录对应的TypeEventSystem实例，并且调用TypeEventSystem实例的UnRegister方法，所以用类或者结构体来存储这些信息和方法。当new 一个TypeEventSystemUnRegister时，传入字段，并且在相应地方调用实例方法，就能注销掉了。</p><p>所以<code>IUnRegister Register&lt;T&gt;(Action&lt;T&gt; onEvent);</code>可以说是返回了记录待注销事件相关信息的变量，然后存在某个地方，等待被注销。</p></blockquote><ul><li>统一注销的实现。这个类继承了Mono，说明可以与物体挂钩，当对应的游戏对象销毁时，自动逐一注销事件</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnRegisterOnDestoryTrigger</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HashSet</span>&lt;<span class="title">IUnRegister</span>&gt; mUnRegisters</span> = <span class="keyword">new</span> HashSet&lt;IUnRegister&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUnRegister</span>(<span class="params">IUnRegister unRegister</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mUnRegisters.Add(unRegister);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> unRegister <span class="keyword">in</span> mUnRegisters)</span><br><span class="line">        &#123;</span><br><span class="line">            unRegister.UnRegister();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mUnRegisters.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关键是怎么调用AddUnRegister方法。视频又用了接口扩展的高级方法，，，👇</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UnRegisterExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterWhenGameObjectDestoryed</span>(<span class="params"><span class="keyword">this</span> IUnRegister unRegister, GameObject gameObject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> trigger = gameObject.GetComponent&lt;UnRegisterOnDestoryTrigger&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!trigger)</span><br><span class="line">        &#123;</span><br><span class="line">            trigger = gameObject.AddComponent&lt;UnRegisterOnDestoryTrigger&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trigger.AddUnRegister(unRegister);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IUnRegister接口以及实现的TypeEventSystemUnRegister类都是为待注销事件服务。一个待注销的事件经历了以下阶段：记录事件以及被管理的方法和实例——存储记录到物体挂载的脚本上——物体销毁事件注销。所以，可以将待注销的事件直接理解成<code>TypeEventSystemUnRegister</code>实例，那么如何进行第二步呢？</p><p>而且明明一个结构体就能记录的，为啥还要弄一个<code>IUnRegister</code>接口呢？接口可以使用静态类进行扩展，如以上这个类所体现的，<code>UnRegisterExtension类</code>扩展了<code>IUnRegister接口</code>，为其添加了<code>UnRegisterWhenGameObjectDestoryed方法</code>，这样所有实现接口的类的实例都能直接调用已经被静态类实现好的接口方法。</p><p>所以，继承了<code>IUnRegister接口</code>的<code>TypeEventSystemUnRegister类</code>的实例能直接调用此方法，也就是说待注销的事件能调用这个方法把自己存储好。</p><p>为什么要设计接口静态类扩展？直接全放在一个类里面不行吗？🤨</p></blockquote><ul><li>实现接口里的事件的相关方法。这里是一个事件系统，也就是说各种类型的事件都是统一管理。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeEventSystem</span> : <span class="title">ITypeEventSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRegisterations</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Registerations</span>&lt;<span class="title">T</span>&gt; : <span class="title">IRegisterations</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Action&lt;T&gt; OnEvents = e =&gt; &#123;&#125;;<span class="comment">//同类型的注册的事件集</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;Type, IRegisterations&gt; mEventRegisterations = <span class="keyword">new</span> Dictionary&lt;Type, IRegisterations&gt;();<span class="comment">//一个类型对应一个相应传参类型的事件集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="keyword">new</span> T();</span><br><span class="line">        Send&lt;T&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line">            (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents(e);  <span class="comment">//执行了方法？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUnRegister <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册的时候，先看看有没有传参类型相同的大部队</span></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            registerations = <span class="keyword">new</span> Registerations&lt;T&gt;();</span><br><span class="line">            mEventRegisterations.Add(type, registerations);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在大部队里面加入自己的个体信息</span></span><br><span class="line">        (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents += onEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回待注销的事件信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TypeEventSystemUnRegister&lt;T&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            OnEvent = onEvent,</span><br><span class="line">            TypeEventSystem = <span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line">            (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents -= onEvent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>应用例子。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeEventSystemExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventA</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventB</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ParamB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventGroup</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventC : IEventGroup</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventD : IEventGroup</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TypeEventSystem mTypeEventSystem = <span class="keyword">new</span> TypeEventSystem();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mTypeEventSystem.Register&lt;EventA&gt;(OnEventA);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem.Register&lt;EventB&gt;(b =&gt; </span><br><span class="line">                                          &#123;</span><br><span class="line">                                              Debug.Log(<span class="string">&quot;OnEventB: &quot;</span> + b.ParamB);</span><br><span class="line">                                          &#125;).UnRegisterWhenGameObjectDestoryed(gameObject);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem.Register&lt;IEventGroup&gt;(e =&gt;</span><br><span class="line">                                               &#123;</span><br><span class="line">                                                   Debug.Log(e.GetType());</span><br><span class="line">                                               &#125;).UnRegisterWhenGameObjectDestoryed(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;EventA&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;EventB&gt;(<span class="keyword">new</span> EventB()</span><br><span class="line">                                          &#123;</span><br><span class="line">                                              ParamB = <span class="number">123</span></span><br><span class="line">                                          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;IEventGroup&gt;(<span class="keyword">new</span> EventC());</span><br><span class="line">            mTypeEventSystem.Send&lt;IEventGroup&gt;(<span class="keyword">new</span> EventD());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEventA</span>(<span class="params">EventA obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnEventA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当没有直接执行扩展方法时，就要手动注销</span></span><br><span class="line">        mTypeEventSystem.UnRegister&lt;EventA&gt;(OnEventA);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230116123132177.png" alt="image-20230116123132177"></p><p>如果一个接口有多个类实现，虽然注册的时候是按照接口类型来存入字典的，但是添加事件却是用实现子类的类型……所以就是IEventGroup的效果？</p><h2 id="约束事件的使用"><a href="#约束事件的使用" class="headerlink" title="约束事件的使用"></a>约束事件的使用</h2><p>事件是<strong>自底向上</strong>通知的时候用的，在底层内部事件也可以监听。</p><p>所以将规则定义为：</p><ul><li>IController可以监听事件</li><li>ICommand可以发送事件</li><li>ISytem可以发送和监听事件</li><li>IModel可以发送事件</li></ul><p>定好规则后，先在<code>Architecture类</code>增加<strong>注册和发送事件的支持</strong>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...在IArchitecture写一下方法然后实现</span></span><br><span class="line"><span class="keyword">private</span> ITypeEventSystem mTypeEventSystem = <span class="keyword">new</span> TypeEventSystem();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.Send&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.Send&lt;T&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IUnRegister <span class="title">RegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mTypeEventSystem.Register&lt;T&gt;(onEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.UnRegister&lt;T&gt;(onEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后写规则脚本，限制接口的方法（本质是空接口再扩展方法）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSendEvent</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanSendEventExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self</span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().SendEvent&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self, T e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().SendEvent&lt;T&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanRegisterEvent</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanRegisterEventExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUnRegister <span class="title">RegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanRegisterEvent self, Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self.GetArchitecture().RegisterEvent&lt;T&gt;(onEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self, Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().UnRegisterEvent&lt;T&gt;(onEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：注册事件。通过Architecture来间接执行事件的相关方法；一个模块管理类拥有一个事件系统。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UI</span> : <span class="title">MonoBehaviour</span>, <span class="title">IController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GamePassEvent.Register(OnGamePass);</span></span><br><span class="line">        <span class="keyword">this</span>.RegisterEvent&lt;GamePassEvent&gt;(OnGamePass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGamePass</span>(<span class="params">GamePassEvent e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;Canvas/EndPanel&quot;</span>).gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GamePassEvent.UnRegister(OnGamePass);</span></span><br><span class="line">        <span class="keyword">this</span>.RegisterEvent&lt;GamePassEvent&gt;(OnGamePass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PointGame.Interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：触发事件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KillEnemyCommand</span> : <span class="title">AbstractCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gameModel = <span class="keyword">this</span>.GetModel&lt;IGameModel&gt;();</span><br><span class="line">        gameModel.KillCount.Value++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gameModel.KillCount.Value == <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SendEvent&lt;GamePassEvent&gt;(); <span class="comment"><span class="doctag">///</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="架构演化小结"><a href="#架构演化小结" class="headerlink" title="架构演化小结"></a>架构演化小结</h1><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>问题：对象之间的引用无规则。</p><p>先使用树结构整理了场景结构，然后引入对象之间交互的概念。</p><p>对象之间的交互方式：</p><ul><li>方法</li><li>委托</li><li>事件</li></ul><p>模块化的三种常规方式：</p><ul><li>单例</li><li>IOC</li><li>分层</li></ul><p>最后总结得出：</p><ul><li>自底向上用事件或者委托</li><li>自顶向下用方法</li></ul><p>这个过程中积累了一个工具类：Event基类</p><p>学习理论：</p><ul><li>表现和数据要分离</li><li>交互逻辑（Command模式）和表现逻辑（数据+事件）</li></ul><p>然后是模块化：</p><p>Model——静态类——单例——</p><p>IOC容器（访问模块对象不能是无任何规则和限制）——模块接口（访问模块对象）——</p><p>四个层级——接口的阉割技术（为层级接口增加了限制）——</p><p>增加了事件的使用规则</p><p><strong>层级之间的规则：</strong></p><ul><li>表现层<ul><li>可以获取System、Model</li><li>可以发送Command</li><li>可以监听Event</li></ul></li><li>系统层<ul><li>可以获取System、Model、Utility</li><li>可以监听、发送Event</li></ul></li><li>数据层<ul><li>可以获取Utility</li><li>可以发送Event</li></ul></li><li>工具层<ul><li>啥都不用干，可以集成第三方库，或者封装API</li></ul></li><li>Command（四个层级之外的一个重要概念）<ul><li>可以获取System、Model、Utility</li><li>可以发送Event、Command</li></ul></li></ul><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230116135422837.png" alt="image-20230116135422837"></p><p>设计方法：</p><ul><li>总览图：包含整个项目的所有System、Model、Utility对象，以及大致的表现层流程</li><li>功能实现图：针对单个业务或操作，绘制表现层对象 或 界面图、相关的System、Model、Utility对象、Command、Event的流向以及简单的引用关系。</li></ul><h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230128171630873.png" alt="image-20230128171630873"></p><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230128171745351.png" alt="image-20230128171745351"></p><blockquote><p>简洁图的表现</p></blockquote>]]></content>
    
    
    <summary type="html">Unity的游戏框架搭建</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity的Input System</title>
    <link href="https://huangxinhere.github.io/2023/01/03/Unity%E7%9A%84InputSystem/"/>
    <id>https://huangxinhere.github.io/2023/01/03/Unity%E7%9A%84InputSystem/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-02-20T04:01:45.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>在Package Manager下载。</p><h1 id="获取Input"><a href="#获取Input" class="headerlink" title="获取Input"></a>获取Input</h1><h2 id="直接从输入设备获取"><a href="#直接从输入设备获取" class="headerlink" title="直接从输入设备获取"></a>直接从输入设备获取</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.InputSystem;<span class="comment">//命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyPlayerScript</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gamepad = Gamepad.current;</span><br><span class="line">        <span class="keyword">if</span> (gamepad == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// No gamepad connected.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gamepad.rightTrigger.wasPressedThisFrame)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// &#x27;Use&#x27; code here</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Vector2 move = gamepad.leftStick.ReadValue();</span><br><span class="line">        <span class="comment">// &#x27;Move&#x27; code here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The same approach works for other Device types (for example, <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/api/UnityEngine.InputSystem.Keyboard.html"><code>Keyboard.current</code></a> or <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/api/UnityEngine.InputSystem.Mouse.html"><code>Mouse.current</code></a>).</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Keyboard.current.aKey.wasPressedThisFrame;//相当于</span><br><span class="line">Input.GetKeyDown()</span><br></pre></td></tr></table></figure><h2 id="Player-Input"><a href="#Player-Input" class="headerlink" title="Player Input"></a>Player Input</h2><p>直接获取虽然方便，但是需要分别地指定对应获取路径，而且如果响应的事件更改按键的话也很难统一更改。</p><ul><li>概念理解</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//按键（信号）——&gt;触发事件或动作（Action）——&gt;动作归类成集</span><br><span class="line">//也就是，一个动作可能由多个信号触发，一个角色有多个动作</span><br></pre></td></tr></table></figure><ul><li>Unity实现方式<ul><li>用户设置面板-asset：可视化设置动作及信号；</li><li>根据asset生成脚本以供调用。</li></ul></li></ul><h3 id="添加PlayerInput组件"><a href="#添加PlayerInput组件" class="headerlink" title="添加PlayerInput组件"></a>添加PlayerInput组件</h3><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/AddPlayerInput.png" alt="Add Player Input Component"></p><h3 id="创建Input-Actions"><a href="#创建Input-Actions" class="headerlink" title="创建Input Actions"></a>创建Input Actions</h3><p>最快的可使用默认的Actions。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/PlayerInputCreateActions.png" alt="Create Actions from Player Input Component"></p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/MyGameActions.png" alt="MyGameActions"></p><p>编辑窗口详见：<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/ActionAssets.html#editing-input-action-assets">Input Action Assets | Input System | 1.4.4 (unity3d.com)</a></p><blockquote><p>最左边栏是map，动作的集合，可以抽象为玩家的动作集合、或者UI点击等等；中间栏是Actions，首先是自定义动作，然后子内容是触发信号，可以有键盘、手柄等；右侧栏是属性，对动作或信号的具体属性进行调整。</p><p>例如：Player有一系列受玩家操作的动作，比如Move、Look、Fire，如何触发Move呢？有触摸屏的leftStick、WASD、箭头。但是在这里Move只是一个动作名称而已，如果要实现Move的具体逻辑，还要知道如何获取信号并实现逻辑。</p></blockquote><h3 id="设置Action的具体逻辑"><a href="#设置Action的具体逻辑" class="headerlink" title="设置Action的具体逻辑"></a>设置Action的具体逻辑</h3><p>其中PlayerInput有Behavior的设置，有多种响应方法。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/PlayerInputNotificationBehaviors.png" alt="PlayerInput Notification Behavior"></p><p>Behavior的选择详见：<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Components.html#notification-behaviors">GameObject components for input | Input System | 1.4.4 (unity3d.com)</a></p><p>以下这个方法用了Invoke Unity Event，就像为UI设置响应事件一样，拖脚本实现其中的方法。</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/MyPlayerActionEvents.png" alt="PlayerInput Action Events"></p><ul><li>如果响应事件需要用到信号相关内容，可以使用传参</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyPlayerScript : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public void Fire(InputAction.CallbackContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Fire!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体参数说明详见：<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#action-callbacks">Actions | Input System | 1.4.4 (unity3d.com)</a></p><h2 id="更灵活的方法"><a href="#更灵活的方法" class="headerlink" title="更灵活的方法"></a>更灵活的方法</h2><h1 id="Maps、Actions与Binding详解"><a href="#Maps、Actions与Binding详解" class="headerlink" title="Maps、Actions与Binding详解"></a>Maps、Actions与Binding详解</h1><p>Input Actions是为了将输入信号（物理）和对应的逻辑语义分离。比如角色有Run这个响应事件，不需要知道是按AD键还是触摸屏还是手柄的什么键，只需要知道这个Run被触发了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//传统方法：对每一种可能的按键进行检查 其是否触发动作</span><br><span class="line">var look = new Vector2();</span><br><span class="line"></span><br><span class="line">var gamepad = Gamepad.current;</span><br><span class="line">if (gamepad != null)</span><br><span class="line">    look = gamepad.rightStick.ReadValue();</span><br><span class="line"></span><br><span class="line">var mouse = Mouse.current;</span><br><span class="line">if (mouse != null)</span><br><span class="line">    look = mouse.delta.ReadValue();</span><br><span class="line"></span><br><span class="line">//改进：只看Look是否被触发</span><br><span class="line">myControls.gameplay.look.performed +=</span><br><span class="line">    context =&gt; look = context.ReadValue&lt;Vector2&gt;();</span><br><span class="line"></span><br><span class="line">//而对应信号直接手动设置便可</span><br></pre></td></tr></table></figure><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/LookActionBinding.png" alt="Look Action Binding"></p><ul><li>一些要用到的名词及概念</li></ul><table><thead><tr><th align="center">名词</th><th align="center">概念</th></tr></thead><tbody><tr><td align="center">Action</td><td align="center"></td></tr><tr><td align="center">Binding</td><td align="center"></td></tr><tr><td align="center">Interaction</td><td align="center">input的模式</td></tr></tbody></table><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Actions的API中有三种关键的类：InputActionAsset、InputActionMap、InputAction。</p><p>其中每一个Action、Map在同类里面的名字必须是唯一的，也有id（改了名字也不会变）。<code>InputAction.name</code>,<code>InputAction.actionMap</code>,<code>InputAction.id</code>;</p><p><code>InputActionMap.name</code>,<code>InputActionMap.asset</code>,<code>InputActionMap.id</code>;</p><h2 id="创建Actions"><a href="#创建Actions" class="headerlink" title="创建Actions"></a>创建Actions</h2><h3 id="用Action编辑器"><a href="#用Action编辑器" class="headerlink" title="用Action编辑器"></a>用Action编辑器</h3><h3 id="在MonoBehaviours中嵌入"><a href="#在MonoBehaviours中嵌入" class="headerlink" title="在MonoBehaviours中嵌入"></a>在MonoBehaviours中嵌入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public MyBehavior : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public InputAction fireAction;</span><br><span class="line">    public InputAction lookAction;</span><br><span class="line"></span><br><span class="line">    public InputActionMap gameplayActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在编辑器可以直观更改：</p><p><img src="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/images/MyBehaviorInspector.png" alt="MyBehavior Inspector"></p><ul><li>除此之外还要手动enable和disable</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class MyBehavior : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        fireAction.performed += OnFire;</span><br><span class="line">        lookAction.performed += OnLook;</span><br><span class="line"></span><br><span class="line">        gameplayActions[&quot;fire&quot;].performed += OnFire;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnEnable()</span><br><span class="line">    &#123;</span><br><span class="line">        fireAction.Enable();</span><br><span class="line">        lookAction.Enable();</span><br><span class="line"></span><br><span class="line">        gameplayActions.Enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void OnDisable()</span><br><span class="line">    &#123;</span><br><span class="line">        fireAction.Disable();</span><br><span class="line">        lookAction.Disable();</span><br><span class="line"></span><br><span class="line">        gameplayActions.Disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>涉及到Json和代码创建，暂不了解。</p><h2 id="使用Actions"><a href="#使用Actions" class="headerlink" title="使用Actions"></a>使用Actions</h2><ul><li>首先必须启用。一组启用比单个启用效率更高</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enable a single action.</span></span><br><span class="line">lookAction.Enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable an en entire action map.</span></span><br><span class="line">gameplayActions.Enable();</span><br></pre></td></tr></table></figure><ul><li>启用时，Actions就能动态监听输入；根据输入设置中的更新模式来更新（Update等）</li></ul><h3 id="响应Actions"><a href="#响应Actions" class="headerlink" title="响应Actions"></a>响应Actions</h3><p>Actions并不会自动处理响应，而是通知你相应的输入信号已发生。响应的途径有以下几种：（前两种重点）</p><ul><li>每个Action有<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#action-callbacks"><code>started</code>, <code>performed</code>,<code>canceled</code> callback</a></li><li>每个Action Map有 <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#inputactionmapactiontriggered-callback"><code>actionTriggered</code> callback</a>.</li><li>The Input System has a global <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#inputsystemonactionchange-callback"><code>InputSystem.onActionChange</code> callback</a>.</li><li>You can <a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#polling-actions">poll the current state</a> of an Action whenever you need it.</li><li><a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.4/manual/Actions.html#inputactiontrace"><code>InputActionTrace</code></a> can record changes happening on Actions.</li></ul><p><strong><u>Action callbacks</u></strong></p><h1 id="Input-Action-Assets-详解"><a href="#Input-Action-Assets-详解" class="headerlink" title="Input Action Assets 详解"></a>Input Action Assets 详解</h1><ul><li><p>内容：Input Actions以及对应的Bindings和Control Schemes。以<code>.inputactions</code>为文件扩展名，JSON格式。</p><blockquote><p>binding：</p></blockquote></li></ul><h2 id="创建asset"><a href="#创建asset" class="headerlink" title="创建asset"></a>创建asset</h2><p>在Project 创建，Input Actions。</p><h2 id="编辑asset"><a href="#编辑asset" class="headerlink" title="编辑asset"></a>编辑asset</h2><h2 id="使用asset"><a href="#使用asset" class="headerlink" title="使用asset"></a>使用asset</h2>]]></content>
    
    
    <summary type="html">新输入系统</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity的状态机实现</title>
    <link href="https://huangxinhere.github.io/2022/12/18/Unity%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/"/>
    <id>https://huangxinhere.github.io/2022/12/18/Unity%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-12-17T16:00:00.000Z</published>
    <updated>2022-12-26T11:26:08.754Z</updated>
    
    <content type="html"><![CDATA[<p>上次接触状态机还是项目中用的插件，现在就从头到尾来捋一遍状态机。</p><h1 id="什么是状态机"><a href="#什么是状态机" class="headerlink" title="什么是状态机"></a>什么是状态机</h1><ul><li>当前只能有一个状态</li><li>状态可以进行切换</li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="概念抽象化"><a href="#概念抽象化" class="headerlink" title="概念抽象化"></a>概念抽象化</h2><p>从代码实现的目的来思考，首先想一下怎么抽象这个概念。可以先从两个方面来概括状态机：一个是某个独立的状态，一个是控制状态变换的东西。</p><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/1c5346cc9c45a3bb.png" alt="image-20221218102556949"></p><blockquote><p>对于每个状态来说，都有状态开始-进行中-结束这三种阶段，所以是每个状态独自处理的；而控制机就是控制状态切换，比如跑步状态Exit，则待机状态Enter。</p></blockquote><h2 id="代码思路设计"><a href="#代码思路设计" class="headerlink" title="代码思路设计"></a>代码思路设计</h2><ul><li>首先设计状态类。因为暂时没有逻辑控制，只是负责实现方法，没有方法的调用，所以相对简单。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/070f114163b13226.png" alt="image-20221218110352498"></p><blockquote><p>（第一次画类图有很多错误，接下来会逐步改正）但还有一个问题是，每个具体状态，其实还要相关的组件来进行控制。所以要获取组件的变量。如果这些类都不继承Monobehaviour的话，就需要通过方法来获得组件变量。所以更改参考PlayerState如下：</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/6448af0f1ed0b868.png" alt="image-20221218111830564"></p><blockquote><p>可见父类通过Initialize方法获得了组件变量作为字段，那么子类就可以直接用了。</p><p>对于父子类继承个人理解还不够深入。刚开始想为什么子类每个都要执行Initialize方法，执行一次父类不就有初始化的字段来供子类使用了吗？这个想法是错误的，首先实例化的是子类，父类并没有实例化，子类只是可以直接使用父类的模板（声明好的字段和方法）罢了。</p></blockquote><ul><li><p>然后是控制机的设计。控制机就是负责状态类方法的调用，来实现状态的执行和转换，所以控制机方法有：启动一个状态、转换状态；还有执行状态的各个阶段。</p><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/779d1d07a42df21e.png" alt="image-20221218115730714"></p><blockquote><p>到目前为止，初步的思路已经进行到这，但是实际能跑通吗？很明显不行，缺少了状态转换的关键步骤。从概念图来看控制机似乎独立于状态之外，其实要执行控制机的转换状态方法，还需要状态自身来调用控制机方法，为了实现这个，状态还得拥有控制机的实例来调用方法。</p></blockquote></li></ul><p>那么进一步思考，每个具体状态（Run、Idle等）都要用State Machine的实例，怎么获得呢？就如刚刚所言用Initialize方法获得。那么Initialize方法在哪调用呢？很明显归于控制机管理。State所需的组件变量就由控制机提供，这就进一步延申控制机的功能：综合组织状态变量，并提供相应的组件变量。</p><p><img src="https://s3.bmp.ovh/imgs/2022/12/18/5b812dfca3ece921.png" alt="image-20221218120854571"></p><p>综合以上，控制机就是实现状态阶段执行方法、状态转换方法（父类）；获取所有状态实例，并传给它们所需的变量以及自身来供它们调用（子类）。</p><p>进一步理解父子类继承的特点应用：父类抽象方法，子类获得更具体的字段来执行方法……</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="IState"><a href="#IState" class="headerlink" title="IState"></a>IState</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface IState</span><br><span class="line">&#123;</span><br><span class="line">    public void Enter();</span><br><span class="line">    public void Exit();</span><br><span class="line">    public void LoginUpdate();</span><br><span class="line">    public void PhysicsUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PlayerState"><a href="#PlayerState" class="headerlink" title="PlayerState"></a>PlayerState</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerState : ScriptableObject, IState</span><br><span class="line">&#123;</span><br><span class="line">    protected Animator animator;</span><br><span class="line">    protected PlayerInput input;</span><br><span class="line">    protected PlayerStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">    public void Initialize(Animator animator, PlayerInput input, PlayerStateMachine stateMachine)</span><br><span class="line">    &#123;</span><br><span class="line">        this.animator = animator;</span><br><span class="line">        this.input = input;</span><br><span class="line">        this.stateMachine = stateMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void Enter()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void Exit()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void LoginUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public virtual void PhysicsUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PlayerState-Idle"><a href="#PlayerState-Idle" class="headerlink" title="PlayerState_Idle"></a>PlayerState_Idle</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">[CreateAssetMenu(menuName = &quot;Data/StateMachine/PlayerState/Idle&quot;, fileName = &quot;PlayerState_Idle&quot;)]</span><br><span class="line">public class PlayerState_Idle : PlayerState</span><br><span class="line">&#123;</span><br><span class="line">    public override void Enter()</span><br><span class="line">    &#123;</span><br><span class="line">        animator.Play(&quot;Idle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void LoginUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        if (input.Move)</span><br><span class="line">        &#123;</span><br><span class="line">            stateMachine.SwitchState(typeof(PlayerState_Run));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="StateMachine"><a href="#StateMachine" class="headerlink" title="StateMachine"></a>StateMachine</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class StateMachine : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    IState currentState;</span><br><span class="line">    protected Dictionary&lt;System.Type, IState&gt; stateTable;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.LoginUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void FixedUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.PhysicsUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void SwitchOn(IState newState)</span><br><span class="line">    &#123;</span><br><span class="line">        currentState = newState;</span><br><span class="line">        currentState.Enter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SwitchState(IState newState)</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.Exit();</span><br><span class="line">        SwitchOn(newState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SwitchState(System.Type newStateType)</span><br><span class="line">    &#123;</span><br><span class="line">        currentState.Exit();</span><br><span class="line">        SwitchOn(stateTable[newStateType]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PlayerStateMachine"><a href="#PlayerStateMachine" class="headerlink" title="PlayerStateMachine"></a>PlayerStateMachine</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerStateMachine : StateMachine</span><br><span class="line">&#123;</span><br><span class="line">    [SerializeField] PlayerState[] states;</span><br><span class="line">    Animator animator;</span><br><span class="line">    PlayerInput input;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponentInChildren&lt;Animator&gt;();</span><br><span class="line">        input = GetComponent&lt;PlayerInput&gt;();</span><br><span class="line"></span><br><span class="line">        stateTable = new Dictionary&lt;System.Type, IState&gt;(states.Length);</span><br><span class="line"></span><br><span class="line">        foreach (PlayerState state in states)</span><br><span class="line">        &#123;</span><br><span class="line">            state.Initialize(animator, input, this);</span><br><span class="line">            stateTable.Add(state.GetType(), state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        SwitchOn(stateTable[typeof(PlayerState_Idle)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码实现过程中的一些技巧"><a href="#代码实现过程中的一些技巧" class="headerlink" title="代码实现过程中的一些技巧"></a>代码实现过程中的一些技巧</h1><h2 id="字典管理"><a href="#字典管理" class="headerlink" title="字典管理"></a>字典管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//前提是每个状态都独立不同（类型不同）</span><br><span class="line">Dictionary&lt;System.Type, IState&gt; stateTable;</span><br><span class="line"></span><br><span class="line">//取键方便</span><br><span class="line">stateTable[typeof(PlayerState_Idle)]</span><br></pre></td></tr></table></figure><p>System.Type是类的类型。</p><h2 id="私有但是可以在编辑器修改的变量"><a href="#私有但是可以在编辑器修改的变量" class="headerlink" title="私有但是可以在编辑器修改的变量"></a>私有但是可以在编辑器修改的变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SerializeField] float resetTime = 3.0f;</span><br></pre></td></tr></table></figure><h2 id="OnTriggerEnter检查碰撞的是否是玩家"><a href="#OnTriggerEnter检查碰撞的是否是玩家" class="headerlink" title="OnTriggerEnter检查碰撞的是否是玩家"></a>OnTriggerEnter检查碰撞的是否是玩家</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//这种写法直接获得了对方的组件</span><br><span class="line">private void OnTriggerEnter(Collider other)</span><br><span class="line">&#123;</span><br><span class="line">    if (other.TryGetComponent&lt;PlayerController&gt;(out PlayerController player))</span><br><span class="line">    &#123;</span><br><span class="line">       //....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Invoke和协程"><a href="#Invoke和协程" class="headerlink" title="Invoke和协程"></a>Invoke和协程</h2><ul><li>Invoke</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invoke(nameof(MethodName),time);//nameof()又比直接字符串好用</span><br></pre></td></tr></table></figure><p>短时间内调用次数较多的时候，Invoke性能较差。用协程比较好。</p><h2 id="OnGUI来进行调试"><a href="#OnGUI来进行调试" class="headerlink" title="OnGUI来进行调试"></a>OnGUI来进行调试</h2><p>将调试信息显示在游戏运行画面上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void OnGUI()</span><br><span class="line">&#123;</span><br><span class="line">    Rect rect = new Rect(200, 200, 200, 200);</span><br><span class="line">    string message = &quot;...&quot;;</span><br><span class="line">    GUIStyle style = new GUIStyle();</span><br><span class="line"></span><br><span class="line">    style.fontSize = 20;</span><br><span class="line">    style.fontStyle = FontStyle.Bold;</span><br><span class="line"></span><br><span class="line">    GUI.Label(rect, message, style);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="碰撞层"><a href="#碰撞层" class="headerlink" title="碰撞层"></a>碰撞层</h2><p>如果不想每次碰撞都检测是否为玩家对象那么麻烦的话，可以将Interactable的对象设置成只和Player层碰撞。</p><p><img src="/2022/12/18/Unity%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/hexo_github_blog\source_posts\Unity的状态机实现.assets\image-20221225102722467.png" alt="image-20221225102722467"></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h2 id="获取脚本实例的方法"><a href="#获取脚本实例的方法" class="headerlink" title="获取脚本实例的方法"></a>获取脚本实例的方法</h2><ul><li><p>声明public或SerializeField，在编辑器里面赋予</p></li><li><p>组件或脚本：GetComponent </p></li><li><p>类的静态字段（如单例等）</p></li><li><p>Scriptable，可在资产中直接创建实例</p><ul><li>这样可以将多种实例作为数据保存下来，也可以方便在编辑器里面编辑</li></ul></li><li><p>一些API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//1.GameObject.Find() 通过名字或路径</span><br><span class="line">GameObject.Find(&quot;...&quot;)//方便但效率低；无法找隐藏物体</span><br><span class="line"></span><br><span class="line">//2.Transform.Find()</span><br><span class="line">GameObject root = GameObject.Find(&quot;MapRoot&quot;);//根下面的（非）隐藏物体都可找到；路径/名字</span><br><span class="line"></span><br><span class="line">GameObject map =  root.transform.Find(&quot;map&quot;).gameObject;       </span><br><span class="line">map.SetActive(true);</span><br><span class="line"></span><br><span class="line">//3.通过类型查找（FindWithTag方法）</span><br><span class="line">GameObject.FindGameObjectsWithTag()</span><br><span class="line">Resources.FindObjectsOfTypeAll()</span><br><span class="line">    </span><br><span class="line">//4.通过标签查找（FindObjectOfType方法）</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/s1314_JHC/article/details/80811834">(40条消息) Unity中各种查找物体的方法_s1314_JHC的博客-CSDN博客</a></p></li></ul><h2 id="退出应用"><a href="#退出应用" class="headerlink" title="退出应用"></a>退出应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//可以退出编辑器或实际应用</span><br><span class="line">public static void QuitGame()</span><br><span class="line">&#123;</span><br><span class="line">    #if UNITY_EDITOR</span><br><span class="line">        UnityEditor.EditorApplication.isPlaying = false;</span><br><span class="line">    #else </span><br><span class="line">        Application.Quit();</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>非常方便方法的归类和管理。一些重复被使用的方法，可以在类里面（继承或不继承Mono..）声明静态方法。</p><h2 id="控制UI的显示和关闭"><a href="#控制UI的显示和关闭" class="headerlink" title="控制UI的显示和关闭"></a>控制UI的显示和关闭</h2><p>以前都是习惯直接把物体SetActive的，这样的问题是不方便挂载脚本也就不能独立实现功能了。所以可以把Canvas组件关闭，这样就方便许多，不容易出错。</p>]]></content>
    
    
    <summary type="html">关于Unity2D物理系统的深入学习</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>人物移动手感</title>
    <link href="https://huangxinhere.github.io/2022/11/08/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/"/>
    <id>https://huangxinhere.github.io/2022/11/08/%E4%BA%BA%E7%89%A9%E7%A7%BB%E5%8A%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</id>
    <published>2022-11-07T16:00:00.000Z</published>
    <updated>2023-02-20T04:04:53.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题：Update和FixedUpdate导致坑越来越深"><a href="#问题：Update和FixedUpdate导致坑越来越深" class="headerlink" title="问题：Update和FixedUpdate导致坑越来越深"></a>问题：Update和FixedUpdate导致坑越来越深</h1><h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//input</span><br><span class="line">if(!isJumped)</span><br><span class="line">&#123;</span><br><span class="line">    movement.GroundToMidAir();</span><br><span class="line">    jumpTime = Time.time + moveData.jumpHoldDuration;</span><br><span class="line">    speedUpTime = Time.time + moveData.speedUpDuration;</span><br><span class="line">    isJumped = true;</span><br><span class="line">    jumpPressed = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(jumpHeld)//Update</span><br><span class="line">&#123;</span><br><span class="line">    if(jumpTime &gt; Time.time)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Time.time: &quot; + Time.time);</span><br><span class="line">        //TODO:根据按压时间受力</span><br><span class="line">        movement.SpeedUpJump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不同电脑可能出现跳跃高度不同的情况。</li><li>每次跳跃的极限高度可能不同，甚至会小跳</li><li>各种各样的跳跃bug：突然飞升，跳不起来……等等</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>刚开始以为是Time有问题，对Time研究了一下（关于Time的博客）然而Time是符合真实世界的。</li></ul>]]></content>
    
    
    <summary type="html">实践ing</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity的物理系统</title>
    <link href="https://huangxinhere.github.io/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/"/>
    <id>https://huangxinhere.github.io/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/</id>
    <published>2022-11-07T16:00:00.000Z</published>
    <updated>2023-02-20T04:11:00.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>​    好奇心（以及一个多月的折磨）驱动我去探究理解物理引擎。写项目的时候一直在骂unity物理引擎，这么多年的推进Unity的物理真的很烂吗？后来进行项目复盘的时候才慢慢理解写了很多的rigidbody和collision到底是怎么回事……还有很多很多待解决的疑问……</p><p>​    研究中途回来补充：Unity 3D 中的物理引擎分为 2D 引擎和 3D 引擎两部分，其中 2D 引擎使用的 <code>Erin Catto</code> 写的是 Box2D，而 3D 引擎使用的的 NVIDIA 的 <code>PhysX</code>。</p><p><a href="https://blog.csdn.net/linshuhe1/article/details/94173345">(39条消息) PhysX 物理引擎研究（一）源码编译_河乐不为的博客-CSDN博客_physx源码</a></p><h1 id="Physics2D-gravity"><a href="#Physics2D-gravity" class="headerlink" title="Physics2D.gravity"></a>Physics2D.gravity</h1><p>Acceleration due to gravity.</p><h1 id="Physics2D-Raycast"><a href="#Physics2D-Raycast" class="headerlink" title="Physics2D.Raycast"></a><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Physics2D.html">Physics2D</a>.Raycast</h1><p><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Physics2D.Raycast.html">Physics2D-Raycast - Unity 脚本 API</a></p><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>public static <a href="https://docs.unity.cn/cn/2019.4/ScriptReference/RaycastHit2D.html">RaycastHit2D</a> <strong>Raycast</strong> (<a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Vector2.html">Vector2</a> <strong>origin</strong>, <a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Vector2.html">Vector2</a> <strong>direction</strong>, float <strong>distance</strong>= Mathf.Infinity, int <strong>layerMask</strong>= DefaultRaycastLayers, float <strong>minDepth</strong>= -Mathf.Infinity, float <strong>maxDepth</strong>= Mathf.Infinity);</p><table><thead><tr><th><strong>origin</strong></th><th><strong>射线在 2D 空间中的起点。</strong></th></tr></thead><tbody><tr><td>direction</td><td>表示射线方向的矢量。</td></tr><tr><td>distance</td><td>射线的最大投射距离。</td></tr><tr><td>layerMask</td><td>过滤器，用于仅在特定层上检测碰撞体。</td></tr><tr><td>minDepth</td><td>仅包括 Z 坐标（深度）大于或等于该值的对象。</td></tr><tr><td>maxDepth</td><td>仅包括 Z 坐标（深度）小于或等于该值的对象。</td></tr></tbody></table><h2 id="例子解析"><a href="#例子解析" class="headerlink" title="例子解析"></a>例子解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Example : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    // Float a rigidbody object a set distance above a surface.</span><br><span class="line"></span><br><span class="line">    public float floatHeight;     // Desired floating height.</span><br><span class="line">    public float liftForce;       // Force to apply when lifting the rigidbody.</span><br><span class="line">    public float damping;         // Force reduction proportional to speed (reduces bouncing).</span><br><span class="line"></span><br><span class="line">    Rigidbody2D rb2D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        rb2D = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void FixedUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        // Cast a ray straight down.</span><br><span class="line">        RaycastHit2D hit = Physics2D.Raycast(transform.position, -Vector2.up);</span><br><span class="line"></span><br><span class="line">        // If it hits something...</span><br><span class="line">        if (hit.collider != null)</span><br><span class="line">        &#123;</span><br><span class="line">            // Calculate the distance from the surface and the &quot;error&quot; relative</span><br><span class="line">            // to the floating height.</span><br><span class="line">            float distance = Mathf.Abs(hit.point.y - transform.position.y);</span><br><span class="line">            float heightError = floatHeight - distance;</span><br><span class="line"></span><br><span class="line">            // The force is proportional to the height error, but we remove a part of it</span><br><span class="line">            // according to the object&#x27;s speed.</span><br><span class="line">            float force = liftForce * heightError - rb2D.velocity.y * damping;</span><br><span class="line"></span><br><span class="line">            // Apply the force to the rigidbody.</span><br><span class="line">            rb2D.AddForce(Vector3.up * force);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>大概意思是，发射射线检测碰撞，如果和射线检测到的相差较远（heightError），将要施加的力（force）会根据 liftForce（固定） * heightError（不确定的高度差）来决定速度的大小。damping是阻尼，阻碍上升运动；然后只要hit不为空，就一直运动：每帧施加力。</p></blockquote><h2 id="RaycastHit2D"><a href="#RaycastHit2D" class="headerlink" title="RaycastHit2D"></a>RaycastHit2D</h2><p>是此方法返回的一个类型，其包含了一些属性（检测对象的一些信息）。<a href="https://docs.unity.cn/cn/current/ScriptReference/RaycastHit2D.html">UnityEngine.RaycastHit2D - Unity 脚本 API</a></p><h1 id="Rigidbody-2D"><a href="#Rigidbody-2D" class="headerlink" title="Rigidbody 2D"></a>Rigidbody 2D</h1><p>  此部分是经过自己通读官方英文文档来理解翻译的，没有cv - -</p><h2 id="为什么有Rigidbody？"><a href="#为什么有Rigidbody？" class="headerlink" title="为什么有Rigidbody？"></a>为什么有Rigidbody？</h2><ul><li>Transform组件控制物体的位置旋转和缩放，同样也控制着其他组件。而collider因为物理碰撞的原因会自动改变Transform的参数；这个改变Transform的过程就需要物理引擎(physics engine)来操作，因此物理引擎需要一个方法来完成这个任务。所以——刚体Rigidbody就用来移动和连接Collider。</li></ul><h2 id="关于Rigidbody和Collider"><a href="#关于Rigidbody和Collider" class="headerlink" title="关于Rigidbody和Collider"></a>关于Rigidbody和Collider</h2><ul><li>Rigidbody继承了Transform所以可以Update位置和旋转。</li><li>同一个游戏对象（以及子物体）所有的Collider2D都隐式地与其Rigidbody连接。也就是说Collider会跟着Rigidbody移动。（现在回想到移动物体都是用rb的方法，从来没有Collider的移动方法可调用，现在可以理解了）所以凡是Collider的移动都不能通过Transform或者它的位移等等，只能通过Rigidbody，这样才能确保其运动符合真实的物理情况。而连接同一个Rigidbody的Collider则不会发生碰撞。</li><li>只有Collider可以碰撞，Rigidbody不能。</li></ul><h2 id="具体参数"><a href="#具体参数" class="headerlink" title="具体参数"></a>具体参数</h2><h3 id="Body-Type"><a href="#Body-Type" class="headerlink" title="Body Type"></a>Body Type</h3><ul><li>任何一个Collider默认和绑定的Rigidbody的BodyType一致（或着理解为继承）。</li><li>这个参数影响移动和旋转行为 &amp; 碰撞体的交互</li><li>这个参数改变时，一些质量相关的内部参数就要被重新计算，所有相关Collider和Rigidbody的联系也要在下一个FixedUpdate重新计算。</li></ul><h4 id="Dynamic"><a href="#Dynamic" class="headerlink" title="Dynamic"></a>Dynamic</h4><p><img src="file:///D:/Unity/2021.3.8f1c1/Editor/Data/Documentation/en/uploads/Main/Rigidbody2D_Dynamic.png" alt="img"></p><ul><li>可以和任何其他BodyType的碰撞</li><li>最常用、代价最昂贵、最完善</li><li>不能通过改变Transform来改变Dynamic Rigidbody（也有想过既然Rigidbody不好处理为什么不直接用Transform呢，看来这个类型不可以，要谨记）。模拟是通过刚体的速度来控制刚体的位置的（这或许是官方改变速度的原因之一），为了达到这个目的可以通过脚本直接控制力或者间接改变碰撞collisions和重力gravity（？后半不懂了）</li></ul><table><thead><tr><th>Property</th><th>Function</th></tr></thead><tbody><tr><td>Body Type</td><td>控制位置、旋转和碰撞体间的相互作用</td></tr><tr><td>Material</td><td>一个Collider优先使用自己的Material；否则用Rigidbody的Material。除了个别设置的，Rigidbody会默认设置所有的Collider的material统一</td></tr><tr><td>Simulated</td><td>勾选：rigidbody和对应colliders以及相关的2Ds都能响应physics simulation</td></tr><tr><td>Use Auto Mass</td><td>勾选：rigidbody根据它的Colliders来自动定义物体的质量Mass</td></tr><tr><td>Collision Detection</td><td>如何检测Colliders之间的碰撞</td></tr><tr><td>-Discrete</td><td>离散。每个物理帧刷新新的位置，所以速度足够快时可能会互相穿过。</td></tr><tr><td>-Continuous</td><td>连续。Colliders会连续移动，这样会消耗更多的CPU。</td></tr><tr><td>Sleeping Mode</td><td>当GameObject处于闲置状态时，会如何“睡眠”来节约处理器空间</td></tr><tr><td>-Never Sleep</td><td>不会睡眠；尽可能避免，因为它会影响系统资源</td></tr><tr><td>-Start Awake</td><td>初始化的时候是醒着的</td></tr><tr><td>-Start Asleep</td><td>初始化的时候是睡的但是一旦有碰撞就醒来（上面的是一开始就活跃，主动型；这个是被动型）</td></tr><tr><td>Interpolate插值</td><td>两个FixedUpdate之间的移动如何过渡（当运动很卡顿的时候有用）</td></tr><tr><td>-None</td><td>没有平滑</td></tr><tr><td>-Interpolate</td><td>根据上一帧来平滑</td></tr><tr><td>-Extrapolate</td><td>根据下一帧来预测、平滑</td></tr></tbody></table><h4 id="Kinematic"><a href="#Kinematic" class="headerlink" title="Kinematic"></a>Kinematic</h4><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\Rigidbody2D_Kinematic.png" alt="img"></p><ul><li>会根据模拟（simulation）来运动，但是要明确的用户控制。</li><li>Dynamic是受重力和力来运动的，而Kinematic不是，所以会更快而且对系统资源有更低要求。</li><li>Kinematic明确受Rigidbody2D.MovePosition / MoveRotation来运动；利用物理查询（physics queries）来检测碰撞，用脚本来控制什么时候&amp;什么地方来移动（想象一下，如果Kinematic不受力-//除了力还能受到物理系统什么控制…//，那么就不能像Dynamic那样因为受到阻力而停止等，落地那样还得自己检测并控制位移）</li><li>Kinematic通过速度来移动，但是不会受到力的影响。kinematic rigidbody不会和kinematic/static rigidbody碰撞（除了Trigger；例如OnCollisionEnter等等<strong>碰撞脚本回调会不生效</strong>）；kinematic的表现像移动不了的物体（质量无穷大…？），质量的相关参数也不可得。</li><li>可能应用的场景：一个collider设为了trigger，但还是想触发其他trigger？可以加一个kinematic的body，这样不会受力的影响而移动位置；偶尔移动的物体——如适当时机会开合的门……【结合例子多多考虑】</li><li>还有ragdoll effect：例如人物被炸出去的时候是根据动画来正常移动的，为了不让力额外增加其他效果，可以把四肢或者什么设成kinematic，直到结束的时候才设为原来值</li></ul><table><thead><tr><th>Property</th><th>Function</th></tr></thead><tbody><tr><td>(以上雷同的就不再赘述)</td><td></td></tr><tr><td>Use Full Kinematic Contacts</td><td>勾选：kinematic会和所有类型产生碰撞/碰撞脚本回调也会生效；否则只会和Dynamic</td></tr></tbody></table><h4 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h4><ul><li>在模拟中永远不会移动；只会和Dynamic碰撞；不支持两个static rigidbody会碰撞，因为都不会移动</li><li>没有rigidbody的Collider默认是这个类型（方便）</li><li>特意设置一个类型为static的rigidbody（看需求：如果需要动态设置或者移动static collider的时候，可以通过统一的rigidbody来控制）</li></ul><h3 id="Simulated"><a href="#Simulated" class="headerlink" title="Simulated"></a>Simulated</h3><ul><li><p>一旦勾选（不勾选反之）</p><ul><li>Rigidbody通过模拟来运动（受到重力和物理的力）</li><li>Collider：继续产生新的相互作用</li><li>Joint 2Ds（所有关节连接？）产生模拟效果</li><li>所有关于Rigidbody、collider、Joint2D内部的物理物体physics objects都会保存在存储中（？</li></ul><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221124151113413.png" alt="image-20221124151113413"></p><blockquote><p>如果取消勾选，则会提示：rigidbody连带所有相关的Collider、关节、或效果器（如2D平台）都会脱离模拟。似乎将没有任何物理相关的模拟了……那么要这个选项干嘛呢？</p></blockquote></li><li><p>要这个选项干嘛？文档接下来提到Why is unchecking Simulated more efficient than individual component controls? 取消勾选这个东西会比单独控制组件更有效。</p><ul><li>先理解这点：在2D物理模拟系统中，rigidbody控制相连Collider的位置和旋转，也使得Joint可以利用这些位置和旋转作为锚点。还有Colliders之间的碰撞……等等，这些都需要模拟的时间。（重复翻译几次也不嫌啰嗦吧）</li><li>启用和禁用单独的物理模拟要素其实要消耗内存和拖慢处理器的。如果使用启用和禁用就意味着物理模拟系统要创建和销毁internal GameObjects &amp; physics-based components。那么直接把模拟给禁用了则会高效和容易得多。【这个得结合例子具体理解了，等待 】</li></ul></li></ul><h1 id="Collision"><a href="#Collision" class="headerlink" title="Collision"></a>Collision</h1><h2 id="Collision相关介绍"><a href="#Collision相关介绍" class="headerlink" title="Collision相关介绍"></a>Collision相关介绍</h2><h3 id="Compound-colliders"><a href="#Compound-colliders" class="headerlink" title="Compound colliders"></a>Compound colliders</h3><ul><li>碰撞体的组合来模拟物体的物理碰撞范围。可以在子物体添加碰撞体来使形状更复杂，但要在父物体用一个Rigidbody来管理所有的Collider</li><li>基础的碰撞体不能使用剪切变换（一种不熟悉的空间线性变换）</li></ul><h3 id="Mesh-Colliders"><a href="#Mesh-Colliders" class="headerlink" title="Mesh Colliders"></a>Mesh Colliders</h3><ul><li>如果简单的碰撞体组合还是不够准确的话，可以用Mesh Colliders来准确的符合3D物体的mesh；2D则是Polygon Collider 2D（可编辑）。</li><li>这种碰撞体更多地消耗处理器，所以要谨慎使用。</li><li>一个mesh碰撞体不能和另一个mesh碰撞体碰撞；但可以通过勾选Convex属性（翻译为凸的），这个会产生凸壳？就像在原来的mesh进行内里的填充…？</li></ul><h3 id="Static-colliders"><a href="#Static-colliders" class="headerlink" title="Static colliders"></a>Static colliders</h3><ul><li>静态物体，可以和dynamic类型的碰撞体碰撞</li></ul><h3 id="Physics-materials"><a href="#Physics-materials" class="headerlink" title="Physics materials"></a>Physics materials</h3><ul><li>虽然碰撞体不会形变，摩擦力和弹性可以通过物理材质来控制</li></ul><h3 id="Triggers-Collision-callbacks-for-scripts-collider-interactions"><a href="#Triggers-Collision-callbacks-for-scripts-collider-interactions" class="headerlink" title="Triggers/Collision callbacks for scripts/collider interactions"></a>Triggers/Collision callbacks for scripts/collider interactions</h3><p>略</p><h3 id="Collision-action-matrix"><a href="#Collision-action-matrix" class="headerlink" title="Collision action matrix"></a>Collision action matrix</h3><p>Collision和Trigger对应不同body type类型触发是否有效</p><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221124224140674.png" alt="image-20221124224140674"></p><h2 id="连续碰撞检测（CCD）"><a href="#连续碰撞检测（CCD）" class="headerlink" title="连续碰撞检测（CCD）"></a>连续碰撞检测（CCD）</h2><p><a href="https://docs.unity.cn/cn/2021.3/Manual/ContinuousCollisionDetection.html#sweep">连续碰撞检测 (CCD) - Unity 手册</a></p><ul><li>对于其中的算法原理，没能找到很好的解释（看来只能老实分析例子代码了），有一些辅助理解的博客</li></ul><p>AABB</p><p><a href="https://blog.csdn.net/flj135792468/article/details/120654391">(39条消息) ❤️UNITY实战进阶-三维AABB包围盒详解-6_Jerrt-J的博客-CSDN博客_aabb盒</a></p><p>OBB</p><p><a href="https://blog.csdn.net/flj135792468/article/details/120759839?spm=1001.2014.3001.5502">(39条消息) ❤️UNITY实战进阶-OBB包围盒详解-6_Jerrt-J的博客-CSDN博客</a></p><p>属性面板的检测模式：</p><p><a href="https://blog.csdn.net/kill566666/article/details/127387079?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-127387079-blog-106075532.pc_relevant_multi_platform_whitelistv4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~YuanLiJiHua~Position-3-127387079-blog-106075532.pc_relevant_multi_platform_whitelistv4&utm_relevant_index=4">(39条消息) unity 碰撞检测的四种检测模式_kill566666的博客-CSDN博客_unity碰撞检测方法有哪些</a></p><p><a href="https://blog.csdn.net/qq_42194657/article/details/106075532">(39条消息) 解决Unity物体速度过快无法进行碰撞检测（碰撞检测穿透）_类人_猿的博客-CSDN博客</a></p><h2 id="物理调试可视化-Physics-debugger"><a href="#物理调试可视化-Physics-debugger" class="headerlink" title="物理调试可视化 Physics debugger"></a>物理调试可视化 Physics debugger</h2><p><a href="https://docs.unity.cn/cn/2021.3/Manual/PhysicsDebugVisualization.html">物理调试可视化 - Unity 手册</a></p><p>2D似乎无法看出效果……即使是</p><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221125101607312.png" alt="image-20221125101607312"></p><p>也看不出什么效果……琢磨不出来，也找不到资料，就先搁置着吧。 【更新：重启一下编辑器就OK了……</p><h1 id="物理碰撞检测"><a href="#物理碰撞检测" class="headerlink" title="物理碰撞检测"></a>物理碰撞检测</h1><ul><li>目前碰到的可以大概分为两类：形状检测和射线检测。</li></ul><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20230108102513633.png" alt="image-20230108102513633"></p><ul><li>按照需求也可进行分类：<ul><li>需要获取检测到的Collider（BoxCast、OverlapArea…）</li><li>需要检测到的对象的更多信息RaycastHit2D（Raycast、Rigidbody.Cast….）</li></ul></li></ul><h2 id="形状检测"><a href="#形状检测" class="headerlink" title="形状检测"></a>形状检测</h2><ul><li><p>直接设置各种基础collider组件</p></li><li><p>脚本设置基本的形状<a href="https://docs.unity.cn/cn/current/ScriptReference/Physics2D.html">UnityEngine.Physics2D - Unity 脚本 API</a></p><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221230110918021.png" alt="image-20221230110918021"></p><blockquote><p>—Cast：例如在场景内像朝特定方向拖动某个形状（盒体胶囊体等）穿过场景一样，在该过程中可以检测并报告与该体接触的任何对象</p></blockquote><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221230111710688.png" alt="image-20221230111710688"></p><blockquote><p>Overlap—：检测碰撞体是否在某个形状区域内</p></blockquote></li></ul><h2 id="射线检测"><a href="#射线检测" class="headerlink" title="射线检测"></a>射线检测</h2><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221230112027244.png" alt="image-20221230112027244"></p><h1 id="官方2D平台跳跃方法解析"><a href="#官方2D平台跳跃方法解析" class="headerlink" title="官方2D平台跳跃方法解析"></a>官方2D平台跳跃方法解析</h1><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>为了解决Update和FixedUpdate不同步的问题，（rigidbody必须要在FixedUpdate之中，而用户输入又必须在Update<a href="https://zhuanlan.zhihu.com/p/137395596">Unity为什么推荐在FixedUpdate处理物理模拟？ - 知乎 (zhihu.com)</a>），那么在Update刷新率不同的情况下，如何确保FixedUpdate中的rb移动是完全一致呢？</p><ul><li>Update触发FixedUpdate及时响应的问题：如果是GetButton，那么由于Update刷新不同，FixedUpdate处理的时间可能多，也可能少（假如按下了0.1s，刷新快的Update就已经刷新了10帧，慢的刷新一帧，但是由于FixedUpdate是得看Update的响应的，所以刷新了10帧的FixedUpdate也跟着刷新了8帧，慢的FixedUpdate只跟着刷新了1帧【只做粗略估计，不严谨计算】）；如果是GetButtonDown（倘若设布尔状态值的其实和上一点差不多），响应可能会不太准，试过按下之后跳不起来的情况。因为是按下那一帧设为true然后下一帧重置为false，如果FixedUpdate刚好错过，那么就没有响应了。</li><li>一般来说解决方法是，Update设置布尔值来保存这个状态，直到FixedUpdate接收并执行就取消这个记录的状态。记录是否触发还好，但是要记录长按短按呢？如果要确保每个电脑执行效果都一样的话，这就变得有些棘手。<ul><li>一种解决办法是跳跃初始的速度、力都是固定的，短按就使加速度往下来使人物立马往下。这样的话FixedUpdate相当于触发一次就行。<strong>如果控制力</strong>：物体质量和施加力能确保相同，只是力作用时间不同才会导致效果不同；那么要用瞬间冲击力Impulse。长按中断的时候得施加往下的力？【对于力没有研究得很清楚，当前帧施加了力，那么那个瞬间有个加速度，同时受到重力的影响，在合力的作用下逐帧运动……？】对于力和速度到底用哪个好，我初步地比较了一下，力要改变速度是要经过加速度这个过程的，比如中断长按，如果突然加往下的力，那一帧加速度变大，速度可能恰好停止、小有上升、最不乐观的是猛下落一截【还没有亲身实践，根据小学物理猜测。】所以很明显控制力对最终速度的影响并不直观【还有什么代价？】。F= ma,m=1,F=a,v=v0+at<del>v=v0+a</del>v=v0+F,质量为1的时候倒是能理解成和速度有直接关系。而<strong>直接控制速度</strong>的话就少了m的约束。</li></ul></li><li>官方的例子就是控制速度（以后找到力的例子也好好研究研究），控制速度也有不方便的地方，如果受到力的作用，也不得不考虑所有力的可能性然后计算合加速度，这对于碰撞来说是非常麻烦的。官方例子直接把Rigidbody设置为Kinematic，只受速度的影响。由此，漫长的看代码痛苦过程就开始了……【完全陌生的领域啊啊啊啊（习惯用力控制的萌新）】</li></ul><h2 id="小插曲：关于力和速度的实践"><a href="#小插曲：关于力和速度的实践" class="headerlink" title="小插曲：关于力和速度的实践"></a>小插曲：关于力和速度的实践</h2><ul><li>一边写的时候一边想着好像不难实现，自己猜想得到底正不正确？实践出真知</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class ForceController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public float basicJumpImpulse = 3.0f;</span><br><span class="line">    public float downImpulse = 1.0f;</span><br><span class="line">    public float moveSpeed = 1.0f;</span><br><span class="line">    private Rigidbody2D rb;</span><br><span class="line">    private bool isToJump, stopJump;</span><br><span class="line">    </span><br><span class="line">    //防止连续跳</span><br><span class="line">    private bool isOnAir;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; !isOnAir)</span><br><span class="line">        &#123;</span><br><span class="line">            isToJump = true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (Input.GetButtonUp(&quot;Jump&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            stopJump = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (rb.velocity.y != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(rb.velocity.y);</span><br><span class="line">        &#125;</span><br><span class="line">        float horizontal = Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">        rb.velocity = new Vector2(horizontal * moveSpeed, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void FixedUpdate()</span><br><span class="line">    &#123;</span><br><span class="line">        if (isToJump)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(new Vector2(0f, basicJumpImpulse), ForceMode2D.Impulse);</span><br><span class="line">            isToJump = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (stopJump &amp;&amp; isOnAir)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(new Vector2(0f, -downImpulse), ForceMode2D.Impulse);</span><br><span class="line">            stopJump = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnCollisionEnter2D(Collision2D other)</span><br><span class="line">    &#123;</span><br><span class="line">        isOnAir = false;</span><br><span class="line">        stopJump = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnCollisionExit2D(Collision2D other)</span><br><span class="line">    &#123;</span><br><span class="line">        isOnAir = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个就能实现长按短按、不会连跳、没有大问题的效果了（长按中断确实得调出合适的阻力以不至于下降地过于突兀）。但是把速度打印出来发现，Update可能有连续帧的速度都是一样的，因为FixedUpdate刷新较慢的时候，力是不变的。这样的话看起来没啥问题，因为Update过快也没事，FixedUpdate是固定刷新的。但是一旦Update比FixedUpdate还慢呢？那Update体现出来的效果又会产生差异。</p><p>【另外通过dubug发现，如果单单检测velocity.y的话精度会达到7、8位（大概），而Vector2(x,y)就会固定是两位，前者可能会出现非常非常小的误差导致判断不准，而后者则不会出现这样的问题了】</p></blockquote><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221125173421047.png" alt="image-20221125173421047"></p><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221126162938840.png" alt="image-20221126162938840"></p><blockquote><p>不同时候运行的结果产生了差异。</p></blockquote><p><img src="/2022/11/08/Unity%E7%9A%84%E7%89%A9%E7%90%86%E7%B3%BB%E7%BB%9F%EF%BC%88%E6%A8%A1%E6%8B%9F%EF%BC%89/hexo_github_blog\source_posts\Unity的物理系统（模拟）.assets\image-20221125172821829.png" alt="image-20221125172821829"></p>]]></content>
    
    
    <summary type="html">关于Unity2D物理系统的深入学习</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Robbie</title>
    <link href="https://huangxinhere.github.io/2022/09/23/Robbie/"/>
    <id>https://huangxinhere.github.io/2022/09/23/Robbie/</id>
    <published>2022-09-22T16:00:00.000Z</published>
    <updated>2023-02-20T04:23:43.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tilemap（Rule-Tile）"><a href="#Tilemap（Rule-Tile）" class="headerlink" title="Tilemap（Rule Tile）"></a>Tilemap（Rule Tile）</h1><ul><li><p>目标：利用资源制作背景/平台等</p></li><li><p>步骤：</p><ul><li><p>准备素材（切成正方形）</p></li><li><p>建立“调色盘”Tile Platte，将素材拖到画布上形成“颜料”Tiles</p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220923153145426.png" alt="image-20220923153145426"></p><blockquote><p>在edit状态下才能编辑颜料。要在工具栏先使用选择工具，再选择移动工具来移动。</p></blockquote></li><li><p>建立画布Create new Objects - 2D - Tilemap，注意分类别建立画布，以便分别处理互不干扰；每个画布也可有专属的分层，在属性面板中的soft layer。</p></li><li><p>调色盘/颜料/画布都准备好后，就可以在画布上作画。一定要对应好调色盘和画布！！</p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220923153110962.png" alt="image-20220923153110962"></p></li></ul></li><li><p>技巧：</p><ul><li><p>使用插件Rule Tile。如图这种如果一个个tile点会很麻烦，想要自动生成这个样子。其实这些符合一定的规则排列。</p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220923153553628.png" alt="image-20220923153553628"></p></li><li><p>插件使用：在project中新建，菜单会出现 “Tile”以及对应的各种Tile。</p></li><li><p>面板是这个样子：</p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220923154040166.png" alt="image-20220923154040166"></p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220923153804618.png" alt="image-20220923153804618"></p><blockquote><p>最上面是默认的sprite。下面这些都是某种规则对应的sprite。例如中间那个，什么时候判定这个瓦片是属于中间那张图片，就是它四周都有瓦片的时候……对照图片仔细琢磨。红叉是没有瓦片的意思，绿色箭头则代表存在瓦片。还要注意内角。</p></blockquote></li><li><p>把Rule Tile拖进调色板中，就能愉快地使用了。</p></li></ul></li></ul><h1 id="2D人物控制移动"><a href="#2D人物控制移动" class="headerlink" title="2D人物控制移动"></a>2D人物控制移动</h1><p>由于人物移动受影响的第一要素是基于物理（平台/阻碍等），所以非常有必要重新梳理一遍必需的物理要素。</p><h2 id="刚体和碰撞体区别"><a href="#刚体和碰撞体区别" class="headerlink" title="刚体和碰撞体区别"></a>刚体和碰撞体区别</h2><ul><li><p>刚体：可使游戏对象在<u>物理系统（力的运算：重力/作用力等）的控制</u>下来运动</p></li><li><p>碰撞体：物理组件的一类，它要与刚体一起添加到游戏对象上才能<u>触发碰撞</u>。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。</p></li><li><p>理解一：想象如果只有刚体的话，很多物体能基于各种力的计算来运动；如果没有碰撞体，物体与物体之间互相穿过，按照自己的运动轨迹；反之，会相互碰撞，改变原来的运动轨迹。</p></li><li><p>理解二：人物会受重力影响等，所以必须添加刚体；要产生和环境的相互阻力，那两者必须有碰撞体。</p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220924092223060.png" alt="image-20220924092223060"></p></li></ul><h3 id="物理系统运行与交互冲突"><a href="#物理系统运行与交互冲突" class="headerlink" title="物理系统运行与交互冲突"></a>物理系统运行与交互冲突</h3><p>由于物理计算与交互Update刷新不一致，很容易导致不同步以至于产生抖动等冲突问题。所以有刚体的时候最好操作刚体来移动，这就是为什么一般拿刚体来移动（而且要在FixedUpdate里面）的原因。</p><h3 id="刚体详细属性"><a href="#刚体详细属性" class="headerlink" title="刚体详细属性"></a>刚体详细属性</h3><p><img src="https://images2015.cnblogs.com/blog/702782/201509/702782-20150929211327761-286673077.png" alt="img"></p><ul><li>Mass 质量：该项用于设置游戏对象的质量（建议在同一个游戏场景中，游戏对象之间的质量差值不要大于100倍）；</li><li>Drag 阻力：0表示没有空气阻力，阻力极大时游戏对象会立即停止运动；</li><li>Angular Drag 角阻力： 当游戏对象受扭矩力旋转时受到的空气阻力。0表示没有空气阻力，阻力极大时游戏对象会立即停止运动；</li><li>Use Gravity 使用重力：开启此项，游戏对象受重力影响；</li><li>Is Kinematic 是否开启动力学：开启此项，游戏对象将不再受物理引擎的影响从而只能通过Transform（几何变换组件）属性来对其操作，该方式适用于模拟平台移动或带有铰链关节链接刚体的动画。</li><li>Interpolate插值：该项用于控制刚体运动的抖动情况（碰撞处有轻微凹陷？）。有三项可以选择：<ul><li>None没有插值</li><li>Interpolate内插值，基于前一帧的Transform来平滑此次的Transform。</li><li>Extrapolate外插值，基于下一帧的Transform来平滑此次的Transform。</li></ul></li><li>Collision Detection碰撞检测：该属性用于控制避免高速运动的游戏对象穿过其他对象而未发生碰撞，有三项可以选择：<ul><li>Continuous 连续碰撞检测：该模式用于检测<u>与动态碰撞体</u><u>（带有Rigidbody）</u>的碰撞，使用连续碰撞检测模式来检测<u>与网格碰撞体</u><u>的（不带Rigidbody）</u>碰撞。其他的刚体采用离散碰撞模式。此模式适用于那些需要与采用连续动态碰撞检测的对象相碰撞的对象:这对物理性能会有很大的影晌 ,如果不需要对快速运动的对象进行碰撞检测,就使用离散碰撞检测模式。</li><li>Continuous Dynamic 连续动态碰撞检测模式：该模式用于检测与采用连续碰撞模式或连续动态碰撞模式对象的碰撞 ,也可用于检 测 没 有Rigidbody的静态网格碰撞体 。 对于与之碰撞的其他对象可采用离散碰撞检测。 动态连续 碰撞检测模式也可用于检测快速运动的游戏对象。</li></ul></li><li>Constraints约束：该项用于控制刚体运动的约束。<ul><li>Freeze Position：冻结位置。刚体对象在世界坐标系中xyz轴方向上(勾选状态)的移动无效。</li><li>Freeze Rotation：冻结旋转。刚体对象在世界坐标系中xyz轴方向上(勾选状态)的旋转无效。</li></ul></li></ul><h3 id="碰撞体详细属性"><a href="#碰撞体详细属性" class="headerlink" title="碰撞体详细属性"></a>碰撞体详细属性</h3><p><a href="https://docs.unity.cn/cn/2020.3/Manual/CollidersOverview.html">碰撞体 - Unity 手册</a></p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220924092456618.png" alt="image-20220924092456618"></p><ul><li>原始碰撞体类型：盒型、球型、胶囊碰撞体……</li><li>复合碰撞体：任意数量的上述碰撞体 添加到单个对象 以创建复合碰撞体。</li><li>静态碰撞体：可将碰撞体添加到没有刚体组件的对象，从而创建场景的地板、墙壁和其他静止元素。通常情况下，不应通过更改变换位置来重新定位静态碰撞体，因为这会极大地影响物理引擎的性能。</li><li>动态碰撞体：具有刚体的对象上的碰撞体称为_动态_碰撞体。静态碰撞体可与动态碰撞体相互作用，但由于没有刚体，因此不会通过移动来响应碰撞。</li><li>物理材质：当碰撞体相互作用时，它们的表面需要模拟所应代表的材质的属性。例如，一块冰将是光滑的，而橡胶球将提供大量摩擦力并且弹性很好。虽然碰撞时碰撞体的形状不会变形，但可以使用 Physics Materials（物理材质）配置碰撞体的摩擦力和弹力。可能需要进行多次试验和纠错后才能获得正确参数，比如冰材质将具有零（或非常低的）摩擦力，而橡胶材质则具有高摩擦力和近乎完美的弹性。有关可用参数的更多详细信息，请参阅<a href="https://docs.unity.cn/cn/2018.4/Manual/class-PhysicMaterial.html">物理材质</a>和 <a href="https://docs.unity.cn/cn/2018.4/Manual/class-PhysicsMaterial2D.html">2D 物理材质</a>的参考页面。请注意，由于历史原因，3D 资源实际上称为Physic Material（物理材质）（<em>不带</em> s），而等效的 2D 资源则称为 _Physics Material 2D（2D 物理材质）（_带s）</li></ul><h2 id="环境设置（Tilemap的碰撞器）"><a href="#环境设置（Tilemap的碰撞器）" class="headerlink" title="环境设置（Tilemap的碰撞器）"></a>环境设置（Tilemap的碰撞器）</h2><ul><li>首先为瓦片地图添加collider</li></ul><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220924094158340.png" alt="image-20220924094158340"></p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220924094242299.png" alt="image-20220924094242299"></p><p>由于每个小碰撞体之间可能会产生缝隙，所以为了流畅性最好把它们整合在一起。所以勾选组件中的_Used By Composite_.但是这个属性要生效有一个条件：就是必须同时添加 <em>CompositeCollider2D</em> 组件。</p><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220924094554435.png" alt="image-20220924094554435"></p><p>另外，添加 <em>Tilemap Collider 2D</em> 的同时也会自动添加 <em>Rigidbody2D</em> 组件，所以要将后者的Body Type改成Static，因为不需要他运动。（还把属性面板的Static勾选上了<a href="https://blog.csdn.net/weixin_41319239/article/details/94230437">(35条消息) Unity的inspector面板中static的作用_蹦蹦跳跳小米粒的博客-CSDN博客_unity中static的作用</a>）</p><h2 id="人物设置"><a href="#人物设置" class="headerlink" title="人物设置"></a>人物设置</h2><h3 id="刚体和碰撞体设置"><a href="#刚体和碰撞体设置" class="headerlink" title="刚体和碰撞体设置"></a>刚体和碰撞体设置</h3><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220924095116831.png" alt="image-20220924095116831"></p><h3 id="移动逻辑"><a href="#移动逻辑" class="headerlink" title="移动逻辑"></a>移动逻辑</h3><p><a href="https://blog.csdn.net/Sea3752/article/details/124108814?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-124108814-blog-103908957.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-3-124108814-blog-103908957.pc_relevant_default&utm_relevant_index=4">(35条消息) Unity3D中玩家的移动方式，三大类型，八种方式_正在奋斗中的小志的博客-CSDN博客_unity 玩家移动</a></p><p><a href="https://docs.unity.cn/cn/2019.4/ScriptReference/Rigidbody-velocity.html">Rigidbody-velocity - Unity 脚本 API</a></p><p>基本语法： public Vector3 <strong>velocity</strong>{get;set;}</p><p>功能说明： 此属性用于设置或返回刚体的速度值，其使用说明如下。</p><pre><code>1、在脚本中无论是给刚体赋予一个Vector3类型的速度向量v,还是获取当前刚体的速度v，v的方向都是相对世界坐标系而言的。2、velocity的单位是米每秒，而不是帧每秒，其中米是Unity默认的长度单位。</code></pre><ul><li>本教程用了Velocity。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xVelocity = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">rb.velocity = <span class="keyword">new</span> Vector2(xVelocity * speed, rb.velocity.y);</span><br></pre></td></tr></table></figure><blockquote><p>在2D项目中速度值是二维向量，其中用输入值来更改水平数值，而垂直数值则受原来的速度影响（自由下落等等）</p></blockquote><ul><li>看到有人评论说：1.用刚体的对象不要使用transform改变位置，因为这会覆盖刚体进行的位移。2. Kinematic类型的刚体不接受力学。3.Dynamic类型的刚体不建议使用rigidbody.MovePosition()方法，这个方法就是为Kinematic类型刚体准备的。所以就是要根据使用的刚体类型，选择合适的位移方法。</li></ul><h1 id="2D人物行动状态的变换和控制"><a href="#2D人物行动状态的变换和控制" class="headerlink" title="2D人物行动状态的变换和控制"></a>2D人物行动状态的变换和控制</h1><p>行走，蹲下，跳跃……不同状态之间如何转换，其实是一个很麻烦的活。一不小心就弄乱了。</p><h2 id="整体逻辑的梳理"><a href="#整体逻辑的梳理" class="headerlink" title="整体逻辑的梳理"></a>整体逻辑的梳理</h2><ul><li>按照行为类型分（走路、跳跃等，以跳跃为例）<ul><li>每种行为类型包括行为 <em>具体控制</em> 和 <em>状态</em><ul><li>具体控制<ul><li>如何产生这个行为（给刚体增加向上的力）</li><li>动画状态机、音效……</li></ul></li><li>状态<ul><li>状态判断：<ul><li>用户输入（水平按键输入）</li><li>自身状态是否已经存在</li><li>其它状态影响（蹲下来不能跳等）</li><li>客观条件（站在地面上）</li></ul></li><li>行为产生导致状态改变：<ul><li>改变本身状态（isJump）</li><li>客观条件（不站在地面上）</li><li>……</li></ul></li></ul></li></ul></li></ul></li><li>根据实际情况 来包装行为类型 或者是将状态和具体行为分别包装等等</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照行为类型分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">FixedUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    PhysicsCheck();</span><br><span class="line">    GroundMovement();</span><br><span class="line">    MidAirMovement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GroundMovement</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//状态转换(行走又包括直立和蹲下两种子行为)</span></span><br><span class="line">    <span class="keyword">if</span>(crouchHeld)</span><br><span class="line">        Crouch();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!crouchHeld &amp;&amp; isCrouch)</span><br><span class="line">        StandUp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移动处理</span></span><br><span class="line">    xVelocity = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(isCrouch)</span><br><span class="line">        xVelocity /= crouchSpeedDivisor;</span><br><span class="line"></span><br><span class="line">    rb.velocity = <span class="keyword">new</span> Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">    FlipDirection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳跃的处理"><a href="#跳跃的处理" class="headerlink" title="跳跃的处理"></a>跳跃的处理</h2><h3 id="长按蓄力和下蹲蓄力"><a href="#长按蓄力和下蹲蓄力" class="headerlink" title="长按蓄力和下蹲蓄力"></a>长按蓄力和下蹲蓄力</h3><p>按照上面的思路分析就能写出基本代码，但是这里还增加了一个 <u>蓄力跳得更高</u> 的设置。</p><p>🧐原理</p><ul><li>按下跳跃键（GetButtonDown 瞬间判断）起跳，完成第一部分；</li><li>按的时间比较长的时候（GetButton 持续），将在跳的过程中再增添一股力，使其跳得更高。</li></ul><p>😎在这里没有用到嵌套if，而是将两个判断分开了。暂停捋一遍思路：部分1产生跳跃，并还标注了一个bool值isJump，说明正在跳跃；有了这个条件的判断，才能接着判断是否有长按空格，如果是，那么就增加力；过了一段极短的时间（jumpHoldDuration）后才停止增加力。</p><ul><li>经实验，如果去掉时间，那么长按效果没有体现。是增加的力不够吗？（因为有了时间加长的概念，而且这个是if-else if，必须等到下一次执行时才能增加）</li><li>增加了力，效果还是不明显。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MidAirMovement</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="keyword">if</span>(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)&#123;</span><br><span class="line">        isOnGround = <span class="literal">false</span>;</span><br><span class="line">        isJump = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        jumpTime = Time.time + jumpHoldDuration;</span><br><span class="line"></span><br><span class="line">        rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0f</span>, jumpForce), ForceMode2D.Impulse);</span><br><span class="line"></span><br><span class="line">        jumpPressed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isJump)&#123;</span><br><span class="line">        <span class="keyword">if</span>(jumpHeld)</span><br><span class="line">            rb.AddForce(<span class="keyword">new</span> Vector2(<span class="number">0f</span>, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class="line">        <span class="keyword">if</span>(jumpTime &lt; Time.time)</span><br><span class="line">            isJump = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        jumpPressed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下蹲蓄力相似，产生跳跃后，如果是下蹲状态，则单独加力。</li></ul><p>🧐还有个问题是：由于为了接收用户输入更加流畅，把其放在了Update中，但是行为的执行是在FixedUpdate中，导致在Update中短暂的按键效果到了FixedUpdate（几帧后）就失效了。</p><h3 id="下蹲时不可站起-状态判断-客观条件影响（环境检测）"><a href="#下蹲时不可站起-状态判断-客观条件影响（环境检测）" class="headerlink" title="下蹲时不可站起  状态判断-客观条件影响（环境检测）"></a>下蹲时不可站起  状态判断-客观条件影响（环境检测）</h3><p>之前判断是否站在地面上用的是</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.IsTouchingLayers(groundLayer)</span><br></pre></td></tr></table></figure><blockquote><p>只要碰到Layer就为true，那无法满足下蹲无法站起的需求。</p></blockquote><ul><li>RaycastHit2D</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RaycastHit2D <span class="title">Raycast</span>(<span class="params">Vector2 offset, Vector2 rayDirection, <span class="built_in">float</span> distance, LayerMask layer</span>)</span>&#123;</span><br><span class="line">    Vector2 pos = transform.position;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//射线起点、方向、距离、碰撞的层</span></span><br><span class="line">    RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, distance, layer);</span><br><span class="line"></span><br><span class="line">    Color color = hit ? Color.red : Color.green;</span><br><span class="line"></span><br><span class="line">    Debug.DrawRay(pos + offset, rayDirection * distance, color, distance);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>直接重载RaycastHit2D的Raycast方法，来满足额外的需求（画出射线等）。然后对左脚右脚头顶分别作出碰撞射线。</p></blockquote><p><img src="/2022/09/23/Robbie/hexo_github_blog\source_posts\pic\image-20220924165947772.png" alt="image-20220924165947772"></p>]]></content>
    
    
    <summary type="html">2D横板平台游戏</summary>
    
    
    
    <category term="Unity教程学习" scheme="https://huangxinhere.github.io/categories/Unity%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>TowerDefense</title>
    <link href="https://huangxinhere.github.io/2022/07/30/TowerDefense/"/>
    <id>https://huangxinhere.github.io/2022/07/30/TowerDefense/</id>
    <published>2022-07-29T16:00:00.000Z</published>
    <updated>2023-02-20T04:25:11.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Unity导入模型贴图无法编辑"><a href="#Unity导入模型贴图无法编辑" class="headerlink" title="Unity导入模型贴图无法编辑"></a>Unity导入模型贴图无法编辑</h1><p><a href="https://tieba.baidu.com/p/6087100187">请教下大佬，导入的模型材质球是灰色的无法编辑【unity3d吧】_百度贴吧 (baidu.com)</a></p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220730100452620.png" alt="image-20220730100452620"></p><blockquote><p>Location：Use External Materials（使用外部材质）</p></blockquote><p>但是看到后面括号有个Legacy的提示，是被弃用的意思，我在想可编辑导入的材质不是很重要的操作吗，为什么要被弃用。看了看官方文档，</p><ul><li>选择 <strong>Use Embedded Materials</strong> 选项<a href="https://docs.unity3d.com/cn/current/Manual/FBXImporter-Materials.html#Embedded">将材质保持在导入的资源中</a></li><li>单击 <strong>Extract Materials</strong> 和 <strong>Extract Textures</strong> 按钮可提取导入的资源中嵌入的所有材质和纹理</li></ul><p>所以看起来是有额外提取内部资源的操作。</p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220730101220983.png" alt="image-20220730101220983"></p><blockquote><p>因此当有材质可提取时，Materials对应的Extract Materials可点击，并可提取，texture同理。</p></blockquote><h1 id="解除预制体关系Break-Prefab-Instance（Unpack-Prefab）"><a href="#解除预制体关系Break-Prefab-Instance（Unpack-Prefab）" class="headerlink" title="解除预制体关系Break Prefab Instance（Unpack Prefab）"></a>解除预制体关系Break Prefab Instance（Unpack Prefab）</h1><p>在Unity使用过程中出现了Children of a Prefab instance cannot be deleted or moved,and components cannot be reordered.You can unpack the Prefab instance to remove its Prefab connection.现象</p><p>我以为点击了OK会有所变化（但是要手动改）</p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220730101639523.png" alt="image-20220730101639523"></p><h1 id="功能的封箱和解耦"><a href="#功能的封箱和解耦" class="headerlink" title="功能的封箱和解耦"></a>功能的封箱和解耦</h1><h2 id="通知BuildManager时只传递信息，不需读取BM的变量"><a href="#通知BuildManager时只传递信息，不需读取BM的变量" class="headerlink" title="通知BuildManager时只传递信息，不需读取BM的变量"></a>通知BuildManager时只传递信息，不需读取BM的变量</h2><ul><li>Shop：UICanvas的脚本处理。点击后通知BuildManager当前Build的类型是什么</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetStandardTurret</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        buildManager.SetTurretToBuild(buildManager.standardTurretPrefab);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMissileLauncher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        buildManager.SetTurretToBuild(buildManager.missileLauncherPrefab);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见通知BuildManager的时候还得访问BM的变量，再返回给BM，所以有点不妥。应该传入信息给BM由它自己处理。那么传给bm应该是什么类型的变量呢？可以是Shop公开接收GameObject然后直接传入，但是未来还要扩展价钱处理，所以一个类型的Turret就附加了多种属性，就把它封装成一个数据类。这样的话就把数据类传进去。理所当然首先在Shop进行实例化（这也是个恰当的做法）</p></blockquote><ul><li>扩展：数据类</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]<span class="comment">//没有继承MonoBehaviour，但是需要在Inspector面板上编辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TurretBlueprint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> GameObject prefab;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> cost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Shop：实例化数据并优化</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TurretBlueprint standardTurret;</span><br><span class="line"><span class="keyword">public</span> TurretBlueprint missile;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectStandardTurret</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">buildManager.SelectTurretToBuild(standardTurret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectMissileLauncher</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">buildManager.SelectTurretToBuild(missile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="点击Node完成Build的过程归给BM"><a href="#点击Node完成Build的过程归给BM" class="headerlink" title="点击Node完成Build的过程归给BM"></a>点击Node完成Build的过程归给BM</h2><p>原来创建一个Turret的功能是在Node实现的：首先读取BM的变量，再在内部创建。但是如果把创建部分归给BM，分工会更加简单明了。所以BM就要知道Node的信息，并执行创建任务。</p><ul><li>原Node相关部分</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"><span class="comment">//还未设置当前的Turret</span></span><br><span class="line">    <span class="keyword">if</span> (buildManager.GetTurretToBuild() == <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (turret != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;There is already a turret!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Build a turret</span></span><br><span class="line">    turretToBuild = BuildManager.instance.GetTurretToBuild();</span><br><span class="line">    turret = Instantiate(turretToBuild, transform.position + initOffset, transform.rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要完善的地方：</p><ul><li>判断当前是否有确定类型这个逻辑可以在BM内部进行处理</li><li>创建功能也归给BM</li></ul></blockquote><ul><li>BM的判断 以及 创建</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> CanBuild &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> turretToBuild != <span class="literal">null</span>; &#125; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuildTurretOn</span>(<span class="params">Node node</span>)</span>&#123;</span><br><span class="line">GameObject turret =  Instantiate(turretToBuild.prefab, node.GetBuildPosition, Quaternion.identity);</span><br><span class="line">node.turret = turret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Update系统的加入：重构Node-BuildManager-Turret的逻辑"><a href="#Update系统的加入：重构Node-BuildManager-Turret的逻辑" class="headerlink" title="Update系统的加入：重构Node-BuildManager-Turret的逻辑"></a>Update系统的加入：重构Node-BuildManager-Turret的逻辑</h2><h1 id="Canvas整体和部分动画的快速制作"><a href="#Canvas整体和部分动画的快速制作" class="headerlink" title="Canvas整体和部分动画的快速制作"></a>Canvas整体和部分动画的快速制作</h1><p>​    不懂方法的我之前可是每个UI都弄了一个动画，非常麻烦且不直观。</p><ul><li><p>首先有明确的父子关系。待会再写为什么</p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220810162252249.png" alt="image-20220810162252249"></p></li><li><p>为根对象创建动画片段</p></li><li><p>点开录制按钮，会呈现红色。这样只要在Inspector修改参数就能自动打关键帧了。</p></li><li><p>这时候子UI更改会自动显示在根对象的时间轴上，就非常方便了。</p></li></ul><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220810162524854.png" alt="image-20220810162524854"></p><ul><li>控件常见动画是更改透明度。可以在控件加上Canvas Group组件，直接更改透明度</li></ul><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220810162753172.png" alt="image-20220810162753172"></p><ul><li>缓入缓出。选择关键帧右键，可以设置Flat，使得动画更顺滑</li></ul><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220810164230795.png" alt="image-20220810164230795"></p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220810164321963.png" alt="image-20220810164321963"></p><h1 id="Node-UI的逻辑理清"><a href="#Node-UI的逻辑理清" class="headerlink" title="Node UI的逻辑理清"></a>Node UI的逻辑理清</h1><ul><li><p>需求：点击Node，如果没有Turret就弹出NodeUI；Node UI隐藏的情况——选择需要Build的Turret / 点击已经弹出的Node。</p></li><li><p>原来想法：Node UI脚本（出现/隐藏）——BuildManager（持有Node UI实例）——Node（调用BuildManager方法）。只是单纯地在各个地方调用UI方法。比如Node不为空 / 设置TurretToBuild等就间接调用SetActive方法。</p><p>​    不理解为什么教程还要在BuildManager保存一个Node实例。如果这个开关操作与Node无关的话，没必要保存一个变量。</p></li><li><p>比较：①后来发现如果没有保存Node，是无法实现多次点击同一个有Turret的Node然后不断开关的功能。因为要对比是否为同一个Node。而且纯逻辑isShow = ! isShow是不适合不同Node的情况的。</p><p>​    ②选择Turret之后再点击NodeUI，然后可以再继续Build Turret❌。这里考虑到体验问题，升级操作和创建操作应该进行独立分开。一旦开始进行升级操作，创建操作就应该停止。不然玩家在忙顾着升级的时候，可能就忘了之前选择什么炮塔；或者并不想进行取消创建炮塔的额外操作。</p></li></ul><p>👉原代码。只考虑开关，分布较散。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectTurretToBuild</span>(<span class="params">TurretBlueprint turret</span>)</span>&#123;</span><br><span class="line">        selectedTurret = turret;</span><br><span class="line"></span><br><span class="line">        nodeUI.Hide();<span class="comment">/*这里*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuildTurretOn</span>(<span class="params">Node node</span>)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        nodeUI.Hide(); <span class="comment">/*这里*/</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowNodeUI</span>(<span class="params">Node node</span>)</span>&#123;</span><br><span class="line">        selectedTurret = <span class="literal">null</span>;</span><br><span class="line">        nodeUI.SetTarget(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>👉改进。归纳到两个情况：选择Turret / Node，代码集中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectTurretToBuild</span>(<span class="params">TurretBlueprint turret</span>)</span>&#123;</span><br><span class="line">    selectedTurret = turret;</span><br><span class="line"></span><br><span class="line">    HideNodeUI();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectNode</span>(<span class="params">Node node</span>)</span>&#123;</span><br><span class="line"><span class="comment">//同一个Node处理</span></span><br><span class="line">    <span class="keyword">if</span> (selectedNode == node)</span><br><span class="line">    &#123;</span><br><span class="line">        HideNodeUI();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不同Node</span></span><br><span class="line">    selectedNode = node;</span><br><span class="line">    selectedTurret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    nodeUI.SetTarget(selectedNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideNodeUI</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    selectedNode = <span class="literal">null</span>;</span><br><span class="line">    nodeUI.Hide();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Text模糊问题解决"><a href="#Text模糊问题解决" class="headerlink" title="Text模糊问题解决"></a>Text模糊问题解决</h1><p>由于场景的模型比较小，和正常画布差距悬殊。所以当创建世界空间的小画布时，字体严重模糊。</p><p><a href="https://www.jb51.net/article/209297.htm">Unity中3DText显示模糊不清的解决方案_C#教程_脚本之家 (jb51.net)</a></p><p>据博客所言，每个字号的边缘模糊程度都是一样的，所以字号小的时候非常模糊，字号大就不明显。所以解决办法是把大字号的Scale缩小，能保留清晰度。</p><h1 id="游戏暂停的动画处理"><a href="#游戏暂停的动画处理" class="headerlink" title="游戏暂停的动画处理"></a>游戏暂停的动画处理</h1><ul><li>需求：点击暂停键，弹出带动画的菜单，并且游戏暂停。</li><li>问题：由于暂停是由</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time.ScaleTime = <span class="number">0f</span>;</span><br></pre></td></tr></table></figure><p>实现的，所以Animatior的动画也同样暂停不动。</p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220813095628408.png" alt="image-20220813095628408"></p><ul><li><p>解决：更改Animator的设置</p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220813095717852.png" alt="image-20220813095717852"></p></li></ul><h1 id="Button的过渡模式"><a href="#Button的过渡模式" class="headerlink" title="Button的过渡模式"></a>Button的过渡模式</h1><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220813100344665.png" alt="image-20220813100344665"></p><p>一般用的就是这种模式。今天认真理解了下，“Transition”是“过渡”的意思，下面是按钮不同的状态对应不同的提示，在Color Tint模式下就对应了不同的颜色。所以当按钮的颜色能平滑地过渡显示不同状态（Unity应该做了平滑工作）。</p><ul><li>同理，还有一个有趣的模式是Animation。</li></ul><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220813100814176.png" alt="image-20220813100814176"></p><p>默认是没有动画的，要自动设置就需要点击Anto Generate Animation，接着会弹出创建Controller的窗口。因为Button固定是有不同的状态意味着有不同的动画Clip，所以就主要是创建状态机。</p><p><img src="/2022/07/30/TowerDefense/hexo_github_blog\source_posts\pic\image-20220813101038218.png" alt="image-20220813101038218"></p><blockquote><p>状态机下面自动带有这些不同状态</p></blockquote><h1 id="Anchor和Pivot的区别"><a href="#Anchor和Pivot的区别" class="headerlink" title="Anchor和Pivot的区别"></a>Anchor和Pivot的区别</h1><ul><li>Pivot：UI根据Pivot的位置缩放/旋转/大小。</li><li>Anchor：如果父物体也是RectTransform，则锚定到父的中心/角；或者拉伸</li></ul><p><a href="https://www.jianshu.com/p/4cccfc517370">UGUI中Anchor和Pivot详解 - 简书 (jianshu.com)</a></p><h1 id="Unity本地持久化类Playerprefs"><a href="#Unity本地持久化类Playerprefs" class="headerlink" title="Unity本地持久化类Playerprefs"></a>Unity本地持久化类Playerprefs</h1><ul><li>Unity3D提供的用于数据本地持久化保存与读取的类。</li><li>以<strong>key-value</strong>的形式将数据保存在本地，在代码中可以写入、读取、更新数据。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储整型数据</span></span><br><span class="line">PlayerPrefs.SetInt(<span class="string">&quot;intKey&quot;</span>,<span class="number">999</span>); </span><br><span class="line"><span class="comment">//存储浮点型数据</span></span><br><span class="line">PlayerPrefs.SetFloat(<span class="string">&quot;floatKey&quot;</span>,<span class="number">1.11f</span>); </span><br><span class="line"><span class="comment">//存储字符串数据</span></span><br><span class="line">PlayerPrefs.SetString(<span class="string">&quot;strKey&quot;</span>,<span class="string">&quot;I am Plane&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出key为&quot;intKey&quot;的整型数据</span></span><br><span class="line"><span class="built_in">int</span> intVal = PlayerPrefs.GetInt(<span class="string">&quot;intKey&quot;</span>); </span><br><span class="line"><span class="comment">//取出key为&quot;floatKey&quot;的浮点型数据</span></span><br><span class="line"><span class="built_in">float</span> floatVal = PlayerPrefs.GetFloat(<span class="string">&quot;floatKey&quot;</span>); </span><br><span class="line"><span class="comment">//获取key为&quot;strKey&quot;的字符串数据</span></span><br><span class="line"><span class="built_in">string</span> strVal = PlayerPrefs.GetString(<span class="string">&quot;strKey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有存储数据</span></span><br><span class="line">PlayerPrefs.DeleteAll();</span><br><span class="line"><span class="comment">//删除key为&quot;score&quot;的数据</span></span><br><span class="line">PlayerPrefs.DeleteKey(<span class="string">&quot;score&quot;</span>);</span><br><span class="line"><span class="comment">//查找是否存在key为&quot;score&quot;的数据</span></span><br><span class="line"><span class="built_in">bool</span> exist = PlayerPrefs.HasKey(<span class="string">&quot;score&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">塔防</summary>
    
    
    
    <category term="Unity教程学习" scheme="https://huangxinhere.github.io/categories/Unity%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityShader 入门精要/高级篇 笔记</title>
    <link href="https://huangxinhere.github.io/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangxinhere.github.io/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2023-02-20T04:22:18.976Z</updated>
    
    <content type="html"><![CDATA[<h1 id="屏幕后处理效果"><a href="#屏幕后处理效果" class="headerlink" title="屏幕后处理效果"></a>屏幕后处理效果</h1><p><strong>screen post-processing effects</strong></p><h2 id="建立一个基本的屏幕后处理脚本系统"><a href="#建立一个基本的屏幕后处理脚本系统" class="headerlink" title="建立一个基本的屏幕后处理脚本系统"></a>建立一个基本的屏幕后处理脚本系统</h2><p>🐥屏幕后处理：通常指的是在渲染完整个场景<strong>得到屏幕图像</strong>之后，再对这个图像进行<strong>一系列的操作</strong>，实现各种屏幕特效。</p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220718105207142.png" alt="image-20220718105207142"></p><p>🧐默认情况下，OnRenderImage函数会在所有不透明和透明的Pass执行完毕后被调用；但是有时候希望在不透明Pass调用后立即调用OnRenderImage函数，从而<strong>不对透明物体产生影响</strong>。可以在函数前添加<strong>ImageEffectOpaque属性</strong>来实现这样的目的。</p><p>🎏实践</p><p>【屏幕后处理的基类】检查条件是否满足等通用功能。</p><p>【摄像机/编辑器可查看】所有屏幕后处理效果都要绑定在某个摄像机上</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent (typeof(Camera))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostEffectBase</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p>【检查各种资源和条件是否满足】</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">CheckResources</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">bool</span> isSupported = CheckSupport();</span><br><span class="line">        <span class="keyword">if</span> (isSupported == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            NotSupported();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="built_in">bool</span> <span class="title">CheckSupport</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( SystemInfo.supportsImageEffects == <span class="literal">false</span> || SystemInfo.supportsRenderTextures == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogWarning(<span class="string">&quot;This platform does not support image effects of render textures&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">NotSupported</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        enabled = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CheckResources();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>【指定Shader / 处理渲染纹理的材质】</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @param</span></span><br><span class="line"><span class="comment">    * shader: 该特效需要使用的shader</span></span><br><span class="line"><span class="comment">    * material：用于后期处理的材质</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    * 先检查Shader的可用性；</span></span><br><span class="line"><span class="comment">    * 检查通过后就返回一个使用了该shader的材质，否则返回null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Material <span class="title">CheckShaderAndCreateMaterial</span>(<span class="params">Shader shader, Material material</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (shader == <span class="literal">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (shader.isSupported &amp;&amp; material &amp;&amp; material.shader == shader)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> material;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (!shader.isSupported)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           material = <span class="keyword">new</span> Material(shader);</span><br><span class="line">           material.hideFlags = HideFlags.DontSave;</span><br><span class="line">           <span class="keyword">if</span> (material)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> material;</span><br><span class="line">           &#125;<span class="keyword">else</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="调整屏幕的亮度、饱和度和对比度"><a href="#调整屏幕的亮度、饱和度和对比度" class="headerlink" title="调整屏幕的亮度、饱和度和对比度"></a>调整屏幕的亮度、饱和度和对比度</h2><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220719162522508.png" alt="image-20220719162522508"></p><blockquote><p>核心理解还是OnRenderImage方法，获取当前屏幕图像，然后看作四边形面片模型那样赋予“材质”，而材质由Shader来控制，最后渲染最新的屏幕图像。</p></blockquote><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><p>原理是利用一些<strong>边缘检测算子</strong>对图像进行<strong>卷积（convolution）操作</strong>。</p><h3 id="什么是卷积"><a href="#什么是卷积" class="headerlink" title="什么是卷积"></a>什么是卷积</h3><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220719164851647.png" alt="image-20220719164851647"></p><h3 id="常见的边缘检测算子"><a href="#常见的边缘检测算子" class="headerlink" title="常见的边缘检测算子"></a>常见的边缘检测算子</h3><p>卷积操作的神奇之处在于选择的卷积核。那么用于边缘检测的卷积核（边缘检测算子）应该长啥样呢？</p><p>👉边如何形成？</p><p>​    如果相邻像素之间存在<strong>差别明显</strong>的颜色、亮度、纹理等属性，我们就会认为它们之间应该有一条<strong>边界</strong>。</p><p>👉<strong>相邻像素</strong>之间的<strong>差值</strong>可以用<strong>梯度（gradient）</strong>来表示。边缘处的梯度<strong>绝对值会比较大</strong>。</p><p>👉如何计算梯度值</p><p>每个像素分别用边缘检测算子进行卷积计算，得到<strong>两个方向上</strong>的梯度值Gx和Gy，再得到<strong>整体的</strong>梯度值。</p><p>🎏实践</p><p>【关键】计算出该像素的深度值，然后lerp出边缘。要计算深度值，需要知道该像素的<strong>相邻像素的坐标</strong>，然后使用<strong>Sobel算子</strong>计算出当前像素的<strong>梯度值</strong>。</p><p>👉【vert】计算该像素的相邻像素的坐标</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//xxx_TexelSize是Unity提供的访问xxx纹理对应的每个纹素的大小</span></span><br><span class="line">half4 _MainTex_TexelSize;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    half2 uv[<span class="number">9</span>] : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span> (<span class="params">appdata_img v</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    half2 uv = v.texcoord;</span><br><span class="line">    o.uv[<span class="number">0</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">1</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    o.uv[<span class="number">2</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    o.uv[<span class="number">3</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    o.uv[<span class="number">4</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    o.uv[<span class="number">5</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    o.uv[<span class="number">6</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">-1</span>, <span class="number">1</span>);</span><br><span class="line">    o.uv[<span class="number">7</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    o.uv[<span class="number">8</span>] = uv + _MainTex_TexelSize.xy * half2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220719182631099.png" alt="image-20220719182631099"></p><blockquote><p>大概猜测……总有点不顺</p></blockquote><p>👉【frag】Sobel函数计算当前像素的梯度值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    //当前像素的梯度值</span><br><span class="line">    half edge = Sobel(i);</span><br><span class="line">    fixed4 withEdgeColor = lerp(_EdgeColor, tex2D(_MainTex, i.uv[4]), edge);</span><br><span class="line">    fixed4 onlyEdgeColor = lerp(_EdgeColor, _BackgroundColor, edge);</span><br><span class="line">    return lerp(withEdgeColor, onlyEdgeColor, _EdgeOnly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>withEdgeColor</li></ul><p>_EdgeColor和该像素根据像素的梯度值来混合</p><ul><li>onlyEdgeColor</li></ul><p>和背景颜色混合</p><ul><li>return</li></ul><p>实际上分别是两张“图像结果”进行混合</p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220719183744055.png" alt="image-20220719183744055"></p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220719183801102.png" alt="image-20220719183801102"></p></blockquote><p>【Sobel】首先定义水平方向和竖直方向使用的卷积Gx和Gy。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fixed luminance(fixed4 color) &#123;</span><br><span class="line">return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">half Sobel(v2f i) &#123;</span><br><span class="line"></span><br><span class="line">/*卷积*/</span><br><span class="line">    const half Gx[9] = &#123;-1,  0,  1,</span><br><span class="line">                        -2,  0,  2,</span><br><span class="line">                        -1,  0,  1&#125;;</span><br><span class="line">    const half Gy[9] = &#123;-1, -2, -1,</span><br><span class="line">                        0,  0,  0,</span><br><span class="line">                        1,  2,  1&#125;;</span><br><span class="line"></span><br><span class="line">/*采样，并计算亮度值；与卷积核对应的权重相乘并叠加*/</span><br><span class="line">    half texColor;</span><br><span class="line">    half edgeX = 0;</span><br><span class="line">    half edgeY = 0;</span><br><span class="line">    for (int it = 0; it &lt; 9; it++) &#123;</span><br><span class="line">        texColor = luminance(tex2D(_MainTex, i.uv[it]));</span><br><span class="line">        edgeX += texColor * Gx[it];</span><br><span class="line">        edgeY += texColor * Gy[it];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">/*计算绝对值：越小越可能是个边缘点*/</span><br><span class="line">    half edge = 1 - abs(edgeX) - abs(edgeY);</span><br><span class="line"></span><br><span class="line">    return edge;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📍此边缘检测仅仅利用了屏幕颜色信息。在实际应用中，物体的纹理、阴影等信息均会影响边缘检测的结果。</p><h2 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h2><p>同样利用了卷积计算。</p><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><p>👉<strong>如何计算得出一个高斯核</strong>。高斯核是一个正方形大小的滤波核，每个元素的计算基于高斯方程：</p><blockquote><p>标准方差（一般取值为1）；x和y分别对应了当前位置到卷积核中心的<strong>整数距离</strong>。</p></blockquote><p>​        📍为了保证滤波后的图像不会变暗，需要对高斯核中的权重进行<strong>归一化</strong>，让每个权重除以所有权重的和，这样可以保证所有权重的和为1</p><p>👉<strong>高斯核的特点</strong></p><ul><li><strong>距离远近</strong>：高斯方程很好地模拟了邻域每个像素对当前处理像素的影响程度——距离越近，影响越大。（模糊，似乎就是相邻像素之间取权重相叠。如果不想太走样的话，应该是相近的像素影响才大）</li><li><strong>维数大小</strong>：高斯核的维数越高，模糊程度越大。（n越大，涉及的像素越多，就越模糊）</li><li><strong>高斯函数降维成一维</strong>：结果和二维高斯核一样，而计算次数大大减少</li></ul><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220720171917121.png" alt="image-20220720171917121"></p><p>🎏实践</p><p>先梳理一下思路。核心是用算子来对像素及其相邻像素进行权重并叠加的运算，然后反馈给该像素。对于高斯模糊来说，高斯核已经知道了（上图给的），然后是求出相邻像素坐标，还有采样运算。</p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220720181721710.png" alt="image-20220720181721710"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//垂直方向维度的</span><br><span class="line">v2f vertBlurVertical(appdata_img v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">    half2 uv = v.texcoord;</span><br><span class="line">    o.uv[0] = uv;</span><br><span class="line">    o.uv[1] = uv + float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;</span><br><span class="line">    o.uv[2] = uv - float2(0.0, _MainTex_TexelSize.y * 1.0) * _BlurSize;</span><br><span class="line">    o.uv[3] = uv + float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;</span><br><span class="line">    o.uv[4] = uv - float2(0.0, _MainTex_TexelSize.y * 2.0) * _BlurSize;</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//水平方向维度类似</span><br></pre></td></tr></table></figure><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220720181914922.png" alt="image-20220720181914922"></p><blockquote><p>利用高斯核的对称性进行采样</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragBlur(v2f i) : SV_Target&#123;</span><br><span class="line">    float weight[3] = &#123;0.4026, 0.2442, 0.0545&#125;;</span><br><span class="line">    fixed3 sum = tex2D(_MainTex, i.uv[0]).rgb * weight[0];</span><br><span class="line">    for(int it = 1; it &lt; 3 ; it++)&#123;</span><br><span class="line">    sum += tex2D(_MainTex, i.uv[it]).rgb * weight[it];</span><br><span class="line">    sum += tex2D(_MainTex, i.uv[it*2]).rgb * weight[it];</span><br><span class="line">    &#125;</span><br><span class="line">    return fixed4(sum, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📍第一个Pass使用竖直方向的一维高斯核对图像进行滤波，第二个Pass用水平方向的，由于两个Pass的片元着色器其实是相同的，为了避免代码冗余，可以使用CGINCLUDE</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        CGINCLUDE</span><br><span class="line">        ...</span><br><span class="line">        //struct</span><br><span class="line">        //vert</span><br><span class="line">        //frag</span><br><span class="line">        ...</span><br><span class="line">        ENDCG</span><br><span class="line">        </span><br><span class="line">        ZTest Always Cull Off ZWrite Off</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            //高斯模糊很常用，所以可能要重复利用</span><br><span class="line">            //所以为Pass定义名字，可以在其它Shader直接通过名字来使用该Pass</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_VERTICAL&quot;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vertBlurVertical</span><br><span class="line">            #pragma fragment fragBlur</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass &#123;</span><br><span class="line">            NAME &quot;GAUSSIAN_BLUR_HORIZONTAL&quot;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vertBlurHorizontal</span><br><span class="line">            #pragma fragment fragBlur</span><br><span class="line">            </span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br></pre></td></tr></table></figure><p>👉以上是Shader内部的处理。重点在“外部”（脚本）调整高斯模糊的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Range(0, 4)]</span><br><span class="line">public int iterations = 3;          //高斯模糊迭代次数（数值越大越模糊）</span><br><span class="line">[Range(0.2f, 0.3f)]</span><br><span class="line">public float blurSpread = 0.6f;     //模糊范围（高斯核维数不变的情况下，数值越大模糊程度越高，采样数却不会受到影响</span><br><span class="line">[Range(1, 8)]</span><br><span class="line">public int downSample = 2;          //缩放系数（数值越大需要处理的像素数越少，也能进一步提高模糊程度）</span><br></pre></td></tr></table></figure><blockquote><p>简单来讲，迭代次数就是高斯模糊执行了多少次，不断模糊就会越来越糊；模糊范围是采样的距离拉大；缩放系数是缩放屏幕图像。</p></blockquote><p>👉如何将属性传递给Shader。Shader真正需要的是模糊范围，其余两个是Shader之外也就是脚本控制的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            int rtW = src.width / downSample;</span><br><span class="line">            int rtH = src.height / downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            Graphics.Blit(src, buffer0);</span><br><span class="line"></span><br><span class="line">            //两个临时缓存在迭代之间进行交替</span><br><span class="line">            for (int i = 0; i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread);</span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 0);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line"></span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 1);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line"></span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Graphics.Blit(buffer0, dest);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Bloom效果"><a href="#Bloom效果" class="headerlink" title="Bloom效果"></a>Bloom效果</h2><p>😎首先根据一个阈值提取出<strong>图像中的较亮区域</strong>，把它们存储在一张<strong>渲染纹理</strong>中，再利用<strong>高斯模糊</strong>对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行<strong>混合</strong>，得到最终的效果。</p><p>👉【Shader部分】如何提取最亮部分</p><p>取整幅图像的亮度值，然后减去阈值，映射到[0,1]。阈值越小，留下来的亮度值越多，高斯模糊的效果越明显。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v2f vertExtractBright(appdata_img v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.texcoord;</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">fixed luminance(fixed4 color)&#123;</span><br><span class="line">return 0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 fragExtractBright(v2f i) : SV_Target&#123;</span><br><span class="line">fixed4 c = tex2D(_MainTex, i.uv);</span><br><span class="line">fixed val = clamp(luminance(c) - _LuminanceThreshold, 0.0, 1.0);</span><br><span class="line">return c * val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    【混合亮部与原图像】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed4 fragBloom(v2fBloom i) : SV_Target &#123;</span><br><span class="line">return tex2D(_MainTex, i.uv.xy) + tex2D(_Bloom, i.uv.zw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉【脚本】比高斯模糊多做的工作是，提取亮部，混合图像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">        if (material != null)</span><br><span class="line">        &#123;</span><br><span class="line">            material.SetFloat(&quot;_LuminanceThreshold&quot;, luminanceThreshold);</span><br><span class="line">            int rtW = src.width / downSample;</span><br><span class="line">            int rtH = src.height / downSample;</span><br><span class="line">            RenderTexture buffer0 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">            buffer0.filterMode = FilterMode.Bilinear;</span><br><span class="line">            </span><br><span class="line">            //提取图像中较亮的区域</span><br><span class="line">            Graphics.Blit(src, buffer0, material, 0);</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; iterations; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                material.SetFloat(&quot;_BlurSize&quot;, 1.0f + i * blurSpread);</span><br><span class="line">                RenderTexture buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 1);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line"></span><br><span class="line">                buffer1 = RenderTexture.GetTemporary(rtW, rtH, 0);</span><br><span class="line">                Graphics.Blit(buffer0, buffer1, material, 2);</span><br><span class="line">                RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">                buffer0 = buffer1;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //亮部区域传递给Shader</span><br><span class="line">            material.SetTexture(&quot;_Bloom&quot;, buffer0);</span><br><span class="line">            </span><br><span class="line">            //混合</span><br><span class="line">            Graphics.Blit(src, dest, material, 3);</span><br><span class="line">            RenderTexture.ReleaseTemporary(buffer0);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220721161630051.png" alt="image-20220721161630051"></p><h2 id="运动模糊"><a href="#运动模糊" class="headerlink" title="运动模糊"></a>运动模糊</h2><p>😏两种实现方法</p><p>👉利用一块<strong>累积缓存（accumulation buffer ）</strong>来混合多张连续的图像。当物体快速移动产生<u>多张图像</u>后，取它们之间的平均值作为最后的运动模糊图像。然而，这种暴力的方法对性能的消耗很大，因为想要获取多张帧图像往往意味着我们需要<u>在同一帧里渲染多次场景</u>。（场景/静止的物体也被重复渲染）</p><p>👉<strong>速度缓存（velocitybuffer）</strong>。这个缓存中存储了各个像素当前的运动速度，然后利用该值来决定模糊的方向和大小。</p><p>👉本次方法：保存之前的渲染结果，不断把当前的渲染图像叠加到之前的渲染图像中，从而产生一种运动轨迹的视觉效果。这种方法与原始的利用累计缓存的方法相比<u>性能更好</u>，但<u>模糊效果可能会略有影响</u>。</p><p>🎏实践</p><p>【主要思想】OnRenderImage方法应该是每隔一定时间就刷新的。所以<strong>前一次的屏幕图像保留下来进行叠加</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void OnRenderImage(RenderTexture src, RenderTexture dest) &#123;</span><br><span class="line">        ....</span><br><span class="line">            accumulationTexture.MarkRestoreExpected();              //恢复操作:发生在渲染到纹理而该纹理又没有被提前清空或销毁的情况下</span><br><span class="line">            material.SetFloat(&quot;_BlurAmount&quot;, 1.0f - blurAmount);</span><br><span class="line">            Graphics.Blit(src, accumulationTexture, material);      //把当前的屏幕图像src叠加到accumulationTexture中</span><br><span class="line">            Graphics.Blit(accumulationTexture, dest);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Graphics.Blit(src, dest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>📍拖尾越明显，实际上是叠加的图像透明度越高。</p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220722170910429.png" alt="image-20220722170910429"></p><h1 id="使用深度和法线纹理"><a href="#使用深度和法线纹理" class="headerlink" title="使用深度和法线纹理"></a>使用深度和法线纹理</h1><h2 id="获取深度和法线纹理"><a href="#获取深度和法线纹理" class="headerlink" title="获取深度和法线纹理"></a>获取深度和法线纹理</h2><h3 id="背后的原理"><a href="#背后的原理" class="headerlink" title="背后的原理"></a>背后的原理</h3><p>🧐<strong>深度纹理</strong>：实际上就是一张渲染纹理（渲染到纹理中），只不过它里面存储的像素值不是颜色值，而是一个<strong>高精度的深度值</strong>（z，深度）。</p><p>​    👉深度值<u>范围</u>：[0,1]，而且通常是非线性分布的。</p><p>​    👉从哪里得到？来自于顶点变换后得到的归一化的设备坐标（Normalized Device Coordinates，NDC）</p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220727205616190.png" alt="image-20220727205616190"></p><blockquote><ul><li>①到②：观察空间下的顶点位置——&gt;应用<strong>透视裁剪矩阵</strong>后的变换结果。【vert输出的顶点变换结果】</li><li>②到③：<strong>透视除法</strong>——&gt;归一化设备坐标。</li></ul></blockquote><p>​    归一化后：深度值就对应了<u>NDC中</u>顶点坐标<strong>z分量</strong>的值。但是NDC中z分量的值为[-1,1]，所以还用通过公式进行映射。</p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220727210157597.png" alt="image-20220727210157597"></p><blockquote><p>其中d就是深度纹理中的像素值了。</p></blockquote><p>👉原理已经理解，那么Unity是如何操作的？</p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220727212320980.png" alt="image-20220727212320980"></p><p><img src="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220727212350604.png" alt="image-20220727212350604"></p><h3 id="如何获取"><a href="#如何获取" class="headerlink" title="如何获取"></a>如何获取</h3><p>👉摄像机脚本设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取深度纹理</span><br><span class="line">camera.depthTextureMode =DepthTextureMode.Depth</span><br><span class="line"></span><br><span class="line">//深度＋法线</span><br><span class="line">camera.depthTextureMode =DepthTextureMode.DepthNormals</span><br><span class="line"></span><br><span class="line">//组合两种模式</span><br><span class="line">camera.depthTextureMode |=DepthTextureMode.Depth;</span><br><span class="line">camera.depthTextureMode |=DepthTextureMode.DepthNormals;</span><br></pre></td></tr></table></figure><p>👉Shader中通过_CameraDepthNormalsTexture来访问</p><p>​    📍使用当前像素的纹理坐标对它进行采样。为了处理平台的差异，Unity将tex2D包装在宏当中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float d =SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, i.uv);</span><br></pre></td></tr></table></figure><p>👉线性空间？</p><h1 id="VScode-的Unity插件无效-代码无法补全"><a href="#VScode-的Unity插件无效-代码无法补全" class="headerlink" title="VScode 的Unity插件无效/代码无法补全"></a>VScode 的Unity插件无效/代码无法补全</h1><p><a href="https://superliii.blog.csdn.net/article/details/110157060?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8-110157060-blog-121160215.pc_relevant_multi_platform_whitelistv1_exp2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-8-110157060-blog-121160215.pc_relevant_multi_platform_whitelistv1_exp2&utm_relevant_index=13">(8条消息) 解决VSCode无法显示Unity代码提示的真正解决办法_斯幽柏雷科技的博客-CSDN博客_vscode写unity没有代码提示</a></p><ul><li>前几天把vscode重新安装了一次，然后终于找到提示说要把 .NET 的SDK升级到6.0，按照它说的做了，然后就有效了。</li></ul>]]></content>
    
    
    <summary type="html">learn sth</summary>
    
    
    
    <category term="shader" scheme="https://huangxinhere.github.io/categories/shader/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityShader 入门精要/中级篇 笔记</title>
    <link href="https://huangxinhere.github.io/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangxinhere.github.io/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/</id>
    <published>2022-07-07T16:00:00.000Z</published>
    <updated>2023-02-20T04:24:17.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="更复杂的光照"><a href="#更复杂的光照" class="headerlink" title="更复杂的光照"></a>更复杂的光照</h1><h2 id="Unity的渲染路径"><a href="#Unity的渲染路径" class="headerlink" title="Unity的渲染路径"></a>Unity的渲染路径</h2><p>🎃<strong>渲染路径</strong></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/900390e3ad846f99.png" alt="image-20220708155451967"></p><p>👉<strong>类型以及设置</strong></p><p>前向渲染路径 Forward Rendering Path、延迟渲染 Deferred Rendering Path、后两个待了解。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/039e6e1d51099a3d.png" alt="image-20220708153924773"></p><blockquote><p>大多数情况下一个项目只使用一种渲染路径，因此可以为整个项目设置渲染路径。☝️</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/1bc03255962a057d.png" alt="image-20220708154504563"></p><blockquote><p>也可以在每个摄像机的渲染路径设置中 设置该摄像机使用的渲染路径，以覆盖Project Setting中的设置。☝️</p></blockquote><p>📍如果当前显卡不支持所选择的渲染路径，Unity会自动使用更低一层的渲染路径。</p><p>🦁不同类型的渲染路径可能包含多种标签，在Pass中用“<strong>LightMode</strong>”指定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">Tags&#123;</span><br><span class="line">&quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">&#125;</span><br><span class="line">//该Pass使用前向渲染路径中的ForwardBase路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">标签名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Always</td><td align="center">不管使用哪种路径，该Pass总是会被渲染，但不会计算光照</td></tr><tr><td align="center">ForwardBase</td><td align="center">用于前向渲染。该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps</td></tr><tr><td align="center">ForwardAdd</td><td align="center">前向渲染。会计算额外的逐像素光源，每个Pass对应一个光源</td></tr><tr><td align="center">…</td><td align="center">(用到再进行补充)</td></tr></tbody></table><blockquote><p>LightMode标签支持的渲染路径设置选项。☝️</p></blockquote><h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>大致过程：(伪代码)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">for (each primitive in this model)&#123;</span><br><span class="line">//对于每个渲染图元</span><br><span class="line">for (each fragment covered by this primitive)&#123;</span><br><span class="line">//1.深度测试</span><br><span class="line">if (failed in depth test)&#123;</span><br><span class="line">discard;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">//2.光照计算</span><br><span class="line">float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">//3.更新帧缓冲</span><br><span class="line">writeFrameBuffer(fragment, color);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于每个逐像素光源，都要进行上面一次完整的渲染流程。</p><p>📍如果一个物体受到<strong>多个光源</strong>影响，该物体就要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在<strong>帧缓冲</strong>中把这些光照结果混合起来得到最终的颜色值。</p></blockquote><h4 id="Unity中的前向渲染"><a href="#Unity中的前向渲染" class="headerlink" title="Unity中的前向渲染"></a>Unity中的前向渲染</h4><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/6a2acfa2da41391c.png" alt="image-20220708165228451"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/db68f3b086f971a5.png" alt="image-20220708165419564"></p><blockquote><p>两者具体说明：….</p></blockquote><h4 id="内置的光照变量和函数"><a href="#内置的光照变量和函数" class="headerlink" title="内置的光照变量和函数"></a>内置的光照变量和函数</h4><p>根据使用的渲染路径（即Pass标签中LightMode的值），Unity会把不同的光照变量传递给Shader。</p><blockquote><p>前向渲染可以使用的内置光照变量👇</p></blockquote><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">_LightColor0</td><td align="center">float4</td><td align="center">该Pass处理的逐像素<strong>光源的颜色</strong></td></tr><tr><td align="center">_WorldSpaceLightPos0</td><td align="center">float4</td><td align="center">_WorldSpaceLightPos0.xyz是该Pass处理的逐像素<strong>光源的位置</strong></td></tr><tr><td align="center">…</td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>前向渲染可以使用的内置光照函数👇</p></blockquote><table><thead><tr><th align="center">函数名</th><th align="center">输入</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center">WorldSpaceLightDir()*</td><td align="center">float4 v：一个模型空间中的顶点位置</td><td align="center">float3：世界空间中从该点到光源的光照方向</td></tr><tr><td align="center">UnityWorldSpaceLightDir()*</td><td align="center">float4 v：一个世界空间中的顶点位置</td><td align="center">float3：世界空间中从该点到光源的光照方向</td></tr><tr><td align="center">ObjSpaceLightDir()*</td><td align="center">float4 v：一个模型空间中的顶点位置</td><td align="center">float3：模型空间中从该点到光源的光照方向</td></tr></tbody></table><h3 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h3><p>😺对硬件配置最少、运算性能最高，但同时也是得到的效果最差的一种类型；仅仅是前向渲染的一个子集。【由于不被重视，需要再继续了解】</p><h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h3><p>🧐前向渲染的问题是：当场景中包含大量实时光源时，前向渲染的性能会急速下降。每个物体执行多个Pass的计算可能很多都是重复的。</p><p>🦁<strong>原理</strong>：主要包含两个Pass。</p><p>​    👉第一个Pass：通过深度缓冲技术，计算哪个片元是可见的，若可见就把相关信息存储到<u>屏幕空间的</u><strong>G缓冲区（G-buffer）</strong>中。【G缓冲区存储了我们所关心的表面（通常指的是离摄像机最近的表面）的其它信息，例如该表面的法线、位置、用于光照计算的材质属性等】</p><p>​    👉第二个Pass：利用G缓冲区的各个片元信息（表面法线、视角方向等），进行真正的光照计算。</p><blockquote><p>可看出延迟渲染跟场景中的光源数目无关，也就是不依赖于场景的复杂度，而是<strong>和使用的屏幕大小有关</strong>。这是因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张2D图像，我们的计算实际上就是在这些图像空间中进行的。</p></blockquote><p>📍如果游戏中使用了<strong>大量的实时光照</strong>，那么可能希望选择延迟渲染路径，但这种路径需要一定的硬件支持</p><p>📍延迟渲染路径中每个光源都可以按<strong>逐像素</strong>的方式处理</p><p>📍【<strong>缺点</strong>】不支持真正的抗锯齿（anti-aliasing）功能；不能处理半透明物体；对显卡有一定要求</p><h3 id="选择哪种路径"><a href="#选择哪种路径" class="headerlink" title="选择哪种路径"></a>选择哪种路径</h3><p>有需要查阅官方文档Rendering Path的有关内容。</p><h2 id="Unity的光源类型"><a href="#Unity的光源类型" class="headerlink" title="Unity的光源类型"></a>Unity的光源类型</h2><p>Unity一共支持4种光源类型：平行光、点光源、聚光灯和面光源（area light）/仅在烘培时才发挥作用</p><p>📍从Shader中使用的5个光源属性来理解不同光源类型。</p><table><thead><tr><th align="center"></th><th align="center">平行光</th><th align="center">点光源（球体）</th><th align="center">聚光灯（锥型）</th></tr></thead><tbody><tr><td align="center">光源位置</td><td align="center">没有唯一位置</td><td align="center">有位置属性</td><td align="center">有</td></tr><tr><td align="center">到某点的方向</td><td align="center">照亮的范围没有限制/几何属性只有方向</td><td align="center">点光源位置-某点位置</td><td align="center">同左</td></tr><tr><td align="center">衰减</td><td align="center">无</td><td align="center">会衰减；球体边界值为0</td><td align="center">点光源衰减公式更复杂，需要判断点是否在锥体内</td></tr><tr><td align="center">强度</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">颜色</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="mul-unity-ObjectToWorld-v-vertex-xyz和UnityObjectToClipPos-v-vertex-的区别"><a href="#mul-unity-ObjectToWorld-v-vertex-xyz和UnityObjectToClipPos-v-vertex-的区别" class="headerlink" title="mul(unity_ObjectToWorld,v.vertex).xyz和UnityObjectToClipPos(v.vertex);的区别"></a>mul(unity_ObjectToWorld,v.vertex).xyz和UnityObjectToClipPos(v.vertex);的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br></pre></td></tr></table></figure><p>这是把顶点从模型空间（物体的本地坐标空间）转化到世界空间中，并取xyz分量；其中，unity_ObjectToWorld是转化矩阵。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnityObjectToClipPos(v.vertex);</span><br></pre></td></tr></table></figure><p>这个是把顶点从模型空间直接转化到裁剪空间，也就是进行了M-V-P三次转化，这个函数是unity重新封装过一次，其实它最初是mul(UNITY_MATRIX_MVP,v.vertex);其中，UNITY_MATRIX_MVP是转化矩阵。</p><h3 id="在前向渲染中处理不同的光源类型"><a href="#在前向渲染中处理不同的光源类型" class="headerlink" title="在前向渲染中处理不同的光源类型"></a>在前向渲染中处理不同的光源类型</h3><p>🎏<strong>实践1</strong>：场景中有一个平行光和一个点光源。这里使用了Blinn-Phong类型，并为前向渲染定义了Base Pass和Additional Pass来处理多个光源。</p><p>👉第一个Pass——Base Pass</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*Pass for ambient light &amp; first pixel light(directional light)*/</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma multi_compile_fwdbase//可以保证在Shader中使用光照衰减等光照变量可以被正确赋值</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//我们希望环境光计算一次就好，因此在后面的Additional Pass不会再计算这个部分</span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);//平行光方向</span><br><span class="line">...</span><br><span class="line">fixed atten = 1.0;//衰减</span><br><span class="line">return fixed4(ambient + (diffuse + specular) * atten, 1.0);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在Base Pass中处理了场景中最重要的平行光</span><br><span class="line">//如果场景中包含了多个平行光，Unity会选择最亮的平行光传递给Base Pass进行逐像素处理</span><br><span class="line">//其它平行光会按照逐顶点或者在Additional Pass中按逐像素处理</span><br><span class="line">//如果场景中没有平行光，那么Base Pass会当成全黑的光源处理</span><br></pre></td></tr></table></figure><p>👉第二个Pass——Additional Pass</p><p>📍思路：①设置好指令；②判断光源类型；③计算光源的5个属性（其中颜色和强度仍然可以用_LightColor0来得到，其它需要分别计算）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*①*/</span><br><span class="line">pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags&#123;</span><br><span class="line">    &quot;LightMode&quot; = &quot;ForwardAdd&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    //开启和设置了混合模式</span><br><span class="line">    //希望AP计算得到的光照结果可以在*帧缓存*中与之前的光照结果进行叠加</span><br><span class="line">    //否则会直接覆盖掉之前的光照结果 </span><br><span class="line">    Blend One One</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line">    //保证在Additional Pass访问到正确的光照变量</span><br><span class="line">    #pragma multi_compile_fwdadd    </span><br><span class="line"></span><br><span class="line">    #include &quot;Lighting.cginc&quot;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>②判断光源类型👇AP和BP的光照处理方式一样，因此只需要把BP的顶点和片元着色器代码粘贴到AP中，再稍微修改一下即可。修改往往是为了<u>去掉BP的环境光、自发光、逐顶点光照、SH光照的部分，并添加一些对不同光源类型的支持</u>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*相关变量*/</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">//------判断光源类型：求光源方向</span><br><span class="line">#ifdef USING_DIRECTIONAL_LIGHT</span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">#else</span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">#endif</span><br><span class="line">//------</span><br><span class="line"></span><br><span class="line">fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*光照衰减*/</span><br><span class="line">#ifdef USING_DIRECTIONAL_LIGHT</span><br><span class="line">fixed atten = 1.0</span><br><span class="line">#else</span><br><span class="line">    #if defined (POINT)</span><br><span class="line">    float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br><span class="line">    fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">    #elif defined (SPOT)</span><br><span class="line">    float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br><span class="line">    fixed atten = (lightCoord.z &gt; 0) </span><br><span class="line">        * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w </span><br><span class="line">    * tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">    #else</span><br><span class="line">    fixed atten = 1.0;</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p>可看出主要修改的是光源的位置、方向和衰减属性。先判断，再分别做处理。</p><p>📍#ifdef指令判断，并注意格式</p><p>📍如果是点光源或者聚光灯，**_WorldSpaceLightPos0.xyz**表示的是世界空间下的光源位置，要得到光源方向，就要减去世界空间下的顶点位置</p><p>📍两种光源的衰减用数学计算的话计算量较大，因此Unity选择了使用<strong>一张纹理</strong>作为<strong>查找表（Lookup Table，LUT）</strong>，以在片元着色器中得到光源的衰减。首先得到<strong>光源空间下的坐标</strong>，然后使用该坐标<strong>对衰减纹理进行采样得到衰减值</strong>。</p></blockquote><p>🎏<strong>实践2</strong>：一个环境光＋四个点光源——BP和AP的调用</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709153034654.png" alt="image-20220709153034654"></p><p>👉决定哪些光源是逐像素光照</p><p>​    光源创建后默认情况下它的Render Mode（Light组件内）是Auto。这意味着，Unity会在背后为我们判断那些光源会按照逐像素处理，而哪些按逐顶点或SH的方式处理。<strong>总逐像素光源数</strong>在（Project Settings——Graphics）Pixel Light Count中设置，默认情况下一个物体可以接受<u>除最亮的平行光外</u>的4个逐像素光照。</p><p>​    📍该场景中，平行光按照逐像素处理；其余4个点光源刚好符合余下4个位置，也按照逐像素处理，因此每个光源都会调用一次物体的Additional Pass。</p><p>👉帧调试器查看场景绘制过程</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709154302348.png" alt="image-20220709154302348"></p><p>​    橙色箭头：是比书本多出来的两个流程，不知道是啥。</p><p>​    黄色框框：6个渲染事件。第一个渲染事件：Unity首先清除颜色、深度和模板缓冲，为后面的渲染做准备；第二个事件：利用第一个Pass，将平行光的光照渲染到帧缓存中；后面4个渲染事件按照AP渲染。</p><blockquote><p>Unity处理点光源的顺序是按照它们的重要度排序的。和距离物体远近、光源强度、颜色有关。</p><p>物体在某个光源的范围内才会调用相应的Pass来处理光源</p></blockquote><p>​    右侧：渲染设置以及变量。</p><p>👉如果设置成Not Important，将不会按照逐像素来处理；如果也没有在BP计算逐顶点和SH光源，那么这个光源不会对物体有任何影响。</p><h2 id="Unity的光照衰减"><a href="#Unity的光照衰减" class="headerlink" title="Unity的光照衰减"></a>Unity的光照衰减</h2><h3 id="用于光照衰减的纹理"><a href="#用于光照衰减的纹理" class="headerlink" title="用于光照衰减的纹理"></a>用于光照衰减的纹理</h3><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709162511273.png" alt="image-20220709162511273"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//先得到光源空间下点的位置</span><br><span class="line">float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br><span class="line"></span><br><span class="line">//使用这个坐标的模的平方【应该是与点光源的距离的平方，避免开方操作】对衰减纹理进行采样</span><br><span class="line">//使用宏UNITY_ATTEN_CHANNEL来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值</span><br><span class="line">fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure><h2 id="Unity的阴影"><a href="#Unity的阴影" class="headerlink" title="Unity的阴影"></a>Unity的阴影</h2><p>如何在Unity中让一个物体向其它物体投射阴影，以及如何让一个物体接受来自其他物体的阴影。</p><h3 id="阴影是如何实现的"><a href="#阴影是如何实现的" class="headerlink" title="阴影是如何实现的"></a>阴影是如何实现的</h3><p>😏<strong>Shadow Map</strong>：真实生活中阴影的产生是因为光线无法到达这些区域。在实时渲染中，最常使用的是Shadow Map技术。它首先把摄像机的位置放在和光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。（摄像机的FOV不会影响吗？还是自动调节成光源那样）Unity用的就是这种技术。</p><p>😏<strong>阴影映射纹理(shadowmap)<strong>：在</strong>前向渲染路径</strong>中，如果场景中<strong>最重要的平行光开启了阴影</strong>，Unity就会为该光源计算它的阴影映射纹理。这张阴影映射纹理本质上也是一张<strong>深度图</strong>，记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）</p><p>😏<strong>LightMode</strong>标签被设置为<strong>ShadowCaster</strong>的Pass：渲染目标是阴影映射纹理（深度纹理）。Unity把摄像机放在光源位置上；调用该Pass，通过顶点变换后得到<strong>光源空间下的位置</strong>；据此来输出深度信息到阴影映射纹理中。</p><p>​    👉Unity的阴影运算过程：当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的Unity Shader中找到有<strong>ShadowCaster</strong>的Pass，没有就在<strong>Fallback指定的Shader</strong>中继续寻找，还没找到，该物体就<strong>无法</strong>向其它物体投射阴影（但还能接受阴影）。</p><p>😏<strong>屏幕空间的阴影映射技术(Screenspace Shadow Map)<strong>：Unity首先通过调用LightMode为ShadowCaster的Pass来得到<u>可投射阴影的光源</u>的<u>阴影映射纹理①</u>以及<u>摄像机的深度纹理②</u>。然后根据①和②来得到<u>屏幕空间的阴影图</u>。如果</strong>摄像机</strong>的深度图中记录的表面深度＞转换到<strong>阴影映射纹理</strong>中的深度值，就说明表面虽然是可见的，但是却处在光源的阴影当中。</p><p>​    👉通过这种方式，阴影图就包含了屏幕空间中所有有阴影的区域。【停下来想一想，为什么弄阴影要这么大费周章呢？之前的光照模型都是一部分一部分手动还原出来的，当然不包括阴影。实现阴影也不能用常规的做法……】</p><p>​    👉如果想要一个物体<strong>接收</strong>来自其他物体的阴影，只需要<strong>在Shader中对阴影图进行采样</strong>。阴影图是在屏幕空间下的，因此需要<u>把表面坐标从模型空间变换到屏幕空间</u>中，然后使用这个<u>坐标对阴影进行采样</u>即可。</p><p>🎈总结</p><p>​    📍如果想要一个物体<strong>接收</strong>来自其它物体的阴影，就必须在Shader中对阴影映射纹理（包括屏幕空间的阴影图）进行<strong>采样</strong>，把采样结果和最后的光照结果相乘来产生阴影效果。</p><p>​    📍如果想要一个物体向其它物体<strong>投影</strong>，就必须把物体<strong>加入到光源的阴影映射纹理的计算中</strong>，从而让其它物体在对阴影映射纹理采样时可以得到该物体的相关信息。在Unity中，这个过程是通过为该物体<u>执行LightMode为ShadowCaster的Pass</u>来实现的。如果使用了<u>屏幕空间的投影映射技术</u>，Unity还会使用这个Pass产生一张<u>摄像机的深度纹理</u>。</p><h3 id="不透明物体的阴影"><a href="#不透明物体的阴影" class="headerlink" title="不透明物体的阴影"></a>不透明物体的阴影</h3><p>🎏实践</p><p>👉让平行光可以收集阴影信息，在组件中开启阴影</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709215721097.png" alt="image-20220709215721097"></p><p><strong>😎让物体投射阴影</strong></p><p>在Unity中，可以选择是否让一个物体投射或接收阴影👇</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709215952239.png" alt="image-20220709215952239"></p><blockquote><ul><li>Cast Shader（On）：unity会把该物体加入到光源的阴影映射纹理的计算中。</li><li>Receive Shadows则可以选择是否让物体接受来自其它物体的阴影。</li></ul></blockquote><p>🧐<strong>Fallback回调到内置的VertexLit</strong>，内含一个LightMode为ShadowCaster的Pass，所以会自动产生投影。手动Pass可以更加灵活地控制阴影的产生；Fallback可以在多个Pass之间通用，所以更加方便。</p><p>🧐<strong>物体背面问题</strong></p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709221309408.png" alt="image-20220709221309408"></p><blockquote><p>平面的正面朝外，产生阴影。</p></blockquote><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709221416658.png" alt="image-20220709221416658"></p><blockquote><p>平面的正面朝内，没有投下阴影。默认情况下，在计算光源的阴影映射纹理时会<strong>剔除掉物体的背面</strong>。由于右侧的平面在光源空间下没有任何正面，因此不会添加到阴影纹理中。可以将Cast Shadows设置为Two Sided（面板中）来<strong>允许对物体的所有面都计算阴影信息</strong>。</p></blockquote><p><strong>😎让物体接收阴影</strong></p><p>👉在Base Pass中包含新的内置文件；下面<strong>计算阴影时所用的宏</strong>都是在这个文件声明的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;AutoLight.cginc&quot;</span><br></pre></td></tr></table></figure><p>👉<strong>顶点着色器的输出结构体v2f</strong>添加一个内置宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD2;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float2 uv : TEXCOORD1;</span><br><span class="line">    //阴影相关的内置宏:声明一个用于对阴影纹理采样的坐标</span><br><span class="line">    //宏的参数:下一个可用的插值寄存器的索引值</span><br><span class="line">    SHADOW_COORDS(3)                    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>👉<strong>顶点着色器返回前</strong>添加一个另一个内置宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //用于在顶点着色器中 计算上一步中声明的 阴影纹理坐标</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和纹理挺相似的。在结构体声明一个寄存器， 然后在vert处理坐标，接着在frag采样</p></blockquote><p>👉在<strong>片元着色器</strong>中计算阴影值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    /*阴影*/</span><br><span class="line">    fixed shadow = SHADOW_ATTENUATION(i);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>📍Unity为了处理不同光源类型、不同平台定义了多个版本的宏。</p><p>📍需要保证<strong>自定义的变量名和这些宏使用的变量名相匹配</strong>。保证：a2f / v2f中的顶点坐标必须是vertex / pos，顶点着色器的输入结构体a2v必须为v</p><h3 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a>统一管理光照衰减和阴影</h3><p>实际上，光照衰减和阴影对物体最终的渲染结果的影响 本质上时相同的——都是把<u>光照衰减因子</u>和<u>阴影值</u>及<u>光照结果</u>相乘得到最终的渲染效果。Unity提供了**内置宏 *UNITY_LIGHT_ATTENUATION *来同时计算两个信息**。</p><p>👉头文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Lighting.cginc&quot;</span><br><span class="line">#include &quot;AutoLight.cginc&quot;</span><br></pre></td></tr></table></figure><p>👉v2f</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD2;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float2 uv : TEXCOORD1;</span><br><span class="line"></span><br><span class="line">    SHADOW_COORDS(3)                    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>👉vert</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRANSFER_SHADOW(o);</span><br></pre></td></tr></table></figure><p>👉frag</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0);</span><br></pre></td></tr></table></figure><blockquote><p><strong>atten</strong>：UNITY_LIGHT_ATTENUATION会帮我们声明这个变量；存储两者相乘后的<strong>结果</strong></p><p><strong>i</strong>：结构体v2f，传递给SHADOW_ATTENUATION来计算<strong>阴影值</strong></p><p><strong>i.worldPos</strong>：世界空间的坐标，用于计算光源空间下的坐标，再对光照衰减纹理采样来得到<strong>光照衰减</strong>。</p><p>📍这个宏版本也有多个，保证多种情况的正确运行。</p></blockquote><h3 id="透明物体的阴影"><a href="#透明物体的阴影" class="headerlink" title="透明物体的阴影"></a>透明物体的阴影</h3><p>​    对于大多数不透明物体来说，把Fallback设为VertLit就能得到正确的阴影。但对于透明物体来说，其实现通常会使用透明度测试或透明度混合；透明度测试中要在片元着色器舍弃某些片元，而VertLit中的阴影投射纹理并没有这样的操作。</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710101850265.png" alt="image-20220710101850265"></p><blockquote><p>透明度测试中，阴影结果是错误的</p></blockquote><p>👉和阴影处理相同，主要是改Fallback</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure><blockquote><p>内置的VertLit并没有进行任何透明度测试的计算，所以会把整个物体的 深度信息 渲染到深度图和 阴影映射纹理中。因此要提供一个<strong>有透明度测试功能的</strong>ShadowCaster Pass。</p><p>📍Transparent/Cutout/VertexLit使用了 <em>_Cutoff</em> 属性来进行透明度测试，这要求Shader中也必须提供名为 <em>_Cutoff</em> 的属性。否则也不能得到正确的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5</span><br></pre></td></tr></table></figure></blockquote><p>👉把正方体的Caster Shadows属性设置为Two Sided</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710105627578.png" alt="image-20220710105627578"></p><blockquote><p>否则下面的面（相当于背面）无法正常投影</p></blockquote><p>🧐为使用<strong>透明度混合</strong>的物体<strong>添加阴影</strong>是一件比较复杂的事情</p><p>📍所有内置的透明度混合的Unity Shader，如Transparent / VertexLit 等，<strong>都没有包含阴影投射的Pass</strong>。不能产生投影也不能接收投影</p><blockquote><p>由于透明度混合<strong>需要关闭深度写入</strong>，带来的问题也影响了阴影的生成。要想为这些半透明物体产生正确的阴影，<u>需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染</u>，这会让阴影处理变得非常复杂，而且也会影响性能。</p></blockquote><h2 id="标准Unity-Shader"><a href="#标准Unity-Shader" class="headerlink" title="标准Unity Shader"></a>标准Unity Shader</h2><p>材质：颜色、纹理、法线纹理</p><p>光照：环境光、<u>平行光（主要光源）、其它光源（衰减）</u>【兰伯特、高光】、阴影</p><p>是否透明</p><h1 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h1><h2 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a>立方体纹理</h2><p>🦁立方体纹理（Cubemap）是<strong>环境映射（Environment Mapping）</strong>的一种实现方法。环境映射可以模拟物体周围的环境。</p><p>​    👉<strong>如何采样</strong>：需要提供一个三维的纹理坐标，表示了在世界空间的一个方向。这个方向矢量从中心出发，向外部延伸时就会和6个纹理之一发生相交，而采样得到的结果就是由该交点计算得来的。</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710153839600.png" alt="image-20220710153839600"></p><p>​    👉<strong>好处</strong>：实现简单快速，效果也较好。</p><p>​    👉<strong>缺点</strong>：当场景中引入了新的物体、光源或者物体发生移动时需要重新生成立方体纹理；仅可以反射环境，但不能反射使用了该立方体纹理的物体本身。</p><h3 id="天空盒子"><a href="#天空盒子" class="headerlink" title="天空盒子"></a>天空盒子</h3><p>可以为摄像机添加skybox组件来覆盖默认的天空盒子。</p><h3 id="创建用于环境映射的立方体纹理"><a href="#创建用于环境映射的立方体纹理" class="headerlink" title="创建用于环境映射的立方体纹理"></a>创建用于环境映射的立方体纹理</h3><p>通过环境映射，我们可以模拟出金属质感的材质。</p><p>👉方法一：提供一张<strong>具有特殊布局的纹理</strong>（如立方体展开图的交叉布局、全景布局等），然后把该纹理的Texture Type<strong>设置成Cubemap</strong>即可，Unity会做好剩下的事。在基于物理的渲染中，通常会使用一张HDR图像来生成高质量的Cubemap。</p><p>👉方法二：Unity5之前的版本。在项目资源中创建一个Cubemap，把6张纹理拖进去。官方推荐第一种方法。</p><p>👉方法三：前两种方法都是提前准备好立方体纹理的图像，得到的立方体纹理往往是被场景中的物体所共用的。在理想情况下，希望根据物体在场景中位置的不同，生成<strong>各自不同的立方体纹理</strong>。这时可以在Unity中使用脚本来创建。这是利用Unity提供的<strong>Camera.RenderToCubemap函数</strong>来实现的。这个函数可以把<strong>从任意位置观察到的场景图像</strong>存储到6张图像中，从而创建出该位置上对应的立方体纹理。实现如下👇</p><p>​    👉创建（Project）Editor文件夹下的一个脚本（关键代码如下）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void OnWizardCreate () &#123;</span><br><span class="line">    // create temporary camera for rendering</span><br><span class="line">    GameObject go = new GameObject( &quot;CubemapCamera&quot;);</span><br><span class="line">    go.AddComponent&lt;Camera&gt;();</span><br><span class="line">    // place it on the object</span><br><span class="line">    go.transform.position = renderFromPosition.position;</span><br><span class="line">    </span><br><span class="line">    // render into cubemap-----重点理解</span><br><span class="line">    go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);</span><br><span class="line"></span><br><span class="line">    // destroy temporary camera</span><br><span class="line">    DestroyImmediate( go );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    👉上面脚本添加了Unity的菜单GameObject——Render into Cubemap。所以点击菜单会出现一个小面板。</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710164355981.png" alt="image-20220710164355981"></p><p>​    👉把一个位置放进去，和一个Project创建的Legacy——Cubemap资源，然后就能点击生成效果</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710164527816.png" alt="image-20220710164527816"></p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>🎃通过入射光线的方向和表面法线方向来计算<strong>反射方向</strong>，再利用反射方向<strong>对立方体纹理采样</strong>。</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710184521883.png" alt="image-20220710184521883"></p><blockquote><p>对书的说法不是很理解，暂时理解为纹理（也就是环境）发出的光经过物体表面反射到达人眼。而这光线到达点o就是物体表面o点记录的纹理信息。</p></blockquote><p>👉【关键部分】在<strong>顶点着色器</strong>计算该点处的<strong>反射方向</strong>；也就是入射光线的方向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">    // Compute the reflect dir in world space</span><br><span class="line">    o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉在<strong>片元着色器</strong>中利用反射方向来对立方体进行<strong>采样</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 1.Use the reflect dir in world space to access the cubemap</span><br><span class="line">    fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line"></span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    // 2.Mix the diffuse color with the reflected color</span><br><span class="line">    fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line"></span><br><span class="line">    return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>1.对立方体纹理的采样需要使用CG的<strong>texCUBE</strong>函数</p><p>2.也可以在片元着色器中计算反射方向，效果会更加细腻，但是对于大多数人来说这种差别是可以忽略不计的，因此出于<strong>性能方面</strong>的考虑，选择在顶点着色器中计算反射方向。<strong>lerp</strong>混合</p></blockquote><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105454256.png" alt="image-20220711105454256"></p><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>😎<strong>斯涅尔定律（Snell‘s Law）</strong>：n1 sinθ1 = n2 sinθ2。其中n1和n2分别是两个介质的<strong>折射率（index of refraction）</strong></p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710215958986.png" alt="image-20220710215958986"></p><p>👉更准确的模拟方法需要计算两次折射——一次是当光线进入它的内部时，而另一次则是从它内部射出时。但是想在实时渲染中模拟出第二次折射方向是比较复杂的，仅仅模拟一次的效果在视觉上也没有很大差异。所以通常只模拟<strong>第一次折射</strong>。</p><p>👉【过程和反射类似，只是属性/公式不同】属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    _RefractColor (&quot;Refraction Color&quot;, Color) = (1, 1, 1, 1)    //折射颜色</span><br><span class="line">    _RefractAmount (&quot;Refraction Amount&quot;, Range(0, 1)) = 1       //材质的折射程度</span><br><span class="line">    _RefractRatio (&quot;Refraction Ratio&quot;, Range(0.1, 1)) = 0.5     //不同介质的透射比</span><br><span class="line">    _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;        //模拟折射的环境映射纹理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👉顶点着色器：计算<strong>折射方向</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);</span><br><span class="line">    ...</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第一个参数：入射光线方向，必须<strong>归一化</strong></p><p>第二个参数：表面法线，法线方向同样必须<strong>归一化</strong></p><p>第三个参数：<u>入射光线所在介质</u>的折射率和<u>折射光线所在介质</u>的折射率之间的比值</p></blockquote><p>👉片元着色器：使用折射方向<strong>对立方体纹理进行采样</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line"></span><br><span class="line">    return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样也没有对i.worldRefr进行归一化操作，因为对立方体纹理的采样只需要提供方向即可</p></blockquote><h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h3><p>😎描述了一种光学现象：当光线照射到物体表面上时，一部分发生<strong>反射</strong>，一部分进入物体内部，发生<strong>折射或散射</strong>。</p><p>😎不仅仅是水、玻璃这样的反光物体具有菲涅尔效果，几乎任何物体都或多或少包含了这个效果，这是基于物理渲染中<strong>非常重要</strong>的一项高光反射计算因子。</p><p>😎真实世界的菲涅尔等式是非常复杂的，在实时渲染中会使用一些<strong>近似公式</strong>来计算。</p><p>​    👉<strong>Schlick</strong>菲涅尔近似等式</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710225656237.png" alt="image-20220710225656237"></p><blockquote><p>F0是一个反射系数，用于控制菲涅尔<strong>反射的强度</strong>；v是视角方向；n是表面法线</p></blockquote><p>​    👉<strong>Empricial</strong>菲涅尔近似等式</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710225754600.png" alt="image-20220710225754600"></p><blockquote><p>bias、scale和power是控制项</p></blockquote><p>🎈属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    _FresnelScale (&quot;Fresnel Scale&quot;, Range(0, 1)) = 0.5   //F0</span><br><span class="line">    _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎈顶点着色器：世界空间下的法线方向、视角方向和<strong>反射方向</strong>【加入了反射】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line"></span><br><span class="line">    o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);//反射</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎈片元着色器：菲涅尔反射；<strong>混合漫反射光照和反射光照</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//反射</span><br><span class="line">fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line">//菲涅尔</span><br><span class="line">fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5);</span><br><span class="line"></span><br><span class="line">UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">//使用fresnel变量来混合漫反射光照和反射光照</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>水面：菲涅尔反射混合反射和折射光照。</p></blockquote><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105324097.png" alt="image-20220711105324097"></p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105401193.png" alt="image-20220711105401193"></p><blockquote><p>F0为0/1的两种效果</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反射、折射与菲涅尔：</p><p>都与视觉方向和法线方向有关，在vert中处理反射 / 折射方向；在frag处理采样。</p><p>都与天空盒有关：采样</p><h2 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h2><p>😺<strong>渲染目标纹理（Render Target Texture，RTT）</strong>：现代的GPU允许我们把整个三维场景渲染到一个<strong>中间缓冲</strong>中，而不是传统的帧缓冲或者后备缓冲（back buffer）。【场景直接渲染到纹理中而不是屏幕上】</p><p>​    👉与之相关的是<strong>多重渲染目标（Multiple Render Target，MRT）</strong>：把场景<strong>同时</strong>渲染到<strong>多个渲染目标纹理</strong>中，而不再需要为每个渲染目标纹理单独渲染完整的场景。</p><h3 id="镜子效果"><a href="#镜子效果" class="headerlink" title="镜子效果"></a>镜子效果</h3><p>😺主要思路：把渲染纹理【也就是另一个设置好的摄像机视角】赋给镜子，并在脚本中进行水平翻转。</p><p>👉创建渲染纹理：Project—Create—Render Texture</p><p>👉创建渲染纹理对应的摄像机：调整好画面后，【Camera组件面板】Target Texture–上一步创建的渲染纹理</p><p>👉Shader控制，也就是当作基本纹理来使用，翻转一下，采样就OK </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.texcoord;</span><br><span class="line">    o.uv.x = 1 - o.uv.x;//翻转【纹理范围为0，1】</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">return tex2D(_MainTex, i.uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105238093.png" alt="image-20220711105238093"></p><h3 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h3><p>🐽<strong>GrabPass</strong>：一种特殊的Pass，来<strong>获取屏幕图像</strong>。当在Shader中定义了一个GrabPass后，Unity会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的Pass中访问它。</p><p>​    👉通常会使用这个来实现诸如<strong>玻璃等透明材质的模拟</strong>，与使用简单的透明混合不同，使用GrabGrass可以让我们<strong>对物体后面的图像进行更复杂的处理</strong>，例如使用法线模拟折射效果。</p><p>​    👉需要小心物体的渲染队列设置。GrabPass<strong>通常用于渲染透明物体</strong>，尽管代码里并<strong>不包含混合指令</strong>[就不会默认开启透明队列]，但还是要把渲染队列设置成透明队列{“Queue” = “Transparent”}</p><p>🐽思路：法线；通过Cubemap来模拟玻璃的<strong>反射</strong>；用Grab Pass获取玻璃后面的屏幕图像来模拟<strong>折射</strong>，并使用切线空间下的<u>法线来对屏幕纹理坐标偏移</u>后，再对屏幕图像进行采样来模拟近似的折射效果。（之前折射的物体表面是光滑的，这次加了法线纹理，凹凸也会影响折射）</p><p>​    👉【再详细说明】反射：关键语句——反射方向：reflect (-worldViewDir, bump);  采样：reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb; bump是法线方向，由于这里采用了法线纹理，所以要对法线纹理进行采样。(一般来说是世界空间)然后是环境纹理</p><p>​    👉折射：不同于之前的用环境纹理，这里用的是屏幕渲染纹理。直接用坐标的偏移来模拟折射。</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711164141728.png" alt="image-20220711164141728"></p><h3 id="渲染纹理-vs-GrabPass"><a href="#渲染纹理-vs-GrabPass" class="headerlink" title="渲染纹理 vs GrabPass"></a>渲染纹理 vs GrabPass</h3><table><thead><tr><th></th><th align="center">渲染纹理</th><th align="center">GrabPass</th></tr></thead><tbody><tr><td>好处</td><td align="center"><strong>效率高</strong>（尤其在移动设备）：可以自定义纹理大小</td><td align="center"><strong>实现简单</strong>：在Shader中几行代码实现</td></tr><tr><td>坏处</td><td align="center">较复杂：创建渲染纹理＆相机—设置RenderTarget—传递渲染纹理给Shader</td><td align="center">获取的图像分辨率和屏幕一致；在移动设备上，往往需要CPU直接读取后备缓冲中的数据，破坏了CPU和GPU的并行性，这是比较耗时的</td></tr></tbody></table><h2 id="程序纹理-Procedural-Texture"><a href="#程序纹理-Procedural-Texture" class="headerlink" title="程序纹理 Procedural Texture"></a>程序纹理 Procedural Texture</h2><p>由计算机生成的图像。通过一些特定的算法来创建个性化图案或者非常真实的自然元素。</p><h3 id="在Unity中实现简单的程序纹理"><a href="#在Unity中实现简单的程序纹理" class="headerlink" title="在Unity中实现简单的程序纹理"></a>在Unity中实现简单的程序纹理</h3><p>🥰基本思想：程序图案由脚本生成；脚本挂载在游戏对象上，生成的纹理影响本对象的Material材质。</p><p>👇主要研究脚本编写：如何生成纹理（绘制基本流程）？如何传递给Material？</p><p>​    【小技巧】在编辑模式下/非Play模式运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ExecuteInEditMode]</span><br><span class="line">public class ProcedualTextureGeneration : MonoBehaviour</span><br></pre></td></tr></table></figure><p>​    【主要变量】脚本生成的一张纹理Texture；纹理将要赋给的材质Material</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Material material = null;</span><br><span class="line">private Texture2D m_generatedTexture = null;</span><br></pre></td></tr></table></figure><p>​    【变量的关键操作】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//-----Material------</span><br><span class="line">private void Start() &#123;</span><br><span class="line">    if (material == null)</span><br><span class="line">    &#123;</span><br><span class="line">    Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">        if (renderer == null)</span><br><span class="line">        &#123;</span><br><span class="line">        Debug.Log(&quot;Cannot find a renderer&quot;);</span><br><span class="line">        return;</span><br><span class="line">        &#125;</span><br><span class="line">        material = renderer.sharedMaterial;//获取不为空的material</span><br><span class="line">    &#125;</span><br><span class="line">    _UpdateMaterial();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void _UpdateMaterial()&#123;</span><br><span class="line">    if (material != null)</span><br><span class="line">    &#123;</span><br><span class="line">    m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">    material.SetTexture(&quot;_MainTex&quot;, m_generatedTexture);//纹理赋给material</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//-----Texture-----</span><br><span class="line">proceduralTexture.SetPixel(w, h, pixel);//新的纹理：长/宽还有像素</span><br><span class="line">proceduralTexture.Apply();   //Apply函数：强制把像素值写入纹理中</span><br></pre></td></tr></table></figure><blockquote><p>由此可见对纹理是逐像素操作。</p></blockquote><h1 id="让画面动起来"><a href="#让画面动起来" class="headerlink" title="让画面动起来"></a>让画面动起来</h1><h2 id="Unity-Shader中的内置变量（时间篇）"><a href="#Unity-Shader中的内置变量（时间篇）" class="headerlink" title="Unity Shader中的内置变量（时间篇）"></a>Unity Shader中的内置变量（时间篇）</h2><h2 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h2><p>可以用纹理动画来代替复杂的粒子系统等模拟各种动画效果。</p><h3 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h3><p>优点：灵活性很大，不需要进行任何物理运算；缺点：所需美术工程量大（关键帧图像）。</p><p>🐽【关键】计算出每个时刻需要播放的关键帧在纹理中的位置：即关键帧所在的行列索引数</p><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220716221140400.png" alt="image-20220716221140400"></p><blockquote><p>原本是这样理解的，但行不通</p></blockquote><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220716221128192.png" alt="image-20220716221128192"></p><blockquote><p>目前是比较说的通的一种理解</p></blockquote><p>【渲染设置】透明度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;</span><br><span class="line">            &quot;Queue&quot; = &quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot; = &quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p>【frag】实质上是uv坐标的偏移。首先把uv“裁剪”到小方块，再进行索引的偏移。（或者偏移了再裁）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    float time = floor(_Time.y * _Speed);</span><br><span class="line">    float row = floor(time / _HorizontalAmount);</span><br><span class="line">    float column = time - row * _HorizontalAmount;</span><br><span class="line"></span><br><span class="line">    //方法一（原理）</span><br><span class="line">    //half2 uv = float2(i.uv.x / _HorizontalAmount, i.uv.y / _VerticalAmount);</span><br><span class="line">    //uv.x += column / _HorizontalAmount;</span><br><span class="line">    //uv.y -= row / _VerticalAmount;</span><br><span class="line"></span><br><span class="line">    //方法二（改进）</span><br><span class="line">    half2 uv = i.uv + half2(column, -row);</span><br><span class="line">    uv.x /= _HorizontalAmount;</span><br><span class="line">    uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">    fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">    c.rgb *= _Color;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220716224957493.png" alt="image-20220716224957493"></p><h3 id="滚动的背景"><a href="#滚动的背景" class="headerlink" title="滚动的背景"></a>滚动的背景</h3><p>【关键】纹理坐标在水平方向的偏移；不同层（纹理）叠加。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, 0.0) * _Time.y);</span><br><span class="line">    o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, 0.0) * _Time.y);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">    fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);</span><br><span class="line">    fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);</span><br><span class="line"></span><br><span class="line">    c.rgb *= _Multiplier;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h3><h4 id="流动的河流"><a href="#流动的河流" class="headerlink" title="流动的河流"></a>流动的河流</h4><p>（待理解完善）</p><p>即使代码写好了，效果不佳，锯齿很明显。可能是<strong>四边形Quad和平面Plane</strong>的区别导致。前者是由两个三角形构成，后者是由两百多个三角形构成，所以从效率上来说，四方形比平面更好。比如要在游戏里显示图片或者视频，这个非常合适。还有在<a href="https://so.csdn.net/so/search?q=GUI&spm=1001.2101.3001.7020">GUI</a>里显示一些图片，以及在粒子系统的粒子显示，精灵和伪图片等等。</p><h4 id="广告牌技术-Billboarding"><a href="#广告牌技术-Billboarding" class="headerlink" title="广告牌技术 Billboarding"></a>广告牌技术 Billboarding</h4><p>😎根据视角方向来旋转一个被纹理着色的多边形，使得多边形看起来好像总是面对着摄像机。</p><p>😺广告牌技术的本质是构建旋转矩阵，而一个变换矩阵需要<strong>三个基向量</strong>；通常是表面法线（normal）、指向上的方向（up）以及指向右的方向（right）。除此之外，还要指定一个锚点（anchor location），在旋转过程中是固定不变的。</p><p>🧐如何根据需求构建三个相互正交的基向量？</p><p>【要求】其中一个基向量是固定的，固定向上/法线等。</p><p>​    👉up固定：比如模拟草丛，想象一个草片立在地上，草尖固定对着天空，但是面片是一直朝向镜头的，所以玩家视角来看草就是立体的，除非从上往下看</p><p>​    👉normal固定：还是那片草，但始终面向摄像机。所以一般模拟粒子效果、烟雾等。</p><p>【条件】up和normal在同一平面上。</p><p>【构建】up和normal叉积出right，再用up和right叉积，以此类推。</p><p>🎏实践</p><p>【渲染设置】透明；取消批处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter11/Billboard&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        //用于调整是固定法线还是固定指向上的方向</span><br><span class="line">        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(0, 1)) = 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;</span><br><span class="line">            &quot;Queue&quot; = &quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot; = &quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            //需要使用物体的模型空间下的位置来作为锚点进行计算</span><br><span class="line">            //所以要取消对该Shader的批处理操作</span><br><span class="line">            &quot;DisableBatching&quot; = &quot;True&quot; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off</span><br></pre></td></tr></table></figure><p>【vert】所有计算都是在模型空间下完成的，所以主要在vert。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">/*向量准备：原点和视角位置*/</span><br><span class="line">float3 center = float3(0, 0, 0);</span><br><span class="line">float3 viewer = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));</span><br><span class="line"></span><br><span class="line">/*计算正交矢量*/</span><br><span class="line">//1.固定法线方向</span><br><span class="line">float3 normalDir = viewer - center;</span><br><span class="line">//若_VerticalBillboarding为1，normalDir不变，说明法线方向固定（因为一直随摄像机）</span><br><span class="line">//若_VerticalBillboarding为0，normalDir的y变0，说明此时normalDir只能在xoz平面上。这就保证up固定不变</span><br><span class="line">normalDir.y *= _VerticalBillboarding;</span><br><span class="line">normalDir = normalize(normalDir);</span><br><span class="line"></span><br><span class="line">//2.判断并得出正确的向上分量，最后得出三个基向量</span><br><span class="line">//只是防止法线和up平行；只能保证两者在同一平面上，不一定互相垂直</span><br><span class="line">float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line">float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line">//3.计算新的顶点位置</span><br><span class="line">//目前只保证了坐标系是正确的；模型的顶点还要更新</span><br><span class="line">//根据原始位置相对于锚点的偏移量，以及3个正交基矢量</span><br><span class="line">float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line"></span><br><span class="line">o.pos = UnityObjectToClipPos(localPos);</span><br><span class="line"></span><br><span class="line">return o;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>🎈取消批处理：会带来一定的性能下降，增加了Draw Call，因此尽量避免使用模型空间下的一些绝对位置和方向来计算。</p><p>🎈为顶点动画计算阴影。如果使用的是内置的ShadowCaster Pass，这个Pass<strong>没有相关的定点动画</strong>，因此Unity仍然<strong>按照原来的顶点位置</strong>来计算阴影。</p><p>​    👉需要提供<strong>自定义</strong>的ShadowCaster Pass，在这个Pass中进行<strong>同样的顶点变换过程</strong>。</p><p>🎏实践（继河流的顶点动画添加阴影）</p><p>​    👉【重点】需要按正常的Pass的处理来剔除片元或进行顶点动画，以便阴影可以和物体渲染的结果<strong>相匹配</strong>。</p><p>​    👉【Unity提供的内置宏】用来计算阴影投影时需要的各种变量。而我们可以只关注自定义计算的部分。</p><p>【设置】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Pass to render object as a shadow caster</span><br><span class="line">Pass &#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;//</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    #pragma multi_compile_shadowcaster//</span><br><span class="line"></span><br><span class="line">    #include &quot;UnityCG.cginc&quot;</span><br></pre></td></tr></table></figure><p>【v2f / vert】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123; </span><br><span class="line">//定义阴影投射需要定义的变量</span><br><span class="line">V2F_SHADOW_CASTER;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata_base v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line"></span><br><span class="line">    float4 offset;</span><br><span class="line">    offset.yzw = float3(0.0, 0.0, 0.0);</span><br><span class="line">    offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">    v.vertex = v.vertex + offset;</span><br><span class="line"></span><br><span class="line">//计算顶点的偏移量——》顶点位置</span><br><span class="line">    TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【frag】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">//让Unity自动完成阴影投射部分，把结果输出到深度图和阴影映射纹理中</span><br><span class="line">SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">learn sth</summary>
    
    
    
    <category term="shader" scheme="https://huangxinhere.github.io/categories/shader/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityShader 入门精要/基础篇＋初级篇 笔记</title>
    <link href="https://huangxinhere.github.io/2022/06/28/Unity%20shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/"/>
    <id>https://huangxinhere.github.io/2022/06/28/Unity%20shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/</id>
    <published>2022-06-27T16:00:00.000Z</published>
    <updated>2022-12-09T09:58:28.829Z</updated>
    
    <content type="html"><![CDATA[<p>学习shader：</p><ul><li>前提要了解整个渲染流程是如何进行的</li><li>更多是面向GPU的工作方式</li><li>基本知识了解<ul><li>OpenGL ＆ DirectX：两种图像应用编程接口。直接操作硬件是很难受滴，所以为上层应用程序和底层GPU架起了沟通桥梁。</li></ul></li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/9cbbce53043dfae55a4ae7adadff7c54.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><ul><li>着色语言：专门用于编写着色器<ul><li>OpenGL的GLSL：跨平台性，只要显卡驱动支持GLSL的编译就能运行（依赖硬件—取决于硬件供应商）</li><li>DirectX的HLSL：微软平台</li><li>NVIDIA的CG：真正意义上的跨平台；和HLSL非常相像；无法发挥出OpenGL的最新特性</li></ul></li></ul><h1 id="第2章-渲染流水线"><a href="#第2章-渲染流水线" class="headerlink" title="第2章 渲染流水线"></a>第2章 渲染流水线</h1><h2 id="2-1什么是渲染流水线"><a href="#2-1什么是渲染流水线" class="headerlink" title="2.1什么是渲染流水线"></a>2.1什么是渲染流水线</h2><ul><li><p>shader：着色器，是渲染流水线中的一个环节</p></li><li><p>渲染流水线：</p><ul><li>最终目的，由一个三维场景出发，生成或者渲染一张二维纹理图像（通常由CPU和GPU共同完成）</li><li>输入一个虚拟摄像机，光源，shader以及纹理等等</li><li>渲染流程可以分为三个阶段：</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/721d712f2f7ee8657003926b18c91cd9.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><ul><li><strong>应用阶段</strong>：（CPU）开发者主导；准备场景数据、粗粒度剔除工作（剔除不可见物体）、设置好每个模型的渲染状态……【最重要的输出时渲染所需的几何信息，即<u>渲染图元</u>】</li><li>几何阶段：（GPU）用于处理所有 和我们要绘制的 几何相关的 东西。比如需要绘制的图元是什么，怎样绘制，在哪里绘制。【把顶点坐标（每个顶点对应的深度值，着色等相关信息）变换到屏幕空间中，再交给光栅器进行处理】</li><li>光栅化阶段：（GPU）使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。</li></ul></li><li><p>以上是概念流水线。</p></li><li><p>GPU流水线——硬件 真正用于实现上述概念的 流水线</p></li></ul><h2 id="2-2-CPU和GPU之间的通信"><a href="#2-2-CPU和GPU之间的通信" class="headerlink" title="2.2 CPU和GPU之间的通信"></a>2.2 CPU和GPU之间的通信</h2><p>应用阶段：（渲染流水线的起点是CPU）</p><h4 id="把数据加载到显存中"><a href="#把数据加载到显存中" class="headerlink" title="把数据加载到显存中"></a>把数据加载到显存中</h4><ul><li>所有渲染的数据都要从🥰硬盘（HDD）中加载到🥰系统内存（RAM）</li><li>然后，网格和纹理等数据又被加载到【🥰显卡（VRAM）上的存储空间——显存】中（显卡对显存的访问速度更快；大多数显卡对RAM没有直接访问的权利）</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/1f6f715e90046a41a9637631a191c978.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><p>​            两纹理＋三网格</p><ul><li><p>数据加载到显存后，RAM的数据就可以删除了</p><ul><li><p>但有些数据，CPU仍需要（通过RAM？）访问它们，比如访问网格数据进行碰撞检测）；如果重新加载，硬盘加载到RAM的过程是十分耗时的</p></li><li><p>开发者通过CPU来设置渲染状态（不知道和上面这点有何联系？？），“指导”GPU如何进行渲染工作</p><p>🧐总结：硬盘-RAM-显存是数据流通，幕后操控是CPU和GPU，其中GPU只操控显存（大概先这样吧）</p></li></ul></li></ul><h4 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h4><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/716ca7c6a58f624dd44812261c4dd5e7.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><p>​        （同一状态下渲染三个网格）</p><ul><li><p>这些状态定义了场景中的网格是怎样被渲染的（有不同的打扮方式嘛？！）</p><ul><li>做法：使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等【应用阶段？？具体怎么做嘛】</li></ul></li></ul><h4 id="调用Draw-Call"><a href="#调用Draw-Call" class="headerlink" title="调用Draw Call"></a>调用Draw Call</h4><p>在我看来很像画画。大脑就是GPU，把看到的模型光线什么的放在脑海里（素描关系色彩什么的），然后除了传递这些数据给（会画画的大脑部分），还得告诉它要主观加工成什么样（一个渲染规范？目标？）。然后会画画的大脑部分就要开始画画啦（接到指令和资料！</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/4c18f630c7caa3211c8bc011cfc95d8a.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><ul><li><p>附加说明：深入理解CPU和GPU与Draw Call之间的关系</p><ul><li><p>GPU和CPU如何实现并行工作？- 命令缓冲区</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/35344c10842212ea69c28174e89e49d7.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>添加命令和读取命令是独立分开的（小小知识点：改变渲染状态的命令比渲染模型更耗时）</p></blockquote></li><li><p>为什么Draw Call多了会影响帧率？</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/e6aa7f1cbae85ff4ed99efdbb96f41e5.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>GPU渲染能力很强，速度往往快于CPU提交命令的速度；如果操作过多，额外的工作量会过于繁琐，很慢，比不上别人，效率很低。</p></blockquote></li><li><p>如何减少Draw Call？</p><p>这里选取<strong>批处理</strong>的方法。</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/084d5694f465bcd8f245d6234e16e82c.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>打包一次性发送（一个包同一种渲染状态）</p><p>但是打包（在CPU的内存中合并网格）也是消耗时间的。所以批处理更适合静态的物体。动态的话每一帧都要合并，会对空间和时间造成一定影响</p></blockquote><p>so，避免使用大量很小的网格；避免使用过多的材质。</p></li></ul></li></ul><h2 id="2-3GPU流水线"><a href="#2-3GPU流水线" class="headerlink" title="2.3GPU流水线"></a>2.3GPU流水线</h2><ul><li><p>几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，但是GPU向开发者开放了很多控制权👇</p></li><li><p>这两个阶段可以分为更小的流水线阶段；每个阶段GPU提供不同的可配置性（设置每一步的操作细节）或可编程性</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/b8e1a2f6d7a5e52cb3d0e9eeaf356b0e.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>绿色：完全可编程控制</p><p>黄色：可配置不可编程</p><p>蓝色：没有任何控制权</p><p>？实线：该shader必须由开发者编程实现【为什么有蓝色的实线？没有控制权的必须编程实现？】</p><p>？虚线：该shader可选</p><p>各个介绍见4%</p></blockquote></li></ul><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><ul><li><p>接受的顶点数据：（GPU接受的数据）由应用阶段加载到显存中；再由DrawCall指定（再次顺一顺上面学到的）</p></li><li><p>干嘛的：坐标变换和逐顶点光照（就是加颜色？）</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/f11f63aa6d913ccf4465950387392444.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><ul><li>坐标变换</li></ul><p>-改变顶点的位置，在顶点动画中非常有用，水面、布料等。</p><p>最基本的工作：把顶点坐标从模型<strong>空间</strong>转换到齐次裁剪<strong>空间</strong>（区别？）——&gt;由硬件做透视除法——&gt;归一化的设备坐标（NDC）【待深究，首先理解坐标变换大概是什么个意思】</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/5829e63db9281058e493ef933d238602.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>对右边空间的思考：</p><p><img src="https://img-blog.csdn.net/20171016201356967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWQ4ODI4MjI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="&lt;image1&gt;"><img src="https://img-blog.csdn.net/20171016201416205?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWQ4ODI4MjI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="&lt;image2&gt;"></p><p>搜了下资料，这是视锥体，分别是透视投影和正交投影。资料所说，裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。那么相当于把自己的视角看作一个固定范围的空间，然后都投影在这个范围里面。</p><p>这个空间大小似乎有规范大小，如图，坐标范围是OpenGL同时也是Unity使用的NDC，z在【-1，1】之间，而在DirectX中，NDC的z【0，1】</p></blockquote></li><li><p>光照相互独立性：本身不可以创建或者销毁任何顶点+获得顶点之间的联系——GPU可以利用本身的特性并行优化处理每一个顶点，处理速度会很快</p></li></ul><h4 id="曲面细分着色器"><a href="#曲面细分着色器" class="headerlink" title="曲面细分着色器"></a>曲面细分着色器</h4><ul><li>可选</li><li>用于细分图元（之前提到的渲染图元？到底有什么数据长什么样？）</li></ul><h4 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h4><ul><li>可选</li><li><u>逐图元</u>【是一个啥东西？】的着色操作，或者被用于产生更多的图元</li></ul><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><ul><li><p>可配置</p></li><li><p>目的：不在摄像机视野范围内的物体不需要被处理</p></li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/e9c4a625643a99425c64f1a195b59c94.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>立方体范围内，图元保留、舍弃、裁剪（生成新的点）；这里还是立方体哇！😎</p></blockquote><h4 id="屏幕映射Screen-Mapping（二维）"><a href="#屏幕映射Screen-Mapping（二维）" class="headerlink" title="屏幕映射Screen Mapping（二维）"></a>屏幕映射Screen Mapping（二维）</h4><ul><li><p>三维坐标数据因为已经由NDC规定好了，但是屏幕的大小/分辨率又会有不同，那么怎么做适配呢？</p></li><li><p>每个图元的x和y坐标转换到屏幕坐标系👇</p></li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/541c691775294b2af9f32af727505ea2.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>🧐所以是有缩放的效果了……可能有点变形？还有z坐标直接被剔去了？前后关系怎么表示咧</p></blockquote><ul><li><p>不会对输入的z坐标做任何处理。屏幕坐标系和z坐标【还在啊…？】一起构成了一个坐标系——&gt;<strong>窗口坐标系</strong>（Window Coordinates），这些值会一起被传递到光栅化阶段</p></li><li><p>然鹅屏幕坐标系对于OpenGL和DirectX仍有所区别，起始点不同（反正要考虑这种差异可能会导致效果倒转）</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/b4ff49d945948ea577003130621b6da9.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p></li></ul><hr><p>顶点已经在二维屏幕集结好啦！还附带了一些信息（深度值z值（原来是它吖，法线方向（见了好多次到底是咋样，视角方向等）可以开始进一步打扮了。👇光栅化阶段：点与点之间覆盖的范围和颜色👇</p><h4 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h4><ul><li>干嘛：计算光栅化一个三角网格所需的信息</li><li>三角网格怎么组成的？三角形的点知道了，那么用多少行多少列表示啊？得整个<strong>三角网格表示数据</strong>哇</li></ul><h4 id="三角形遍历（扫描变换）"><a href="#三角形遍历（扫描变换）" class="headerlink" title="三角形遍历（扫描变换）"></a>三角形遍历（扫描变换）</h4><ul><li>🦁<strong>检查</strong>每个像素是否被一个三角网格覆盖——&gt;覆盖，生成一个片元。网格好了，边范围也知道了，开始填填乐呗</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/5990d470b57bfcdca705c250ed5b45df.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>生成像素，对应像素生成一个<strong>片元</strong>（并不是真正意义上的像素，是包含<u>很多状态的集合</u>，这些状态用于计算每个像素的最终颜色）。整个输出<strong>片元序列</strong>。</p><p><strong>片元的状态</strong>是对三个顶点的信息进行<strong>插值</strong>【这又是什么哇？】得到。状态比如有屏幕坐标，深度信息，法线，纹理坐标等等</p><p>总结：填填乐怎么得来？插值？填的计算方法嘛？而且不是颜色，是生成片元的状态。</p></blockquote><h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><ul><li><u>以上阶段</u>实际上不影响像素的颜色值，而是产生一系列的数据信息（一个三角网络是怎样覆盖每个像素的）</li><li><u>每个片元</u>负责存储这样一系列数据。</li><li>片元着色器的输入输出（欧，就先想象是每个顶点带着自己的捆绑包经历千辛万苦坐火车做安检什么的，终于在片元着色器完成了资源的计算完成了修炼，完成华丽的蜕变/有了该片元的输出颜色…）</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/52837b327f33ad1730daba41dc3ad66c.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>输入：上一个阶段对顶点信息插值得到的结果（片元带）</p><p>输出：一个或多个颜色值</p></blockquote><ul><li><p>补充：纹！理！采！样！？（片元着色器中）</p><ul><li><p>纹理坐标：从顶点着色器阶段输出每个点对应的纹理坐标（怎么来好像没稀奇，所以到底是啥</p><p>​                    ——插值——顶点们覆盖的片元的纹理坐标（就是顶点包裹里面的一个东西嘛，所以是啥？!</p></li></ul></li><li><p>局限：仅可以影响单个片元</p></li></ul><h4 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h4><ul><li><p>高度可配置性</p></li><li><p>任务：</p><ol><li><p>决定每个片元的可见性，涉及很多测试操作（测试？从种种角度来看能不能可见吧）</p></li><li><p>若一个片元通过了所有测试，其颜色值+已经存储在颜色缓冲区中的颜色（好的已经可见啦，就得有颜色来展示；相当于投了简历，即使到了最后一面被刷到也还是没有offer啊！！！）</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/a6ffc86900aa747f898d07a55c729193.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>颜色缓冲区？为啥会有这个。怎么混合啊</p><ul><li>像素的颜色信息被存储在名为颜色缓冲的地方</li><li>往往有上次渲染之后的颜色结果</li><li>so，是覆盖呢，还是进行其它处理?</li></ul></blockquote><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/0428aea75587eb49eaaafb64d6bf043f.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>这个是其中两个测试的具体过程，嗯，跳过！</p><p>回来了。原理关键是矩形内容。深度这个，透明度或许有解答</p></blockquote></li></ol></li><li><p>混合！</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/1afda4956ed174150b5324174c29d126.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>不透明物体：<strong>开发者</strong>可以关闭混合条件。源颜色会覆盖掉颜色缓冲区的像素值</p><p>半透明：混合操作。</p></blockquote></li><li><p>测试顺序：对于大多数GPU来说，尽可能在片元着色器之前进行这些测试，为了节省力气（直接把简历筛下去的意思嘛？！</p></li><li><p>提前的话可能会有些冲突；性能下降（GPU判断提前测试是否有冲突，此时会有更多的片元需要被处理</p></li><li><p>显示到屏幕上之后，GPU会双重缓冲。后置缓冲：对场景的渲染是在幕后发生，前置缓冲：之前显示在屏幕中的图像。两者交换以保证图像连续。</p></li></ul><hr><p>（气喘吁吁🙃）</p><p>大概了解了整个渲染流程，而shader所在阶段就是渲染流水线的一部分，所以shader就是：</p><ul><li>GPU流水线上一些可高度编程的阶段</li></ul><h1 id="第3章-Unity-Shader基础"><a href="#第3章-Unity-Shader基础" class="headerlink" title="第3章 Unity Shader基础"></a>第3章 Unity Shader基础</h1><p>对一些操作进行了封装，方便更好地编程和设置</p><h2 id="Unity-Shader概述"><a href="#Unity-Shader概述" class="headerlink" title="Unity Shader概述"></a>Unity Shader概述</h2><h3 id="材质和Unity-Shader"><a href="#材质和Unity-Shader" class="headerlink" title="材质和Unity Shader"></a>材质和Unity Shader</h3><p>没有细读这本书之前，按照一贯的操作思路，就是先弄一个shader，然后根据它创建一个材质，这样效果就能赋给模型了。为什么shader和材质会产生这种割裂，还有联系?</p><p>Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等），而😏<strong>材质则允许我们调节这些属性</strong>，<strong>并将其最终赋给相应的模型</strong>。</p><h3 id="Unity中的材质"><a href="#Unity中的材质" class="headerlink" title="Unity中的材质"></a>Unity中的材质</h3><p>有面板可更改数值</p><h3 id="Unity中的Shader"><a href="#Unity中的Shader" class="headerlink" title="Unity中的Shader"></a>Unity中的Shader</h3><ul><li>Standard Surface Shader：会产生一个包含了标准光照模型的<u>表面着色器</u>（啥玩意，没见过）模板</li><li>Unlit Shader：不包含光照（但包含雾效）的基本的顶点/片元着色器</li><li>Image Effect Shader：为屏幕后处理效果提供模板</li><li>Compute Shader：（略</li></ul><blockquote><p>这些基本的理解，或许在其它的shader插件或者什么中有共性</p></blockquote><ul><li>可以在shader面板中查看各种东西，是否为Surface shader啊，Fixed function啊，等等，有需要我再细看吧</li></ul><h2 id="Unity-Shader的基础：ShaderLab"><a href="#Unity-Shader的基础：ShaderLab" class="headerlink" title="Unity Shader的基础：ShaderLab"></a>Unity Shader的基础：ShaderLab</h2><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/4b9a50ca2993153f23d86a7786580f3e.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>　Unity Shader为控制渲染过程提供了一层抽象。如果没有使用UnityShader（左图），开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果；而在Unity Shader的帮助下（右图），开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作</p></blockquote><ul><li>ShaderLab: 是Unity提供的编写Unity Shader的一种说明性语言</li><li>一个Unity Shader的基础结构如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot; &#123;    </span><br><span class="line">Properties &#123;        </span><br><span class="line">// 属性</span><br><span class="line">    &#125;    </span><br><span class="line">    SubShader &#123;        </span><br><span class="line">    // 显卡A使用的子着色器</span><br><span class="line">    &#125;    </span><br><span class="line">    SubShader &#123;        </span><br><span class="line">    // 显卡B使用的子着色器</span><br><span class="line">    &#125;        </span><br><span class="line">    Fallback &quot;VertexLit&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="Unity-Shader的结构"><a href="#Unity-Shader的结构" class="headerlink" title="Unity Shader的结构"></a>Unity Shader的结构</h2><p>上节见到了一些ShaderLab的语义，如Properties、SubShader、Fallback等。这些语义定义了Unity Shader的结构，从而帮助Unity分析该Unity Shader文件，以便进行正确的编译。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h3 id="材质和Unity-Shader-的桥梁：Properties（属性）"><a href="#材质和Unity-Shader-的桥梁：Properties（属性）" class="headerlink" title="材质和Unity Shader 的桥梁：Properties（属性）"></a>材质和Unity Shader 的桥梁：Properties（属性）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;    </span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue    </span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue    // 更多属性</span><br><span class="line">&#125;</span><br><span class="line">//比如 _int (&quot;Int&quot;, Int) = 2;</span><br><span class="line">//在Shader中访问属性， 通过Name，通常由一个下划线开始</span><br><span class="line">//显示的名称display name则是出现在材质面板上的名字</span><br><span class="line">//指定类型 PropertyType</span><br><span class="line">//默认值</span><br><span class="line"></span><br><span class="line">//虽然不是C#但为了代码染色</span><br></pre></td></tr></table></figure><ul><li><p>数字类型的属性</p></li><li><p>Color， Vector（1，2，3，4）</p></li><li><p>2D，Cube，3D “”{}  </p><blockquote><p>具体怎么填详情看书，不知道现在还通用不</p></blockquote></li><li><p>还能重载默认的材质面板</p></li></ul><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><ul><li><p>数量要求：每个Unity Shader文件可以包含多个SubShader语义块，最少要一个</p></li><li><p>运行机制：当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader。如果都不支持的话，Unity就会使用Fallback语义指定的UnityShader。</p><blockquote><p>原因：不同的显卡具有不同的能力。例如，一些旧的显卡仅能支持一定数目的操作指令，而一些更高级的显卡可以支持更多的指令数，那么我们希望在旧的显卡上使用计算复杂度较低的着色器，而在高级的显卡上使用计算复杂度较高的着色器，以便提供更出色的画面。【可选择，确实挺照顾玩家的，所以游戏会有最低配置最高配置？】</p></blockquote></li><li><p>```c#<br>SubShader {    </p><pre><code>// 可选的“标签”[Tags]    // 可选的“状态”[RenderSetup]    Pass &#123;    &#125;    // Other Passes</code></pre><p>}<br>//每个pass定义了一次完整的渲染流程；但数目过多会造成渲染性能的下降</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 👉状态设置👈</span><br><span class="line"></span><br><span class="line">  ShaderLab提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等（首先渲染状态是什么玩意儿？都看不懂，希望后面有实例说明）</span><br><span class="line"></span><br><span class="line">  - 当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。如果我们不想这样可以在Pass语义块中单独进行上面的设置。</span><br><span class="line"></span><br><span class="line">* 👉标签👈</span><br><span class="line"></span><br><span class="line">  是一个键值对，键和值都是字符串类型；这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：我希望&lt;u&gt;怎样以及何时渲染这个对象&lt;/u&gt;。</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  Tags &#123; </span><br><span class="line">      &quot;TagName1&quot; =&quot;Value1&quot; </span><br><span class="line">      &quot;TagName2&quot; =&quot;Value2&quot; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>巴拉巴拉详细举例和介绍等等，有用到就细看。</p><p><img src="/2022/06/28/Unity%20shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/hexo_github_blog\source_posts\pic\image-20220426193126888.png" alt="image-20220426193126888"></p><ul><li>仅可以在SubShader中声明，不可以在Pass块声明</li></ul></li><li><p>👉Pass语义块👈</p><ul><li>```c#<br>Pass{<pre><code>[Name]             //Name &quot;MyPassName&quot;[Tags][RenderSetup]//other code</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; * 名称：通过名称，可以使用ShaderLab的UsePass命令来直接使用其它Unity Shader中的Pass。例如：</span><br><span class="line">&gt;</span><br><span class="line">&gt;   ```c#</span><br><span class="line">&gt;   UsePass &quot;MyShader/MYPASSNAME&quot;</span><br><span class="line">&gt;   //这样提高代码的复用性。Unity内部会把所有的Pass名称转换成大写字母</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>渲染状态：SubShader的状态设置同样适用于Pass；还能使用固定管线的着色器命令。</p></li><li><p>标签：不同于SubShader标签。用于告诉渲染引擎希望怎样来渲染物体</p></li></ul><p>（例子见9%）</p></blockquote></li></ul></li><li><p>Fallback</p><p>下下策：最低级的Unity Shader</p><p>还会影响阴影的投射</p></li></ul><h2 id="Unity-Shader的形式"><a href="#Unity-Shader的形式" class="headerlink" title="Unity Shader的形式"></a>Unity Shader的形式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;        </span><br><span class="line">    // 所需的各种属性</span><br><span class="line">    &#125;    </span><br><span class="line">SubShader &#123;        </span><br><span class="line">    // 真正意义上的Shader代码会出现在这里</span><br><span class="line">    // 表面着色器（Surface Shader）或者</span><br><span class="line">    // 顶点/片元着色器（Vertex/Fragment Shader）或者</span><br><span class="line">    // 固定函数着色器（Fixed Function Shader）</span><br><span class="line">    &#125;    </span><br><span class="line">SubShader &#123;        </span><br><span class="line">    // 和上一个SubShader类似</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unity的宠儿：表面着色器"><a href="#Unity的宠儿：表面着色器" class="headerlink" title="Unity的宠儿：表面着色器"></a>Unity的宠儿：表面着色器</h3><ul><li>Unity自己创造的一种着色器代码类型</li><li>所需代码量少，Unity在背后做了很多工作，但渲染的代价比较大</li><li>本质和其它着色器一样/ 是它们的更高抽象</li><li>unity为我们处理了很多光照细节</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot; &#123;</span><br><span class="line">    //在SubShader语句块里面（而非Pass语句块里面）</span><br><span class="line">    SubShader &#123;        </span><br><span class="line">        Tags &#123; &quot;RenderType&quot; =&quot;Opaque&quot; &#125;</span><br><span class="line">        CGPROGRAM/**/        </span><br><span class="line">        #pragma surface surf Lambert        </span><br><span class="line">        struct Input &#123;            </span><br><span class="line">            float4 color : COLOR;        </span><br><span class="line">        &#125;;        </span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o) &#123;            </span><br><span class="line">            o.Albedo =1;        </span><br><span class="line">        &#125;        </span><br><span class="line">        ENDCG/**/    </span><br><span class="line">    &#125;    </span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不需要开发者关心使用多少个Pass、每个Pass如何渲染等问题，Unity会处理</span><br><span class="line">//CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的，也就是说，我们需要把Cg/HLSL语言嵌套在ShaderLab语言中。值得注意的是，这里的Cg/HLSL是Unity经封装后提供的，它的语法和标准的Cg/HLSL语法几乎一样，但还是有细微的不同，例如有些原生的函数和用法Unity并没有提供支持</span><br></pre></td></tr></table></figure><h3 id="最聪明：顶点-片元着色器"><a href="#最聪明：顶点-片元着色器" class="headerlink" title="最聪明：顶点/片元着色器"></a>最聪明：顶点/片元着色器</h3><ul><li><p>在Unity中我们可以使用Cg/HLSL语言来编写顶点/片元着色器（Vertex/FragmentShader）</p></li><li><p>更加复杂，灵活性也更高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple VertexFragment Shader&quot; &#123;</span><br><span class="line">    SubShader &#123;  </span><br><span class="line">        //Pass语义块里面</span><br><span class="line">        Pass &#123;            </span><br><span class="line">        CGPROGRAM            </span><br><span class="line">        #pragma vertex vert            </span><br><span class="line">        #pragma fragment frag            </span><br><span class="line">         float4 vert(float4 v : POSITION) :SV_POSITION &#123;                return mul (UNITY_MATRIX_MVP, v);            </span><br><span class="line">            &#125;            </span><br><span class="line">            fixed4 frag() : SV_Target &#123;                </span><br><span class="line">                return fixed4(1.0, 0.0, 0.0, 1.0);            </span><br><span class="line">            &#125;            </span><br><span class="line">            ENDCG        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="被抛弃：固定函数着色器"><a href="#被抛弃：固定函数着色器" class="headerlink" title="被抛弃：固定函数着色器"></a>被抛弃：固定函数着色器</h3><ul><li>上面两种unity shader都用了可编程管线。</li><li>这个不可编程，效果简单，用在旧设备</li></ul><h3 id="Unity-Shader形式的选择"><a href="#Unity-Shader形式的选择" class="headerlink" title="Unity Shader形式的选择"></a>Unity Shader形式的选择</h3><ul><li>和各种光源打交道：表面着色器；移动平台性能可能欠佳</li><li>光照数目非常少，顶点/片元着色器</li></ul><h1 id="第4章-数学基础"><a href="#第4章-数学基础" class="headerlink" title="第4章 数学基础"></a>第4章 数学基础</h1><h2 id="矩阵的几何意义：变换"><a href="#矩阵的几何意义：变换" class="headerlink" title="矩阵的几何意义：变换"></a>矩阵的几何意义：变换</h2><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>把一些数据，如点、方向矢量甚至是颜色等，通过某种方式进行转换的过程</p><h3 id="线性变换：矢量加-标量乘"><a href="#线性变换：矢量加-标量乘" class="headerlink" title="线性变换：矢量加 / 标量乘"></a>线性变换：矢量加 / 标量乘</h3><p><strong>缩放、旋转</strong>、错切、镜像、正交投影等</p><h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><ul><li>非线性变换</li></ul><h3 id="仿射变换——齐次坐标空间"><a href="#仿射变换——齐次坐标空间" class="headerlink" title="仿射变换——齐次坐标空间"></a>仿射变换——齐次坐标空间</h3><ul><li>合并线性变换和平移变换的变换类型</li><li>可以用一个4×4矩阵来表示——需要把矢量扩展到四维空间上，这就是<strong>齐次坐标空间</strong></li></ul><h3 id="常见变换种类及矩阵"><a href="#常见变换种类及矩阵" class="headerlink" title="常见变换种类及矩阵"></a>常见变换种类及矩阵</h3><table><thead><tr><th align="center">变换名称</th><th align="center">线性变换？</th><th align="center">仿射变换？</th><th align="center">可逆矩阵？</th><th align="center">正交矩阵？</th></tr></thead><tbody><tr><td align="center">平移矩阵</td><td align="center">N</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">绕坐标轴旋转的旋转矩阵</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">绕任意轴旋转的旋转矩阵</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">按坐标轴缩放的缩放矩阵</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">错切矩阵</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td></tr><tr><td align="center">镜像矩阵</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td><td align="center">Y</td></tr><tr><td align="center">正交投影矩阵</td><td align="center">Y</td><td align="center">Y</td><td align="center">N</td><td align="center">N</td></tr><tr><td align="center">透视投影矩阵</td><td align="center">N</td><td align="center">N</td><td align="center">N</td><td align="center">N</td></tr></tbody></table><h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><ul><li>4×4矩阵可以表示平移，所以将3×3扩展到4×4（四维矢量</li><li>转换过程：将其w分量设为1（如果是方向矢量，将其设为0）</li><li>这样转换的结果是：当4×4矩阵对一个点进行变换时，平移、旋转、缩放都会施加于该点；若是变换一个方向矢量的话，平移的效果就会被忽略。</li></ul><h2 id="分解基础变换矩阵"><a href="#分解基础变换矩阵" class="headerlink" title="分解基础变换矩阵"></a>分解基础变换矩阵</h2><ul><li><p><strong>基础变换矩阵</strong>：纯平移、纯旋转、纯缩放的变换矩阵</p></li><li><p>共同特点：</p><p><img src="https://pic.jitudisk.com/public/2022/06/29/ba7742d8009ef.png" alt="image-20220629191518926"></p></li></ul><h3 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h3><ul><li><p>使用矩阵乘法来表示对一个点进行平移变换：</p><p><img src="https://pic.jitudisk.com/public/2022/06/29/423d0ad4e0b0e.png" alt="image-20220629191614399"></p><ul><li><p>如果对一个方向矢量变换：</p><p><img src="https://pic.jitudisk.com/public/2022/06/29/05d98f05cbcf1.png" alt="image-20220629191710238"></p><blockquote><p>平移变换对方向矢量没有任何影响。矢量没有位置属性，可以在任何一点</p></blockquote></li><li><p>平移矩阵的逆矩阵：反向平移</p><p><img src="https://pic.jitudisk.com/public/2022/06/29/2e9aae0d2b481.png" alt="image-20220629191840641"></p></li></ul></li></ul><h3 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h3><ul><li><p>沿空间x/y/z进行缩放</p><p><img src="https://pic.jitudisk.com/public/2022/06/29/52828875a3e72.png" alt="image-20220629192302319"></p></li><li><p>对于方向矢量</p><p><img src="https://pic.jitudisk.com/public/2022/06/29/519c35ffd1954.png" alt="image-20220629192329883"></p></li><li><p>缩放矩阵的逆矩阵</p><p><img src="https://pic.jitudisk.com/public/2022/06/29/9577ade991ffc.png" alt="image-20220629192403028"></p></li><li><p>在任意方向上进行缩放：复合变换。其中一个重要思想是将缩放轴变换成标准坐标轴，然后进行沿坐标轴的缩放，<u>再使用逆变换得到原来的缩放轴朝向</u>（？逐渐脱离控制）。</p></li></ul><h3 id="旋转矩阵（绕空间坐标轴"><a href="#旋转矩阵（绕空间坐标轴" class="headerlink" title="旋转矩阵（绕空间坐标轴"></a>旋转矩阵（绕空间坐标轴</h3><ul><li>绕X轴旋转θ度</li></ul><p><img src="https://pic.jitudisk.com/public/2022/06/29/0f3d1e1db0b0f.JPG" alt="IMG_0242"></p><ul><li>绕Y轴旋转θ度</li></ul><p><img src="https://pic.jitudisk.com/public/2022/06/29/ccd73fa6809c0.JPG" alt="IMG_0243"></p><ul><li>绕Z轴旋转θ度</li></ul><p><img src="https://pic.jitudisk.com/public/2022/06/29/0167dd7b2dd2a.JPG" alt="IMG_0244"></p><ul><li>旋转矩阵的逆矩阵：旋转相反角度得到的变换矩阵。旋转矩阵是正交矩阵，且多个旋转矩阵之间的串联同样是正交的。</li></ul><h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><ul><li>由于使用的是列矩阵，阅读顺序从右往左（？</li><li>绝大多数情况下，约定变换的顺序就是先缩放，再旋转，最后平移</li></ul><p><img src="https://pic.jitudisk.com/public/2022/06/29/c1aa9f08f8af1.JPG" alt="IMG_0245"></p><p><img src="https://pic.jitudisk.com/public/2022/06/29/fbd887a63e638.JPG" alt="IMG_0246"></p><p><img src="https://pic.jitudisk.com/public/2022/06/29/14aa3946cfc65.JPG" alt="IMG_0247"></p><ul><li>世界坐标下（坐标轴不变），Unity中旋转顺序是zxy</li></ul><p><img src="https://pic.jitudisk.com/public/2022/06/29/c843828f47d5f.JPG" alt="IMG_0248"></p><h2 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h2><ul><li>关注如何使用以上这些基本变换来对坐标空间进行变换</li><li>一些概念只有在特定的坐标空间下才有意义</li></ul><h3 id="坐标空间的变换"><a href="#坐标空间的变换" class="headerlink" title="坐标空间的变换"></a>坐标空间的变换</h3><ul><li><p>例子：需求——点/矢量在父子空间之间互换</p><p><img src="https://pic.jitudisk.com/public/2022/07/05/d1b2d09b35430.png" alt="image-20220629202408397"></p></li><li><p>过程：坐标空间原点，沿x移动a个单位，沿y轴移动b个单位，沿z轴移动c个单位</p><p><img src="https://pic.jitudisk.com/public/2022/07/05/70243e098437d.png" alt="image-20220629202654052"></p></li><li><p>结果分析</p><p><img src="https://pic.jitudisk.com/public/2022/07/05/cc8a250f07cb5.png" alt="image-20220629202855142"></p><blockquote><p>到最后式子还存在加法表达式，即平移变换。为了得到更漂亮的结果，把式子扩展到齐次坐标空间中</p></blockquote></li></ul><p><img src="https://pic.jitudisk.com/public/2022/07/05/4af7ca20407de.png" alt="image-20220629202807457"></p><blockquote><p>具体是怎么算的已经看晕，有缘再解</p><ul><li>两种空间转换可通过求逆矩阵得</li><li><strong>变换矩阵</strong>：3个坐标轴依次放入矩阵的前3列，把原点矢量放到最后一列，再用0和1填充最后一行</li></ul></blockquote><ul><li><p>反向推导子空间的原点和坐标轴方向（待机中……</p></li><li><p>对方向矢量的坐标空间变换</p><ul><li>平移坐标系的原点是不会对矢量造成影响的（与位置无关。那么对矢量的坐标空间变换就可以用3×3的矩阵来表示，因为不需要平移变换。</li></ul><blockquote><p>在Shader中，常常看到截取变换矩阵的前3行3列来对法线方向、光照方向来进行空间变换，这就是原因所在</p></blockquote></li><li><p>如果变换矩阵是正交矩阵，则逆矩阵直接等于其转置矩阵。</p></li></ul><h3 id="顶点的坐标空间变换过程"><a href="#顶点的坐标空间变换过程" class="headerlink" title="顶点的坐标空间变换过程"></a>顶点的坐标空间变换过程</h3><h4 id="模型空间（model-object-local-space"><a href="#模型空间（model-object-local-space" class="headerlink" title="模型空间（model/object/local space)"></a>模型空间（model/object/local space)</h4><ul><li>自然方向：前后左右上下</li><li>Unity在模型空间中使用的是左手坐标系，+x轴、+y轴、+z轴分别对应模型的右、上和前</li><li>模型空间的原点和坐标轴通常是由美术人员制定好的</li><li>可以在<u>顶点着色器</u>访问到模型的顶点信息，这些坐标都是相对于<u>模型空间</u>中的原点定义的</li></ul><h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><ul><li>最外层的坐标空间</li><li>同样使用了左手坐标系</li></ul><h4 id="第一步：模型空间——-gt-世界空间【模型变换】"><a href="#第一步：模型空间——-gt-世界空间【模型变换】" class="headerlink" title="第一步：模型空间——&gt;世界空间【模型变换】"></a>第一步：模型空间——&gt;世界空间【模型变换】</h4><p><img src="https://pic.jitudisk.com/public/2022/07/05/787b53086b5ec.png" alt="image-20220630151833057"></p><h4 id="第二步：世界空间——-gt-观察空间【观察变换】"><a href="#第二步：世界空间——-gt-观察空间【观察变换】" class="headerlink" title="第二步：世界空间——&gt;观察空间【观察变换】"></a>第二步：世界空间——&gt;观察空间【观察变换】</h4><ul><li>观察空间：<ul><li>在此空间中，摄像机位于原点</li><li>Unity中观察空间的坐标轴：+x指向右方，+y指向上方，+z指向<strong>后方</strong>（右手坐标系，符合OpenGL传统）</li></ul></li><li>方法①【父子空间】：子——&gt;父的变换矩阵，再求逆</li><li>方法②【空间变换】：观察空间和顶点同时进行同样的变换而保持相对位置不变，这样的话保证拍出来的东西是一样的。为什么要把摄像机弄到原点呢？因为摄像机可能的位置角度非常多，而放在原点像坐标轴那样规范放好，有利于简化计算。摄像机放回原点的变换矩阵不好求，那就逆向来想。这样求得的矩阵变回逆矩阵就好。</li></ul><blockquote><p>注意区分同一空间的顶点变换 和 顶点坐标空间的变换。就所学到的而言，顶点变换就是旋转缩放平移，而后者则需要子空间的原点和坐标轴信息。</p></blockquote><h4 id="第三步：观察空间——-gt-（齐次）裁剪空间"><a href="#第三步：观察空间——-gt-（齐次）裁剪空间" class="headerlink" title="第三步：观察空间——&gt;（齐次）裁剪空间"></a>第三步：观察空间——&gt;（齐次）裁剪空间</h4><ul><li><p><u>用于变换的矩阵</u>叫做裁剪矩阵，也称为投影矩阵</p></li><li><p>目标：能够方便地对渲染图元进行裁剪</p></li><li><p>空间：视锥体，六个平面包围而成，平面也被称为裁剪平面。</p><ul><li>正交投影</li><li>透视投影</li></ul></li><li><p>如果直接使用视锥体定义的空间来进行裁剪，不同的视锥体就要有不同的处理过程。用一种更加通用、方便和简洁的方式来进行裁剪工作——通过一个投影矩阵把顶点转换到一个<strong>裁剪空间</strong>中。</p></li><li><p>投影矩阵的目的：为投影做准备；对x、y、z分量进行缩放。</p></li></ul><blockquote><p>透视投影(详细看书，还需斟酌)</p></blockquote><ul><li>**构成投影矩阵M(frustum)**：建立在Unity坐标系上。根据已知的Near（近裁剪平面）、Far、FOV（视觉上下角度）和Aspect（摄像机的纵横比：由Game视图的纵横比和ViewPort Rect中的W和H属性共同决定）的值来确定</li><li>顶点和投影矩阵相乘，从<strong>观察空间转换到裁剪空间</strong>：P(clip) = M(frustum) P(view)<ul><li>矩阵本质就是对x、y、z分量进行了不同程度的缩放，缩放的目的是为了方便裁剪。而w分量不再是1，而是原先z分量的取反结果</li></ul></li><li><strong>判断</strong>顶点是否位于视锥体内：如果在，变换后的坐标必须满足-w≤x/y/z≤w.</li></ul><blockquote><p>正交投影</p></blockquote><ul><li>确定裁剪矩阵：根据Near、Far、Size和Aspect</li><li>P(clip) = M(otho) P(view)</li><li>变换后w分量仍为1</li><li>判断如上</li></ul><h4 id="第四步：裁剪空间——-gt-屏幕空间"><a href="#第四步：裁剪空间——-gt-屏幕空间" class="headerlink" title="第四步：裁剪空间——&gt;屏幕空间"></a>第四步：裁剪空间——&gt;屏幕空间</h4><ul><li>完成了所有的裁剪工作后，进行真正的投影。</li></ul><blockquote><p>①标准齐次除法（透视除法）</p></blockquote><ul><li>用齐次坐标系的w分量去除x、y、z分量。在这OpenGL中，把这一步得到的坐标叫做<strong>归一化的设备坐标(Normalized Device Coordinates, NDC)</strong>. 变换到一个立方体内</li></ul><blockquote><p>②根据变换后的x和y坐标来映射输出窗口的对应像素坐标</p></blockquote><ul><li>在Unity中，屏幕空间左下角的像素坐标是（0，0）.由于当前x和y坐标都是[-1,1]，所以这个映射的过程就是一个缩放的过程。</li></ul><blockquote><p>齐次除法和屏幕映射的过程可以用一个公式来总结</p></blockquote><ul><li>关于z分量：通常z分量会被用于深度缓冲。，，，</li><li>顶点着色器：在Unity中，裁剪空间到屏幕空间的转换是底层帮助完成的。顶点着色器只需要把顶点转换到裁剪空间即可。</li></ul><h4 id="补充【games101】"><a href="#补充【games101】" class="headerlink" title="补充【games101】"></a>补充【games101】</h4><p>这个思路是直接从观察空间压缩到<strong>归一化的齐次</strong>裁剪空间。而精要是先把观察空间转换到裁剪空间中，然后再通过w分量除x、y、z分量来归一化。所以变换矩阵会有所区别？</p><ul><li>正交投影</li></ul><p><img src="https://pic.jitudisk.com/public/2022/07/05/33b561a6b67dd.png" alt="image-20220703092233636"></p><blockquote><p>先平移，后缩放</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/6feb671426107.png" alt="image-20220703092548255"></p><ul><li>透视投影</li></ul><p><img src="https://pic.jitudisk.com/public/2022/07/05/d8c309ec0b56c.png" alt="image-20220703093014365"></p><blockquote><p>远裁剪平面按照规则缩放成右图。</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/59046d7783ab6.png" alt="image-20220703093303961"></p><blockquote><p>先从侧面看，找到变换前后的关系。【注意，这里的分母用了z。如果对于近远平面都适用的话，z可以等于n，也可以等于f。】</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/6b1e483b977a2.png" alt="image-20220703093823668"></p><blockquote><p>从顶视图来看，再找到x的关系；</p><p>下面：（x,y,z,1）T变换成右侧样式，然后再乘以z，点不变。</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/e5147459cac46.png" alt="image-20220703094052599"></p><blockquote><p>上：透视投影变换成正交投影的结果。变换矩阵M 坐标点 = 远坐标点。</p><p>下：推导出变换矩阵。还剩余一行需要被填补</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/5bd00b03d64c4.png" alt="image-20220703094418291"></p><blockquote><p>可利用信息：近/远裁剪平面的z都不变</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/5bb48f0451857.png" alt="image-20220703094827259"></p><blockquote><p>【如果近远通用的前提成立】那么近平面的条件可以使用：z=n时，变化前后都相等，但是都乘以n后，保持不变的同时格式也相符。</p><p>下：变换矩阵第三行肯定与x，y无关，所以头两个先确定为0</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/2c282bbb59eda.png" alt="image-20220703100254697"></p><blockquote><p>上：从近平面来说</p><p>下：从远平面来说，中心点不变，得出来一个等式</p></blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/eda9864f60191.png" alt="image-20220703100647123"></p><blockquote><p>完成变换矩阵的补充。</p></blockquote><h3 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h3><ul><li><p>在游戏中，模型的一个顶点往往会携带额外的信息，而顶点法线就是其中一种</p></li><li><p>变换一个模型的时候，不仅要变换顶点，<strong>还要变换法线</strong>，以便在后续处理（如片元着色器）中计算光照等</p></li><li><p><strong>切线</strong>是由两个顶点之间的差值计算得到的，因此可以直接使用用于变换顶点的变换矩阵来变换切线。</p></li><li><p>进行非统一缩放时，如果使用<u>变换顶点的变换矩阵</u>来变换法线，会得到<strong>错误结果</strong></p></li><li><p>经推导，应用原变换矩阵的逆矩阵。避免计算逆矩阵的情况如下：</p><blockquote><p>原变换矩阵是正交矩阵，只需转置；</p><p>只包括旋转——变换矩阵是正交矩阵；</p><p>只包括旋转和统一缩放——系数k；</p><p>而包含了统一变换则必须求解逆矩阵。</p></blockquote></li></ul><h1 id="第5章-开始Shader代码编写"><a href="#第5章-开始Shader代码编写" class="headerlink" title="第5章 开始Shader代码编写"></a>第5章 开始Shader代码编写</h1><h2 id="一个最简单的顶点-片元着色器"><a href="#一个最简单的顶点-片元着色器" class="headerlink" title="一个最简单的顶点/片元着色器"></a>一个最简单的顶点/片元着色器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter5/SimpleShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM   //---CG代码片段</span><br><span class="line"></span><br><span class="line">            /*编译指令*/</span><br><span class="line">            //告诉Unity，第一个自定义函数vert包含了顶点着色器代码</span><br><span class="line">            //第二个自定义函数frag包含了片元着色器代码</span><br><span class="line">            #pragma vertex vert     </span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            /*顶点着色器*/</span><br><span class="line">            //逐顶点执行</span><br><span class="line">            //语法：类型 函数名（输入参数）：语义 //主要是限制返回类型的含义</span><br><span class="line">            //例：vert函数返回裁剪空间（SV_POSITION）中的float4类型坐标</span><br><span class="line">            //    其中输入参数v被限制为模型的顶点坐标</span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITION &#123;</span><br><span class="line">                return UnityObjectToClipPos (v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag() : SV_TARGET&#123;</span><br><span class="line">                return fixed4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG       //---CG代码片段</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Unity升级到5.6及以后，所有跟UNITY_MATRIX_MVP运算的<a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">矩阵</a>或者向量的mul方法，会被自动转成UnityObjectToClipPos方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4×4 m = mul(UNTIY_MATRIX_MVP, RM);</span><br><span class="line"></span><br><span class="line">float4×4 m = UnityObjectToClipPos(RM);</span><br></pre></td></tr></table></figure><p>In the past, we uses <code>mul(UNITY_MATRIX_MVP, v.vertex)</code> to convert vertex position from local to world space. <em>v.vertex</em> is <em>float4</em> which has w component.</p><p>But in most cases w is = 1. To make vertex shader run faster, Unity replaced it with <code>UnityObjectToClipPos(float3 pos)</code>, which ignores w component even you pass a <em>float4</em> position instead of <em>float3</em>.</p><p>For some advanced users who still need the w component in their custom shaders, here is a cheaper <strong>UnityObjectToClipPos()</strong> function which respects the w component!</p></blockquote><h3 id="获取更多的模型数据"><a href="#获取更多的模型数据" class="headerlink" title="获取更多的模型数据"></a>获取更多的模型数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    CGPROGRAM   //---CG代码片段</span><br><span class="line"></span><br><span class="line">    #pragma vertex vert     </span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    struct a2v&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;     //模型空间的法线</span><br><span class="line">    float4 texcoord : TEXCOORD; //模型的第一套纹理坐标填充texcoord变量</span><br><span class="line">    &#125;;                          //不要漏了分号</span><br><span class="line"></span><br><span class="line">    float4 vert(a2v v) : SV_POSITION &#123;</span><br><span class="line">    return UnityObjectToClipPos (v.vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag() : SV_TARGET&#123;</span><br><span class="line">    return fixed4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG       //---CG代码片段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>获取模型更多的信息：结构体。结构体必须包含语义；</p><p>a2v命名含义：把数据从应用阶段传递到顶点着色器；</p><p>语义中的数据来源：Unity中该材质的Mesh Render组件提供。每帧调用Draw Call时，会把它负责渲染的模型数据发送给Unity Shader。</p></blockquote><h3 id="顶点着色器和片元着色器之间如何通信"><a href="#顶点着色器和片元着色器之间如何通信" class="headerlink" title="顶点着色器和片元着色器之间如何通信"></a>顶点着色器和片元着色器之间如何通信</h3><p>​    在实践中往往希望从顶点着色器输出一些数据，例如把模型的法线、纹理坐标等递给片元着色器。顶点着色器是逐顶点用的，片元着色器是逐片元用的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    CGPROGRAM  </span><br><span class="line"></span><br><span class="line">    #pragma vertex vert     </span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    struct a2v&#123;</span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float3 normal : NORMAL;     </span><br><span class="line">        float4 texcoord : TEXCOORD; </span><br><span class="line">    &#125;;       </span><br><span class="line"></span><br><span class="line">    /*顶点着色器的输出*/</span><br><span class="line">    struct v2f&#123;</span><br><span class="line">        float4 pos : SV_POSITION;</span><br><span class="line">        fixed3 color : COLOR0;      //COLOR0可以用于存储颜色信息</span><br><span class="line">    &#125;;                       </span><br><span class="line"></span><br><span class="line">    v2f vert(a2v v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.color = v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">    return fixed4(i.color, 1.0);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何使用属性"><a href="#如何使用属性" class="headerlink" title="如何使用属性"></a>如何使用属性</h3><p>Properties语义块以及参数使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (1.0, 1.0, 1.0, 1.0)  //没有分号</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM  </span><br><span class="line"></span><br><span class="line">            #pragma vertex vert     </span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;      //需要在Cg代码中定义一个与属性名称和类型都匹配的变量</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;     </span><br><span class="line">                float4 texcoord : TEXCOORD; </span><br><span class="line">            &#125;;       </span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR0;     </span><br><span class="line">            &#125;;                       </span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.color = v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                fixed3 c = i.color;</span><br><span class="line">                c *= _Color.rgb;    //使用属性来控制颜色</span><br><span class="line">                return fixed4(c, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Unity-提供的内置文件和变量"><a href="#Unity-提供的内置文件和变量" class="headerlink" title="Unity 提供的内置文件和变量"></a>Unity 提供的内置文件和变量</h2><p>为了方便开发者的编码过程，Unity提供了很多内置文件，包含了很多提前定义的函数、变量和宏。</p><ul><li>一些常用包含文件以及定义的结构体、函数等。</li></ul><h1 id="第6章-Unity中的基础光照"><a href="#第6章-Unity中的基础光照" class="headerlink" title="第6章 Unity中的基础光照"></a>第6章 Unity中的基础光照</h1><h2 id="我们是如何看到这个世界的"><a href="#我们是如何看到这个世界的" class="headerlink" title="我们是如何看到这个世界的"></a>我们是如何看到这个世界的</h2><ul><li>光源</li><li>光线和场景中的一些物体相交：一些光线被物体吸收了，另一些被散射到其它方向</li><li>摄像机吸收了一些光，产生了一张图像</li></ul><h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><ul><li><strong>方向</strong>：通常把光源当作一个没有体积的点，用**/**来表示它的方向。</li><li><strong>辐照度</strong>：量化光。对于平行光来说，可通过计算 垂直于/的单位面积上 单位时间内 穿过的能量来得到。在计算光照模型时需要知道一个物体表面的辐射度。</li></ul><h3 id="吸收和散射"><a href="#吸收和散射" class="headerlink" title="吸收和散射"></a>吸收和散射</h3><p>光线从光源发射出来后，就会与一些物体相交。通常相交的结果有两个：散射（scattering）和吸收（absorption）。</p><table><thead><tr><th align="center"></th><th align="center">改变光线的密度和颜色</th><th align="center">改变光线的方向</th></tr></thead><tbody><tr><td align="center">散射</td><td align="center">N</td><td align="center">Y</td></tr><tr><td align="center">吸收</td><td align="center">Y</td><td align="center">N</td></tr></tbody></table><blockquote><p>散射</p></blockquote><ul><li>散射到<strong>物体内部</strong>，这种现象被称为折射或透射。</li></ul><p><img src="https://pic.jitudisk.com/public/2022/07/05/727ed048952d1.png" alt="image-20220703154358052"></p><blockquote><p>对于不透明物体，折射的光线会在物体内部继续传播，最终有一部分光线会重新从物体表面被发射出去</p></blockquote><ul><li><p>散射到<strong>外部</strong>——反射。</p></li><li><p>为了区分两种不同的散射方向，在光照模型中使用了不同的部分来计算它们</p></li></ul><table><thead><tr><th align="center"></th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">高光反射</td><td align="center">表示物体是如何反射光线的</td></tr><tr><td align="center">漫反射</td><td align="center">表示有多少光线会被折射、吸收和散射出表面</td></tr></tbody></table><ul><li><strong>出射度</strong>：出射光线的数量和方向；辐射度和出射度之间满足线性关系，比值就是材质的漫反射和高光反射属性（本章假定漫反射没有方向性，光线在所有方向上都是平均分布的）</li></ul><h3 id="着色（shading）"><a href="#着色（shading）" class="headerlink" title="着色（shading）"></a>着色（shading）</h3><table><thead><tr><th align="center">条件1</th><th align="center">条件2</th><th align="center">结果</th><th></th></tr></thead><tbody><tr><td align="center">光源信息（如光源方向、辐照度）</td><td align="center">材质属性（如漫反射属性等）</td><td align="center">沿某个观察方向的出射度（一个等式计算）</td><td>这个等式被称为<strong>光照模型</strong></td></tr></tbody></table><h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p>①只关心直接光照：直接从光源发射出来照射到物体表面后，经过物体表面的<strong>一次反射</strong>直接进入摄像机的光线；无法表现很多重要的物理现象（菲涅尔/各向异性的表面如毛发等）。</p><p>②基本方法——把进入到摄像机内的光线分成4个部分，每个部分用一种方法来计算它的贡献度：</p><p>​    自发光（emissive）：一个表面本身，向给定的方向<u>发射</u>多少辐射量。</p><p>​    高光反射（specular）：在<strong>完全镜面反射方向</strong><u>散射</u>多少辐射量。</p><p>​    漫反射（diffuse）：模型表面向<strong>每个方向</strong><u>散射</u>多少辐射量。</p><p>​    环境光（ambient）：其它所有的间接光照。</p><blockquote><p>体现了多种情况下，光源信息和材质属性共同作用下得出不同的出射度。</p></blockquote><table><thead><tr><th></th><th>描述</th><th>公式</th></tr></thead><tbody><tr><td>环境光</td><td>近似模拟间接光照（全局变量）</td><td><img src="https://pic.jitudisk.com/public/2022/07/05/2e12deaf0ecab.JPG" alt="IMG_0255"></td></tr><tr><td>自发光</td><td>不经过物体反射的光源（？</td><td><img src="https://pic.jitudisk.com/public/2022/07/05/be1f4e23df8b5.JPG" alt="IMG_0257"></td></tr><tr><td>漫反射</td><td>视角位置不重要，入射光线角度很重要；兰伯特定律①</td><td><img src="https://pic.jitudisk.com/public/2022/07/05/7b74d4490f615.JPG" alt="IMG_0258">②</td></tr><tr><td>高光反射</td><td>沿着完全镜面反射方向被反射的光线</td><td><img src="https://pic.jitudisk.com/public/2022/07/05/0ba4f260dfc25.JPG" alt="IMG_0260(20220703-164839)"><img src="https://pic.jitudisk.com/public/2022/07/05/b06af7ceb1579.JPG" alt="IMG_0259">③</td></tr></tbody></table><blockquote><p>①反射光线的强度与 表面法线和光源方向之间夹角的余弦值 成正比（夹角越小cosθ越大，反射越强）</p><p>②兰伯特公式符号：<strong>n</strong>是表面法线，l是指向光源的单位向量，<strong>m</strong>（diffuse）是材质的漫反射颜色，<strong>c</strong>（light）是光源颜色。要防止法线和光源方向点乘的结果是负值。【与法线、光线有关】</p><p>③高光反射还和观察视角有关。其中反射方向<strong>r</strong>可由法线方向<strong>n</strong>、光线方向<strong>l</strong>求出；</p><ul><li><p>Phong模型：如表格所示公式。与漫反射比较，主要区别是<strong>观察＆反射</strong>方向，漫反射因为和观察角度无关，注重光线和法线（？。其他的，<strong>m</strong>（gloss）是材质的光泽度（gloss），也称为反光度（shininess），用于控制高光区域的”亮点“有多宽，值越大，亮点越小。<strong>m</strong>（specular）是材质的高光反射颜色。</p><p><img src="https://pic.jitudisk.com/public/2022/07/05/8d3b94eac7eeb.JPG" alt="IMG_0263"></p></li><li><p>Blinn模型：相比于Phong提出一个简单的修改方法来得到类似的效果。基本思想：避免计算反射方向<strong>r</strong>。因此引用了一个新的矢量<strong>h</strong>。</p><p><img src="https://pic.jitudisk.com/public/2022/07/05/4343d9404308b.JPG" alt="IMG_0261"></p><p><strong>h</strong>由<strong>v</strong>和<strong>l</strong>取平均后再归一化得到的。</p><p><img src="https://pic.jitudisk.com/public/2022/07/05/8702f4c0be8d0.JPG" alt="IMG_0262"></p><p>然后再用<strong>n</strong>和<strong>h</strong>的夹角进行计算。</p><p><img src="https://pic.jitudisk.com/public/2022/07/05/4937a0d403a89.JPG" alt="IMG_0264(20220703-170923)"></p></li></ul></blockquote><p>【夹角——向量点乘cos——反映光照强度】那颜色点乘……？</p><h3 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h3><ul><li><p><strong>逐像素光照</strong>（per-pixel lighting）：在<strong>片元着色器</strong>中计算基本光照模型的数学公式。</p><p>以每个像素为基础，得到它的<strong>法线</strong>（对顶点法线插值得到 || 从法线纹理中采样得到），然后进行光照模型的计算。这种<u>在面片之间对顶点法线进行插值的技术被称为Phong着色</u>（Phong Shading）。这不同于Phong光照模型。</p></li><li><p><strong>逐顶点光照</strong>（per-vertex lighting）：在顶点着色器。</p><p>在每个顶点中计算光照，然后会在渲染图元内部进行线性插值，最后输出像素颜色。</p></li><li><p>由于顶点数目往往远远小于像素数目，因此逐顶点光照<strong>计算量</strong>往往远远小于像素光照；</p><p>顶点依赖于【线性插值？】</p></li></ul><h2 id="在Unity-Shader中实现漫反射光照模型"><a href="#在Unity-Shader中实现漫反射光照模型" class="headerlink" title="在Unity Shader中实现漫反射光照模型"></a>在Unity Shader中实现漫反射光照模型</h2><h3 id="逐顶点光照"><a href="#逐顶点光照" class="headerlink" title="逐顶点光照"></a>逐顶点光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_World2Object&#x27; with &#x27;unity_WorldToObject&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Chapter6/DiffuseVertexLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            //LightMode标签是Pass标签的一种</span><br><span class="line">            //用于定义该Pass在Unity的光照流水线中的角色</span><br><span class="line">            //只有正确定义了正确的LightMode，才能得到一些Unity的内置光照变量</span><br><span class="line">            //Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                /*漫反射光照*/</span><br><span class="line">                //法线和光源处在同一坐标空间下点积才有意义</span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                //_WorldSpaceLightPos0只适用于平行光</span><br><span class="line">                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));  //saturate：把参数截取在[0,1]内</span><br><span class="line">                o.color = diffuse + ambient;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                return fixed4(i.color, 1.0);</span><br><span class="line">                //return fixed4(0.5,0.5,0.5,1);   //sucess</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题：Tags { “LightMode” = “ForwardBase” }这句话好像导致基本的颜色都输出不了。去掉之后，ambient和diffuse也没起效果。这是为什么呢？？？经测验是项目的问题，不知道动了哪里就生成很多警告，可能和警告有关。再进一步，可能和渲染管线有关，没有URP的话是正常的，有了URP即使新建了项目没有警告效果还是紫色没有生效……</p></blockquote><p>而对于细分程度较低的模型，可能会出现锯齿。（因为顶点较疏？</p><h3 id="逐像素光照"><a href="#逐像素光照" class="headerlink" title="逐像素光照"></a>逐像素光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_World2Object&#x27; with &#x27;unity_WorldToObject&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Chapter6/DiffusePixelLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Name &quot;FORWARD&quot;</span><br><span class="line">            //LightMode标签是Pass标签的一种</span><br><span class="line">            //用于定义该Pass在Unity的光照流水线中的角色</span><br><span class="line">            //只有正确定义了正确的LightMode，才能得到一些Unity的内置光照变量</span><br><span class="line">            Tags &#123; </span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //只需把法线传给片元着色器</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                float lambert = saturate(dot(worldLightDir, worldNormal));</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">                return fixed4(color, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>获取顶点的法线，然后在片元着色器内进行处理，生成颜色。逐像素关照可以得到更加平滑的光照效果。</p></blockquote><h3 id="半兰伯特模型"><a href="#半兰伯特模型" class="headerlink" title="半兰伯特模型"></a>半兰伯特模型</h3><p>点积的值*0.5 + 0.5，思想是将值统一映射到[0,1]内，没有物理依据。</p><h2 id="实现高光反射光照模型"><a href="#实现高光反射光照模型" class="headerlink" title="实现高光反射光照模型"></a>实现高光反射光照模型</h2><h3 id="逐顶点光照-1"><a href="#逐顶点光照-1" class="headerlink" title="逐顶点光照"></a>逐顶点光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter6/SpecularVertexLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2f&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2f v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                /*漫反射部分*/</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                /*高光部分*/</span><br><span class="line">                //reflect(i,n):n为法线方向，i是入射，要求由光源指向交点处</span><br><span class="line">                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - UnityObjectToClipPos(v.vertex).xyz);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                o.color = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                return fixed4(i.color, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/f8c88a6609c2d.png" alt="image-20220705104418177"></p><p>高光部分明显不平滑。主要因为高光反射部分的计算是非线性的，而在顶点着色器中计算光照再插值的过程是线性的【具体在哪里体现？】，破坏了原计算的非线性关系，就会出现较大的视觉问题。</p></blockquote><h3 id="逐像素光照-1"><a href="#逐像素光照-1" class="headerlink" title="逐像素光照"></a>逐像素光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter6/SpecularPixelLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2f&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2f v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //世界空间下的法线方向和顶点坐标</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = o.pos.xyz;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/ea90e1c8995ee.png" alt="image-20220705105908989"></p><p>明显会更光滑些</p></blockquote><h3 id="Blinn-Phong-模型"><a href="#Blinn-Phong-模型" class="headerlink" title="Blinn-Phong 模型"></a>Blinn-Phong 模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);</span><br><span class="line">fixed3 halfDir = normalize(worldLightDir + viewDir);//</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss);</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://pic.jitudisk.com/public/2022/07/05/a6042a7c86767.png" alt="image-20220705110710127"></p><p>（右三）可以看出这个模型的高光更大更亮一些，是通常情况下的选择。这两种光照模型都是<strong>经验模型</strong>【对真实场景进行理想化和简化后的模型。并不能真实地反映物体和光线之间的交互】</p></blockquote><h2 id="使用Unity内置的函数"><a href="#使用Unity内置的函数" class="headerlink" title="使用Unity内置的函数"></a>使用Unity内置的函数</h2><p>麻烦之处：手动找变量并计算很麻烦；判断特殊光源如点光源等就很复杂。</p><ul><li>UnityCG.cgnic中一些常用的帮助函数。（实践当中其实只加了Lighting.cginc，但还是正常）</li></ul><table><thead><tr><th align="center">函数名</th><th align="center">输入</th><th align="center">返回</th></tr></thead><tbody><tr><td align="center">WorldSpaceViewDir()</td><td align="center">float4 v：一个模型空间中的顶点位置</td><td align="center">float3：世界空间中从该点到摄像机的观察方向</td></tr><tr><td align="center">UnityWorldSpaceViewDir()</td><td align="center">float4 v:一个世界空间中的顶点位置</td><td align="center">float3：世界空间中从该点到摄像机的观察方向</td></tr><tr><td align="center">ObjSpaceViewDir()</td><td align="center">float4 v:一个模型空间中的顶点位置</td><td align="center">float3：模型空间中从该点到摄像机的观察方向</td></tr><tr><td align="center">WorldSpaceLightDir()*</td><td align="center">float4 v：一个模型空间中的顶点位置</td><td align="center">float3：世界空间中从该点到光源的光照方向</td></tr><tr><td align="center">UnityWorldSpaceLightDir()*</td><td align="center">float4 v：一个世界空间中的顶点位置</td><td align="center">float3：世界空间中从该点到光源的光照方向</td></tr><tr><td align="center">ObjSpaceLightDir()*</td><td align="center">float4 v：一个模型空间中的顶点位置</td><td align="center">float3：模型空间中从该点到光源的光照方向</td></tr><tr><td align="center">UnityObjectToWorldNormal()</td><td align="center">float3 norm：模型空间的法线</td><td align="center">float3：转换到世界空间中</td></tr><tr><td align="center">UnityObjectToWorldDir()</td><td align="center">float3 dir：模型空间中的方向矢量</td><td align="center">float3：转换到世界空间中</td></tr><tr><td align="center">UnityWorldToObjectDir()</td><td align="center">float3 dir：世界空间中的方向矢量</td><td align="center">float3：转换到模型空间中</td></tr></tbody></table><p>*：仅可用于前向渲染中。</p><p>PS：这些函数得到的方向都是没有归一化的。</p><p>这些函数让我们不需要考虑光源情况。</p><h1 id="第7章-基础纹理"><a href="#第7章-基础纹理" class="headerlink" title="第7章 基础纹理"></a>第7章 基础纹理</h1><ul><li><strong>纹理映射技术</strong>：把一张图“黏”在模型表面，逐纹素地控制模型颜色。</li><li><strong>纹理映射坐标（uv坐标）</strong>：把模型顶点对应的2D坐标存储在每个顶点上。<ul><li>归一化：纹理大小多种多样，但顶点uv坐标的范围通常都是被归一化到【0，1】内。有时纹理采样时的纹理坐标不在这范围内，但是有时会非常有用。</li><li>纹理的平铺模式：决定渲染引擎在遇到不在【0，1】范围内的纹理坐标如何进行纹理采样。</li></ul></li><li>OpenGL和DirectX在二维纹理空间中的坐标系差异：OpenGL——原点在左下角；后者在左上角。Unity中使用的一般是OpenGL的（会处理这种差异问题）。</li></ul><h2 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a>单张纹理</h2><p>（a2f）texcoord : TEXCOORD0 ——&gt;①顶点着色器（纹理坐标变换—&gt;uv:TEXCOORD2）——&gt;②片元着色器（纹理采样——&gt;albedo）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct a2v&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    float2 uv : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//①</span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    ...</span><br><span class="line">    o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">    //o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">    //使用纹理坐标的属性值 来对 顶点纹理坐标 进行变换</span><br><span class="line">    //内置函数，是把纹理名字传进去找到对应的 _ST</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//②</span><br><span class="line">fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">    //纹理*固有色——材质的反射率albedo</span><br><span class="line">    //tex2D(_MainTex, i.uv):对纹理进行采样；</span><br><span class="line">    //第一个参数：需要被采样的纹理；第二个：纹理坐标，返回计算得到的纹素值</span><br><span class="line">    fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="纹理的属性"><a href="#纹理的属性" class="headerlink" title="纹理的属性"></a>纹理的属性</h3><h4 id="Texture-Type"><a href="#Texture-Type" class="headerlink" title="Texture Type"></a>Texture Type</h4><h4 id="Wrap-Mode"><a href="#Wrap-Mode" class="headerlink" title="Wrap Mode"></a>Wrap Mode</h4><p>决定了当纹理坐标超过【0，1】范围后将会如何被平铺。</p><ul><li>Repeat：如果纹理坐标超过了1，整数部分被舍弃，而直接使用小数部分来采样（取余重复）。</li><li>Clamp：纹理坐标大于1，那么将会截取到1，小于0则截取到0.</li></ul><h4 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a>Filter Mode</h4><p>当纹理由于变换而产生拉伸时将会采用哪种滤波方式。支持三种模式：Point，Bilinear，Trilinear。它们得到的图片滤波效果逐渐提升，但需要耗费的性能也依次增大。<strong>纹理滤波</strong>会影响放大或缩放纹理时得到的图片质量（马赛克糊度）。</p><ul><li>多级渐远纹理（mipmapping）</li></ul><p>将原纹理提前用滤波处理来得到更多更小的图像，形成了一个图像金字塔，每一层都是对上一层图像降采样的结果。这样在运行时可以快速得到结果像素，例如物体远离摄像机时可以直接使用较小的纹理。缺点是空间存储较大。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/60299f7bf30b6748.png" alt="image-20220705222204054"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/711f00732d7267ef.png" alt="image-20220705220943067"></p><h4 id="纹理的最大尺寸和纹理模式"><a href="#纹理的最大尺寸和纹理模式" class="headerlink" title="纹理的最大尺寸和纹理模式"></a>纹理的最大尺寸和纹理模式</h4><p>不同平台的纹理尺寸和质量不同。</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/b28daa560046705e.png" alt="image-20220705221219288"></p><ul><li><p>Max Size</p><p>如果导入的纹理大小超过了Max Size中的值，Unity会把这个图像压缩为最大分辨率。</p><p>理想情况下，导入的纹理可以是非正方形的，但长宽的大小最好是2的幂，如2，4，8等。如果用了非2的幂大小（Non Power of Two, NPOT)，这些纹理往往会占用更多的内存空间，而且GPU读取该纹理的速度也会有所下降。<u>出于性能和空间的考虑，应该尽量使用2的幂大小纹理。</u></p></li><li><p>Format</p><p>决定Unity内部使用哪种格式来存储该纹理。如果精度要求不高，尽量使用压缩格式。</p></li></ul><h2 id="凹凸映射-bump-mapping"><a href="#凹凸映射-bump-mapping" class="headerlink" title="凹凸映射 bump mapping"></a>凹凸映射 bump mapping</h2><p>使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。</p><h3 id="高度纹理-height-map"><a href="#高度纹理-height-map" class="headerlink" title="高度纹理 height map"></a>高度纹理 height map</h3><p>使用一张高度纹理来模拟表面位移（displacement），然后得到一个修改后的法线值。</p><p><strong>高度图</strong>：存储的是强度值（intensity），用于表示模型表面局部的海拔高度。缺点是计算更加复杂，在实时计算时不能直接得到表面法线，而是需要由<strong>像素的灰度值计算</strong>而得，因此需要消耗更多的性能。</p><p>高度图通常会和法线映射一起使用，用于给出表面凹凸的额外信息。</p><h3 id="法线纹理-normal-map"><a href="#法线纹理-normal-map" class="headerlink" title="法线纹理 normal map"></a>法线纹理 normal map</h3><p>存储的是表面的法线方向。</p><ul><li><strong>映射</strong>：法线方向的分量范围在[-1,1]，像素分量范围是[0,1]，因此需要做一个映射——pixel = （normal + 1）/ 2.</li><li><strong>反映射</strong>：在Shader中对法线纹理进行纹理采样后，还需要对结果进行一次反映射的过程来得到原先的法线方向。normal = pixel * 2 - 1</li><li><strong>坐标空间</strong></li></ul><table><thead><tr><th></th><th align="center">模型空间</th><th align="center">切线空间</th></tr></thead><tbody><tr><td>法线纹理特征</td><td align="center">五颜六色：同一空间下法线方向各异</td><td align="center">浅蓝色：每个点在各自切线空间中的法线扰动方向；若法线方向不变(0,0,1)-(0.5,0.5,1)</td></tr><tr><td>优点</td><td align="center">计算更少；纹理坐标的缝合处和尖锐的尖角部分可见的缝隙较少（？</td><td align="center">相对法线信息—不同模型/uv动画/可重用/可压缩（仅存储xy方向推导z）</td></tr></tbody></table><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/d7b1bd096f2bca3b.png" alt="image-20220706092200233"></p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/bc5ae8e6d0fb36e4.png" alt="image-20220706092217872"></p><h3 id="在切线空间下进行光照计算"><a href="#在切线空间下进行光照计算" class="headerlink" title="在切线空间下进行光照计算"></a>在切线空间下进行光照计算</h3><p>把光照方向、视觉方向变换到切线空间下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter7/NormalMapTangentSpace&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Colot Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0          //控制凹凸程度</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;       //float4 tangent.w分量决定切线空间中副切线的方向性</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float3 lightDir : TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                /*纹理坐标变换*/</span><br><span class="line">                //_MainTex 和 _BumpMap 通常使用同一组纹理坐标，减少插值寄存器的使用数目</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                /*空间转换*/</span><br><span class="line">                //法线空间下的副法线：叉积得来</span><br><span class="line">                float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;</span><br><span class="line">                float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br><span class="line"></span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                //获取切线空间下的观察/光源方向</span><br><span class="line">                fixed3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">                //法线纹理采样</span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal;</span><br><span class="line">                tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale; //？？</span><br><span class="line">                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));//？？</span><br><span class="line"></span><br><span class="line">                //贴图纹理采样</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                //光照</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir, tangentNormal));</span><br><span class="line">                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular * pow(saturate(dot(halfDir, tangentNormal)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>插值寄存器</strong>：这些被TEXCOORD0、TEXCOORD1、TEXCOORD2…等修饰的变量是会被存储在特定的寄存器里，然后这些数值会被<strong>插值</strong>后传递给fragment shader，因此简称为插值寄存器。除了Unity特定语义修饰的插值寄存器变量（比如SV_POSITION）等外，其他插值寄存器里存储的什么没有规定，可以是纹理坐标也可以是其他需要从vertex shader传递给fragment shader的值。</p><h3 id="在世界空间下进行光照计算"><a href="#在世界空间下进行光照计算" class="headerlink" title="在世界空间下进行光照计算"></a>在世界空间下进行光照计算</h3><p>把采样到的法线方向变换【需要在顶点着色器中求得变换矩阵】到世界空间下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter7/NormalMapWorldSpace&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Colot Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0          //控制凹凸程度</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;       //float4 tangent.w分量决定切线空间中副切线的方向性</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                //一个插值寄存器（TEXCOORDn是其中一种）最多存放float4大小的变量</span><br><span class="line">                //对于矩阵，可以按行拆分成多个变量</span><br><span class="line">                //依次存储了从切线空间到世界空间的变换矩阵的行</span><br><span class="line">                //对方向矢量的变换只需要3×3矩阵</span><br><span class="line">                //但为了充分利用存储空间，把世界空间下的顶点位置存在w分量中</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                /*纹理坐标变换*/</span><br><span class="line">                //_MainTex 和 _BumpMap 通常使用同一组纹理坐标，减少插值寄存器的使用数目</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                /*空间转换*/</span><br><span class="line">                //世界空间下的坐标分量</span><br><span class="line">                float3 worldPos = o.pos;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                //获取世界空间下的观察/光源方向</span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                //法线纹理采样</span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 bump = UnpackNormal(packedNormal);</span><br><span class="line">                bump.xy *= _BumpScale; //？？</span><br><span class="line">                bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy)));//？？</span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                //贴图纹理采样</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                //光照</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(lightDir, bump));</span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular * pow(saturate(dot(halfDir, bump)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">切线空间下</th><th align="center">世界空间下</th></tr></thead><tbody><tr><td align="center">效率</td><td align="center"><strong>√</strong> 在顶点着色器中就能完成变换</td><td align="center">由于要先对法线纹理进行采样，变换过程必须在frag</td></tr><tr><td align="center">通用性</td><td align="center"></td><td align="center"><strong>√</strong> 有时需要在世界空间下进行计算（如使用Cubemap进行环境映射）</td></tr></tbody></table><h3 id="Unity中的法线纹理类型"><a href="#Unity中的法线纹理类型" class="headerlink" title="Unity中的法线纹理类型"></a>Unity中的法线纹理类型</h3><p>把纹理类型设置成Normal map时到底发生了什么，为什么要这么做？</p><p>👉这么做可以让Unity根据不同平台对纹理进行压缩，再通过UnpackNormal函数来针对不同的压缩格式对法线纹理进行正确的采样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//UnityCG.cginc中UnpackNormal函数实现</span><br><span class="line"></span><br><span class="line">inline fixed3 UnpackNormal(fixed4 packedNormal)&#123;</span><br><span class="line">#if defined(UNITY_NO_DXT5nm)</span><br><span class="line">return packednormal.xyz * 2 - 1;</span><br><span class="line">#else</span><br><span class="line">return UnpackNormalDXT5nm(packedNormal);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可见某些平台由于用了DXT5nm格式，需要针对这种格式对法线进行解码。</p></blockquote><p>📍<strong>DXT5nm格式</strong>的法线纹理：</p><p>纹素的α通道对应法线的x分量，g通道—法线的y分量，纹理的r和b通道则会被舍弃，法线的z分量可以由xy分量推导而得。因为实际上法线只有两个通道时必不可少的，使用这种压缩方法能减少法线纹理占用的内存空间。</p><p>📍在高度图生成法线纹理</p><p>导入高度图——纹理类型：Normal map——勾选Create from Grayscale</p><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/6e97128dffc51abd.png" alt="image-20220706163533300"></p><p>-Bumpiness: 凹凸程度；Filtering：使用哪种方式来计算凹凸程度（smooth使得生成后的法线纹理比较平滑/ Sharp使用Sobel滤波来生成法线）</p><h2 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h2><p>🦁纹理其实可以用于存储任何表面属性。其中一种常见用法就是使用渐变纹理来控制漫反射光照效果【Lambert的值映射到纹理上】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/fd4674374f495ed3.png" alt="image-20220706172525205"></p><blockquote><p>左图在高光区域有一些黑点。这是由浮点精度造成的，当使用fixed2对渐变纹理进行采样时，理论上halfLambert的值在【0，1】之间，但可能会有1.00001这样的值出现。Repeat保留小数部分对应的是黑色，所以会有黑点。改成Clamp就能解决。</p></blockquote><h2 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h2><p>遮罩允许我们可以保护某些区域，使它们免于某些修改。</p><p>🎈例子1：模型的高光的反光某些区域亮一些，某些区域弱一些；</p><p>🎈例子2：制作地形材质要混合多张照片。</p><p>一般流程：通过采样得到遮罩纹理的纹素值，然后使用其中<strong>某个（某几个）通道的值来与某种表面属性进行相乘</strong>，这样，当该通道的值为0时，可以保护表面不受该属性的影响。</p><blockquote><p>遮罩纹理可以<strong>存储任何逐像素控制的表面属性</strong>。通常会充分利用一张纹理的RGBA四个通道，用于存储不同的属性。例如，把高光反射的强度存储在R通道，把边缘光照的强度存储在G通道…</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//一个实践例子</span><br><span class="line">...</span><br><span class="line">fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular * pow(saturate(dot(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="第8章-透明效果"><a href="#第8章-透明效果" class="headerlink" title="第8章 透明效果"></a>第8章 透明效果</h1><p>🎃<strong>透明度</strong>：开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值，还有这个属性。</p><p>🎃<strong>实现透明效果的两种方法</strong>：透明度测试（Alpha Test）；透明度混合（Alpha Blending）。</p><p>​    👉透明度测试：只要一个片元的透明度不满足条件（通常是小于某个阈值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它。不需要关闭深度写入。</p><p>​    👉透明度混合：这种方法可以得到真正的半透明效果。使用当前片元的透明度作混合因子，与<strong>已经存储</strong>在颜色缓冲中的颜色值进行混合，得到新的颜色。</p><p>🎃<strong>深度缓冲</strong>：渲染一个片元时，需要把它的深度值和已经存在于深度缓冲中的值比较（如果开启了<u>深度测试</u>）——值距离摄像机更远，不应该被渲染到屏幕上（被遮挡）；否则覆盖掉此时<u>颜色缓冲</u>中的像素值，并把深度值更新到<u>深度缓冲</u>中（如果开启了<u>深度写入</u>）。</p><blockquote><p>按这种方式的话，如果透明物体在前面，后面的不透明就被剔除掉了，导致不能透过半透明来看到后面的物体了。所以就把深度写入（ZWrite）关掉，也就是半透明的深度写入关了，这样不透明后面物体就直接进入颜色缓冲？</p><p>关闭深度写入意味着破坏了深度缓冲的工作机制，导致渲染顺序将变得非常重要。</p></blockquote><h2 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h2><p>📍应该在不透明物体渲染完后再渲染半透明物体。（不透明才有深度写入，半透明要和<u>已经存储</u>在颜色缓冲区的颜色混合，而不是直接被后来的关掉ZWrite的不透明的颜色直接覆盖）</p><p>📍半透明物体之间也要符合一定的渲染顺序（颜色缓冲中的混合也分先后顺序）</p><p>👉所以渲染引擎一般都会对物体<strong>先排序，再渲染</strong>：先渲染所有不透明物体，并开启它们的深度测试和深度写入；把半透明物体按距离摄像机的远近排序，再从后往前渲染这些半透明物体，并开启它们的深度测试但关闭深度写入。</p><p>🧐但是是按照整个半透明物体来进行远近区分的，所以当物体出现重叠 / 错位等情况时，就会出现错误的遮挡问题。为了减少错误排序情况， 可以尽可能让模型是凸面体，并且考虑将复杂的模型拆分成可以独立排序的多个子模型等。</p><h2 id="Unity-Shader的渲染顺序"><a href="#Unity-Shader的渲染顺序" class="headerlink" title="Unity Shader的渲染顺序"></a>Unity Shader的渲染顺序</h2><p><strong>渲染队列（render queue）</strong>：Unity在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。使用SubShader的Queue标签来决定模型归于哪个渲染对列。</p><table><thead><tr><th align="center">名称</th><th align="center">队列索引号</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Background</td><td align="center">1000</td><td align="center">最先渲染，通常绘制背景上的物体</td></tr><tr><td align="center">Geometry</td><td align="center">2000</td><td align="center">默认的渲染队列。不透明物体</td></tr><tr><td align="center">AlphaTest</td><td align="center">2450</td><td align="center">需要透明度测试的物体</td></tr><tr><td align="center">Transparent</td><td align="center">3000</td><td align="center">使用透明度混合的物体</td></tr><tr><td align="center">Overlay</td><td align="center">4000</td><td align="center">实现叠加效果。最后渲染的物体</td></tr></tbody></table><h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h2><p>🦁通常在片元着色器中使用<strong>clip函数</strong>来进行透明度测试。clip是Cg中的一个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void clip(float/float2/float3/float4 x);</span><br><span class="line">//参数：裁剪时使用的标量或者矢量条件</span><br><span class="line"></span><br><span class="line">void clip(float4 x)&#123;</span><br><span class="line">if(any(x &amp;lt; 0))</span><br><span class="line">discard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🎏实践</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">//当texColor.α小于材质参数_Cutoff时，该片元就会产生完全透明效果</span><br><span class="line">clip(texCoor.a - _Cutoff);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">//不仅保证在编写的SubShader无法在当前显卡上工作时可以有代替的Shader</span><br><span class="line">//还能保证使用透明度测试的物体可以正确地向其它物体投射阴影</span><br><span class="line">Fallback &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/38d198e643972a97.png" alt="image-20220707160939337"></p><p>🧐效果极端，要么完全透明，要么完全不透明；而且得到的透明效果在边缘处往往参差不齐，有锯齿，这是因为在边界处纹理的透明度的变化精度问题。</p><h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>🎃回顾透明度混合原理：使用当前片元透明度作为<strong>混合因子</strong>，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。需要关闭深度写入；打开混合模式。</p><p>🦁Unity提供的混合命令——<strong>Blend</strong>：混合时的函数由该指令决定。</p><table><thead><tr><th align="center">语义</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Blend Off</td><td align="center">关闭混合</td></tr><tr><td align="center">Blend SrcFactor DstFactor</td><td align="center">开启混合，并设置混合因子。源颜色（该片元产生的颜色）<em>SrcFactor + 目标颜色（已经存在于颜色缓存的颜色）</em>DstFactor —颜色缓存</td></tr><tr><td align="center">Blend SrcFactor DstFactor,  SrcFactorA DstFactorA</td><td align="center">和上面几乎一样，只是使用不同的因子来混合透明通道</td></tr><tr><td align="center">BlendOp BlendOperation</td><td align="center">并非把源颜色和目标颜色简单相加后混合，而使用BlendOperation对它们进行其它操作</td></tr></tbody></table><p>🎏实践。在此使用第二种语义，把SrcFactor 设为SrcAlpha，DstFactor设为OneMinusSrcAlpha</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; </span><br><span class="line">            &quot;Queue&quot; = &quot;Transparent&quot; //</span><br><span class="line">            &quot;IgnoreProjector&quot; = &quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot; = &quot;Transparent&quot; //</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            //关闭深度写入</span><br><span class="line">            ZWrite Off</span><br><span class="line">            //开启并设置该Pass的混合模式</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            ....</span><br><span class="line">            </span><br><span class="line">            //片元着色器内</span><br><span class="line">            return fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            ....</span><br><span class="line">            </span><br><span class="line">  Fallback &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看来透明度混合操作已经被封装成了一个命令，只要开启设置就好。</p></blockquote><h2 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h2><p>关闭了深度写入后，无法对模型进行像素级别的深度排序。其中一种办法时分割网络，但很多情况下这往往是不切实际的。这时我们可以想办法重新利用深度写入。</p><p>🦁一种解决办法：使用两个Pass来渲染模型</p><p>​    👉第一个Pass开启深度写入，但不输出颜色，目的仅仅是为了把该模型的深度值写入深度缓冲中；</p><p>​    👉第二个Pass进行正常的透明度混合。由于上一个Pass得到了逐像素的正确的深度信息，该Pass就可以按照像素级别的深度排序结果来进行透明渲染。</p><p>🧐缺点：使用多个Pass会对性能造成一定影响。</p><p>🎏实践</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//只需在原来的Pass之前再增加这个Pass</span><br><span class="line">Pass&#123;</span><br><span class="line">    ZWrite On</span><br><span class="line">    ColorMask 0//意味着该Pass不写入任何颜色通道，即不会输出任何颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a>ShaderLab的混合命令</h2><p>实际上，混合还有许多其它用处，不仅仅是用于透明度混合。</p><p>🎃混合是如何实现的</p><p>​    👉<strong>源颜色（source color）</strong>:用S表示，指的是由片元着色器产生的颜色值</p><p>​    👉<strong>目标颜色（destination color）</strong>：用D表示，指的是从颜色缓冲中读取到的颜色值</p><p>​    👉<strong>输出颜色</strong>：用O表示，它会重新写入到颜色缓冲中</p><p>​    它们都包含了RGBA四个通道的值；想要使用混合，必须先开启它。在Unity中使用Blend命令时也开启了混合。但是在其他图形API中是需要手动开启的。</p><h3 id="混合等式和参数"><a href="#混合等式和参数" class="headerlink" title="混合等式和参数"></a>混合等式和参数</h3><p>😎混合是一个逐片元的操作，而且不是可编程的，但是可高度配置的。配置：混合时的运算操作、混合因子。</p><p>​    👉<strong>混合等式 blend equation</strong>：源颜色S、目标颜色D——输出颜色O。当混合时需要使用两个混合等式：一个用于混合RGB通道，一个用于混合A通道。</p><p>​    👉混合时的<strong>运算操作</strong>：默认情况下都是加操作。</p><p>​    👉<strong>混合因子</strong>：由于需要两个等式，分别都有两个因子（S/D），因此共需要4个因子。</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Blend SrcFactor DstFactor</td><td align="center">开启混合并设置混合因子。使用同样的混合因子来混合RGB/A通道</td></tr><tr><td align="center">Blend SrcFactor DstFactor,  SrcFactorA DstFactorA</td><td align="center">和上面不同的是使用不同的因子</td></tr></tbody></table><blockquote><p>ShaderLab中的混合因子👇</p></blockquote><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">One</td><td align="center">因子为1</td></tr><tr><td align="center">Zero</td><td align="center">因子为0</td></tr><tr><td align="center">SrcColor</td><td align="center">因子为源颜色值</td></tr><tr><td align="center">SrcAlpha</td><td align="center">因子为源颜色的透明度值（A通道</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><h3 id="混合运算操作"><a href="#混合运算操作" class="headerlink" title="混合运算操作"></a>混合运算操作</h3><p>Add、Sub（减）、Min等，详情见表8.5</p><h3 id="常见的混合类型"><a href="#常见的混合类型" class="headerlink" title="常见的混合类型"></a>常见的混合类型</h3><p>通过混合操作和混合因子命令的组合，可以得到一些类似于Photoshop混合模式中的混合效果（详情见8.6.3</p><h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>🦁默认情况下渲染引擎剔除了物体背面（相对于摄像机方向）的渲染图元，只渲染物体的正面。所以在之前的透明物体都无法看到其内部结构。如果想得到双面渲染的结果，可以使用Cull指令来控制需要剔除哪个面的渲染图元。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cull Back | Front | Off</span><br><span class="line">//剔除后面 | 剔除前面 | 关闭剔除功能（所有的渲染图元都被渲染）</span><br></pre></td></tr></table></figure><h3 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h3><p>只需要在Pass渲染设置中使用Cull命令来关闭剔除即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">Tags &#123;...&#125;</span><br><span class="line">Cull Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h3><p>🧐由于关闭了深度写入，无法保证同一个物体的正面和背面图元的渲染顺序，直接关闭剔除功能的话就可能得到错误的半透明效果。</p><p>📍为此把渲染工作分成两个Pass：第一个Pass只渲染背面，第二个Pass只渲染正面，由于Unity是顺序执行各个Pass，因此可以保证背面总是在正面被渲染之前渲染。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">Tags &#123;...&#125;</span><br><span class="line">Cull Front</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Pass &#123;</span><br><span class="line">Tags &#123;...&#125;</span><br><span class="line">Cull Back</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">learn sth</summary>
    
    
    
    <category term="shader" scheme="https://huangxinhere.github.io/categories/shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity入门(三)——MyGame2</title>
    <link href="https://huangxinhere.github.io/2022/06/04/202264-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame2/"/>
    <id>https://huangxinhere.github.io/2022/06/04/202264-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame2/</id>
    <published>2022-06-03T16:00:00.000Z</published>
    <updated>2022-06-22T13:01:45.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人物移动与交互"><a href="#人物移动与交互" class="headerlink" title="人物移动与交互"></a>人物移动与交互</h1><h2 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h2><h2 id="PlayerMotor"><a href="#PlayerMotor" class="headerlink" title="PlayerMotor"></a>PlayerMotor</h2><h2 id="Interactable"><a href="#Interactable" class="headerlink" title="Interactable"></a>Interactable</h2><p><img src="https://i.bmp.ovh/imgs/2022/06/04/c6b46d139b9b9c42.png" alt="image-20220604215558038"></p><h1 id="物品的收集"><a href="#物品的收集" class="headerlink" title="物品的收集"></a>物品的收集</h1><h2 id="Delegate委托"><a href="#Delegate委托" class="headerlink" title="Delegate委托"></a>Delegate委托</h2><p><a href="https://wenku.baidu.com/view/e61fcfb5d9ef5ef7ba0d4a7302768e9950e76e43.html">在unity中如何使用delegate - 百度文库 (baidu.com)</a></p><h1 id="继承类之间的冲突"><a href="#继承类之间的冲突" class="headerlink" title="继承类之间的冲突"></a>继承类之间的冲突</h1><p>先看例子：获取子类的animator组件</p><ul><li>（公用）CharacterCombat类</li></ul><table><thead><tr><th></th><th align="center">GetChild()</th><th align="center">GetComponentInChild()</th></tr></thead><tbody><tr><td>player</td><td align="center">√</td><td align="center">√</td></tr><tr><td>enemy</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><ul><li>（公用且继承）CharacterStats类</li></ul><table><thead><tr><th align="center"></th><th align="center">GetChild()</th><th align="center">GetComponentInChild()</th></tr></thead><tbody><tr><td align="center">player（PlayerStats）</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">enemy（EnemyStats）</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>这就说明层级没问题，获取也没问题，而问题出现在player有PlayerStats的脚本。仔细比较，那个脚本里面有Start方法……证明start方法覆盖掉了父类的start方法，以至于player的CharacterStats类一直没有运行获取animator组件的代码。写之前没有考虑到这个问题，算是困扰了很久的一个坑了。</p><h1 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h1><h2 id="尝试一：事件类控制所有事件"><a href="#尝试一：事件类控制所有事件" class="headerlink" title="尝试一：事件类控制所有事件"></a>尝试一：事件类控制所有事件</h2><ul><li>如果一个脚本没有继承 MonoBehaviour ，就无法挂在物体上（可能是因为没有继承start，update等方法，无法和游戏对象进行生命周期的同步）；但是类还是可以被用的。</li><li>C#单例模式<a href="https://blog.csdn.net/zls365365/article/details/122904766">C# 单例模式详解_zls365365的博客-CSDN博客</a></li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h2><h3 id="逻辑设计：动画覆盖"><a href="#逻辑设计：动画覆盖" class="headerlink" title="逻辑设计：动画覆盖"></a>逻辑设计：动画覆盖</h3><ul><li>现有设计：</li></ul><table><thead><tr><th align="center"></th><th align="center">触发</th><th align="center">处理方法</th></tr></thead><tbody><tr><td align="center">attack 攻击</td><td align="center">Enemy Controller / Enemy</td><td align="center">CharacterCombat(Trigger:”Attack”)</td></tr><tr><td align="center">hit 受伤</td><td align="center">CharacterCombat – Take Damage()</td><td align="center">CharacterStat(Trigger:”Hit”)</td></tr><tr><td align="center">die 死亡</td><td align="center">CharacterStat(Health &lt; 0)</td><td align="center">EnemyStat – Die(Trigger:”Die”)</td></tr></tbody></table><ul><li>问题：设计是将功能解耦得很明显的，分工也很明确。但是当分工多起来的时候处理流程会被拉长，然后通知的代价也会提高。最后的死亡动画，因为没有及时通知前面的Attack停止，还用了Trigger，所以死亡动画会被覆盖掉。</li><li>解决：从源头上解决问题，即停止Attack的开始。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distance &lt;= lookRadius)</span><br><span class="line">&#123;</span><br><span class="line">    agent.SetDestination(target.position);</span><br><span class="line">    FaceTarget();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (distance &lt;= agent.stoppingDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//attack：敌人 攻击 玩家</span></span><br><span class="line">        CharacterStats playerStats = target.GetComponent&lt;CharacterStats&gt;();</span><br><span class="line">        <span class="keyword">if</span> (playerStats != <span class="literal">null</span> &amp;&amp; enemyStat.currentHealth &gt;= <span class="number">0</span>)<span class="comment">//添加</span></span><br><span class="line">        &#123;</span><br><span class="line">            enemyCombat.Attack(playerStats);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也就是最后的整个流程链执行之后就不会再执行导致覆盖</p></blockquote><h3 id="animatior-trigger触发的动画失效"><a href="#animatior-trigger触发的动画失效" class="headerlink" title="animatior.trigger触发的动画失效"></a>animatior.trigger触发的动画失效</h3><ul><li><p>实现功能：点击按钮弹出选择菜单，点击返回菜单退出。</p></li><li><p>具体设计</p><p>Animator：（默认）弹出动画——（trigger“out”）——触发菜单退出动画</p><p>Animation：退出动画是出现动画速度的-1，在最后设置了Animation 事件（SetActive）</p><p>逻辑：“选择按钮”——UI控件的SetActive，触发默认动画并只播放一次——“返回按钮”——Animator的SetTrigger()。</p></li><li><p>问题：“返回按钮”之后，菜单执行了Animation事件，但动画失效，没有动画。</p></li><li><p>解决：经排查，是退出动画速度为-1的原因，具体不知道是什么原理。</p></li></ul><h3 id="GetComponentsInChildren对动画组件的获取"><a href="#GetComponentsInChildren对动画组件的获取" class="headerlink" title="GetComponentsInChildren对动画组件的获取"></a>GetComponentsInChildren对动画组件的获取</h3><ul><li><p>实现功能：点击Setting按钮，弹出设置菜单，并且背景变暗</p></li><li><p>具体设计</p><p>​    SettingPanel（bg变色）（父对象）——&gt;SettingMenu（子对象）；</p><p>​    出现：SettingPanel.SetActive()，父子对象都会触发默认出现动画；</p><p>​    隐藏：同理，只需父对象SetActive就行，但是要同时触发父子对象的动画</p></li><li><p>不同方法的区别</p><table><thead><tr><th align="center"></th><th align="center">父对象有Animator</th><th align="center">父对象无Animator</th></tr></thead><tbody><tr><td align="center">GetChildrenInComponent</td><td align="center">获取的是父的</td><td align="center">才是子的</td></tr><tr><td align="center">GetChildrenInComponents</td><td align="center">父+子</td><td align="center">子</td></tr></tbody></table></li></ul><h2 id="Button自定义脚本"><a href="#Button自定义脚本" class="headerlink" title="Button自定义脚本"></a>Button自定义脚本</h2><ul><li><p>实现功能：两种状态值切换：召唤菜单/隐藏菜单。</p></li><li><p>分析：控制面板上的响应事件似乎无法记录Btn的状态值。</p><ul><li><p>写了一个脚本挂在Btn对象上面，有</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isActive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Click</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    isActive = !isActive;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是控制板点击事件不能获取到这个Click方法。（原来是方法没有用public…寄</p></blockquote><p>证实这个方法可用…-_-</p></li><li><p>主要是想记录一下btn的监听事件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button = GetComponent&lt;Button&gt;();</span><br><span class="line">        button.onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            OnBtnClick();</span><br><span class="line">        &#125;); </span><br></pre></td></tr></table></figure><blockquote><p>这个和安卓写法很像。要自己重写OnClick方法，就要给btn添加监听器。</p></blockquote></li><li><p>如果非得将这两种方法做个比较的话……我觉得后一种方法在自己处理事件的时候逻辑上更为合理。也就是，btn本身这个游戏对象处理的逻辑，直接调用组件btn来监听事件，而不用在面板上再把自己拖进去，再调用自己脚本的方法。（其实也可以直接拖脚本组件，emmm）如果处理的是其它游戏对象，就比在脚本获取更方便。</p><p>当然，把事件都放在面板上有助于一目了然，视情况而定。</p><p>不，还是第一种方便。</p></li></ul></li></ul><h1 id="TimeLine的Animation-Playable-Asset"><a href="#TimeLine的Animation-Playable-Asset" class="headerlink" title="TimeLine的Animation Playable Asset"></a>TimeLine的Animation Playable Asset</h1><ul><li><p>想在timeLine播放完后添加Animation Event。</p><p><img src="https://pic.jitudisk.com/public/2022/06/22/2dacd2d878eb3.png" alt="image-20220622184053916"></p><p>例如在Record那儿。</p><p>但是一点击打开，发现</p><p><img src="https://pic.jitudisk.com/public/2022/06/22/987b547f8605c.png" alt="image-20220622184145215"></p><p>左边的名称栏有点陌生，Cinemachine Tracked脚本？我记录的是轨道相机的关键帧……</p><p>先不管它，点击动画事件的时候……</p><p><img src="https://pic.jitudisk.com/public/2022/06/22/3cfb69788c6e8.png" alt="image-20220622184424410"></p><p>似乎说重载方法无效。但是在其他场景也可以用啊。如果我把重载方法改掉，又会说什么没有挂载在对象上（继承了Monobehavior的话要挂在对象上才生效）。那我就去挂载在相机上。然鹅并没有什么用</p></li><li><p>这东西就怪在它不是某个Animator的动画。打关键帧那个相机的Animator长这样👇没有Controller，取消勾选的话动画就无法播放。这是为啥呢?</p><p><img src="https://pic.jitudisk.com/public/2022/06/22/8e142769fc32f.png" alt="image-20220622184844367"></p><blockquote><ul><li><p>没有Animator Controller</p></li><li><p>但是依赖Animator才能播放</p></li><li><p>具体的动画片段在TimeLine下</p><p><img src="https://pic.jitudisk.com/public/2022/06/22/c513a16f1670d.png" alt="image-20220622192045865"></p></li><li><p>动画事件添加不成功</p></li></ul></blockquote></li><li><p>单击那个Record。属性栏显示是Animation Playable Asset。这又是什么？</p></li></ul><p><a href="https://docs.unity3d.com/Packages/com.unity.timeline@1.2/manual/insp_clp_anim_plyb.html">Animation clip Playable Asset properties | Timeline | 1.2.18 (unity3d.com)</a></p><ul><li><p>Clip Transform Offsets</p><ul><li>可以设置那个在TimeLine上对应片段的动画位置。之前认识的动画都是作为状态附属在对象上的，现在是动画高于对象了？还是说理解成看作一个对象？</li></ul><p><img src="https://pic.jitudisk.com/public/2022/06/22/5ac0a16ee6d40.png" alt="image-20220622190400126"></p><blockquote><p>尝试用人物行走动画来用TimeLine形成连续行走，也应用了根运动，但是就是闪回鬼畜，好奇怪，为啥啊？</p><p>–原来是<img src="https://pic.jitudisk.com/public/2022/06/22/b29dec4155917.png" alt="image-20220622190851201">把Player拖进去了，自动生成了特殊的Animator，应该就和子对象冲突了。但是把子对象拖进去的时候，一个片段结束后又从原点出发了，所以在不断闪退。</p><p>–<img src="https://pic.jitudisk.com/public/2022/06/22/dcc9a68045b5e.png" alt="image-20220622191358717">笑死我自己，是把其中一个片段拉长，而不是重叠。真的考验细心啊。这样就方便随时拉动TimeLine来调整了，不用每次都点击开始游戏。</p><p>–动画控制对象的话，好像默认位置会置为世界坐标原点。</p></blockquote></li><li><p><img src="https://pic.jitudisk.com/public/2022/06/22/9608bf5a6bbb4.png" alt="image-20220622192644106"></p></li></ul><blockquote><p>理解：TimeLine第一行红色，控制什么相机在什么时候优先；然后相机具体怎么做则由它自己的Animation Track来控制。这个不能用对象控制动画那样的animator来理解……这个animator是挂在Timeline属性上的，所以在对象上不会出现？</p></blockquote><ul><li>嗷嗷，脚本确实是添加在被编辑的相机上而不是timeline上，就和之前那样。警告什么的就不管了唉</li></ul>]]></content>
    
    
    <summary type="html">结课作业第二波：老实跟着教程做</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity入门(三)——MyGame</title>
    <link href="https://huangxinhere.github.io/2022/05/09/202259-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame/"/>
    <id>https://huangxinhere.github.io/2022/05/09/202259-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-06-20T01:48:45.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h1><h2 id="水平垂直方向的平移"><a href="#水平垂直方向的平移" class="headerlink" title="水平垂直方向的平移"></a>水平垂直方向的平移</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> h = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    <span class="built_in">float</span> v = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*存储角色的移动*/</span></span><br><span class="line">    m_Movement.Set(h, <span class="number">0f</span>, v);</span><br><span class="line">    m_Movement.Normalize();     <span class="comment">//确保对角线移动速度相同【矢量标准化为长度1】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> hasHorizontalInput = !Mathf.Approximately(h, <span class="number">0f</span>);  <span class="comment">//两者相似，则不在移动</span></span><br><span class="line">    <span class="built_in">bool</span> hasVerticalInput = !Mathf.Approximately(v, <span class="number">0f</span>);</span><br><span class="line">    <span class="built_in">bool</span> isWalking = hasHorizontalInput || hasVerticalInput;<span class="comment">//判断是否在走路</span></span><br><span class="line">    animator.SetBool(<span class="string">&quot;isWalking&quot;</span>, isWalking);               <span class="comment">//通过所有定义的输入来判断是否走路。如果按照按键则限制较大</span></span><br><span class="line">    <span class="comment">//这里为止，只是播放动画但会一直往前走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>控制角色旋转的速度：</p><ul><li>创建和存储旋转，以便可以在任何需要的地方使用。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"> Quaternion m_Rotation = Quaternion.identity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line">Vector3 desiredForward = Vector3.RotateTowards(transform.forward, m_Movement, rotateSpeed * Time.deltaTime, <span class="number">0f</span>);</span><br><span class="line">        m_Rotation = Quaternion.LookRotation(desiredForward);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四元数是存储旋转的一种方式"><a href="#四元数是存储旋转的一种方式" class="headerlink" title="四元数是存储旋转的一种方式"></a>四元数是存储旋转的一种方式</h3><ul><li>可用于解决将旋转存储为 3D 矢量时遇到的一些问题。</li><li>通常情况下，创建类的实例时，会将属于类的变量（成员变量）而不是属于特定方法的变量设置为默认值。例如，Vector3 的默认值是将 x、y 和 z 都设置为 0。四元数也是如此。但是，虽然零矢量是合理的（因为没有移动），零四元数却不太合理。这里设置的 Quaternion.identity 值就是为其赋予无旋转的值，这是一个<strong>更合理的默认值</strong>。</li></ul><h3 id="Vector3-RotateTowards"><a href="#Vector3-RotateTowards" class="headerlink" title="Vector3.RotateTowards"></a>Vector3.RotateTowards</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">RotateTowards</span> (<span class="params">Vector3 current, Vector3 target, <span class="built_in">float</span> maxRadiansDelta, <span class="built_in">float</span> maxMagnitudeDelta</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/05/09/46b181830a7d075b.png" alt="image-20220509155607107"></p><ul><li>返回<strong>Vector3</strong> RotateTowards 生成的位置。</li><li>描述：该函数类似于 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.MoveTowards.html">MoveTowards</a>，但<strong>向量被视为方向而不是位置</strong>。 <code>current</code> 向量将朝 <code>target</code> 方向旋转 <code>maxRadiansDelta</code> 的角度， 但其将准确地落在目标上而不会超过目标。 如果 <code>current</code> 和 <code>target</code> 的大小不同，则在旋转期间对结果大小进行线性插值。 如果为 <code>maxRadiansDelta</code> 使用负值，则向量将朝远离 <code>target</code> 的方向旋转， 直到它指向完全相反的方向，然后停止。</li></ul><h3 id="每一帧存储旋转方向"><a href="#每一帧存储旋转方向" class="headerlink" title="每一帧存储旋转方向"></a>每一帧存储旋转方向</h3><h2 id="将移动和旋转应用于角色"><a href="#将移动和旋转应用于角色" class="headerlink" title="将移动和旋转应用于角色"></a>将移动和旋转应用于角色</h2><ul><li><p>可以通过多种方式来执行此操作，但是由于<strong>角色需要成为物理系统的一部分</strong>，因此需要移动刚体而不是使用任何其他方法。</p></li><li><p>该角色有一段有趣的 Walk 动画，最好为此使用<strong>根运动</strong>。但是，该动画中没有任何旋转，如果尝试在 Update 方法中旋转刚体 (Rigidbody)，则动画可能会覆盖该刚体（这可能导致角色在应该旋转的时候不旋转）</p></li><li><p><strong>实际需要的是动画的一部分根运动</strong>（？，但不是全部的根运动；具体来说，需要应用移动而不是旋转。那么如何更改从 Animator 中应用根运动的方式呢？幸运的是，MonoBehaviour 有一种特殊的方法可用于更改从 Animator 中应用根运动的方式</p></li></ul><h3 id="根运动"><a href="#根运动" class="headerlink" title="根运动"></a>根运动</h3><ul><li><p>根运动 (Root Motion) 角色根的运动（无论是由动画本身还是由外部控制）。</p></li><li><p>工作原理：<a href="https://docs.unity.cn/cn/2020.3/Manual/RootMotion.html">根运动 - 工作原理 - Unity 手册</a></p></li><li><p>动画用于在特定层级视图中移动和旋转所有游戏对象。这些移动和旋转大多数都是相对于其父项完成的，但是层级视图的父游戏对象没有父项，因此它们的移动不是相对的。此父游戏对象也可以称为根 (Root)，因此其移动称为根运动 (Root Motion)。</p><p><strong>重要注意事项！</strong>在 JohnLemon 预制件的层级视图中称为根的游戏对象指的是其骨架的根，而不是实际的根游戏对象。根游戏对象是 Animator 组件所在的任何游戏对象，在本例中，该游戏对象称为 JohnLemon。</p><p>在 Animator 组件上启用了 Apply Root Motion，因此根在动画中的任何移动都将应用于每一帧。由于 Animator 正在播放 Idle 动画，没有移动，因此 Animator 不会施加任何动作。那么，为什么 JohnLemon 游戏对象会移动呢？这是因为 Animator 的**更新模式 (Update Mode)**。</p></li></ul><h3 id="OnAnimatorMove（）"><a href="#OnAnimatorMove（）" class="headerlink" title="OnAnimatorMove（）"></a>OnAnimatorMove（）</h3><ul><li>MonoBehaviour 有一种特殊的方法可用于更改从 Animator 中应用根运动的方式。</li><li>在每个更新帧中为每个 <strong>Animator 组件</strong>调用一次此函数来<strong>修改根运动</strong> (Root Motion)。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    m_Rigidbody.MovePosition(m_Rigidbody.position + m_Movement * animator.deltaPosition.magnitude);</span><br><span class="line">    m_Rigidbody.MoveRotation(m_Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Animator 的 <strong>deltaPosition</strong> 是由于可以应用于此帧的根运动而导致的位置变化。将其大小（即长度）乘以我们希望角色移动的实际方向上的移动向量</p></blockquote><h3 id="Animator通过物理循环适时运行"><a href="#Animator通过物理循环适时运行" class="headerlink" title="Animator通过物理循环适时运行"></a>Animator通过物理循环适时运行</h3><p><a href="https://learn.unity.com/tutorial/the-player-character-part-1">从而避免物理与动画之间发生冲突。但是，现在您将使用 OnAnimatorMove 来覆盖根运动。这意味着 OnAnimato</a>rMove 实际上将通过物理适时被调用，而不是像 Update 方法那样通过渲染被调用。</p><ul><li>FixedUpdate：在物理系统处理所有碰撞和其他已发生的交互之前被调用。默认情况下，每秒正好调用 50 次这个方法。</li></ul><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>整个流程下来都是很晕。试了一下，如果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1*/</span></span><br><span class="line">m_Movement.Set(h, <span class="number">0f</span>, v);</span><br><span class="line">m_Movement.Normalize();  </span><br><span class="line"></span><br><span class="line">rg.MovePosition(m_Movement);<span class="comment">//h，v只是方向向量，长度为1，所以不能连续移动（最远也是一个单位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2:普通做法*/</span></span><br><span class="line">Vector3 move = rg.position;</span><br><span class="line">move.x += move_speed * h * Time.deltaTime;</span><br><span class="line">move.z += move_speed * v * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">rg.MovePosition(move);<span class="comment">//这样便是自己控制速度来移动（不会旋转）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    m_Rigidbody.MovePosition(m_Rigidbody.position + m_Movement * animator.deltaPosition.magnitude);</span><br><span class="line">    m_Rigidbody.MoveRotation(m_Rotation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以比较看出，这个方法并没有设置速度，而是用了animator.deltaPosition.magnitude来作为移动的变化量</span></span><br><span class="line"><span class="comment">//官方解释：应用于此帧的根运动而导致的位置变化；或者说是动画固定的步长？</span></span><br><span class="line"><span class="comment">//那么，模型和动画实质上可以相互影响的？</span></span><br><span class="line"><span class="comment">//之前觉得就是控制模型刚体移动，然后顺便播放动画</span></span><br></pre></td></tr></table></figure><h2 id="吃透理解！！"><a href="#吃透理解！！" class="headerlink" title="吃透理解！！"></a>吃透理解！！</h2><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/2bcff3ae37034084.png" alt="image-20220509202135390"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/4b31d6cfc4ff781a.png" alt="image-20220513213526442"></p><blockquote><p>补充PS部分：是重写了OnAnimationMove()方法才会取消复选框</p></blockquote><h2 id="Root-Motion工作原理"><a href="#Root-Motion工作原理" class="headerlink" title="Root Motion工作原理"></a>Root Motion工作原理</h2><h3 id="Body-Transform"><a href="#Body-Transform" class="headerlink" title="Body Transform"></a>Body Transform</h3><p>是角色的质心（重心）。用于Mecanim系统的<em>重定向引擎</em>中来提供<strong>稳定的模型移动</strong>。身体朝向是角色模型在T姿势下上身和下身朝向的平均值。</p><p><strong>Body Transform和朝向</strong>存储在Animation Clip中，这两个是Animation Clip中存储的唯二<strong>世界空间</strong>的曲线，<u>其他的动画曲线</u>都是以相对body transform的形式存储的。</p><h3 id="Root-Transform（根变换）"><a href="#Root-Transform（根变换）" class="headerlink" title="Root Transform（根变换）"></a>Root Transform（根变换）</h3><p>是body transform在Y平面上的投影，并且是运行时运算的。每一帧Root Transform的变化实时计算。然后Transform的变化会被应用到GameObject上从而让物体移动。</p><h3 id="调整Root-Transform"><a href="#调整Root-Transform" class="headerlink" title="调整Root  Transform"></a>调整Root  Transform</h3><h4 id="Root-Transform-Rotation"><a href="#Root-Transform-Rotation" class="headerlink" title="Root Transform Rotation"></a>Root Transform Rotation</h4><h4 id="Root-Transform-Position-Y"><a href="#Root-Transform-Position-Y" class="headerlink" title="Root Transform Position(Y)"></a>Root Transform Position(Y)</h4><h4 id="Root-Transform-Position-XZ"><a href="#Root-Transform-Position-XZ" class="headerlink" title="Root Transform Position(XZ)"></a>Root Transform Position(XZ)</h4><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/d065079294b6ba57.png" alt="image-20220513213506678"></p><p>详情见<a href="https://zhuanlan.zhihu.com/p/151387595">Unity动画系统详解6：如何做好角色的移动动画？（Root Motion详解） - 知乎 (zhihu.com)</a></p><h1 id="相机跟随（CineMachine）"><a href="#相机跟随（CineMachine）" class="headerlink" title="相机跟随（CineMachine）"></a>相机跟随（CineMachine）</h1><p><a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html">使用Cinemachine|电影|2.8.4 (unity.cn)</a></p><h2 id="虚拟摄像机"><a href="#虚拟摄像机" class="headerlink" title="虚拟摄像机"></a>虚拟摄像机</h2><p>Cinemachine 是 Unity 针对游戏中与摄像机有关的所有问题的解决方案。</p><ul><li>在场景中创建一个或多个“虚拟”摄像机。</li><li>这些虚拟摄像机由一个名为 Cinemachine Brain 的组件进行管理。</li><li>Cinemachine Brain 与 Camera 组件连接到相同的游戏对象，默认情况下，这个游戏对象将是 Main Camera 游戏对象。</li><li>Cinemachine Brain 管理所有虚拟摄像机，并确定实际摄像机应跟随哪个虚拟摄像机（或虚拟摄像机的组合）。</li></ul><p>详细说明：</p><ul><li><p>Cinemachine不会创建新的摄像机。相反，它会将单个 Unity 摄像机定向到多个镜头。您可以使用<strong>虚拟摄像机</strong>构图这些镜头。虚拟摄像机移动和旋转 Unity 摄像机并控制其设置。</p></li><li><p>虚拟摄像机是独立于 Unity 摄像机的游戏对象，其行为独立。它们不嵌套在彼此内。例如，场景可能如下所示：</p><p><img src="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/images/CinemachineSceneHierarchy.png" alt="A Scene containing a Unity camera with Cinemachine Brain (blue) and multiple Virtual Cameras (red)"></p><ul><li>虚拟摄像机为您执行的主要任务：<ul><li>将 Unity 摄像机放置在场景中。</li><li>将 Unity 相机对准某些物体。</li><li>将程序噪声添加到 Unity 摄像机。噪音模拟手持效果或车辆晃动等。</li></ul></li><li>Cinemachine鼓励您创建许多虚拟摄像机。虚拟摄像机的设计<strong>消耗很少的处理能力</strong>。如果您的场景对性能敏感，请在任何给定时刻停用除基本虚拟摄像机之外的所有摄像机，以获得最佳性能。</li><li>一个虚拟摄像机可以在任何时间点控制 Unity 摄像机。这是<strong>实时</strong>虚拟摄像机。此规则的例外情况是从一个虚拟摄像机到下一个虚拟摄像机的混合。在混合过程中，两个虚拟摄像机都是实时的。</li></ul></li></ul><h2 id="Cinemachine-Brain"><a href="#Cinemachine-Brain" class="headerlink" title="Cinemachine Brain"></a>Cinemachine Brain</h2><ul><li><p>是Unity Camera本身的一个组件.</p></li><li><p><strong>监控</strong>场景中所有活动的虚拟摄像机。【选择】要指定下一个实时虚拟摄像机，请<a href="https://docs.unity.cn/Manual/DeactivatingGameObjects.html">激活或停用</a>所需虚拟摄像机的游戏对象。然后，Cinemachine Brain选择与实时虚拟摄像机具有相同或更高优先级的最新激活的虚拟摄像机。它在以前的虚拟摄像机和新虚拟摄像机之间执行剪切或混合。</p></li><li><p>使用Cinemachine Brain实时响应动态游戏事件。它允许您的游戏逻辑通过操作优先级来控制摄像机。这对于实时游戏玩法特别有用，因为实时游戏玩法中的动作并不总是可预测的。使用<a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineTimeline.html">时间轴</a>在可预测的情况下（如过场动画）编排摄像机。时间轴覆盖了Cinemachine Brain优先级系统，为您提供精确的帧摄像机控制。</p><p>（也就是相对于时间轴来说可以实时控制摄像机）</p></li></ul><h2 id="Moving-and-aiming"><a href="#Moving-and-aiming" class="headerlink" title="Moving and aiming"></a>Moving and aiming</h2><p>这里面有多种算法来控制移动和瞄准。每个算法都解决一个特定问题。（理解为某种特定的相机行为模式,在此分为怎么样跟随，怎么样旋转）</p><h3 id="Body-properties-how-to-move-跟随"><a href="#Body-properties-how-to-move-跟随" class="headerlink" title="Body properties: how to move(跟随)"></a>Body properties: how to move(跟随)</h3><ul><li>Transposer：以<u>固定关系</u>移动到<strong>“跟随</strong>”目标，并具有可选的阻尼。</li><li>Do Nothing: 虚拟相机不移动。</li><li>Framing Transposer: 在固定的屏幕空间关系中移动到<strong>“跟随”</strong>目标，并带有可选的阻尼。</li></ul><blockquote><p>Transposer和Framing那个区别好像是，前者是以固定相对位置来移动，比如设置在人后面，那么会一直跟在人的后面；后者就是人可以任意旋转，但是仍在画面固定位置。</p><p>前者：好像会跟随动作一直晃，有点难受</p><p>后者：移动摄像机有点奇怪，坐标轴拉近了相机却跑远了。</p></blockquote><ul><li>Orbital Transposer: 在可变关系中移动到<strong>“跟随”</strong>目标，可以选择接受玩家输入。??</li><li>Tracked Dolly: 沿预定义的路径移动。为静态拍摄或直接使用自定义脚本对摄像机位置进行动画处理，选择此算法。</li><li>Hard Lock to Target: 在<strong>“跟随</strong>”目标位置使用相同的位置。</li><li>3rd Person Follow: 将摄像机保持在相对于跟随目标的恒定位置和距离（受阻尼控制），跟踪目标的移动和旋转。</li></ul><h3 id="Aim-properties-how-to-rotate（瞄准）"><a href="#Aim-properties-how-to-rotate（瞄准）" class="headerlink" title="Aim properties: how to rotate（瞄准）"></a>Aim properties: how to rotate（瞄准）</h3><ul><li>Composer: 将<strong>“查看”</strong>目标保留在相机帧中，并带有合成约束。??</li><li>Group Composer: 在相机帧中保留多个<strong>“查看”</strong>目标。</li><li>Do Nothing: 不旋转</li><li>POV: 根据用户输入旋转虚拟摄像机</li><li>Same As Follow Target: 将相机的旋转设置为<strong>跟随</strong>目标的旋转。</li><li>Hard Look At: 将<strong>“看向”</strong>目标保持在相机帧的中心。</li></ul><h3 id="Composing-a-shot-构图"><a href="#Composing-a-shot-构图" class="headerlink" title="Composing a shot 构图"></a>Composing a shot 构图</h3><p>Framing Transposer/Composer/Group Composer算法定义了相机帧中区域，以便构图：</p><ul><li><p><strong>盲区</strong>：Cinemachine将目标保留在画面中的区域。</p></li><li><p><strong>柔和区域</strong>：如果目标进入帧的此区域，相机将重新定向以将其放回盲区。它将根据阻尼设置中指定的时间缓慢或快速地执行此操作。</p></li><li><p><strong>屏幕</strong>：死区中心的屏幕位置。0.5 是屏幕的中心。</p></li><li><p><strong>阻尼</strong>：模拟真实摄像机操作员在操作重型物理摄像机时引入的滞后。阻尼指定当目标进入<strong>软区</strong>时，当摄像机跟踪目标时，摄像机会快速或缓慢地做出反应。使用小数字来模拟响应更快的相机，快速移动或瞄准相机以将目标保持在<strong>盲区</strong>。模拟更重的摄像机数量越多，值越大，Cinemachine允许目标进入软区的数量就越多。</p><p><img src="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/images/CinemachineGameWindowGuides.png" alt="游戏窗口指南提供阻尼、屏幕、软区和死区的视觉指示"></p><blockquote><p>清晰区域表示<strong>盲区</strong>。蓝色区域表示<strong>柔和区域</strong>。软区和死区的位置表示<strong>屏幕</strong>位置。红色区域表示目标从未进入的<strong>无通过</strong>区域。黄色方块表示目标。</p></blockquote></li></ul><p>调整这些区域以获得各种相机行为。为此，请在“游戏”视图中拖动其边缘，或在“检查器”窗口中编辑其属性。</p><h2 id="使用噪点模拟相机抖动"><a href="#使用噪点模拟相机抖动" class="headerlink" title="使用噪点模拟相机抖动"></a>使用噪点模拟相机抖动</h2><p>现实世界的物理相机通常很重且笨重。它们由摄像机操作员手持或安装在不稳定的物体上，如移动的车辆。使用<a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraNoise.html">“杂色”属性</a>（Noise properties）来模拟这些真实世界品质，以获得电影效果。例如，您可以在跟随正在奔跑的角色时添加摄像机抖动，以使玩家沉浸在动作中。</p><h2 id="虚拟摄像机属性"><a href="#虚拟摄像机属性" class="headerlink" title="虚拟摄像机属性"></a>虚拟摄像机属性</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li><strong>Live</strong>：虚拟摄像机主动控制具有Cinemachine大脑的Unity摄像机。当Cinemachine大脑从一个虚拟摄像机混合到下一个虚拟摄像机时，两个虚拟摄像机都是实时的。混合完成后，只有一个实时虚拟摄像机。</li><li><strong>待机</strong>Standby：虚拟摄像机无法控制 Unity 摄像机。但是，它仍然遵循并瞄准其目标，并在每一帧更新。处于此状态的虚拟摄像机将被激活，其优先级与实时虚拟摄像机相同或更低。</li><li><strong>已禁用</strong>Disabled：虚拟摄像机无法控制 Unity 摄像机，也不会主动跟踪或瞄准其目标。处于此状态的虚拟摄像机不会消耗处理能力。要禁用虚拟摄像机，请停用其游戏对象。虚拟摄像机存在，但在场景中处于禁用状态。但是，即使游戏对象已停用，如果虚拟摄像机正在参与混合，或者如果时间轴调用了该混合，虚拟摄像机仍然可以控制 Unity 摄像机。</li></ul><table><thead><tr><th align="left"><strong>Property:</strong></th><th align="left"></th><th align="left"><strong>Function:</strong></th></tr></thead><tbody><tr><td align="left"><strong>Solo</strong></td><td align="left"></td><td align="left">Toggles whether or not the Virtual Camera is temporarily live. Use this property to get immediate visual feedback in the <a href="https://docs.unity.cn/Manual/GameView.html">Game view</a> to adjust the Virtual Camera.</td></tr><tr><td align="left"><strong>Game Window Guides</strong></td><td align="left"></td><td align="left">参考线</td></tr><tr><td align="left"><strong>Save During Play</strong></td><td align="left"></td><td align="left">Check to <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineSavingDuringPlay.html">apply the changes while in Play mode</a>.</td></tr><tr><td align="left"><strong>Priority</strong></td><td align="left"></td><td align="left">值越大，表示优先级越高。 将虚拟摄像机与时间轴配合使用时，此属性不起作用。</td></tr><tr><td align="left"><strong>Follow</strong></td><td align="left"></td><td align="left">The target GameObject that the Virtual Camera moves with. The <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraBody.html">Body properties</a> use this target to update <strong>the position of the Unity camera</strong>. //？？Keep this property empty to make the Unity camera use the position of the Virtual Camera’ transform. For example, you might choose to animate the Virtual Camera in Timeline.</td></tr><tr><td align="left"><strong>Look At</strong></td><td align="left"></td><td align="left">The target GameObject to aim the Unity camera at. The <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraAim.html">Aim properties</a> use this target to update the rotation of the Unity camera. Keep this property empty to make the Unity camera use the orientation of the Virtual Camera.</td></tr><tr><td align="left"><strong>Standby Update</strong></td><td align="left"></td><td align="left">Controls <u>how often</u> the virtual camera is updated when the virtual camera is not live.</td></tr><tr><td align="left"><strong>Position Blending</strong></td><td align="left"></td><td align="left">Style for blending positions to and from this Virtual Camera.</td></tr><tr><td align="left"></td><td align="left"><em>Linear</em></td><td align="left">Standard linear position blend.</td></tr><tr><td align="left"></td><td align="left"><em>Spherical</em></td><td align="left">Spherical blend about the Look At position, if there is a Look At target.</td></tr><tr><td align="left"></td><td align="left"><em>Cylindrical</em>圆柱</td><td align="left">Cylindrical blend about the Look At position, if there is a Look At target. Vertical coordinate is linearly interpolated.</td></tr><tr><td align="left"><strong>Lens</strong></td><td align="left"></td><td align="left">属性镜像<a href="https://docs.unity.cn/Manual/class-Camera.html">Unity camera</a>.</td></tr><tr><td align="left"></td><td align="left"><em>Field Of View</em></td><td align="left">The camera view in vertical degrees. For example, to specify the equivalent of a 50mm lens on a Super 35 sensor, enter a Field of View of 19.6 degrees. This property is available when the Unity camera with the Cinemachine Brain component uses a Projection of Perspective.//太专业了，不懂</td></tr><tr><td align="left"></td><td align="left"><em>Presets</em></td><td align="left">A drop-down menu of settings for commonly-used lenses. Choose <strong>Edit Presets</strong> to add or edit the asset that contains a default list of lenses.</td></tr><tr><td align="left"></td><td align="left"><em>Orthographic Size</em></td><td align="left">When using an orthographic camera, defines the half-height of the camera view, in world coordinates. Available when the Unity camera with the Cinemachine Brain component uses a Projection of Orthographic.</td></tr><tr><td align="left"></td><td align="left"><em>Near Clip Plane</em></td><td align="left">The closest point relative to the camera where drawing occurs.</td></tr><tr><td align="left"></td><td align="left"><em>Far Clip Plane</em></td><td align="left">The furthest point relative to the camera where drawing occurs.</td></tr><tr><td align="left"></td><td align="left"><em>Dutch</em>荷兰语（特有的）</td><td align="left">Dutch angle. Tilts the Unity camera on the z-axis, in degrees. This property is unique to the Virtual Camera; there is no counterpart property in the Unity camera.</td></tr><tr><td align="left"><strong>Mode Override</strong></td><td align="left"></td><td align="left">Allows you to select a different camera mode to apply to the <a href="https://docs.unity.cn/Manual/class-Camera.html">Unity camera</a> component when Cinemachine activates this Virtual Camera. <strong>Important:</strong> All the changes applied to the Camera component through this setting will remain after the Virtual Camera deactivation. If you set a mode override in any Virtual Camera, you should set one in all Virtual Cameras.</td></tr><tr><td align="left"></td><td align="left"><em>None</em></td><td align="left">Leaves the <strong>Projection</strong> and <strong>Physical Camera</strong> properties unchanged in the Camera.</td></tr><tr><td align="left"></td><td align="left"><em>Orthographic</em></td><td align="left">Sets the <strong>Projection</strong> property to <strong>Orthographic</strong>.</td></tr><tr><td align="left"></td><td align="left"><em>Perspective</em></td><td align="left">Sets the <strong>Projection</strong> property to <strong>Perspective</strong> and <em>disables</em> the <strong>Physical Camera</strong> feature and properties.</td></tr><tr><td align="left"></td><td align="left"><em>Physical</em></td><td align="left">Sets the <strong>Projection</strong> property to <strong>Perspective</strong> and <em>enables</em> the <strong>Physical Camera</strong> feature and properties.</td></tr><tr><td align="left"><strong>Blend Hint</strong></td><td align="left"></td><td align="left">Provides hints for blending positions to and from the virtual camera.</td></tr><tr><td align="left"><strong>Inherit Position</strong></td><td align="left"></td><td align="left">When enabled, whenever this virtual camera goes live, forces the initial position to be the same as the current position of the Unity Camera, if possible.</td></tr><tr><td align="left"><strong>Extensions</strong></td><td align="left"></td><td align="left">Components that add extra behaviors to the Virtual Camera.</td></tr><tr><td align="left"></td><td align="left"><em>Add Extension</em></td><td align="left">Choose a new <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraExtensions.html">extension</a> to add to the Virtual Camera.</td></tr></tbody></table><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><p><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/UIToolkits.html">Unity - 手动：创建用户界面 （UI） (unity3d.com)</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>表示在其中布局和呈现 UI 的抽象空间。所有 UI 元素都必须是附加了画布组件的游戏对象的子级。</p><table><thead><tr><th align="left">*<em>Property:*</em></th><th align="left">*<em>Function:*</em></th></tr></thead><tbody><tr><td align="left"><strong>Render Mode</strong></td><td align="left">The way the <strong>UI</strong>  is rendered to the screen or as an object in 3D space (see below). The options are <em>Screen Space - Overlay</em>, <em>Screen Space - Camera</em> and <em>World Space</em>.</td></tr><tr><td align="left"><strong>Pixel Perfect (*Screen Space* modes only)</strong></td><td align="left">Should the UI be rendered without <strong>antialiasing</strong>  for precision?为了精确度产生抗锯齿</td></tr><tr><td align="left"><strong>Render</strong> Camera__ (<em>Screen Space - Camera</em> mode only)__</td><td align="left">The camera to which the UI should be rendered (see below).</td></tr><tr><td align="left"><strong>Plane Distance (*Screen Space - Camera* mode only)</strong></td><td align="left">The distance at which the UI plane should be placed in front of the camera.</td></tr><tr><td align="left"><strong>Event Camera (*World Space* mode only)</strong></td><td align="left">The camera that will be used to process UI events.</td></tr><tr><td align="left"><strong>Receives Events</strong></td><td align="left">UI 事件是否由此画布处理？</td></tr></tbody></table><h3 id="单个或多个canvas"><a href="#单个或多个canvas" class="headerlink" title="单个或多个canvas"></a>单个或多个canvas</h3><p>所有 UI 元素的单个画布就足够了，但scene是可能的。也可以使用嵌套的 Canvas，其中一个 Canvas 被放置为另一个 Canvas 的子级以进行优化。嵌套的画布使用与其父级相同的渲染模式。</p><h3 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h3><h4 id="Screen-Space-Overlay-屏幕空间-叠加"><a href="#Screen-Space-Overlay-屏幕空间-叠加" class="headerlink" title="Screen Space - Overlay 屏幕空间 - 叠加"></a>Screen Space - Overlay 屏幕空间 - 叠加</h4><p>在此模式下，将缩放 Canvas 以<strong>适合屏幕</strong>，然后直接渲染，而<strong>不参考场景或摄像机</strong>（即使场景中根本没有摄像机，也会渲染 UI）。如果屏幕的大小或分辨率发生更改，则 UI 将自动重新缩放以适合屏幕大小。UI 将在任何其他图形（如相机视图）上绘制。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasOverlay.png" alt="在场景对象上呈现的叠加 UI"></p><blockquote><p>在场景对象上呈现的叠加 UI</p></blockquote><p>注： “屏幕空间 - 叠加”画布需要存储在层次结构的顶层。如果不使用它，则 UI 可能会从视图中消失。这是一个内置限制。将“屏幕空间 - 叠加”画布<strong>保留在层次结构的顶层</strong>，以获得预期的结果。(在游戏对象的排序中最前？)</p><h4 id="Screen-Space-Camera-屏幕空间-相机"><a href="#Screen-Space-Camera-屏幕空间-相机" class="headerlink" title="Screen Space - Camera 屏幕空间 - 相机"></a>Screen Space - Camera 屏幕空间 - 相机</h4><p>在此模式下，Canvas 的渲染方式就像是<strong>在给定摄像机前方一定距离的平面对象上绘制</strong>的一样。UI 的屏幕大小不会随距离而变化，因为它始终会重新缩放以完全适合<a href="https://docs.unity3d.com/2021.3/Documentation/Manual/FrustumSizeAtDistance.html">相机视锥体</a>。如果屏幕的大小或分辨率或相机视锥体发生更改，则 UI 将自动重新缩放以适合。任何<strong>3D 对象</strong>在场景中，比UI平面更靠近UI平面将在UI前面渲染，而平面后面的对象将被遮挡。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasCamera.png" alt="相机模式 UI，前面有场景对象"></p><blockquote><p>相机模式 UI，前面有场景对象</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/dcd6a08baf6d9250.png" alt="image-20220516145017102"></p><blockquote><p>Plane distance: 绘制平面离相机多远</p></blockquote><h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>此模式将 UI 呈现为<strong>场景中的平面对象</strong>。然而，与<em>屏幕空间 - 相机</em>模式不同，飞机不需要面对相机，并且可以随心所欲地定向。Canvas 的大小可以使用其 Rect Transform 进行设置，但<strong>其屏幕大小将取决于摄像机的视角和距离</strong>。其他场景对象可以穿过画布的后面、穿过或前面。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasWorldSpace.png" alt="与场景对象相交的世界空间 UI"></p><blockquote><p>与场景对象相交的世界空间 UI</p></blockquote><h3 id="适应屏幕分辨率"><a href="#适应屏幕分辨率" class="headerlink" title="适应屏幕分辨率"></a>适应屏幕分辨率</h3><h4 id="使用锚点适应不同的宽高比（相对位置）"><a href="#使用锚点适应不同的宽高比（相对位置）" class="headerlink" title="使用锚点适应不同的宽高比（相对位置）"></a>使用锚点适应不同的宽高比（相对位置）</h4><ul><li><p>锚点Anchors</p><p>（父布局如Canvas和子布局如Img相对变换的关系）</p></li><li><p>Pivot控件自身的锚点</p><p>在Pivot模式下才能编辑（相当于自身坐标时吧，反之是世界坐标？）</p></li></ul><p>把控件锚定到各自的角落</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_MultiResCorners.png" alt="img"></p><h4 id="随屏幕尺寸缩放（相对大小）"><a href="#随屏幕尺寸缩放（相对大小）" class="headerlink" title="随屏幕尺寸缩放（相对大小）"></a>随屏幕尺寸缩放（相对大小）</h4><p>The <strong>Canvas Scaler</strong> component can be added to a root <strong>Canvas</strong></p><ul><li><p>UI缩放模式：随屏幕大小缩放</p></li><li><p>可以指定要用作参考的分辨率。如果当前屏幕分辨率小于或大于此参考分辨率，则会相应地设置 Canvas 的比例因子，以便所有 UI 元素与屏幕分辨率一起放大或缩小</p></li><li><p>缩放的方式也会带来效果的不同：</p><ul><li><p>添加 Canvas Scaler 组件后，检查布局在其他宽高比下的外观也很重要。通过将分辨率设置回 Phone HD 横向，我们可以看到按钮现在看起来比它们应该（和过去）更大。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_MultiResLandscapeWrongScaling.png" alt="img"></p><blockquote><p>横向宽高比中较大按钮的原因归结为画布缩放器设置的工作方式。默认情况下，它将宽度或当前分辨率与 Canvas 缩放器的宽度进行比较，并将结果用作缩放所有内容的比例因子。由于当前 960 x 640 的横向分辨率的宽度比 640 x 960 的纵向 Canvas 缩放器大 1.5 倍，因此布局放大了 1.5 倍。**[只比较宽度]**</p></blockquote></li><li><p><strong>Match</strong> 的属性，该属性可以是 0（宽度）、1（高度）或介于两者之间的值。默认情况下，它设置为 0，这会将当前屏幕宽度与画布缩放器宽度进行比较，如上所述。</p><p>如果 <strong>Match</strong> 属性设置为 0.5，它将当前宽度与参考宽度进行比较，将当前<strong>高度</strong>与参考高度进行比较，并选择介于两者之间的比例因子。由于在这种情况下，横向分辨率宽1.5倍，但也短1.5倍，因此这两个因素平衡并产生最终比例因子1，这意味着按钮保持其原始大小。</p></li></ul></li></ul><h3 id="Canvas-Group"><a href="#Canvas-Group" class="headerlink" title="Canvas Group"></a>Canvas Group</h3><p>The <strong>Canvas Group</strong> can be used to control certain aspects of a whole group of <strong>UI</strong> elements from one place without needing to handle them each individually. The properties of the Canvas Group affect the <strong>GameObject</strong> it is on as well as all children.</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_CanvasGroupInspector.png" alt="img"></p><table><thead><tr><th align="left">*<strong>Property:*</strong></th><th align="left">*<strong>Function:*</strong></th></tr></thead><tbody><tr><td align="left"><strong>Alpha</strong></td><td align="left">此组中 UI 元素的不透明度。该值介于 0 和 1 之间，其中 0 表示完全透明，1 表示完全不透明。请注意，元素也保留其自身的透明度，因此 Canvas Group Alpha 和各个 UI 元素的 Alpha 值将相互相乘。</td></tr><tr><td align="left"><strong>Interactable</strong></td><td align="left">确定此组件是否接受输入。当它设置为 false 交互时，将禁用该交互。</td></tr><tr><td align="left"><strong>Block Raycasts</strong></td><td align="left">此组件是否充当<strong>对撞机</strong><br>对于 Raycasts？您需要在连接到 Canvas 的图形光线投射器上调用 RayCast 函数。这<em>不适用于</em><strong>Physics.Raycast</strong>。</td></tr><tr><td align="left"><strong>Ignore Parent Groups</strong></td><td align="left">此组是否也会受到游戏对象层次结构中更上方的 Canvas 组组件中的设置的影响，还是会忽略这些设置并因此覆盖它们？</td></tr></tbody></table><p>Canvas Group 的典型用途包括：</p><ul><li>通过在窗口的游戏对象上添加画布组来淡入或淡出整个窗口，并控制其 Alpha 属性。</li><li>通过将 Canvas 组添加到父游戏对象并将其 Interactable 属性设置为 false，使整组控件不可交互（“灰显”）。</li><li>通过将 Canvas Group 组件放在元素或其父元素之一上，并将其 Block Raycasts 属性设置为 false，使一个或多个 UI 元素不阻止鼠标事件。</li></ul><h2 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h2><p>此子系统负责控制构成事件的所有其他元素。它协调当前处于活动状态的输入模块，哪个<strong>游戏对象</strong>目前被认为是“被选中的”，以及许多其他高级别<strong>事件系统</strong>概念。</p><h4 id="Graphic-Raycaster-图形光线投射器"><a href="#Graphic-Raycaster-图形光线投射器" class="headerlink" title="Graphic Raycaster 图形光线投射器"></a>Graphic Raycaster 图形光线投射器</h4><p>图形光线投射器用于<strong>对画布进行光线投射</strong>。Raycaster 会查看画布上的所有图形，并确定其中<strong>是否有任何图形被击中</strong>。</p><table><thead><tr><th align="left">*<strong>Property:*</strong></th><th align="left">*<strong>Function:*</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ignore Reversed Graphics</strong></td><td align="left">是否应考虑远离光线投射器的图形？</td></tr><tr><td align="left"><strong>Blocked Objects</strong></td><td align="left">将阻止图形光线投射的对象类型。</td></tr><tr><td align="left"><strong>Blocking Mask</strong></td><td align="left">Type of objects that will block graphic raycasts.</td></tr></tbody></table><h4 id="Physics-Raycaster"><a href="#Physics-Raycaster" class="headerlink" title="Physics Raycaster"></a>Physics Raycaster</h4><p>The Raycaster raycasts against <strong>3D objects</strong> in the <strong>scene</strong>. This allows messages to be sent to 3D physics objects that implement event interfaces.（意思是可以将点击事件反馈到3D物理对象上？）</p><table><thead><tr><th align="left">*<strong>Property:*</strong></th><th align="left">*<strong>Function:*</strong></th></tr></thead><tbody><tr><td align="left"><strong>Depth</strong></td><td align="left">Get the depth of the configured <strong>camera</strong> .</td></tr><tr><td align="left"><strong>Event Camera</strong></td><td align="left">Get the camera that is used for this module.</td></tr><tr><td align="left"><strong>Event Mask</strong></td><td align="left">Logical and of Camera mask and eventMask.</td></tr><tr><td align="left"><strong>Final Event Mask</strong></td><td align="left">Logical and of Camera mask and eventMask.</td></tr></tbody></table><h1 id="unity中括号"><a href="#unity中括号" class="headerlink" title="unity中括号"></a>unity中括号</h1><h2 id="HideInInspector"><a href="#HideInInspector" class="headerlink" title="[HideInInspector]"></a>[HideInInspector]</h2><p>让public变量在编辑器里不显示</p><h2 id="SerializeField"><a href="#SerializeField" class="headerlink" title="[SerializeField]"></a>[SerializeField]</h2><p>让private在编辑器里显示</p><h2 id="Range-0-100"><a href="#Range-0-100" class="headerlink" title="[Range(0,100)]"></a>[Range(0,100)]</h2><p>设定某个值的范围</p><h2 id="Header-“XXX”"><a href="#Header-“XXX”" class="headerlink" title="[Header(“XXX”)]"></a>[Header(“XXX”)]</h2><p>显示提示</p><h2 id="Tooltip-“XXX”"><a href="#Tooltip-“XXX”" class="headerlink" title="[Tooltip(“XXX”)]"></a>[Tooltip(“XXX”)]</h2><p>鼠标移至属性名产生提示</p><h2 id="Space-50"><a href="#Space-50" class="headerlink" title="[Space(50)]"></a>[Space(50)]</h2><p>空出几行</p><p><a href="https://zhuanlan.zhihu.com/p/101124913">Unity脚本用中括号引起来的属性 - 知乎 (zhihu.com)</a></p><h2 id="RequireComponent-typeof-XX"><a href="#RequireComponent-typeof-XX" class="headerlink" title="[RequireComponent(typeof(XX))]"></a>[RequireComponent(typeof(XX))]</h2><p>当你添加的一个用了RequireComponent组件的脚本，需要的组件将会自动被添加到game object（游戏物体）。这个可以有效的避免组装错误。</p><h1 id="昼夜交替"><a href="#昼夜交替" class="headerlink" title="昼夜交替"></a>昼夜交替</h1><p><a href="https://www.youtube.com/watch?v=H3JpkcGi8DI">DAY &amp; NIGHT CYCLE in Unity using HDRP (2019.3) - YouTube</a></p><h2 id="时间的范围和计时机制"><a href="#时间的范围和计时机制" class="headerlink" title="时间的范围和计时机制"></a>时间的范围和计时机制</h2><h2 id="模拟阳光的角度变换"><a href="#模拟阳光的角度变换" class="headerlink" title="模拟阳光的角度变换"></a>模拟阳光的角度变换</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*白天阳光的旋转角度*/</span></span><br><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;Sun Light&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Transform dailyRotation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustSunRotation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">float</span> sunAngle = timeOfDay * <span class="number">360f</span>;</span><br><span class="line">    dailyRotation.transform.localRotation = Quaternion.Euler(<span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, sunAngle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transform-localRotation"><a href="#Transform-localRotation" class="headerlink" title="Transform.localRotation"></a>Transform.localRotation</h3><ul><li><p>相对于父级变换旋转的变换旋转</p></li><li><p>Unity 在内部将旋转存储为四元数。要旋转对象，请使用 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Transform.Rotate.html">Transform.Rotate</a>。 要将旋转修改为欧拉角，请使用 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Transform-localEulerAngles.html">Transform.localEulerAngles</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.localRotation = Quaternion.identity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Quaternion-Euler"><a href="#Quaternion-Euler" class="headerlink" title="Quaternion.Euler"></a>Quaternion.Euler</h3><ul><li><p>public static <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Quaternion.html">Quaternion</a> <strong>Euler</strong> (float <strong>x</strong>, float <strong>y</strong>, float <strong>z</strong>);</p></li><li><p>返回一个旋转，它围绕 z 轴旋转 z 度、围绕 x 轴旋转 x 度、围绕 y 轴旋转 y 度（按该顺序应用）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// A rotation 30 degrees around the y-axis</span></span><br><span class="line">    Quaternion rotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>public static <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Quaternion.html">Quaternion</a> <strong>Euler</strong> (<a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.html">Vector3</a> <strong>euler</strong>);</p></li><li><p>返回一个围绕 Z 轴旋转 z 度、围绕 X 轴旋转 x 度、围绕 Y 轴旋转 y 度的旋转。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// A rotation 30 degrees around the y-axis</span></span><br><span class="line">      Vector3 rotationVector = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">      Quaternion rotation = Quaternion.Euler(rotationVector);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">### Unity中的旋转和方向</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>D 应用程序中的旋转通常以两种方式之一表示：四元数或欧拉角。每种方式都有自己的用途和缺点。Unity 在内部使用四元数表示，但在 Inspector 中显示等效的欧拉角值以便于进行编辑。</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 欧拉角</span></span><br><span class="line"></span><br><span class="line">​欧拉角由按顺序应用的 X、Y 和 Z 三个角度值来表示。要将欧拉旋转应用于特定游戏对象，则依次应用每个旋转值，作为围绕其对应轴的旋转。</span><br><span class="line"></span><br><span class="line">* 优点：具有直观的“可读”格式，由三个角度组成；可表示通过大于 <span class="number">180</span> 度转向从一个方向到另一个方向的旋转</span><br><span class="line"></span><br><span class="line">* 局限性：欧拉角受到[万向锁 (Gimbal Lock)](https:<span class="comment">//en.wikipedia.org/wiki/Gimbal_lock) 的影响。当依次施加三个旋转时，第一个或第二个旋转可能导致第三个轴的方向与先前两个轴之一相同。这意味着已失去“自由度”，因为不能围绕唯一轴应用第三个旋转值。</span></span><br><span class="line"></span><br><span class="line">  &gt; 先浅浅了解一下万向锁：[“欧拉角旋转”产生“万向锁”的来源，以及如何避免万向锁_哔哩哔哩_bilibili](https:<span class="comment">//www.bilibili.com/video/BV1YJ41127qe?spm_id_from=333.337.search-card.all.click)</span></span><br><span class="line">  &gt;</span><br><span class="line">  &gt; [计算机动画 ：用unity引擎演示万向节死锁（Gimbal Lock）现象 - 知乎 (zhihu.com)](https:<span class="comment">//zhuanlan.zhihu.com/p/376468636)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#### 四元数</span></span><br><span class="line"></span><br><span class="line">​四元数可用于表示&lt;u&gt;游戏对象的方向或旋转&lt;/u&gt;。此表示方式在内部由四个数字组成（在 Unity 中称为 x、y、z 和 w），但是这些数字&lt;u&gt;不代表角度或轴&lt;/u&gt;，您通常不需要直接访问它们。除非特别想深入研究[四元数的数学原理](https:<span class="comment">//en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)，否则只需要知道四元数&lt;u&gt;代表 3D 空间中的旋转即可&lt;/u&gt;，通常不需要知道或修改 x、y 和 z 属性。</span></span><br><span class="line"></span><br><span class="line">- **优点**：四元数旋转不受万向锁的影响。</span><br><span class="line">- **局限性**：单个四元数不能表示任何方向超过 <span class="number">180</span> 度的旋转。</span><br><span class="line">- **局限性**：四元数的数字表示在直观上难以理解。</span><br><span class="line"></span><br><span class="line">​Unity 在内部将所有游戏对象旋转存储为四元数，因为这种表示方式的好处超过了局限性。</span><br><span class="line"></span><br><span class="line">​Transform Inspector 会使用欧拉角显示旋转，因为这种形式更容易理解和编辑。Unity 将 Inspector 中输入的用于旋转游戏对象的新值转换为该游戏对象的新四元数旋转值</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 对动画的影响</span></span><br><span class="line"></span><br><span class="line">​许多 <span class="number">3</span>D 制作包以及 Unity 自己的内部 [Animation 窗口](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/AnimationEditorGuide.html)均允许使用欧拉角来指定动画期间的旋转。</span></span><br><span class="line"></span><br><span class="line">​这些旋转值通常可能超过四元数可表示的范围。例如，如果一个游戏对象旋转 <span class="number">720</span> 度，这可以用欧拉角“X：<span class="number">0</span>，Y：<span class="number">720</span>，Z：<span class="number">0</span>”表示。但这不能通过四元数值来表示。</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 四元数扩展</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">重要的类 - Quaternion - Unity 手册</span>](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/class-Quaternion.html)</span></span><br><span class="line"></span><br><span class="line">Unity 使用 Quaternion 类来存储游戏对象的三维方向，也使用它们来描述从一个方向到另一个方向的相对旋转。</span><br><span class="line"></span><br><span class="line">&lt;u&gt;处理脚本中的旋转时，应使用 Quaternion 类及其函数来创建和修改旋转值。&lt;/u&gt;在某些情况下，使用欧拉角也是有效的，但应记住： - 应使用处理欧拉角的 Quaternion 类函数 - 从旋转中检索、修改和重新应用欧拉值可能会导致意外的副作用</span><br><span class="line"></span><br><span class="line"><span class="meta">##### 直接创建和操作四元数</span></span><br><span class="line"></span><br><span class="line">* 创建旋转</span><br><span class="line"></span><br><span class="line">  ```csharp</span><br><span class="line">  <span class="comment">//Quaternion.LookRotaion</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Vector3 relativePos = target.position - transform.position;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// the second argument, upwards, defaults to Vector3.up</span></span><br><span class="line">          Quaternion rotation = Quaternion.LookRotation(relativePos, Vector3.up);</span><br><span class="line">          transform.rotation = rotation;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.Angle</span></span><br><span class="line">  <span class="comment">//返回两个旋转 a 和 b 之间的角度（以度为单位）</span></span><br><span class="line">  <span class="built_in">float</span> angle = Quaternion.Angle(transform.rotation, target.rotation);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.AngleAxis</span></span><br><span class="line">  <span class="comment">//创建一个围绕 axis 旋转 angle 度的旋转</span></span><br><span class="line">  transform.rotation = Quaternion.AngleAxis(<span class="number">30</span>, Vector3.up);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.FromToRotation</span></span><br><span class="line">  <span class="comment">//创建一个从 fromDirection 旋转到 toDirection 的旋转</span></span><br><span class="line">  transform.rotation = Quaternion.FromToRotation(Vector3.up, transform.forward);</span><br></pre></td></tr></table></figure></li><li><p>操作旋转</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Quaternion.Slerp</span></span><br><span class="line"><span class="comment">//Quaternion 在四元数 a 和 b 之间进行球形插值的四元数,参数 t 限制在范围 [0, 1] 内</span></span><br><span class="line"><span class="comment">//这可用于创建一个旋转，以基于参数的值 a，在第一个四元数 a 到第二个四元数 b 之间平滑进行插值。如果参数的值接近于 0，则输出会接近于 /a/，如果参数的值接近于 1，则输出会接近于 /b/</span></span><br><span class="line"><span class="keyword">public</span> Transform <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timeCount = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.rotation = Quaternion.Slerp(<span class="keyword">from</span>.rotation, to.rotation, timeCount);</span><br><span class="line">        timeCount = timeCount + Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quaternion.Inverse</span></span><br><span class="line"><span class="comment">//返回 rotation 的反转</span></span><br><span class="line">Transform target;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.rotation = Quaternion.Inverse(target.rotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quaternion.RotateTowards</span></span><br><span class="line"><span class="comment">//将旋转 from 向 to 旋转。将 from 四元数朝 to 旋转 maxDegreesDelta 的角度步长（但请注意， 该旋转不会过冲）。 如果 maxDegreesDelta 为负值，则向远离 to 的方向旋转，直到旋转 恰好为相反的方向。</span></span><br><span class="line"><span class="comment">// The object whose rotation we want to match.</span></span><br><span class="line">Transform target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Angular speed in degrees per sec.</span></span><br><span class="line"><span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The step size is equal to speed times frame time.</span></span><br><span class="line">    <span class="keyword">var</span> step = speed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate our transform a step closer to the target&#x27;s.</span></span><br><span class="line">    transform.rotation = Quaternion.RotateTowards(transform.rotation, target.rotation, step);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用欧拉角</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某些情况下，更适合在脚本中使用欧拉角。这时，请务必注意，必须将角度保存在变量中，在使用它们的时候，仅将它们作为欧拉角应用于旋转，最终仍应存储为 Quaternion。虽然可从四元数中获取欧拉角，但在获取、修改和重新应用时，可能会出现问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转脚本错误 #1</span></span><br><span class="line"><span class="comment">// 此处的错误在于我们正在修改四元数的 x 值</span></span><br><span class="line"><span class="comment">// 此值不表示角度，不会产生所需的结果</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> rot = transform.rotation;</span><br><span class="line">    rot.x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = rot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转脚本错误 #2</span></span><br><span class="line"><span class="comment">// 从四元数读取、修改并写入欧拉值。</span></span><br><span class="line"><span class="comment">// 因为这些值是从四元数计算的，</span></span><br><span class="line"><span class="comment">// 所以每个新的旋转可能会返回非常不同的欧拉角，而这可能会受到万向锁的影响。</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> angles = transform.rotation.eulerAngles;</span><br><span class="line">    angles.x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = Quaternion.Euler(angles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确使用欧拉角的旋转脚本。</span></span><br><span class="line"><span class="comment">// 将欧拉角存储在一个类变量中，并仅使用</span></span><br><span class="line"><span class="comment">// 该变量作为欧拉角进行应用，但从不依赖于读回欧拉值。</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">float</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = Quaternion.Euler(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="阳光变换过程中的处理"><a href="#阳光变换过程中的处理" class="headerlink" title="阳光变换过程中的处理"></a>阳光变换过程中的处理</h2><h3 id="阳光的强度"><a href="#阳光的强度" class="headerlink" title="阳光的强度"></a>阳光的强度</h3><p>（待研究</p><h3 id="阳光的颜色"><a href="#阳光的颜色" class="headerlink" title="阳光的颜色"></a>阳光的颜色</h3><h2 id="ui和时间的绑定"><a href="#ui和时间的绑定" class="headerlink" title="ui和时间的绑定"></a>ui和时间的绑定</h2><h2 id="Unity实时阴影"><a href="#Unity实时阴影" class="headerlink" title="Unity实时阴影"></a>Unity实时阴影</h2><p><a href="https://blog.csdn.net/qq_35711014/article/details/106746027">(34条消息) Unity角色实时阴影方案_一克拉绿豆的博客-CSDN博客_unity 实时阴影</a></p><h1 id="Nav-Mesh-Agent-导航网格代理"><a href="#Nav-Mesh-Agent-导航网格代理" class="headerlink" title="Nav Mesh Agent 导航网格代理"></a>Nav Mesh Agent 导航网格代理</h1><p>NavMeshAgent 组件可帮助您创建在朝目标移动时能够彼此避开的角色。代理 (Agent) 使用导航网格来推断游戏世界，并知道如何避开彼此以及其他移动障碍物。寻路和空间推断是使用导航网格代理的脚本 API 进行处理的。</p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul><li>从一点走到一点</li><li>需要考虑：阻挡，路径选择，可行路径，地形特点（沙地草地等）……</li></ul><h2 id="游戏中常用的导航情况"><a href="#游戏中常用的导航情况" class="headerlink" title="游戏中常用的导航情况"></a>游戏中常用的导航情况</h2><ul><li>ai角色：纯导航</li><li>主角：ui交互控制下的导航——？</li></ul><h2 id="导航的常用算法"><a href="#导航的常用算法" class="headerlink" title="导航的常用算法"></a>导航的常用算法</h2><ul><li>A*算法（广度优先）<ul><li>广泛应用于2D格子型地图</li></ul></li><li>navigation mesh的寻路算法原理<ul><li>A*算法的变种</li><li>将A*算法的格子变成三角形或多边形网络<ul><li>如何构建合理高效的三角形网格，即navigation Mesh</li></ul></li><li>可以方便地从二维扩展到三维</li><li>3D游戏的主流寻路算法（基于三角形网格）</li></ul></li></ul><h2 id="导航网格制作"><a href="#导航网格制作" class="headerlink" title="导航网格制作"></a>导航网格制作</h2><h3 id="标记哪些物体是属于导航网格的"><a href="#标记哪些物体是属于导航网格的" class="headerlink" title="标记哪些物体是属于导航网格的"></a>标记哪些物体是属于导航网格的</h3><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/b2b81d3d8b6ef4db.png" alt="image-20220527210302934"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/a6914beef4d9ff26.png" alt="image-20220527210737542"></p><blockquote><p>可以在这个视图中查看到物体被纳入</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/0294525fcd76abd0.png" alt="image-20220527210825800"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/0423c1f54e4e0037.png" alt="image-20220527210839518"></p><blockquote><p>Bake会出现这些三角形网格。这些物体也是被设为navigation static的</p></blockquote><ul><li>一般会用虚拟物来自定义导航网格的面积，基于模型的话生成的结果可能偏差很大</li></ul><h2 id="控制物体在导航网格上行走"><a href="#控制物体在导航网格上行走" class="headerlink" title="控制物体在导航网格上行走"></a>控制物体在导航网格上行走</h2><ul><li><p>加上Nav Mesh Agent组件</p></li><li><p>脚本控制方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*首先要声明using UnityEngine.AI*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1.自动导航到目标坐标（朝向默认为z轴）</span></span><br><span class="line">  NevMeshAgent agent = Get...</span><br><span class="line">  agent.SetDestination(<span class="keyword">new</span> Vector3(,,));</span><br><span class="line"></span><br><span class="line">​可以展示导航情况；目标在网格外的话就停在网格内</span><br><span class="line"></span><br><span class="line">&gt; 路线是提前设置好并算死了的而且不会考虑碰撞，如果路上遇到阻碍可能会卡在那儿；</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果物体离网格太远的话会无法生成代理？会发出警告</span><br><span class="line"></span><br><span class="line">* 组件的参数设置：[导航网格代理 (NavMesh Agent) - Unity 手册](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/class-NavMeshAgent.html)</span></span><br><span class="line">* 在实践中角色行走会很卡顿不流畅？</span><br><span class="line"></span><br><span class="line"><span class="meta">## Nav Mesh  Obstacle组件</span></span><br><span class="line"></span><br><span class="line">阻碍物（不可行走类型）可以随着移动而动态变化烘焙的网格。</span><br><span class="line"></span><br><span class="line"><span class="meta"># 鼠标对人物行走的控制</span></span><br><span class="line"></span><br><span class="line"><span class="meta">## 鼠标点击控制人物运动</span></span><br><span class="line"></span><br><span class="line"><span class="meta">### 鼠标点击的位置落在模型上</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">移动设备输入 - Unity 手册</span>](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/MobileInput.html)</span></span><br><span class="line"></span><br><span class="line">```<span class="function">csharp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Ray ray = cam.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">            RaycastHit hit;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;We hit&quot;</span> + hit.collider.name);</span><br><span class="line">                Debug.DrawRay(ray.origin, ray.direction * <span class="number">10</span>, Color.yellow,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Camera.ScreenPointToRay()</p><p>public <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Ray.html">Ray</a> <strong>ScreenPointToRay</strong> (<a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.html">Vector3</a> <strong>pos</strong>);</p><ul><li>从摄像机的方向发出的一条到鼠标点方向的射线</li><li>易看出摄像机点是固定的，鼠标在屏幕周围映射到四方，呈现点射光的状态</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/938081b90cf4959a.png" alt="image-20220528101846438"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/629ff5209bdefd99.png" alt="image-20220528102026215"></p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;We hit&quot;</span> + hit.collider.name);</span><br><span class="line">    Debug.DrawRay(ray.origin, ray.direction * <span class="number">10</span>, Color.yellow,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生出光线之后，赋予物理属性，即可发生碰撞，这样就能与场景中的物体产生互动。</p></blockquote><h2 id="自动导航到目标点"><a href="#自动导航到目标点" class="headerlink" title="自动导航到目标点"></a>自动导航到目标点</h2><h2 id="导航造成动画卡顿和小鸡无法获得主角的动态位置"><a href="#导航造成动画卡顿和小鸡无法获得主角的动态位置" class="headerlink" title="导航造成动画卡顿和小鸡无法获得主角的动态位置"></a>导航造成动画卡顿和小鸡无法获得主角的动态位置</h2><ul><li><p>isKinematic:关闭动力学的模拟；覆盖use gravity，不受重力影响</p><p>由此position将完全由脚本或者动画控制。</p><p><a href="https://www.kchuhai.com/report/view-4168.html">改变Rigidbody组件中IsKinematic属性的实验 - 快出海 (kchuhai.com)</a></p></li><li><p>为什么主角加上Nav组件，rigidbody勾选use gravity就卡住不动，把动力学取消了就能艰难移动？</p></li><li><p>小鸡无法跟踪是因为之前把project的prefab拖进去了，要拖进hierarchy的才行……</p></li></ul><h1 id="自动导航与刚体运动的冲突"><a href="#自动导航与刚体运动的冲突" class="headerlink" title="自动导航与刚体运动的冲突"></a>自动导航与刚体运动的冲突</h1><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/01a2abb988c7094a.png" alt="image-20220530150307740"></p>]]></content>
    
    
    <summary type="html">结课作业第一波：第一次尝试想法先行，后操作</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity入门(二)</title>
    <link href="https://huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>https://huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-06-18T03:19:52.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3D动画"><a href="#3D动画" class="headerlink" title="3D动画"></a>3D动画</h1><p>终于弄懂是怎么回事了！！</p><h2 id="Avatar到底干啥用"><a href="#Avatar到底干啥用" class="headerlink" title="Avatar到底干啥用"></a>Avatar到底干啥用</h2><p>Avatar是得和模型部位一一对应的。</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/0f7dd9e233365448.png" alt="image-20220411165207704"></p><blockquote><p>avatar的对应的总的那个东西，点击进行修改</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/f4b8ac4b9f7308b6.png" alt="image-20220411165247758"></p></blockquote><h2 id="外部导入的动画设置成Humanoid"><a href="#外部导入的动画设置成Humanoid" class="headerlink" title="外部导入的动画设置成Humanoid"></a>外部导入的动画设置成Humanoid</h2><p>这是动画对应模型的关键部分！！比如跳拉丁舞的动画如何映射到僵尸身上——首先僵尸已经绑定了对应的Avatar，相当于绑定了每个主要关节、部位等等。然后unity通过Humanoid设置将动画也一一对应映射，所以模型和动画就能对应一起了！！</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/79d4bf8aeef02eb7.png" alt="image-20220411165328998"></p><blockquote><p>进avatar查看，发现会有对应的绑定部分。</p></blockquote><p>所以是模型对应了avatar，才能重用各种动画。要把顺序和逻辑理清啊！</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/86081fb00add0dd0.png" alt="image-20220411165521134"></p><blockquote><p>搞了好久，僵尸终于如愿以偿开始舞蹈</p></blockquote><h2 id="对动画片段的设置"><a href="#对动画片段的设置" class="headerlink" title="对动画片段的设置"></a>对动画片段的设置</h2><h3 id="设置是否循环Loop"><a href="#设置是否循环Loop" class="headerlink" title="设置是否循环Loop"></a>设置是否循环Loop</h3><p>要在Project面板上的资源那点击才会出现，在controller点击的话会见不到</p><h1 id="切水果简易版"><a href="#切水果简易版" class="headerlink" title="切水果简易版"></a>切水果简易版</h1><h2 id="2D视图3D游戏"><a href="#2D视图3D游戏" class="headerlink" title="2D视图3D游戏"></a>2D视图3D游戏</h2><p>将摄像机的background变成纯色，然后把y变成0，这样就创建的球体就能居中显示在画面中心。还有把透视改成正视Orthographic</p><h2 id="3D模型挂有Rigidbody2D＆Circle-Collider-2D"><a href="#3D模型挂有Rigidbody2D＆Circle-Collider-2D" class="headerlink" title="3D模型挂有Rigidbody2D＆Circle Collider 2D"></a>3D模型挂有Rigidbody2D＆Circle Collider 2D</h2><p>仍可下落</p><h2 id="鼠标移动＋切片"><a href="#鼠标移动＋切片" class="headerlink" title="鼠标移动＋切片"></a>鼠标移动＋切片</h2><h3 id="鼠标按下-松开的状态"><a href="#鼠标按下-松开的状态" class="headerlink" title="鼠标按下/松开的状态"></a>鼠标按下/松开的状态</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isCutting = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取鼠标按下状态</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            StartCutting();</span><br><span class="line">        <span class="comment">//获取鼠标松开状态</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            StopCutting();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果正在切，将更新鼠标位置</span></span><br><span class="line">        <span class="keyword">if</span> (isCutting)</span><br><span class="line">        &#123;</span><br><span class="line">            UpdateCut();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateCut</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//更改鼠标状态值（这种写代码逻辑很清晰）</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartCutting</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        isCutting = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StopCutting</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        isCutting = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="跟随鼠标位置"><a href="#跟随鼠标位置" class="headerlink" title="跟随鼠标位置"></a>跟随鼠标位置</h3><p>如何获取鼠标的位置？？有一个方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input.MousePostition</span><br><span class="line"><span class="comment">//但是由于鼠标位置是屏幕坐标，值会比想象中大很多？（为啥</span></span><br><span class="line"><span class="comment">//所以要转换成世界坐标</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//利用主摄像机来转换？（为什么是摄像机啊</span></span><br><span class="line"><span class="comment">//在这里也用了rigidbody的position，为什么不直接用transfrom呢。transform是只读的，position好像没搞出来，不认</span></span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/d535d7daead35026.png" alt="image-20220418145449652"></p><blockquote><p>把刀片的这个组件类型换成这个，不受重力或啥的影响</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取主相机</span></span><br><span class="line">    cam = Camera.main;</span><br><span class="line">    rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateCut</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//转换坐标：待研究，竟然是用相机转换坐标空间，不在摄像机里面的就不能转吗</span></span><br><span class="line">    rb.position = cam.ScreenToWorldPoint(Input.MousePosition());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="根据鼠标位置生成轨迹：组件TrailRenderer"><a href="#根据鼠标位置生成轨迹：组件TrailRenderer" class="headerlink" title="根据鼠标位置生成轨迹：组件TrailRenderer"></a>根据鼠标位置生成轨迹：组件TrailRenderer</h3><p>在子对象添加这个组件（为什么在子对象添加更好呢？）不是LineRenderer!!笑死我自己，长得很像但老有参数找不着，太傻了</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/2fdbcae93a2670e7.png" alt="image-20220418151705532"></p><blockquote><p>Time：消失时间</p><p>Material：可以添加材质，shader可以改成Sprites默认值，这样就可以显示纯色，否则默认3D材质会有质感</p></blockquote><h3 id="解决轨迹随鼠标松开即消失的问题"><a href="#解决轨迹随鼠标松开即消失的问题" class="headerlink" title="解决轨迹随鼠标松开即消失的问题"></a>解决轨迹随鼠标松开即消失的问题</h3><p>设想如果鼠标点击很短然后又迅速点很多下，轨迹是不太好看的。而且希望在点击其它地方时之前的轨迹会留有余痕。因为带有轨迹渲染组件的对象是刀片的子对象，会立刻随着鼠标位置变化。所以希望在点击时是子对象，松开时是非子对象，这样就实现了捆绑＋及时脱离。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartCutting</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    isCutting = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//点击的时候才实例化一个轨迹对象</span></span><br><span class="line">    <span class="comment">//构造函数好像包含了当前组件的transform，就能把当前对象认为父对象</span></span><br><span class="line">    <span class="comment">//一个私有的对象引用它</span></span><br><span class="line">    currentBladeTrail = Instantiate(bladeTrailPrefab, transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StopCutting</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    isCutting = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//松开，取消父对象</span></span><br><span class="line">    currentBladeTrail.transform.SetParent(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//并在一定时间后删除这个对象</span></span><br><span class="line">    Destroy(currentBladeTrail, <span class="number">2f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="轨迹＋碰撞"><a href="#轨迹＋碰撞" class="headerlink" title="轨迹＋碰撞"></a>轨迹＋碰撞</h2><p>拖尾的效果有了，而我们需要实际的碰撞来进行实际的切片。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/327d42dde8c3235a.png" alt="image-20220418163505743"></p><blockquote><p>添加这个组件。然后设为点击才启用这个玩意儿。具体代码不贴了，在相应的地方用enabled方法开启或关闭</p></blockquote><p>但是希望在鼠标划切时才有碰撞的力度，不然只是单击不拖动也会有碰撞效果，no no no</p><p>这时候测量的一个维度就是速度，本来刚体有velocity方法来获取当前速度，但刚体已经被更换成其它类型，不受力的作用，速度方法也就用不了了，所以需要自定义</p><h3 id="自定义测速"><a href="#自定义测速" class="headerlink" title="自定义测速"></a>自定义测速</h3><p>unity很重要的概念是实时，帧率，意味着固定时间。既然时间已经固定了，那么位移的大小就能代表速度的大小。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateCut</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Vector2 newPosition = cam.ScreenToWorldPoint(Input.mousePosition);</span><br><span class="line">    rb.position = newPosition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//涉及到固定时间的，用deltaTime固定一下【大概这样理解吧】</span></span><br><span class="line">    <span class="built_in">float</span> velocity = (newPosition - previousPosition).magnitude * Time.deltaTime;</span><br><span class="line">    <span class="keyword">if</span>( velocity &gt; minCuttingVelocity )&#123;</span><br><span class="line">        circleCollider.enabled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//勿漏。实时更新前一个位置</span></span><br><span class="line">    previousPosition = newPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/69783902727cb5e9.png" alt="image-20220419162935961"></p><p>所以能获得一个非负数。</p></blockquote><p>以上是考虑当在切的时候的速度。因为prePosition记录的是点击的上一帧的位置，所以重新点击的时候还是用的这个数据。所以要改改</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartCutting</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    isCutting = <span class="literal">true</span>;</span><br><span class="line">    currentBladeTrail = Instantiate(bladeTrailPrefab, transform);</span><br><span class="line">    circleCollider.enabled = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//重新点击时，将上一帧位置赋为鼠标点击位置</span></span><br><span class="line">    previousPosition = cam.ScreenToWorldPoint(Input.mousePosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标和水果碰撞的本质"><a href="#鼠标和水果碰撞的本质" class="headerlink" title="鼠标和水果碰撞的本质"></a>鼠标和水果碰撞的本质</h2><p>归根到底其实也还是物理物体和物体的碰撞。定义一个有rigidbody和collider的游戏对象跟随鼠标位置，然后实际上能与水果发生碰撞（因为是屏幕空间，所以用2D，这样就不考虑z轴的差距）</p><h2 id="碰撞之后裂开"><a href="#碰撞之后裂开" class="headerlink" title="碰撞之后裂开"></a>碰撞之后裂开</h2><p>也就是在碰撞时原瓜消失，一个两半瓜实例生成，然后预先将俩瓜碰撞体相斥然后自然就裂开了。</p><h3 id="裂开的方向"><a href="#裂开的方向" class="headerlink" title="裂开的方向"></a>裂开的方向</h3><p>如果不做方向调整的话，瓜将始终朝一个方向裂开，这看起来会不太真实。所以得计算出裂开的方向。</p><p>跟着教程做了，但是裂开的西瓜总是乱飙，不但位置不对，旋转的方向也不对。这bug还是得细究一下。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D col</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(col.tag == <span class="string">&quot;Blade&quot;</span>)&#123;</span><br><span class="line">        <span class="comment">//这个是被切西瓜的代码，col是鼠标的刚体</span></span><br><span class="line">        <span class="comment">//碰撞的位置-西瓜的位置</span></span><br><span class="line">        <span class="comment">//两者其实都是三维的物体，但用的是二维的碰撞体和刚体，所以位置都可以运算成三维向量</span></span><br><span class="line">        <span class="comment">//鼠标碰撞的位置始终是x,y平面上，被切西瓜也是。所以计算出来的是z为0的三维向量。想象一下生成的二维向量怎么指：沿圆的半径。</span></span><br><span class="line">        Vector3 direction = (col.transform.position - transform.position).normalized;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//详见往后的四元数解析</span></span><br><span class="line">        Quaternion rotation = Quaternion.LookRotation(direction);</span><br><span class="line"></span><br><span class="line">        Instantiate(fruitSlicedPrefab, transform.position, rotation);</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/2a0032a405805e41.png" alt="image-20220419163104347"></p><p>所以这里获取了切的方向</p></blockquote><h2 id="四元数学习"><a href="#四元数学习" class="headerlink" title="四元数学习"></a>四元数学习</h2><p>首先这个方法是这样定义的</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Quaternion <span class="title">LookRotation</span>(<span class="params">Vector3 forward, Vector3 upwards = Vector3.up</span>)</span>;</span><br></pre></td></tr></table></figure><p>forward又是什么？继续探究🧐</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/8b75ef443cbb2553.png" alt="image-20220419163822551"></p><blockquote><p>Vector3 里面有很多默认的简称。经测验，forward指向z轴，（0，0，1）</p><p>up就是y轴，（0，1，0）</p><p>其余根据这两条推导</p></blockquote><p>那么回到那个函数，官方回答：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You can also use transform.LookAt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ExampleClass</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Transform target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos = target.position - transform.position;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the second argument, upwards, defaults to Vector3.up</span></span><br><span class="line">        Quaternion rotation = Quaternion.LookRotation(relativePos, Vector3.up);</span><br><span class="line">        transform.rotation = rotation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我理解是第一个参数将是forward所要指向的方向，第二个可能考虑会沿z轴旋转，所以进行钳制</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/722081d4c805895e.png" alt="image-20220419165046179"></p><blockquote><p>由图可看出z轴方向会沿着计算的向量方向，为了使裂开的开口对着屏幕，开口应该平行于z轴。然后不确定y的话开口可能沿着z轴旋转，所以钳制y。按照图二进行坐标轴的修改，就达到了想要的效果！！🎉🎉🎉🎉🎉（尽管还有略微的差异</p></blockquote><ul><li>顺便提一嘴：碰撞体的形状也是有微妙差别，为啥我会一上手就胶囊碰撞体……碰撞的效果就很奇怪。</li></ul><h2 id="切的时候物体消失，和物理系统有关？"><a href="#切的时候物体消失，和物理系统有关？" class="headerlink" title="切的时候物体消失，和物理系统有关？"></a>切的时候物体消失，和物理系统有关？</h2><p>问题如上，把裂开西瓜的use gravity取消掉，切的时候是正常受力的，但是一打开就切了立马消失。但是裂开西瓜单独掉下的时候并没有问题。</p><p>难道是两者转换的时候物理系统出了冲突？</p><p>难道是刷新</p><h2 id="为游戏赋予自定的模型和贴图"><a href="#为游戏赋予自定的模型和贴图" class="headerlink" title="为游戏赋予自定的模型和贴图"></a>为游戏赋予自定的模型和贴图</h2><p>把完整的球体和裂开的球体分别设计成自己想要的。基本方法就是在maya展uv用Ps绘制，然后再导入maya，再导出fbx文件到unity（很麻烦就是说）</p><ul><li>遇到maya导出文件的材质丢失问题。应该是材质所需的图片也应该在unity工程上面，我以为maya导出的模型自带图片的信息，但是还得放进工程中。</li></ul><h2 id="脚本的prefab对象-一定要导入工程文件中的"><a href="#脚本的prefab对象-一定要导入工程文件中的" class="headerlink" title="脚本的prefab对象 一定要导入工程文件中的"></a>脚本的prefab对象 一定要导入工程文件中的</h2><p>一言难尽，就总是要么脚本中拖入的prefab突然消失，不生效什么的，很细节的东西顾东不及西的感觉，就很烦，希望不要再踩这个坑了，浪费时间</p><h2 id="水果汁喷溅效果（Particle-System）"><a href="#水果汁喷溅效果（Particle-System）" class="headerlink" title="水果汁喷溅效果（Particle System）"></a>水果汁喷溅效果（Particle System）</h2><p><img src="/huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421145456159.png" alt="image-20220421145456159"></p><blockquote><p>看起来就是两个三角形组成的面片</p></blockquote><p><img src="/huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421151339608.png" alt="image-20220421151339608"></p><blockquote><p>首先是基本的设置，鼠标移动到相应属性有说明，应该也能猜出</p></blockquote><p><img src="/huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421151410665.png" alt="image-20220421151410665"></p><blockquote><p>发射器的形状，这里选了球体，因为只发射一粒所以没很大用处</p></blockquote><ul><li>Color over life time: 颜色变化</li><li>Size over Lifetime: 大小变化</li><li>Renderer：每个粒子的贴图</li><li>粒子发射器的参数非常地多也非常地灵活，还能点击右边的三角形进行下拉菜单选择</li></ul><p><img src="/huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421152714285.png" alt="image-20220421152714285"></p><blockquote><p>公告牌：意思是粒子始终面向摄像机。可以设置为拉伸等</p></blockquote><h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p>字的正向要和发射点的轴方向一致才能出现效果。我刚开始想着非得朝前为z，然后没有考虑一致的问题，所以总是看不到正面。这玩意真的令人摸不着头脑</p><h2 id="随机发射实现"><a href="#随机发射实现" class="headerlink" title="随机发射实现"></a>随机发射实现</h2><ul><li>在哪发射，发射什么：先简略描述一下。设置不同位置不同角度的发射点组成一个数组，每一帧都随机挑取一个点发射物体，而物体是物体数组的随机一个</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random.Range(num1, num2);</span><br></pre></td></tr></table></figure><ul><li><p>怎么发射：对于物体来说，一创建就受到力的作用；对于spawn来说，创建并将发射点的position和rotation赋给它们就好。</p></li><li><p>bug：还是不够深入了解rigidbody和collider。没有解决勾选use Gravity后划切就消失的问题；没有解决物体改成rigidbody但点击消失的问题。</p><p>【后续：不知为啥某天更改之后又可以了，这个bug并不明显…？】</p></li></ul><h2 id="加载场景后灯光变暗问题"><a href="#加载场景后灯光变暗问题" class="headerlink" title="加载场景后灯光变暗问题"></a>加载场景后灯光变暗问题</h2><ul><li>加载场景方法：</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SceneManager.Load(<span class="string">&quot;scene name&quot;</span>);</span><br><span class="line">SceneManager.Load(SceneManager.GetActiveScene().name);<span class="comment">//获得当前场景及其名字</span></span><br></pre></td></tr></table></figure><ul><li><p>发现问题：重新加载之后场景中的默认平行光和摄像机消失了，所以物体呈现变暗的效果。</p></li><li><p>解决办法：Lighting窗口—Scene—右下角的烘焙操作？？然后就可以了。不知道为什么，神奇，待深究。</p><p><img src="/huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220502160911194.png" alt="image-20220502160911194"></p></li></ul><h1 id="Unity协程（IE-numerator）"><a href="#Unity协程（IE-numerator）" class="headerlink" title="Unity协程（IE numerator）"></a>Unity协程（IE numerator）</h1><h2 id="如果没有协程"><a href="#如果没有协程" class="headerlink" title="如果没有协程"></a>如果没有协程</h2><ul><li>调用函数时，函数将运行到完成状态，然后返回。这实际上意味着在函数中发生的任何动作都必须在<strong>单帧更新</strong>内发生；函数调用不能用于包含程序性动画或随时间推移的一系列事件。一帧内就更新完了，比如几秒的动画或需要花时间的就执行不了。</li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程就像一个函数，🧐能够暂停执行并将控制权返还给 Unity，然后在下一帧继续执行🧐。在 C# 中，声明协程的方式如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用返回类型IEnumerator声明的函数</span></span><br><span class="line"><span class="comment">/*执行内容*/</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">Fade</span>(<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">float</span> f = <span class="number">1f</span>; f &gt;= <span class="number">0</span>; f -= <span class="number">0.1f</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Color c = renderer.material.color;</span><br><span class="line">        c.a = f;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;  <span class="comment">//在主体某个位置中；暂停执行并随后在下一帧恢复的点</span></span><br><span class="line">    &#125;<span class="comment">//在这里，某次循环的结束暂停，然后在下一次循环之前（下一帧）开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行开始*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input.GetKeyDown(<span class="string">&quot;f&quot;</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(<span class="string">&quot;Fade&quot;</span>);<span class="comment">//开始</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非逐帧执行，还想再延迟（WaitForSeconds）"><a href="#非逐帧执行，还想再延迟（WaitForSeconds）" class="headerlink" title="非逐帧执行，还想再延迟（WaitForSeconds）"></a>非逐帧执行，还想再延迟（WaitForSeconds）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">Fade</span>(<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">float</span> f = <span class="number">1f</span>; f &gt;= <span class="number">0</span>; f -= <span class="number">0.1f</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        Color c = renderer.material.color;</span><br><span class="line">        c.a = f;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">.1</span>f</span>)</span>;<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用：在一段时间内传播效果；👉有用的优化"><a href="#作用：在一段时间内传播效果；👉有用的优化" class="headerlink" title="作用：在一段时间内传播效果；👉有用的优化"></a>作用：在一段时间内传播效果；👉有用的优化</h3><ul><li><p>定期执行的任务，不需要逐帧重复任务时，可以放在协程中来进行定期更新。</p><blockquote><p>实例：在附近有敌人时向玩家发出的警报</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">ProximityCheck</span>(<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; enemies.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Vector3.Distance(transform.position, enemies[i].transform.position) &lt; dangerDistance)  &#123;<span class="comment">//每帧逐个检查敌人的位置远近，开销很大</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用协程，每0.1f调用一次</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">DoCheck</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        ProximityCheck;</span><br><span class="line">        <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">.1</span>f</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>协程并不会在Unity中开辟新的线程来执行，其执行<strong>仍然发生在主线程</strong>中。</p></li><li><p>调用协程的方法有两种</p><ul><li>StartCoroutine(//<em>这里直接调用方法，添加参数</em>//);</li><li>StartCoroutine(//<em>这里填写”字符串的方法名字”，方法参数</em>//);</li></ul><blockquote><p>前者</p><p>😏优势：可以调用多个参数的方法</p><p>🙃不足：不能通过StopCoroutine(/<em>这里填写”字符串的方法名”</em>/)来结束协程，只能通过StopAllCoroutines来结束</p><p>后者</p><p>🙃不足：只能调用不含参数或只包含一个参数的协程方法</p><p>😏优势：可以通过StopCoroutine来结束对正在执行的协程的调用</p></blockquote></li><li><p>当某一个脚本中的协程在执行过程中，如果我们将该脚本的enable设置为false，协程不会停止。只有将挂载该脚本的物体设置为SetActive(false)时才会停止。</p></li><li><p>Unity在调用StartCoroutine()后不会等待协程中的内容返回，会立即执行后续代码。</p></li><li><p>yield return的介绍：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//下一帧再执行后续代码</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//下一帧再执行后续代码</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">6</span>;<span class="comment">//(任意数字) 下一帧再执行后续代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">break</span>; <span class="comment">//直接结束该协程的后续操作</span></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">return</span> asyncOperation;<span class="comment">//等异步操作结束后再执行后续代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">StartCoroution</span>(<span class="params"><span class="comment">/*某个协程*/</span></span>)</span>;<span class="comment">//等待某个协程执行完毕后再执行后续代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*以下待深入了解*/</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">WWW</span>(<span class="params"></span>)</span>;<span class="comment">//等待WWW操作完成后再执行后续代码</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForEndOfFrame</span>(<span class="params"></span>)</span>;<span class="comment">//等待帧结束,等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前执行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">0.3f</span></span>)</span>;<span class="comment">//等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间会受到Time.timeScale的影响）;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSecondsRealtime</span>(<span class="params"><span class="number">0.3f</span></span>)</span>;<span class="comment">//等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间不受到Time.timeScale的影响）;</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="title">WaitForFixedUpdate</span>(<span class="params"></span>)</span>;<span class="comment">//等待下一次FixedUpdate开始时再执行后续代码</span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitUntil</span>(<span class="params"></span>)<span class="comment">//将协同执行直到 当输入的参数（或者委托）为true的时候....如:yield return new WaitUntil(() =&gt; frame &gt;= 10);</span></span></span><br><span class="line"><span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitWhile</span>(<span class="params"></span>)<span class="comment">//将协同执行直到 当输入的参数（或者委托）为false的时候.... 如:yield return new WaitWhile(() =&gt; frame &lt; 10);</span></span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">冲冲冲</summary>
    
    
    
    <category term="Unity" scheme="https://huangxinhere.github.io/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>作品集</title>
    <link href="https://huangxinhere.github.io/2022/04/09/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    <id>https://huangxinhere.github.io/2022/04/09/%E4%BD%9C%E5%93%81%E9%9B%86/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2023-02-28T11:10:11.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参赛-GameJam作品"><a href="#参赛-GameJam作品" class="headerlink" title="参赛/GameJam作品"></a>参赛/GameJam作品</h1><h2 id="2022吉比特高校挑战赛《太阳羊》-银奖（2022-11）"><a href="#2022吉比特高校挑战赛《太阳羊》-银奖（2022-11）" class="headerlink" title="2022吉比特高校挑战赛《太阳羊》 银奖（2022.11）"></a>2022吉比特高校挑战赛《太阳羊》 银奖（2022.11）</h2><iframe src="//player.bilibili.com/player.html?aid=562291028&bvid=BV1Zv4y1D7o7&cid=883463176&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h1 id="课程作品集"><a href="#课程作品集" class="headerlink" title="课程作品集"></a>课程作品集</h1><h2 id="Unity（2021—2022大二下）"><a href="#Unity（2021—2022大二下）" class="headerlink" title="Unity（2021—2022大二下）"></a>Unity（2021—2022大二下）</h2><ul><li>计设负责的小游戏部分</li><li>两周时间期末周赶出来的……（？</li><li>之前学的一些shader</li></ul><iframe src="//player.bilibili.com/player.html?aid=342584589&bvid=BV1k94y127LP&cid=747610638&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"></iframe><h2 id="三维动画（2021—2022大二下）"><a href="#三维动画（2021—2022大二下）" class="headerlink" title="三维动画（2021—2022大二下）"></a>三维动画（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=385041465&bvid=BV1kZ4y1q7TM&cid=747529286&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="Maya建模（2021—2022-大二上）"><a href="#Maya建模（2021—2022-大二上）" class="headerlink" title="Maya建模（2021—2022 大二上）"></a>Maya建模（2021—2022 大二上）</h2><div class="justified-gallery"><p>]</p><p><img src="https://pic.jitudisk.com/public/2022/06/15/f7e8f1850ca36.jpg" alt="01.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/b5a4554d557da.jpg" alt="mmexport1640791718045.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/cffde7fcda8da.jpg" alt="mmexport1640791781564.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/1a1d5fe094b43.jpg" alt="mmexport1640791785491.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/5e27a27361ce4.jpg" alt="mmexport1640791786998.jpg"><img src="https://pic.jitudisk.com/public/2022/06/15/5983da104c11d.jpg" alt="mmexport1640791788750.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/b5069a03b7945.jpg" alt="mmexport1640791791369.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/9efdd7ff2e314.jpg" alt="mmexport1640791797689.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/7c9c11112130d.jpg" alt="mmexport1640791806708.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/068ea8e658fdf.jpg" alt="mmexport1640791809330.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/cb5fae721a7eb.jpg" alt="mmexport1640791811585.jpg"></p>          </div><h2 id="设计基础（2021-2022-大二上）"><a href="#设计基础（2021-2022-大二上）" class="headerlink" title="设计基础（2021-2022 大二上）"></a>设计基础（2021-2022 大二上）</h2><div class="justified-gallery"><p><img src="https://pic.jitudisk.com/public/2022/06/15/12f318d353df8.png" alt="1.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/44456f5c13d34.png" alt="2.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/754537fdd07a6.png" alt="3.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/ff3093e87db9a.png" alt="4.png"><img src="https://pic.jitudisk.com/public/2022/06/15/ece4595b56d5a.png" alt="5.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/fa18101b2d666.png" alt="6.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/b29470db77658.png" alt="7.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/16ec3d8061c61.png" alt="8.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/bedb06047220c.png" alt="9.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/1d666e6ca4767.png" alt="10.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/e5195260afd6c.png" alt="11.png"></p>          </div><h2 id="微电影创作（2021—2022大二下）"><a href="#微电影创作（2021—2022大二下）" class="headerlink" title="微电影创作（2021—2022大二下）"></a>微电影创作（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=215085519&bvid=BV1ya411s7bF&cid=747556490&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="看中国（2021—2022大二下）"><a href="#看中国（2021—2022大二下）" class="headerlink" title="看中国（2021—2022大二下）"></a>看中国（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=257544819&bvid=BV1FY411T7o4&cid=747615512&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="混剪（2021—2022大二下）"><a href="#混剪（2021—2022大二下）" class="headerlink" title="混剪（2021—2022大二下）"></a>混剪（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=897560994&bvid=BV1xA4y1d747&cid=747597803&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="视觉信息传达设计（2022-大二下）"><a href="#视觉信息传达设计（2022-大二下）" class="headerlink" title="视觉信息传达设计（2022 大二下）"></a>视觉信息传达设计（2022 大二下）</h2><h2 id="写生作品（2020-2021-大一暑假）"><a href="#写生作品（2020-2021-大一暑假）" class="headerlink" title="写生作品（2020-2021 大一暑假）"></a>写生作品（2020-2021 大一暑假）</h2><div class="justified-gallery"><p><img src="https://pic.jitudisk.com/public/2022/06/15/35bd6639f8fe9.jpg" alt="IMG_20210708_194148.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/55660a17c9f3e.jpg" alt="IMG_20210708_194257.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/db485e71b046e.jpg" alt="IMG_20210708_194921.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/43e59980878a0.jpg" alt="IMG_20210708_194936.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/44d5fd286c169.jpg" alt="IMG_20210709_154459.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/7ea66abaafd36.jpg" alt="IMG_20210712_181451.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/a216a4a4a260f.jpg" alt="IMG_20210712_181520.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/fd5084b0fe68a.jpg" alt="IMG_20210712_181542.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/0e640e01ccf1e.jpg" alt="IMG_20210712_181614.jpg"></p>          </div><h1 id="课外作品集"><a href="#课外作品集" class="headerlink" title="课外作品集"></a>课外作品集</h1><h2 id="学习画"><a href="#学习画" class="headerlink" title="学习画"></a>学习画</h2><div class="justified-gallery"><p><img src="https://pic.jitudisk.com/public/2022/06/15/9aa4f8699a71e.jpg" alt="03.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/aa0e5ff6e7cff.jpg" alt="04.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/0d2fe04f96ec0.jpg" alt="01.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/d04f479fb20c1.jpg" alt="02.jpg"></p>          </div>]]></content>
    
    
    <summary type="html">一些产出…？</summary>
    
    
    
    <category term="作品集" scheme="https://huangxinhere.github.io/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>shader forge 从入门到放弃</title>
    <link href="https://huangxinhere.github.io/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>https://huangxinhere.github.io/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</id>
    <published>2022-04-05T16:00:00.000Z</published>
    <updated>2022-06-15T10:39:49.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="屏幕特效"><a href="#屏幕特效" class="headerlink" title="屏幕特效"></a>屏幕特效</h1><ul><li>将uv延展到屏幕上</li></ul><h2 id="顶点偏移"><a href="#顶点偏移" class="headerlink" title="顶点偏移"></a>顶点偏移</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/08/c5d289facf3035bb.png" alt="image-20220406222529980"></p><blockquote><p>Vertex Offset：输入sin函数变化的值，模型顶点同时增加（-1，1）的值，所以就二维平面而言，它是沿对角线方向移动的。？</p></blockquote><h2 id="将uv展开到屏幕上"><a href="#将uv展开到屏幕上" class="headerlink" title="将uv展开到屏幕上"></a>将uv展开到屏幕上</h2><p>把顶点铺展到屏幕上🐎？</p><ul><li><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/221ca65ddacdcd3c.png" alt="image-20220406223510471"></p><blockquote><p>从数值来看，（先从一维来看）范围扩大了一倍，然后-1到0都是黑色的，可知黑色占了大半部分；总的来说变化是原来的被压缩，被填充更多其它值的颜色</p></blockquote></li><li><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/eab028ca62e74241.png" alt="image-20220406223735717"></p><blockquote><p>同时要更改属性值。第一个Face Culling换成Double Sided，就可以显示被展开的面了。</p><p>🧐我原本理解的uv可能和模型法线有直接的联系，或者说相当于把模型uv部分拿出来进行操作吧。所以为什么就改了一下范围就使它展开了呢？？🧐</p><p>😎经实验，改变范围只是表面亮度发生了相应的变化。真正做到展uv是Vertex Position这个输出通道。这个通道解释如下👇</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/544e58a96f021f45.png" alt="image-20220406225019710"></p><p>😎经实验，原uv连VP结果如下👇或许是没有z这个值，所以干脆就没有了？（不是说偏移量嘛？！）</p><p>🧐尝试理解为什么会展开：假设模型最亮点值为1，对应uv值为1那，然后1+1=2…那模型的每个表面点都进行了二倍乘，同时z没了…这时候所见的展开图是原来uv那个样子，只是位置变了</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/b627dee83287b5b3.png" alt="image-20220406225212089"></p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/4c35ae058cf87c7c.png" alt="image-20220406230108815"></p><p>😎这时候看到展开的uv由于长宽各加一倍，所以面积增加了3倍。此时uv的后面是不可见的</p><p>👉回到设置，把Face Culling变成Double Sided，两面可见；</p><p>​     Vertex Positioning： Clip space，映射到屏幕上</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/aa861fedf8f2f770.png" alt="image-20220406230637600"></p><p>🧐但是上下边缘出现了难看的锯齿，我暂时把Remap范围扩大来解决。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/a838c447941cd91d.png" alt="image-20220406230923055"></p><p>🧐把Remap范围扩大时发现效果与理解有所出入。变化越大边界值越强硬。先从极值来想，-2<del>0是黑色，0</del>1是原色，1~2可能是增强色（？），比例分别为2：1：1。也就是说原来的颜色范围比例会更小，在多余的变化范围中显得生存空间狭小…</p></blockquote></li></ul><h2 id="双变量反正切ArcTan2"><a href="#双变量反正切ArcTan2" class="headerlink" title="双变量反正切ArcTan2"></a>双变量反正切ArcTan2</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/dbe530d1d2c1ea3a.png" alt="image-20220408175644145"></p><blockquote><p>这个着实是不知道咋得来的哇…啥时候研究一下（flag缓缓升起又缓缓倒下）</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/dfd5cff71d3f9d92.png" alt="image-20220408175922508"></p><blockquote><p>这个啥，双变量反正切得到的效果和uv合在一起！由于ArcTan2输出的是一维，惯例append升维。</p></blockquote><h2 id="Rotator节点"><a href="#Rotator节点" class="headerlink" title="Rotator节点"></a>Rotator节点</h2><p>顾名思义，也就是旋转啦！！试了下，嗯，就是普通的旋转（魔力转圈圈）对uv的旋转</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/1ae7ce69612b54ec.png" alt="image-20220408180434114"></p><blockquote><p>Spd也就是速度</p></blockquote><h2 id="Distance节点"><a href="#Distance节点" class="headerlink" title="Distance节点"></a>Distance节点</h2><p>现在开始实现四周向中心渐变透明的效果。</p><p>🧐到现在发现很多Texture显示的区域规划都用到了黑白效果。比如利用黑白遮罩…啊。黑白可能最简单的表明数值变化给图像带来的显示……以后见多了可以回来总结一下</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/a375fa9d226c497a.png" alt="image-20220408203955698"></p><blockquote><p>快速理解：现在见到的是输入了一个uv和一个二维坐标值。设想经过二维坐标生成一条直线，然后直线变成坐标轴，想象离原点的距离变化。然后再铺展成（旋转）一个平面</p></blockquote><h2 id="透明通道"><a href="#透明通道" class="headerlink" title="透明通道"></a>透明通道</h2><p>在这里，形成的黑白图连到了透明通道……</p><p>🧐透明通道到底是怎样判断哪里该透明呢？主要是输入什么样的值呢？进行实验。👇</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/bbe614040e06e88c.png" alt="image-20220408205350042"><img src="https://s3.bmp.ovh/imgs/2022/04/08/2d594e3e801b731e.png" alt="image-20220408205525227"></p><blockquote><p>验证了猜想：值为0时透明度最大。值为1时没有透明。但是值再大，会有一种奇怪的高饱和且有种差值的效果？为什么呢？</p></blockquote><p>由此可见黑白值（或者可能是普遍的数值）都在shader forge里面有对应表现的设定。得多多体验和比较了</p><p>🦁连入透明通道后要把左边属性栏的Blending——Blend Mode 改成 alpha blended，否则会警告</p><h2 id="改变透明的范围（Power节点"><a href="#改变透明的范围（Power节点" class="headerlink" title="改变透明的范围（Power节点"></a>改变透明的范围（Power节点</h2><p>现在需要对透明的范围进行调整，也就是要动态改变uv上0—1的值。</p><ul><li>可用multiply节点进行相乘。在这里目标是拉大对比度，所以只能乘以小于1的非负数.首先从极端来看，乘0则全黑，乘1则原样，所以从左到右是由全黑逐渐显现。</li><li>或者用power。Val是底数，Exp是指数，Exp为0时，是全白，为1时，是原样。可见当Exp从0到1变化时，由全白到原样。越靠近0的底数的函数值越往下陡峭，越黑；</li><li>要说两者还有啥区别的话…感觉差不多，暂时。因为看不出变化过程的大的区别（看过渡程度变化速度），所以就先这样吧。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/1a7bf527fe4017a0.png" alt="image-20220408210531868"></p><blockquote><p>还要记得用Clamp0-1限制一下范围。Multiply这个倒还好，power那个可能就负数有点厉害了？</p></blockquote><h2 id="锐化过渡灰区域（Remap节点"><a href="#锐化过渡灰区域（Remap节点" class="headerlink" title="锐化过渡灰区域（Remap节点"></a>锐化过渡灰区域（Remap节点</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/4ae1e874ebc6ce15.png" alt="image-20220408212829571"></p><p>之前是扩展到负数区域，还好理解一些。现在都是0-1，目标也不想弄出负数来，那么怎么办呢？现在重新思考Remap这个节点。🧐范围的变化实际上是映射？？</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/3101bb264873e845.png" alt="image-20220408213145933"></p><blockquote><p>这是一个粗糙的草图。将关键点进行了二倍的映射，可见可以理解原来的一半都变成了大于0.5的，结果就白的区域更多了。</p></blockquote><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/0f0e647c49e7fe5e.png" alt="image-20220408214321709"></p><ul><li>😎其实为了效果更加明显，加了Multiply节点。但是需要调整的参数就变成了两个，而且可适用范围较小，一旦调猛了就容易出现过度的情况。有没有优化的方法呢？待定。</li></ul><h2 id="Texture-Assets"><a href="#Texture-Assets" class="headerlink" title="Texture Assets"></a>Texture Assets</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/026fbb85fb90349e.png" alt="image-20220408214913855"></p><blockquote><p>一张图多用，节约性能</p></blockquote><h1 id="后处理（Post-Processing之类）"><a href="#后处理（Post-Processing之类）" class="headerlink" title="后处理（Post Processing之类）"></a>后处理（Post Processing之类）</h1><p>教程是有个插件的，直接生成屏幕特效，找不到了，算了吧</p><h1 id="旗飘动效果"><a href="#旗飘动效果" class="headerlink" title="旗飘动效果"></a>旗飘动效果</h1><h2 id="sinx＋time"><a href="#sinx＋time" class="headerlink" title="sinx＋time"></a>sinx＋time</h2><p>之前做屏幕特效的时候弄了这个，time作为函数的x而且是不断递增的，所以sin time 会在-1到1的范围内游动。</p><p>想象这个sin图……（绝不是因为画图懒）假设旗飘动基本是sin波浪的效果，那么顶点就作为x轴上的变量。</p><p><img src="/huangxinhere.github.io/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/hexo_github_blog\source_posts\pic\image-20220415184513656.png" alt="image-20220415184513656"></p><blockquote><p>sin x＋ 物体顶点【World Pos.】。这时候就有个样子啦！怎么让它动呢？加上time就好啦，让顶点加上流动的值所以也进行了流动。</p></blockquote><p><img src="/huangxinhere.github.io/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/hexo_github_blog\source_posts\pic\image-20220415185407650.png" alt="image-20220415185407650"></p><blockquote><p>World Pos.节点，物体的世界坐标。如果直接把xyz三维向量放进sin函数的话…反正没反应。所以用xyz分别的一维向量数据来add相加啦。反正先理解的是每个维度都分别与时间相加？虽然add出的是一维向量……有点难理解，算了……</p></blockquote><h2 id="Multiply-uv"><a href="#Multiply-uv" class="headerlink" title="Multiply uv"></a>Multiply uv</h2><p>🚩是一条边几乎不同的，而离得越远动得越明显。怎么实现这个效果呢？怎么样的数值满足这种需求呢？【由0到大过渡】</p><p>👉那就是uv啦！取出u/v，就是这种效果。和x变量相乘，就能实现啦</p><p>注意：物体的顶点其实是不同的，只是（渲染的时候？）顶点发生了偏移。</p>]]></content>
    
    
    <summary type="html">炫酷！美！</summary>
    
    
    
    <category term="shader" scheme="https://huangxinhere.github.io/categories/shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Context</title>
    <link href="https://huangxinhere.github.io/2022/04/05/Android%20Context/"/>
    <id>https://huangxinhere.github.io/2022/04/05/Android%20Context/</id>
    <published>2022-04-04T16:00:00.000Z</published>
    <updated>2022-04-10T01:33:15.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h1><p>getActivity(), getContext(), this…是不是特别常见？当看到方法报错要填Context类型时，一个个试就对了！！……？是时候认识一下context了！（下次瞎填也有理有据了）</p><h1 id="什么是Context"><a href="#什么是Context" class="headerlink" title="什么是Context"></a>什么是Context</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activity mActivity = <span class="keyword">new</span> Activity()<span class="comment">//??</span></span><br></pre></td></tr></table></figure><p>Activity可以new吗？Android的应用程序开发采用JAVA语言，Activity本质上也是一个对象，但这是不可行的。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能运行，Android应用模型是<strong>基于组件的应用设计模式</strong>。Context是维持Android程序中各组件能够正常工作的一个核心功能类。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/5b045dda33f98e78.png" alt="image-20220409203722884"></p><ul><li><p>用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）</p><blockquote><p>比如微信聊天，此时的“环境”是指聊天的界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与</p></blockquote></li><li><p>一个应用程序可以认为是一个工作环境，用户在这个环境中会切换到不同的场景，这就像一个前台秘书，她可能需要接待客人，可能要打印文件，还可能要接听客户电话，而这些就称之为不同的场景，前台秘书可以称之为一个应用程序。</p></li></ul><h1 id="Context类"><a href="#Context类" class="headerlink" title="Context类"></a>Context类</h1><ul><li>Context提供了关于👉应用环境全局信息👈的接口（描述一个应用程序环境的信息）</li><li>一个抽象类，Android提供了该抽象类的具体实现类</li><li>通过它我们可以获取😍<u>应用程序的资源和类</u>😍（包括应用级别操作，如启动Activity，发广播，接受Intent等）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/f1d1f7d515455953.png" alt="image-20220408161403621"></p><blockquote><p>Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中👉都会创建ContextImpl对象，由ContextImpl实现Context中的方法👈。</p><p>🧐ContextWrapper？</p><p>👉如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。</p><p>【所以包装里只有context引用，要去取真正的Context对象。这……又能怎么样呢？？】</p><p>👉ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理</p><p>【wrapper还有装饰（主题）包装嘛？】</p><p>🧐ContextImp？</p><p>👉真正实现了Context中的所有函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。</p></blockquote><ul><li>那么一个应用中有多少个Context呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appContextCount = Application + ActivityCount + ServiceCount;</span><br><span class="line"><span class="comment">//Android应用程序只有四大组件，其中两大组件都继承自Context，另外每个应用程序还有一个全局的Application对象</span></span><br></pre></td></tr></table></figure><blockquote><p>Android 开发的四大组件分别是：😜活动（activity），用于表现功能；😜服务（service），后台运行服务，不提供界面呈现；😜广播接受者（Broadcast Receive），用于接收广播；😜内容提供者（Content Provider），支持多个应用中存储和读取数据，相当于数据库。</p></blockquote><h1 id="Context作用域"><a href="#Context作用域" class="headerlink" title="Context作用域"></a>Context作用域</h1><p>context可以实现的功能非常多！弹出toast，启动activity，启动service等等都需要context。虽然很神通广大，但不是随便拿到一个Context实例就能为所欲为，使用还是有限制的。</p><ul><li><p>由于Context的具体实例是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以<strong>通用</strong>的。【前面提到这三初始化时会创建ContextImp对象，用它的context方法，也就是拿到了context】</p></li><li><p>出于安全原因的考虑，Android是<strong>不允许</strong>Activity或Dialog凭空出现的，🦁一个<strong>Activity</strong>的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。🦁而<strong>Dialog</strong>则必须在一个Activity上面弹出，因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p><p><img src="https://upload-images.jianshu.io/upload_images/1187237-fb32b0f992da4781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/589/format/webp" alt="img"></p><blockquote><p>由图可知，Activity所持有的Context的作用域最广，无所不能。因为Activity继承自ContextThemeWrapper，而Application和Service继承自ContextWrapper，很显然😏<u>ContextThemeWrapper在ContextWrapper的基础上又做了一些操作使得Activity变得更强大</u>😏</p><p>【总结！】 凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p></blockquote></li></ul><h1 id="如何获取Context"><a href="#如何获取Context" class="headerlink" title="如何获取Context"></a>如何获取Context</h1><p>主要有以下四种方法！👇</p><ul><li><p>😀View.getContext()</p><p>返回当前View对象的Context对象，通常是当前正在展示的Activity对象</p></li><li><p>😏Activity.getApplicationContext()</p><p>获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context</p></li><li><p>😎ContextWrapper.getBaseContext()</p><p>用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用</p></li><li><p>😍Activity.this </p><p>返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用Application,Context也可以</p></li></ul><h1 id="一些常用方法的区别"><a href="#一些常用方法的区别" class="headerlink" title="一些常用方法的区别"></a>一些常用方法的区别</h1><h2 id="getApplication-和-getApplicationContext"><a href="#getApplication-和-getApplicationContext" class="headerlink" title="getApplication() 和 getApplicationContext()"></a>getApplication() 和 getApplicationContext()</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/28c6fb61a9303d81.webp" alt="img"></p><ul><li><p>区别：getApplication() 方法语义性非常强，一看就知道是用来获取Application实例的，但这个方法只有在Activity和Service中才能调用得到。大多数场景中我们都是在Activity和Service中使用Application，但是如果在其他一些场景，比如BroadcastReceiver中也想获得Application实例，就可以借用getApplicationContext()方法了。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/fd3e5cced5a5dc3b.png" alt="image-20220409165536914"></p></li></ul><h1 id="Context引起的内存泄漏"><a href="#Context引起的内存泄漏" class="headerlink" title="Context引起的内存泄漏"></a>Context引起的内存泄漏</h1><h2 id="错误的单例模式"><a href="#错误的单例模式" class="headerlink" title="错误的单例模式"></a>错误的单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个Activity用了getInstance（this），那么这个静态的instance的生命周期要比Activity还长，它常驻内存，保存了传入的那个activity的对象并一直持有，即使Activity被销毁掉，它的引用还存在于一个Singleton中，就不可能被GC掉，就导致了内存泄漏。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/784a0fb65045c1d3.png" alt="image-20220409163255669"></p><p>解决办法👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    ｝</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//区别在这里</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Application对象的生命周期和整个项目一样长，和单例对象一致。</p><h2 id="View持有Activity引用"><a href="#View持有Activity引用" class="headerlink" title="View持有Activity引用"></a>View持有Activity引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Drawable mDrawable;<span class="comment">//静态</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ImageView iv = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);<span class="comment">//</span></span><br><span class="line">        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);</span><br><span class="line">        iv.setImageDrawable(mDrawable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/46cc57e444a01f3d.png" alt="image-20220409171311849"></p><p>有一个静态的Drawable对象，当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏</p><h2 id="正确使用Context"><a href="#正确使用Context" class="headerlink" title="正确使用Context"></a>正确使用Context</h2><p>一般Context造成的内存泄漏，🧧几乎都是当Context销毁的时候，却因为<strong>被引用</strong>导致销毁失败🧧，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：<br> 1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。<br> 2：不要让生命周期长于Activity的对象持有到Activity的引用。<br> 3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。【？？？</p><h3 id="非静态内部类会隐式持有外部类实例的引用"><a href="#非静态内部类会隐式持有外部类实例的引用" class="headerlink" title="非静态内部类会隐式持有外部类实例的引用"></a>非静态内部类会隐式持有外部类实例的引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleOne();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    newThread() &#123;<span class="comment">//匿名内部类，非静态的匿名类会持有外部类的一个隐式引用</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要非静态的匿名类对象没有被回收，MainActivity就不会被回收，MainActivity所关联的资源和视图都不会被回收，发生比较严重的内存泄漏。</p><p>要解决MainActivity的内存泄漏问题，只需把非静态的Thread匿名类定义成静态的内部类就行了（静态的内部类不会持有外部类的一个隐式引用）👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleTwo();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> MyThread().start();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在新创建的Thread不会持有MainActivity的一个隐式引用，当手机屏幕旋转时不会阻止垃圾回收器对旧MainActivity的回收工作。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.jianshu.com/p/fb0681f5f12b">Android基础之Context - 简书 (jianshu.com)</a></p><p><a href="https://www.jianshu.com/p/94e0f9ab3f1d">Context都没弄明白，还怎么做Android开发？ - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/zhongwcool/article/details/22886067">(34条消息) 非静态的内部类会持有外部类的一个隐式引用_zhongwcool的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">打败context！！</summary>
    
    
    
    <category term="Android" scheme="https://huangxinhere.github.io/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Java继承</title>
    <link href="https://huangxinhere.github.io/2021/12/04/Java%E7%BB%A7%E6%89%BF/"/>
    <id>https://huangxinhere.github.io/2021/12/04/Java%E7%BB%A7%E6%89%BF/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2022-04-09T11:41:43.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul><li>基于已存在的类构造一个新类</li></ul><h3 id="为何有继承"><a href="#为何有继承" class="headerlink" title="为何有继承"></a>为何有继承</h3><ul><li>复用（继承）原有类的方法和域</li><li>添加新的方法和域，满足新的需求</li></ul><h3 id="关于子类与父类"><a href="#关于子类与父类" class="headerlink" title="关于子类与父类"></a>关于子类与父类</h3><ol><li><p>声明关键字：sonClass extends FatherClass</p></li><li><p>继承层次</p><ul><li>继承层次：由一个<u>公共超类</u>派生出来的<u>所有类的集合</u></li><li>继承链：从某个特定的类到其祖先的路径</li></ul><p><img src="https://s2.loli.net/2021/12/04/HaFcZEeCABu9TxM.png" alt="image-20211201195725979.png"></p><ul><li><p>一个子类可以继承多个父类吗？</p><p><img src="https://s2.loli.net/2021/12/04/jmq4DF1QCdxiJe5.png" alt="image-20211203220706240.png"></p><ul><li>Java认为多继承弊大于利</li><li>为弥补，用接口</li></ul></li></ul></li></ol><h3 id="子类对继承内容的处理"><a href="#子类对继承内容的处理" class="headerlink" title="子类对继承内容的处理"></a>子类对继承内容的处理</h3><ul><li><p><strong>访问权限</strong>（借用cpp的说法）</p><p>——一般类中将域定义为private，方法定义为public。那什么情况下能访问父类的数据域、方法？</p><ul><li><p>public: 对所有类可见</p></li><li><p>protected：对本包和所有子类可见</p><p>——子类的域和方法用protected都是同样的效果吗？</p><ul><li>域：常用private，是为了强调其封装性，用protected意味着很多子类可以使用，存在被修改的风险，破坏了封装性</li><li>方法：常用public，用protected限制了使用范围</li></ul></li><li><p>private：仅对本类可见</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> money;</span><br><span class="line">    <span class="keyword">protected</span> String antique;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> books;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFromFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(money);</span><br><span class="line">        System.out.println(antique);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>子类构造器</strong></p><ul><li><p>私有域。父类私有域不能被访问，所以要调用父类构造器对其初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">float</span> money, <span class="keyword">int</span> books)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(money);<span class="comment">//实现对父类构造器的调用；必须是子类构造器的第一条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果没有调用父类构造器，直接用同名变量呢？</p><p>——子类的变量会覆盖掉父类的，即用子类的money是属于子类的，而不是父类的</p></blockquote></li><li><p>若没有显式调用超类构造器，将自动调用超类默认没有参数的构造器</p></li><li><p>超类有构造器，子类没有显式调用，将报错</p></li></ul></li><li><p><strong>覆盖方法</strong></p><ul><li><p>在原有的基础上更新新的功能</p></li><li><p>不同的方法体</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money - <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么还是无法访问money域？</p><ul><li>尽管每个子类对象都有money域，子类的方法不能直接访问父类的私有域。只有父类方法才能访问（继承过来干嘛呢？</li><li>如何才能访问？借助公有的接口（调用父类的getSalary()方法）</li></ul></blockquote></li><li><p>问题又来了：子类同名方法调用父类的同名方法，能否成功？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMoney() - <span class="number">100.0</span>;</span><br><span class="line">&#125;<span class="comment">//结果里面还是调用自己，无限循环</span></span><br></pre></td></tr></table></figure><blockquote><p>声明要调用的是父类方法：</p><p>super.getMoney();</p></blockquote></li><li><p>判断下面是不是覆盖方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">float</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSalay() + add - <span class="number">100.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSalay()- <span class="number">100.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载和重写</span></span><br></pre></td></tr></table></figure><blockquote><p>这里延伸出编译器如何寻找方法的知识点：</p><ul><li>查看对象的声明类型和方法名    float getMoney();</li><li>查看方法提供的参数类型           float getMoney(…);2</li></ul></blockquote></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>——父类对象和子类对象的奇妙转化(?</p><ul><li>出现父类对象的任何地方都可以用子类对象置换</li><li>多态：一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定</li><li>一个父类对象可以引用一个父类对象，也可以引用任何一个子类的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Father f;</span><br><span class="line">f = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Son s;</span><br><span class="line">s = <span class="keyword">new</span> Father();</span><br></pre></td></tr></table></figure><p>[java提高篇(四)—–理解java的三大特性之多态 - chenssy - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/chenssy/p/3372798.html#:~:text=%E6%89%80%E8%B0%93%E5%A4%9A%E6%80%81%E5%B0%B1%E6%98%AF%E6%8C%87%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%80%9A%E8%BF%87%E8%AF%A5%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%8F%91%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%9C%A8%E7%BC%96%E7%A8%8B%E6%97%B6%E5%B9%B6%E4%B8%8D%E7%A1%AE%E5%AE%9A%EF%BC%8C%E8%80%8C%E6%98%AF%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E6%89%8D%E7%A1%AE%E5%AE%9A%EF%BC%8C%E5%8D%B3%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%80%92%E5%BA%95%E4%BC%9A%E6%8C%87%E5%90%91%E5%93%AA%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%AF%A5%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%8F%91%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%88%B0%E5%BA%95%E6%98%AF%E5%93%AA%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%94%B1%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E6%89%8D%E8%83%BD%E5%86%B3%E5%AE%9A%E3%80%82">https://www.cnblogs.com/chenssy/p/3372798.html#:~:text=所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</a>. 因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。.,比如你是一个酒神，对酒情有独钟。. 某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。.)</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li><p>更为抽象，更通用。比如student和Employee的更高类Person类</p></li><li><p>为什么要高度抽象</p><p>——当我们存在一类事物，他们大多数结构和功能存在雷同，只有少部分存在不同，如果我们直接使用子类实现接口，那么结构和功能相同部分的代码将会造成大量冗余，因此我们需要一种结构，里面可以提供一部分已经实现了的共同的代码，剩下的<strong>一小部分</strong>由具体子类去实现即可，达到了代码的重用</p></li><li><p>抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象方法。子类继承这个类的时候再去实现里面的方法体</span></span><br><span class="line"><span class="comment">//相当于一个概括，具体实现看子类需求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>为了提高程序的清晰度， 包含一个或多个抽象方法的类本身必须被声明为抽象的</li><li>除了抽象方法之外，抽象类还可以包含具体数据和具体方法</li><li>对于抽象方法，子类继承可以具体实现，否则也是抽象类</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.抽象类不能被实例化（抽象类结构和功能一般不完整）</span></span><br><span class="line"><span class="comment">//2.但可以定义一个抽象类的对象变量（区别？）来引用具体子类的对象</span></span><br></pre></td></tr></table></figure><ul><li>再次解读一下书上的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person[] people = <span class="keyword">new</span> Person[<span class="number">2</span>];</span><br><span class="line">people[<span class="number">0</span>] = <span class="keyword">new</span> Emplyee(...);</span><br><span class="line">people[<span class="number">1</span>] = <span class="keyword">new</span> Student(...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Person p : people)&#123;</span><br><span class="line">    System.out.println(p.getName());<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Java继承</summary>
    
    
    
    <category term="Android" scheme="https://huangxinhere.github.io/categories/Android/"/>
    
    
  </entry>
  
</feed>

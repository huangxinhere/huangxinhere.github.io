<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hx&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/32690cfd58b9093251b720ee371b49ad</icon>
  <subtitle>aha</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-18T02:54:20.568Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>(●ˇ∀ˇ●)</name>
    <email>1159390360@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity入门(三)——MyGame2</title>
    <link href="http://example.com/2022/06/04/202264-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame2/"/>
    <id>http://example.com/2022/06/04/202264-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame2/</id>
    <published>2022-06-03T16:00:00.000Z</published>
    <updated>2022-06-18T02:54:20.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="人物移动与交互"><a href="#人物移动与交互" class="headerlink" title="人物移动与交互"></a>人物移动与交互</h1><h2 id="PlayerController"><a href="#PlayerController" class="headerlink" title="PlayerController"></a>PlayerController</h2><h2 id="PlayerMotor"><a href="#PlayerMotor" class="headerlink" title="PlayerMotor"></a>PlayerMotor</h2><h2 id="Interactable"><a href="#Interactable" class="headerlink" title="Interactable"></a>Interactable</h2><p><img src="https://i.bmp.ovh/imgs/2022/06/04/c6b46d139b9b9c42.png" alt="image-20220604215558038"></p><h1 id="物品的收集"><a href="#物品的收集" class="headerlink" title="物品的收集"></a>物品的收集</h1><h2 id="Delegate委托"><a href="#Delegate委托" class="headerlink" title="Delegate委托"></a>Delegate委托</h2><p><a href="https://wenku.baidu.com/view/e61fcfb5d9ef5ef7ba0d4a7302768e9950e76e43.html">在unity中如何使用delegate - 百度文库 (baidu.com)</a></p><h1 id="继承类之间的冲突"><a href="#继承类之间的冲突" class="headerlink" title="继承类之间的冲突"></a>继承类之间的冲突</h1><p>先看例子：获取子类的animator组件</p><ul><li>（公用）CharacterCombat类</li></ul><table><thead><tr><th></th><th align="center">GetChild()</th><th align="center">GetComponentInChild()</th></tr></thead><tbody><tr><td>player</td><td align="center">√</td><td align="center">√</td></tr><tr><td>enemy</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><ul><li>（公用且继承）CharacterStats类</li></ul><table><thead><tr><th align="center"></th><th align="center">GetChild()</th><th align="center">GetComponentInChild()</th></tr></thead><tbody><tr><td align="center">player（PlayerStats）</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">enemy（EnemyStats）</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>这就说明层级没问题，获取也没问题，而问题出现在player有PlayerStats的脚本。仔细比较，那个脚本里面有Start方法……证明start方法覆盖掉了父类的start方法，以至于player的CharacterStats类一直没有运行获取animator组件的代码。写之前没有考虑到这个问题，算是困扰了很久的一个坑了。</p><h1 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h1><h2 id="尝试一：事件类控制所有事件"><a href="#尝试一：事件类控制所有事件" class="headerlink" title="尝试一：事件类控制所有事件"></a>尝试一：事件类控制所有事件</h2><ul><li>如果一个脚本没有继承 MonoBehaviour ，就无法挂在物体上（可能是因为没有继承start，update等方法，无法和游戏对象进行生命周期的同步）；但是类还是可以被用的。</li><li>C#单例模式<a href="https://blog.csdn.net/zls365365/article/details/122904766">C# 单例模式详解_zls365365的博客-CSDN博客</a></li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="动画优化"><a href="#动画优化" class="headerlink" title="动画优化"></a>动画优化</h2><h3 id="逻辑设计：动画覆盖"><a href="#逻辑设计：动画覆盖" class="headerlink" title="逻辑设计：动画覆盖"></a>逻辑设计：动画覆盖</h3><ul><li>现有设计：</li></ul><table><thead><tr><th align="center"></th><th align="center">触发</th><th align="center">处理方法</th></tr></thead><tbody><tr><td align="center">attack 攻击</td><td align="center">Enemy Controller / Enemy</td><td align="center">CharacterCombat(Trigger:”Attack”)</td></tr><tr><td align="center">hit 受伤</td><td align="center">CharacterCombat – Take Damage()</td><td align="center">CharacterStat(Trigger:”Hit”)</td></tr><tr><td align="center">die 死亡</td><td align="center">CharacterStat(Health &lt; 0)</td><td align="center">EnemyStat – Die(Trigger:”Die”)</td></tr></tbody></table><ul><li>问题：设计是将功能解耦得很明显的，分工也很明确。但是当分工多起来的时候处理流程会被拉长，然后通知的代价也会提高。最后的死亡动画，因为没有及时通知前面的Attack停止，还用了Trigger，所以死亡动画会被覆盖掉。</li><li>解决：从源头上解决问题，即停止Attack的开始。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distance &lt;= lookRadius)</span><br><span class="line">&#123;</span><br><span class="line">    agent.SetDestination(target.position);</span><br><span class="line">    FaceTarget();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (distance &lt;= agent.stoppingDistance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//attack：敌人 攻击 玩家</span></span><br><span class="line">        CharacterStats playerStats = target.GetComponent&lt;CharacterStats&gt;();</span><br><span class="line">        <span class="keyword">if</span> (playerStats != <span class="literal">null</span> &amp;&amp; enemyStat.currentHealth &gt;= <span class="number">0</span>)<span class="comment">//添加</span></span><br><span class="line">        &#123;</span><br><span class="line">            enemyCombat.Attack(playerStats);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也就是最后的整个流程链执行之后就不会再执行导致覆盖</p></blockquote><h3 id="animatior-trigger触发的动画失效"><a href="#animatior-trigger触发的动画失效" class="headerlink" title="animatior.trigger触发的动画失效"></a>animatior.trigger触发的动画失效</h3><ul><li><p>实现功能：点击按钮弹出选择菜单，点击返回菜单退出。</p></li><li><p>具体设计</p><p>Animator：（默认）弹出动画——（trigger“out”）——触发菜单退出动画</p><p>Animation：退出动画是出现动画速度的-1，在最后设置了Animation 事件（SetActive）</p><p>逻辑：“选择按钮”——UI控件的SetActive，触发默认动画并只播放一次——“返回按钮”——Animator的SetTrigger()。</p></li><li><p>问题：“返回按钮”之后，菜单执行了Animation事件，但动画失效，没有动画。</p></li><li><p>解决：经排查，是退出动画速度为-1的原因，具体不知道是什么原理。</p></li></ul><h3 id="GetComponentsInChildren对动画组件的获取"><a href="#GetComponentsInChildren对动画组件的获取" class="headerlink" title="GetComponentsInChildren对动画组件的获取"></a>GetComponentsInChildren对动画组件的获取</h3><ul><li><p>实现功能：点击Setting按钮，弹出设置菜单，并且背景变暗</p></li><li><p>具体设计</p><p>​    SettingPanel（bg变色）（父对象）——&gt;SettingMenu（子对象）；</p><p>​    出现：SettingPanel.SetActive()，父子对象都会触发默认出现动画；</p><p>​    隐藏：同理，只需父对象SetActive就行，但是要同时触发父子对象的动画</p></li><li><p>不同方法的区别</p><table><thead><tr><th align="center"></th><th align="center">父对象有Animator</th><th align="center">父对象无Animator</th></tr></thead><tbody><tr><td align="center">GetChildrenInComponent</td><td align="center">获取的是父的</td><td align="center">才是子的</td></tr><tr><td align="center">GetChildrenInComponents</td><td align="center">父+子</td><td align="center">子</td></tr></tbody></table></li></ul><h2 id="Button自定义脚本"><a href="#Button自定义脚本" class="headerlink" title="Button自定义脚本"></a>Button自定义脚本</h2><ul><li><p>实现功能：两种状态值切换：召唤菜单/隐藏菜单。</p></li><li><p>分析：控制面板上的响应事件似乎无法记录Btn的状态值。</p><ul><li><p>写了一个脚本挂在Btn对象上面，有</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> isActive;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Click</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    isActive = !isActive;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是控制板点击事件不能获取到这个Click方法。（原来是方法没有用public…寄</p></blockquote><p>证实这个方法可用…-_-</p></li><li><p>主要是想记录一下btn的监听事件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button = GetComponent&lt;Button&gt;();</span><br><span class="line">        button.onClick.AddListener(() =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            OnBtnClick();</span><br><span class="line">        &#125;); </span><br></pre></td></tr></table></figure><blockquote><p>这个和安卓写法很像。要自己重写OnClick方法，就要给btn添加监听器。</p></blockquote></li><li><p>如果非得将这两种方法做个比较的话……我觉得后一种方法在自己处理事件的时候逻辑上更为合理。也就是，btn本身这个游戏对象处理的逻辑，直接调用组件btn来监听事件，而不用在面板上再把自己拖进去，再调用自己脚本的方法。（其实也可以直接拖脚本组件，emmm）如果处理的是其它游戏对象，就比在脚本获取更方便。</p><p>当然，把事件都放在面板上有助于一目了然，视情况而定。</p><p>不，还是第一种方便。</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">结课作业第二波：老实跟着教程做</summary>
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity入门(三)——MyGame</title>
    <link href="http://example.com/2022/05/09/202259-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame/"/>
    <id>http://example.com/2022/05/09/202259-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-06-15T10:45:45.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h1><h2 id="水平垂直方向的平移"><a href="#水平垂直方向的平移" class="headerlink" title="水平垂直方向的平移"></a>水平垂直方向的平移</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> h = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    <span class="built_in">float</span> v = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*存储角色的移动*/</span></span><br><span class="line">    m_Movement.Set(h, <span class="number">0f</span>, v);</span><br><span class="line">    m_Movement.Normalize();     <span class="comment">//确保对角线移动速度相同【矢量标准化为长度1】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> hasHorizontalInput = !Mathf.Approximately(h, <span class="number">0f</span>);  <span class="comment">//两者相似，则不在移动</span></span><br><span class="line">    <span class="built_in">bool</span> hasVerticalInput = !Mathf.Approximately(v, <span class="number">0f</span>);</span><br><span class="line">    <span class="built_in">bool</span> isWalking = hasHorizontalInput || hasVerticalInput;<span class="comment">//判断是否在走路</span></span><br><span class="line">    animator.SetBool(<span class="string">&quot;isWalking&quot;</span>, isWalking);               <span class="comment">//通过所有定义的输入来判断是否走路。如果按照按键则限制较大</span></span><br><span class="line">    <span class="comment">//这里为止，只是播放动画但会一直往前走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>控制角色旋转的速度：</p><ul><li>创建和存储旋转，以便可以在任何需要的地方使用。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"> Quaternion m_Rotation = Quaternion.identity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line">Vector3 desiredForward = Vector3.RotateTowards(transform.forward, m_Movement, rotateSpeed * Time.deltaTime, <span class="number">0f</span>);</span><br><span class="line">        m_Rotation = Quaternion.LookRotation(desiredForward);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四元数是存储旋转的一种方式"><a href="#四元数是存储旋转的一种方式" class="headerlink" title="四元数是存储旋转的一种方式"></a>四元数是存储旋转的一种方式</h3><ul><li>可用于解决将旋转存储为 3D 矢量时遇到的一些问题。</li><li>通常情况下，创建类的实例时，会将属于类的变量（成员变量）而不是属于特定方法的变量设置为默认值。例如，Vector3 的默认值是将 x、y 和 z 都设置为 0。四元数也是如此。但是，虽然零矢量是合理的（因为没有移动），零四元数却不太合理。这里设置的 Quaternion.identity 值就是为其赋予无旋转的值，这是一个<strong>更合理的默认值</strong>。</li></ul><h3 id="Vector3-RotateTowards"><a href="#Vector3-RotateTowards" class="headerlink" title="Vector3.RotateTowards"></a>Vector3.RotateTowards</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">RotateTowards</span> (<span class="params">Vector3 current, Vector3 target, <span class="built_in">float</span> maxRadiansDelta, <span class="built_in">float</span> maxMagnitudeDelta</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/05/09/46b181830a7d075b.png" alt="image-20220509155607107"></p><ul><li>返回<strong>Vector3</strong> RotateTowards 生成的位置。</li><li>描述：该函数类似于 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.MoveTowards.html">MoveTowards</a>，但<strong>向量被视为方向而不是位置</strong>。 <code>current</code> 向量将朝 <code>target</code> 方向旋转 <code>maxRadiansDelta</code> 的角度， 但其将准确地落在目标上而不会超过目标。 如果 <code>current</code> 和 <code>target</code> 的大小不同，则在旋转期间对结果大小进行线性插值。 如果为 <code>maxRadiansDelta</code> 使用负值，则向量将朝远离 <code>target</code> 的方向旋转， 直到它指向完全相反的方向，然后停止。</li></ul><h3 id="每一帧存储旋转方向"><a href="#每一帧存储旋转方向" class="headerlink" title="每一帧存储旋转方向"></a>每一帧存储旋转方向</h3><h2 id="将移动和旋转应用于角色"><a href="#将移动和旋转应用于角色" class="headerlink" title="将移动和旋转应用于角色"></a>将移动和旋转应用于角色</h2><ul><li><p>可以通过多种方式来执行此操作，但是由于<strong>角色需要成为物理系统的一部分</strong>，因此需要移动刚体而不是使用任何其他方法。</p></li><li><p>该角色有一段有趣的 Walk 动画，最好为此使用<strong>根运动</strong>。但是，该动画中没有任何旋转，如果尝试在 Update 方法中旋转刚体 (Rigidbody)，则动画可能会覆盖该刚体（这可能导致角色在应该旋转的时候不旋转）</p></li><li><p><strong>实际需要的是动画的一部分根运动</strong>（？，但不是全部的根运动；具体来说，需要应用移动而不是旋转。那么如何更改从 Animator 中应用根运动的方式呢？幸运的是，MonoBehaviour 有一种特殊的方法可用于更改从 Animator 中应用根运动的方式</p></li></ul><h3 id="根运动"><a href="#根运动" class="headerlink" title="根运动"></a>根运动</h3><ul><li><p>根运动 (Root Motion) 角色根的运动（无论是由动画本身还是由外部控制）。</p></li><li><p>工作原理：<a href="https://docs.unity.cn/cn/2020.3/Manual/RootMotion.html">根运动 - 工作原理 - Unity 手册</a></p></li><li><p>动画用于在特定层级视图中移动和旋转所有游戏对象。这些移动和旋转大多数都是相对于其父项完成的，但是层级视图的父游戏对象没有父项，因此它们的移动不是相对的。此父游戏对象也可以称为根 (Root)，因此其移动称为根运动 (Root Motion)。</p><p><strong>重要注意事项！</strong>在 JohnLemon 预制件的层级视图中称为根的游戏对象指的是其骨架的根，而不是实际的根游戏对象。根游戏对象是 Animator 组件所在的任何游戏对象，在本例中，该游戏对象称为 JohnLemon。</p><p>在 Animator 组件上启用了 Apply Root Motion，因此根在动画中的任何移动都将应用于每一帧。由于 Animator 正在播放 Idle 动画，没有移动，因此 Animator 不会施加任何动作。那么，为什么 JohnLemon 游戏对象会移动呢？这是因为 Animator 的**更新模式 (Update Mode)**。</p></li></ul><h3 id="OnAnimatorMove（）"><a href="#OnAnimatorMove（）" class="headerlink" title="OnAnimatorMove（）"></a>OnAnimatorMove（）</h3><ul><li>MonoBehaviour 有一种特殊的方法可用于更改从 Animator 中应用根运动的方式。</li><li>在每个更新帧中为每个 <strong>Animator 组件</strong>调用一次此函数来<strong>修改根运动</strong> (Root Motion)。</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    m_Rigidbody.MovePosition(m_Rigidbody.position + m_Movement * animator.deltaPosition.magnitude);</span><br><span class="line">    m_Rigidbody.MoveRotation(m_Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Animator 的 <strong>deltaPosition</strong> 是由于可以应用于此帧的根运动而导致的位置变化。将其大小（即长度）乘以我们希望角色移动的实际方向上的移动向量</p></blockquote><h3 id="Animator通过物理循环适时运行"><a href="#Animator通过物理循环适时运行" class="headerlink" title="Animator通过物理循环适时运行"></a>Animator通过物理循环适时运行</h3><p><a href="https://learn.unity.com/tutorial/the-player-character-part-1">从而避免物理与动画之间发生冲突。但是，现在您将使用 OnAnimatorMove 来覆盖根运动。这意味着 OnAnimato</a>rMove 实际上将通过物理适时被调用，而不是像 Update 方法那样通过渲染被调用。</p><ul><li>FixedUpdate：在物理系统处理所有碰撞和其他已发生的交互之前被调用。默认情况下，每秒正好调用 50 次这个方法。</li></ul><h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>整个流程下来都是很晕。试了一下，如果</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1*/</span></span><br><span class="line">m_Movement.Set(h, <span class="number">0f</span>, v);</span><br><span class="line">m_Movement.Normalize();  </span><br><span class="line"></span><br><span class="line">rg.MovePosition(m_Movement);<span class="comment">//h，v只是方向向量，长度为1，所以不能连续移动（最远也是一个单位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2:普通做法*/</span></span><br><span class="line">Vector3 move = rg.position;</span><br><span class="line">move.x += move_speed * h * Time.deltaTime;</span><br><span class="line">move.z += move_speed * v * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">rg.MovePosition(move);<span class="comment">//这样便是自己控制速度来移动（不会旋转）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    m_Rigidbody.MovePosition(m_Rigidbody.position + m_Movement * animator.deltaPosition.magnitude);</span><br><span class="line">    m_Rigidbody.MoveRotation(m_Rotation);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所以比较看出，这个方法并没有设置速度，而是用了animator.deltaPosition.magnitude来作为移动的变化量</span></span><br><span class="line"><span class="comment">//官方解释：应用于此帧的根运动而导致的位置变化；或者说是动画固定的步长？</span></span><br><span class="line"><span class="comment">//那么，模型和动画实质上可以相互影响的？</span></span><br><span class="line"><span class="comment">//之前觉得就是控制模型刚体移动，然后顺便播放动画</span></span><br></pre></td></tr></table></figure><h2 id="吃透理解！！"><a href="#吃透理解！！" class="headerlink" title="吃透理解！！"></a>吃透理解！！</h2><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/2bcff3ae37034084.png" alt="image-20220509202135390"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/4b31d6cfc4ff781a.png" alt="image-20220513213526442"></p><blockquote><p>补充PS部分：是重写了OnAnimationMove()方法才会取消复选框</p></blockquote><h2 id="Root-Motion工作原理"><a href="#Root-Motion工作原理" class="headerlink" title="Root Motion工作原理"></a>Root Motion工作原理</h2><h3 id="Body-Transform"><a href="#Body-Transform" class="headerlink" title="Body Transform"></a>Body Transform</h3><p>是角色的质心（重心）。用于Mecanim系统的<em>重定向引擎</em>中来提供<strong>稳定的模型移动</strong>。身体朝向是角色模型在T姿势下上身和下身朝向的平均值。</p><p><strong>Body Transform和朝向</strong>存储在Animation Clip中，这两个是Animation Clip中存储的唯二<strong>世界空间</strong>的曲线，<u>其他的动画曲线</u>都是以相对body transform的形式存储的。</p><h3 id="Root-Transform（根变换）"><a href="#Root-Transform（根变换）" class="headerlink" title="Root Transform（根变换）"></a>Root Transform（根变换）</h3><p>是body transform在Y平面上的投影，并且是运行时运算的。每一帧Root Transform的变化实时计算。然后Transform的变化会被应用到GameObject上从而让物体移动。</p><h3 id="调整Root-Transform"><a href="#调整Root-Transform" class="headerlink" title="调整Root  Transform"></a>调整Root  Transform</h3><h4 id="Root-Transform-Rotation"><a href="#Root-Transform-Rotation" class="headerlink" title="Root Transform Rotation"></a>Root Transform Rotation</h4><h4 id="Root-Transform-Position-Y"><a href="#Root-Transform-Position-Y" class="headerlink" title="Root Transform Position(Y)"></a>Root Transform Position(Y)</h4><h4 id="Root-Transform-Position-XZ"><a href="#Root-Transform-Position-XZ" class="headerlink" title="Root Transform Position(XZ)"></a>Root Transform Position(XZ)</h4><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/d065079294b6ba57.png" alt="image-20220513213506678"></p><p>详情见<a href="https://zhuanlan.zhihu.com/p/151387595">Unity动画系统详解6：如何做好角色的移动动画？（Root Motion详解） - 知乎 (zhihu.com)</a></p><h1 id="相机跟随（CineMachine）"><a href="#相机跟随（CineMachine）" class="headerlink" title="相机跟随（CineMachine）"></a>相机跟随（CineMachine）</h1><p><a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html">使用Cinemachine|电影|2.8.4 (unity.cn)</a></p><h2 id="虚拟摄像机"><a href="#虚拟摄像机" class="headerlink" title="虚拟摄像机"></a>虚拟摄像机</h2><p>Cinemachine 是 Unity 针对游戏中与摄像机有关的所有问题的解决方案。</p><ul><li>在场景中创建一个或多个“虚拟”摄像机。</li><li>这些虚拟摄像机由一个名为 Cinemachine Brain 的组件进行管理。</li><li>Cinemachine Brain 与 Camera 组件连接到相同的游戏对象，默认情况下，这个游戏对象将是 Main Camera 游戏对象。</li><li>Cinemachine Brain 管理所有虚拟摄像机，并确定实际摄像机应跟随哪个虚拟摄像机（或虚拟摄像机的组合）。</li></ul><p>详细说明：</p><ul><li><p>Cinemachine不会创建新的摄像机。相反，它会将单个 Unity 摄像机定向到多个镜头。您可以使用<strong>虚拟摄像机</strong>构图这些镜头。虚拟摄像机移动和旋转 Unity 摄像机并控制其设置。</p></li><li><p>虚拟摄像机是独立于 Unity 摄像机的游戏对象，其行为独立。它们不嵌套在彼此内。例如，场景可能如下所示：</p><p><img src="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/images/CinemachineSceneHierarchy.png" alt="A Scene containing a Unity camera with Cinemachine Brain (blue) and multiple Virtual Cameras (red)"></p><ul><li>虚拟摄像机为您执行的主要任务：<ul><li>将 Unity 摄像机放置在场景中。</li><li>将 Unity 相机对准某些物体。</li><li>将程序噪声添加到 Unity 摄像机。噪音模拟手持效果或车辆晃动等。</li></ul></li><li>Cinemachine鼓励您创建许多虚拟摄像机。虚拟摄像机的设计<strong>消耗很少的处理能力</strong>。如果您的场景对性能敏感，请在任何给定时刻停用除基本虚拟摄像机之外的所有摄像机，以获得最佳性能。</li><li>一个虚拟摄像机可以在任何时间点控制 Unity 摄像机。这是<strong>实时</strong>虚拟摄像机。此规则的例外情况是从一个虚拟摄像机到下一个虚拟摄像机的混合。在混合过程中，两个虚拟摄像机都是实时的。</li></ul></li></ul><h2 id="Cinemachine-Brain"><a href="#Cinemachine-Brain" class="headerlink" title="Cinemachine Brain"></a>Cinemachine Brain</h2><ul><li><p>是Unity Camera本身的一个组件.</p></li><li><p><strong>监控</strong>场景中所有活动的虚拟摄像机。【选择】要指定下一个实时虚拟摄像机，请<a href="https://docs.unity.cn/Manual/DeactivatingGameObjects.html">激活或停用</a>所需虚拟摄像机的游戏对象。然后，Cinemachine Brain选择与实时虚拟摄像机具有相同或更高优先级的最新激活的虚拟摄像机。它在以前的虚拟摄像机和新虚拟摄像机之间执行剪切或混合。</p></li><li><p>使用Cinemachine Brain实时响应动态游戏事件。它允许您的游戏逻辑通过操作优先级来控制摄像机。这对于实时游戏玩法特别有用，因为实时游戏玩法中的动作并不总是可预测的。使用<a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineTimeline.html">时间轴</a>在可预测的情况下（如过场动画）编排摄像机。时间轴覆盖了Cinemachine Brain优先级系统，为您提供精确的帧摄像机控制。</p><p>（也就是相对于时间轴来说可以实时控制摄像机）</p></li></ul><h2 id="Moving-and-aiming"><a href="#Moving-and-aiming" class="headerlink" title="Moving and aiming"></a>Moving and aiming</h2><p>这里面有多种算法来控制移动和瞄准。每个算法都解决一个特定问题。（理解为某种特定的相机行为模式,在此分为怎么样跟随，怎么样旋转）</p><h3 id="Body-properties-how-to-move-跟随"><a href="#Body-properties-how-to-move-跟随" class="headerlink" title="Body properties: how to move(跟随)"></a>Body properties: how to move(跟随)</h3><ul><li>Transposer：以<u>固定关系</u>移动到<strong>“跟随</strong>”目标，并具有可选的阻尼。</li><li>Do Nothing: 虚拟相机不移动。</li><li>Framing Transposer: 在固定的屏幕空间关系中移动到<strong>“跟随”</strong>目标，并带有可选的阻尼。</li><li>Orbital Transposer: 在可变关系中移动到<strong>“跟随”</strong>目标，可以选择接受玩家输入。??</li><li>Tracked Dolly: 沿预定义的路径移动。为静态拍摄或直接使用自定义脚本对摄像机位置进行动画处理，选择此算法。</li><li>Hard Lock to Target: 在<strong>“跟随</strong>”目标位置使用相同的位置。</li><li>3rd Person Follow: 将摄像机保持在相对于跟随目标的恒定位置和距离（受阻尼控制），跟踪目标的移动和旋转。</li></ul><h3 id="Aim-properties-how-to-rotate（瞄准）"><a href="#Aim-properties-how-to-rotate（瞄准）" class="headerlink" title="Aim properties: how to rotate（瞄准）"></a>Aim properties: how to rotate（瞄准）</h3><ul><li>Composer: 将<strong>“查看”</strong>目标保留在相机帧中，并带有合成约束。??</li><li>Group Composer: 在相机帧中保留多个<strong>“查看”</strong>目标。</li><li>Do Nothing: 不旋转</li><li>POV: 根据用户输入旋转虚拟摄像机</li><li>Same As Follow Target: 将相机的旋转设置为<strong>跟随</strong>目标的旋转。</li><li>Hard Look At: 将<strong>“看向”</strong>目标保持在相机帧的中心。</li></ul><h3 id="Composing-a-shot-构图"><a href="#Composing-a-shot-构图" class="headerlink" title="Composing a shot 构图"></a>Composing a shot 构图</h3><p>Framing Transposer/Composer/Group Composer算法定义了相机帧中区域，以便构图：</p><ul><li><p><strong>盲区</strong>：Cinemachine将目标保留在画面中的区域。</p></li><li><p><strong>柔和区域</strong>：如果目标进入帧的此区域，相机将重新定向以将其放回盲区。它将根据阻尼设置中指定的时间缓慢或快速地执行此操作。</p></li><li><p><strong>屏幕</strong>：死区中心的屏幕位置。0.5 是屏幕的中心。</p></li><li><p><strong>阻尼</strong>：模拟真实摄像机操作员在操作重型物理摄像机时引入的滞后。阻尼指定当目标进入<strong>软区</strong>时，当摄像机跟踪目标时，摄像机会快速或缓慢地做出反应。使用小数字来模拟响应更快的相机，快速移动或瞄准相机以将目标保持在<strong>盲区</strong>。模拟更重的摄像机数量越多，值越大，Cinemachine允许目标进入软区的数量就越多。</p><p><img src="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/images/CinemachineGameWindowGuides.png" alt="游戏窗口指南提供阻尼、屏幕、软区和死区的视觉指示"></p><blockquote><p>清晰区域表示<strong>盲区</strong>。蓝色区域表示<strong>柔和区域</strong>。软区和死区的位置表示<strong>屏幕</strong>位置。红色区域表示目标从未进入的<strong>无通过</strong>区域。黄色方块表示目标。</p></blockquote></li></ul><p>调整这些区域以获得各种相机行为。为此，请在“游戏”视图中拖动其边缘，或在“检查器”窗口中编辑其属性。</p><h2 id="使用噪点模拟相机抖动"><a href="#使用噪点模拟相机抖动" class="headerlink" title="使用噪点模拟相机抖动"></a>使用噪点模拟相机抖动</h2><p>现实世界的物理相机通常很重且笨重。它们由摄像机操作员手持或安装在不稳定的物体上，如移动的车辆。使用<a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraNoise.html">“杂色”属性</a>（Noise properties）来模拟这些真实世界品质，以获得电影效果。例如，您可以在跟随正在奔跑的角色时添加摄像机抖动，以使玩家沉浸在动作中。</p><h2 id="虚拟摄像机属性"><a href="#虚拟摄像机属性" class="headerlink" title="虚拟摄像机属性"></a>虚拟摄像机属性</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul><li><strong>Live</strong>：虚拟摄像机主动控制具有Cinemachine大脑的Unity摄像机。当Cinemachine大脑从一个虚拟摄像机混合到下一个虚拟摄像机时，两个虚拟摄像机都是实时的。混合完成后，只有一个实时虚拟摄像机。</li><li><strong>待机</strong>Standby：虚拟摄像机无法控制 Unity 摄像机。但是，它仍然遵循并瞄准其目标，并在每一帧更新。处于此状态的虚拟摄像机将被激活，其优先级与实时虚拟摄像机相同或更低。</li><li><strong>已禁用</strong>Disabled：虚拟摄像机无法控制 Unity 摄像机，也不会主动跟踪或瞄准其目标。处于此状态的虚拟摄像机不会消耗处理能力。要禁用虚拟摄像机，请停用其游戏对象。虚拟摄像机存在，但在场景中处于禁用状态。但是，即使游戏对象已停用，如果虚拟摄像机正在参与混合，或者如果时间轴调用了该混合，虚拟摄像机仍然可以控制 Unity 摄像机。</li></ul><table><thead><tr><th align="left"><strong>Property:</strong></th><th align="left"></th><th align="left"><strong>Function:</strong></th></tr></thead><tbody><tr><td align="left"><strong>Solo</strong></td><td align="left"></td><td align="left">Toggles whether or not the Virtual Camera is temporarily live. Use this property to get immediate visual feedback in the <a href="https://docs.unity.cn/Manual/GameView.html">Game view</a> to adjust the Virtual Camera.</td></tr><tr><td align="left"><strong>Game Window Guides</strong></td><td align="left"></td><td align="left">参考线</td></tr><tr><td align="left"><strong>Save During Play</strong></td><td align="left"></td><td align="left">Check to <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineSavingDuringPlay.html">apply the changes while in Play mode</a>.</td></tr><tr><td align="left"><strong>Priority</strong></td><td align="left"></td><td align="left">值越大，表示优先级越高。 将虚拟摄像机与时间轴配合使用时，此属性不起作用。</td></tr><tr><td align="left"><strong>Follow</strong></td><td align="left"></td><td align="left">The target GameObject that the Virtual Camera moves with. The <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraBody.html">Body properties</a> use this target to update <strong>the position of the Unity camera</strong>. //？？Keep this property empty to make the Unity camera use the position of the Virtual Camera’ transform. For example, you might choose to animate the Virtual Camera in Timeline.</td></tr><tr><td align="left"><strong>Look At</strong></td><td align="left"></td><td align="left">The target GameObject to aim the Unity camera at. The <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraAim.html">Aim properties</a> use this target to update the rotation of the Unity camera. Keep this property empty to make the Unity camera use the orientation of the Virtual Camera.</td></tr><tr><td align="left"><strong>Standby Update</strong></td><td align="left"></td><td align="left">Controls <u>how often</u> the virtual camera is updated when the virtual camera is not live.</td></tr><tr><td align="left"><strong>Position Blending</strong></td><td align="left"></td><td align="left">Style for blending positions to and from this Virtual Camera.</td></tr><tr><td align="left"></td><td align="left"><em>Linear</em></td><td align="left">Standard linear position blend.</td></tr><tr><td align="left"></td><td align="left"><em>Spherical</em></td><td align="left">Spherical blend about the Look At position, if there is a Look At target.</td></tr><tr><td align="left"></td><td align="left"><em>Cylindrical</em>圆柱</td><td align="left">Cylindrical blend about the Look At position, if there is a Look At target. Vertical coordinate is linearly interpolated.</td></tr><tr><td align="left"><strong>Lens</strong></td><td align="left"></td><td align="left">属性镜像<a href="https://docs.unity.cn/Manual/class-Camera.html">Unity camera</a>.</td></tr><tr><td align="left"></td><td align="left"><em>Field Of View</em></td><td align="left">The camera view in vertical degrees. For example, to specify the equivalent of a 50mm lens on a Super 35 sensor, enter a Field of View of 19.6 degrees. This property is available when the Unity camera with the Cinemachine Brain component uses a Projection of Perspective.//太专业了，不懂</td></tr><tr><td align="left"></td><td align="left"><em>Presets</em></td><td align="left">A drop-down menu of settings for commonly-used lenses. Choose <strong>Edit Presets</strong> to add or edit the asset that contains a default list of lenses.</td></tr><tr><td align="left"></td><td align="left"><em>Orthographic Size</em></td><td align="left">When using an orthographic camera, defines the half-height of the camera view, in world coordinates. Available when the Unity camera with the Cinemachine Brain component uses a Projection of Orthographic.</td></tr><tr><td align="left"></td><td align="left"><em>Near Clip Plane</em></td><td align="left">The closest point relative to the camera where drawing occurs.</td></tr><tr><td align="left"></td><td align="left"><em>Far Clip Plane</em></td><td align="left">The furthest point relative to the camera where drawing occurs.</td></tr><tr><td align="left"></td><td align="left"><em>Dutch</em>荷兰语（特有的）</td><td align="left">Dutch angle. Tilts the Unity camera on the z-axis, in degrees. This property is unique to the Virtual Camera; there is no counterpart property in the Unity camera.</td></tr><tr><td align="left"><strong>Mode Override</strong></td><td align="left"></td><td align="left">Allows you to select a different camera mode to apply to the <a href="https://docs.unity.cn/Manual/class-Camera.html">Unity camera</a> component when Cinemachine activates this Virtual Camera. <strong>Important:</strong> All the changes applied to the Camera component through this setting will remain after the Virtual Camera deactivation. If you set a mode override in any Virtual Camera, you should set one in all Virtual Cameras.</td></tr><tr><td align="left"></td><td align="left"><em>None</em></td><td align="left">Leaves the <strong>Projection</strong> and <strong>Physical Camera</strong> properties unchanged in the Camera.</td></tr><tr><td align="left"></td><td align="left"><em>Orthographic</em></td><td align="left">Sets the <strong>Projection</strong> property to <strong>Orthographic</strong>.</td></tr><tr><td align="left"></td><td align="left"><em>Perspective</em></td><td align="left">Sets the <strong>Projection</strong> property to <strong>Perspective</strong> and <em>disables</em> the <strong>Physical Camera</strong> feature and properties.</td></tr><tr><td align="left"></td><td align="left"><em>Physical</em></td><td align="left">Sets the <strong>Projection</strong> property to <strong>Perspective</strong> and <em>enables</em> the <strong>Physical Camera</strong> feature and properties.</td></tr><tr><td align="left"><strong>Blend Hint</strong></td><td align="left"></td><td align="left">Provides hints for blending positions to and from the virtual camera.</td></tr><tr><td align="left"><strong>Inherit Position</strong></td><td align="left"></td><td align="left">When enabled, whenever this virtual camera goes live, forces the initial position to be the same as the current position of the Unity Camera, if possible.</td></tr><tr><td align="left"><strong>Extensions</strong></td><td align="left"></td><td align="left">Components that add extra behaviors to the Virtual Camera.</td></tr><tr><td align="left"></td><td align="left"><em>Add Extension</em></td><td align="left">Choose a new <a href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraExtensions.html">extension</a> to add to the Virtual Camera.</td></tr></tbody></table><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><p><a href="https://docs.unity3d.com/2021.3/Documentation/Manual/UIToolkits.html">Unity - 手动：创建用户界面 （UI） (unity3d.com)</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>表示在其中布局和呈现 UI 的抽象空间。所有 UI 元素都必须是附加了画布组件的游戏对象的子级。</p><table><thead><tr><th align="left">*<em>Property:*</em></th><th align="left">*<em>Function:*</em></th></tr></thead><tbody><tr><td align="left"><strong>Render Mode</strong></td><td align="left">The way the <strong>UI</strong>  is rendered to the screen or as an object in 3D space (see below). The options are <em>Screen Space - Overlay</em>, <em>Screen Space - Camera</em> and <em>World Space</em>.</td></tr><tr><td align="left"><strong>Pixel Perfect (*Screen Space* modes only)</strong></td><td align="left">Should the UI be rendered without <strong>antialiasing</strong>  for precision?为了精确度产生抗锯齿</td></tr><tr><td align="left"><strong>Render</strong> Camera__ (<em>Screen Space - Camera</em> mode only)__</td><td align="left">The camera to which the UI should be rendered (see below).</td></tr><tr><td align="left"><strong>Plane Distance (*Screen Space - Camera* mode only)</strong></td><td align="left">The distance at which the UI plane should be placed in front of the camera.</td></tr><tr><td align="left"><strong>Event Camera (*World Space* mode only)</strong></td><td align="left">The camera that will be used to process UI events.</td></tr><tr><td align="left"><strong>Receives Events</strong></td><td align="left">UI 事件是否由此画布处理？</td></tr></tbody></table><h3 id="单个或多个canvas"><a href="#单个或多个canvas" class="headerlink" title="单个或多个canvas"></a>单个或多个canvas</h3><p>所有 UI 元素的单个画布就足够了，但scene是可能的。也可以使用嵌套的 Canvas，其中一个 Canvas 被放置为另一个 Canvas 的子级以进行优化。嵌套的画布使用与其父级相同的渲染模式。</p><h3 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h3><h4 id="Screen-Space-Overlay-屏幕空间-叠加"><a href="#Screen-Space-Overlay-屏幕空间-叠加" class="headerlink" title="Screen Space - Overlay 屏幕空间 - 叠加"></a>Screen Space - Overlay 屏幕空间 - 叠加</h4><p>在此模式下，将缩放 Canvas 以<strong>适合屏幕</strong>，然后直接渲染，而<strong>不参考场景或摄像机</strong>（即使场景中根本没有摄像机，也会渲染 UI）。如果屏幕的大小或分辨率发生更改，则 UI 将自动重新缩放以适合屏幕大小。UI 将在任何其他图形（如相机视图）上绘制。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasOverlay.png" alt="在场景对象上呈现的叠加 UI"></p><blockquote><p>在场景对象上呈现的叠加 UI</p></blockquote><p>注： “屏幕空间 - 叠加”画布需要存储在层次结构的顶层。如果不使用它，则 UI 可能会从视图中消失。这是一个内置限制。将“屏幕空间 - 叠加”画布<strong>保留在层次结构的顶层</strong>，以获得预期的结果。(在游戏对象的排序中最前？)</p><h4 id="Screen-Space-Camera-屏幕空间-相机"><a href="#Screen-Space-Camera-屏幕空间-相机" class="headerlink" title="Screen Space - Camera 屏幕空间 - 相机"></a>Screen Space - Camera 屏幕空间 - 相机</h4><p>在此模式下，Canvas 的渲染方式就像是<strong>在给定摄像机前方一定距离的平面对象上绘制</strong>的一样。UI 的屏幕大小不会随距离而变化，因为它始终会重新缩放以完全适合<a href="https://docs.unity3d.com/2021.3/Documentation/Manual/FrustumSizeAtDistance.html">相机视锥体</a>。如果屏幕的大小或分辨率或相机视锥体发生更改，则 UI 将自动重新缩放以适合。任何<strong>3D 对象</strong>在场景中，比UI平面更靠近UI平面将在UI前面渲染，而平面后面的对象将被遮挡。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasCamera.png" alt="相机模式 UI，前面有场景对象"></p><blockquote><p>相机模式 UI，前面有场景对象</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/dcd6a08baf6d9250.png" alt="image-20220516145017102"></p><blockquote><p>Plane distance: 绘制平面离相机多远</p></blockquote><h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>此模式将 UI 呈现为<strong>场景中的平面对象</strong>。然而，与<em>屏幕空间 - 相机</em>模式不同，飞机不需要面对相机，并且可以随心所欲地定向。Canvas 的大小可以使用其 Rect Transform 进行设置，但<strong>其屏幕大小将取决于摄像机的视角和距离</strong>。其他场景对象可以穿过画布的后面、穿过或前面。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasWorldSpace.png" alt="与场景对象相交的世界空间 UI"></p><blockquote><p>与场景对象相交的世界空间 UI</p></blockquote><h3 id="适应屏幕分辨率"><a href="#适应屏幕分辨率" class="headerlink" title="适应屏幕分辨率"></a>适应屏幕分辨率</h3><h4 id="使用锚点适应不同的宽高比（相对位置）"><a href="#使用锚点适应不同的宽高比（相对位置）" class="headerlink" title="使用锚点适应不同的宽高比（相对位置）"></a>使用锚点适应不同的宽高比（相对位置）</h4><ul><li><p>锚点Anchors</p><p>（父布局如Canvas和子布局如Img相对变换的关系）</p></li><li><p>Pivot控件自身的锚点</p><p>在Pivot模式下才能编辑（相当于自身坐标时吧，反之是世界坐标？）</p></li></ul><p>把控件锚定到各自的角落</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_MultiResCorners.png" alt="img"></p><h4 id="随屏幕尺寸缩放（相对大小）"><a href="#随屏幕尺寸缩放（相对大小）" class="headerlink" title="随屏幕尺寸缩放（相对大小）"></a>随屏幕尺寸缩放（相对大小）</h4><p>The <strong>Canvas Scaler</strong> component can be added to a root <strong>Canvas</strong></p><ul><li><p>UI缩放模式：随屏幕大小缩放</p></li><li><p>可以指定要用作参考的分辨率。如果当前屏幕分辨率小于或大于此参考分辨率，则会相应地设置 Canvas 的比例因子，以便所有 UI 元素与屏幕分辨率一起放大或缩小</p></li><li><p>缩放的方式也会带来效果的不同：</p><ul><li><p>添加 Canvas Scaler 组件后，检查布局在其他宽高比下的外观也很重要。通过将分辨率设置回 Phone HD 横向，我们可以看到按钮现在看起来比它们应该（和过去）更大。</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_MultiResLandscapeWrongScaling.png" alt="img"></p><blockquote><p>横向宽高比中较大按钮的原因归结为画布缩放器设置的工作方式。默认情况下，它将宽度或当前分辨率与 Canvas 缩放器的宽度进行比较，并将结果用作缩放所有内容的比例因子。由于当前 960 x 640 的横向分辨率的宽度比 640 x 960 的纵向 Canvas 缩放器大 1.5 倍，因此布局放大了 1.5 倍。**[只比较宽度]**</p></blockquote></li><li><p><strong>Match</strong> 的属性，该属性可以是 0（宽度）、1（高度）或介于两者之间的值。默认情况下，它设置为 0，这会将当前屏幕宽度与画布缩放器宽度进行比较，如上所述。</p><p>如果 <strong>Match</strong> 属性设置为 0.5，它将当前宽度与参考宽度进行比较，将当前<strong>高度</strong>与参考高度进行比较，并选择介于两者之间的比例因子。由于在这种情况下，横向分辨率宽1.5倍，但也短1.5倍，因此这两个因素平衡并产生最终比例因子1，这意味着按钮保持其原始大小。</p></li></ul></li></ul><h3 id="Canvas-Group"><a href="#Canvas-Group" class="headerlink" title="Canvas Group"></a>Canvas Group</h3><p>The <strong>Canvas Group</strong> can be used to control certain aspects of a whole group of <strong>UI</strong> elements from one place without needing to handle them each individually. The properties of the Canvas Group affect the <strong>GameObject</strong> it is on as well as all children.</p><p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_CanvasGroupInspector.png" alt="img"></p><table><thead><tr><th align="left">*<strong>Property:*</strong></th><th align="left">*<strong>Function:*</strong></th></tr></thead><tbody><tr><td align="left"><strong>Alpha</strong></td><td align="left">此组中 UI 元素的不透明度。该值介于 0 和 1 之间，其中 0 表示完全透明，1 表示完全不透明。请注意，元素也保留其自身的透明度，因此 Canvas Group Alpha 和各个 UI 元素的 Alpha 值将相互相乘。</td></tr><tr><td align="left"><strong>Interactable</strong></td><td align="left">确定此组件是否接受输入。当它设置为 false 交互时，将禁用该交互。</td></tr><tr><td align="left"><strong>Block Raycasts</strong></td><td align="left">此组件是否充当<strong>对撞机</strong><br>对于 Raycasts？您需要在连接到 Canvas 的图形光线投射器上调用 RayCast 函数。这<em>不适用于</em><strong>Physics.Raycast</strong>。</td></tr><tr><td align="left"><strong>Ignore Parent Groups</strong></td><td align="left">此组是否也会受到游戏对象层次结构中更上方的 Canvas 组组件中的设置的影响，还是会忽略这些设置并因此覆盖它们？</td></tr></tbody></table><p>Canvas Group 的典型用途包括：</p><ul><li>通过在窗口的游戏对象上添加画布组来淡入或淡出整个窗口，并控制其 Alpha 属性。</li><li>通过将 Canvas 组添加到父游戏对象并将其 Interactable 属性设置为 false，使整组控件不可交互（“灰显”）。</li><li>通过将 Canvas Group 组件放在元素或其父元素之一上，并将其 Block Raycasts 属性设置为 false，使一个或多个 UI 元素不阻止鼠标事件。</li></ul><h2 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h2><p>此子系统负责控制构成事件的所有其他元素。它协调当前处于活动状态的输入模块，哪个<strong>游戏对象</strong>目前被认为是“被选中的”，以及许多其他高级别<strong>事件系统</strong>概念。</p><h4 id="Graphic-Raycaster-图形光线投射器"><a href="#Graphic-Raycaster-图形光线投射器" class="headerlink" title="Graphic Raycaster 图形光线投射器"></a>Graphic Raycaster 图形光线投射器</h4><p>图形光线投射器用于<strong>对画布进行光线投射</strong>。Raycaster 会查看画布上的所有图形，并确定其中<strong>是否有任何图形被击中</strong>。</p><table><thead><tr><th align="left">*<strong>Property:*</strong></th><th align="left">*<strong>Function:*</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ignore Reversed Graphics</strong></td><td align="left">是否应考虑远离光线投射器的图形？</td></tr><tr><td align="left"><strong>Blocked Objects</strong></td><td align="left">将阻止图形光线投射的对象类型。</td></tr><tr><td align="left"><strong>Blocking Mask</strong></td><td align="left">Type of objects that will block graphic raycasts.</td></tr></tbody></table><h4 id="Physics-Raycaster"><a href="#Physics-Raycaster" class="headerlink" title="Physics Raycaster"></a>Physics Raycaster</h4><p>The Raycaster raycasts against <strong>3D objects</strong> in the <strong>scene</strong>. This allows messages to be sent to 3D physics objects that implement event interfaces.（意思是可以将点击事件反馈到3D物理对象上？）</p><table><thead><tr><th align="left">*<strong>Property:*</strong></th><th align="left">*<strong>Function:*</strong></th></tr></thead><tbody><tr><td align="left"><strong>Depth</strong></td><td align="left">Get the depth of the configured <strong>camera</strong> .</td></tr><tr><td align="left"><strong>Event Camera</strong></td><td align="left">Get the camera that is used for this module.</td></tr><tr><td align="left"><strong>Event Mask</strong></td><td align="left">Logical and of Camera mask and eventMask.</td></tr><tr><td align="left"><strong>Final Event Mask</strong></td><td align="left">Logical and of Camera mask and eventMask.</td></tr></tbody></table><h1 id="unity中括号"><a href="#unity中括号" class="headerlink" title="unity中括号"></a>unity中括号</h1><h2 id="HideInInspector"><a href="#HideInInspector" class="headerlink" title="[HideInInspector]"></a>[HideInInspector]</h2><p>让public变量在编辑器里不显示</p><h2 id="SerializeField"><a href="#SerializeField" class="headerlink" title="[SerializeField]"></a>[SerializeField]</h2><p>让private在编辑器里显示</p><h2 id="Range-0-100"><a href="#Range-0-100" class="headerlink" title="[Range(0,100)]"></a>[Range(0,100)]</h2><p>设定某个值的范围</p><h2 id="Header-“XXX”"><a href="#Header-“XXX”" class="headerlink" title="[Header(“XXX”)]"></a>[Header(“XXX”)]</h2><p>显示提示</p><h2 id="Tooltip-“XXX”"><a href="#Tooltip-“XXX”" class="headerlink" title="[Tooltip(“XXX”)]"></a>[Tooltip(“XXX”)]</h2><p>鼠标移至属性名产生提示</p><h2 id="Space-50"><a href="#Space-50" class="headerlink" title="[Space(50)]"></a>[Space(50)]</h2><p>空出几行</p><p><a href="https://zhuanlan.zhihu.com/p/101124913">Unity脚本用中括号引起来的属性 - 知乎 (zhihu.com)</a></p><h2 id="RequireComponent-typeof-XX"><a href="#RequireComponent-typeof-XX" class="headerlink" title="[RequireComponent(typeof(XX))]"></a>[RequireComponent(typeof(XX))]</h2><p>当你添加的一个用了RequireComponent组件的脚本，需要的组件将会自动被添加到game object（游戏物体）。这个可以有效的避免组装错误。</p><h1 id="昼夜交替"><a href="#昼夜交替" class="headerlink" title="昼夜交替"></a>昼夜交替</h1><p><a href="https://www.youtube.com/watch?v=H3JpkcGi8DI">DAY &amp; NIGHT CYCLE in Unity using HDRP (2019.3) - YouTube</a></p><h2 id="时间的范围和计时机制"><a href="#时间的范围和计时机制" class="headerlink" title="时间的范围和计时机制"></a>时间的范围和计时机制</h2><h2 id="模拟阳光的角度变换"><a href="#模拟阳光的角度变换" class="headerlink" title="模拟阳光的角度变换"></a>模拟阳光的角度变换</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*白天阳光的旋转角度*/</span></span><br><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;Sun Light&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Transform dailyRotation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustSunRotation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">float</span> sunAngle = timeOfDay * <span class="number">360f</span>;</span><br><span class="line">    dailyRotation.transform.localRotation = Quaternion.Euler(<span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, sunAngle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Transform-localRotation"><a href="#Transform-localRotation" class="headerlink" title="Transform.localRotation"></a>Transform.localRotation</h3><ul><li><p>相对于父级变换旋转的变换旋转</p></li><li><p>Unity 在内部将旋转存储为四元数。要旋转对象，请使用 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Transform.Rotate.html">Transform.Rotate</a>。 要将旋转修改为欧拉角，请使用 <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Transform-localEulerAngles.html">Transform.localEulerAngles</a></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.localRotation = Quaternion.identity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Quaternion-Euler"><a href="#Quaternion-Euler" class="headerlink" title="Quaternion.Euler"></a>Quaternion.Euler</h3><ul><li><p>public static <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Quaternion.html">Quaternion</a> <strong>Euler</strong> (float <strong>x</strong>, float <strong>y</strong>, float <strong>z</strong>);</p></li><li><p>返回一个旋转，它围绕 z 轴旋转 z 度、围绕 x 轴旋转 x 度、围绕 y 轴旋转 y 度（按该顺序应用）。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// A rotation 30 degrees around the y-axis</span></span><br><span class="line">    Quaternion rotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>public static <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Quaternion.html">Quaternion</a> <strong>Euler</strong> (<a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.html">Vector3</a> <strong>euler</strong>);</p></li><li><p>返回一个围绕 Z 轴旋转 z 度、围绕 X 轴旋转 x 度、围绕 Y 轴旋转 y 度的旋转。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// A rotation 30 degrees around the y-axis</span></span><br><span class="line">      Vector3 rotationVector = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">      Quaternion rotation = Quaternion.Euler(rotationVector);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">### Unity中的旋转和方向</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>D 应用程序中的旋转通常以两种方式之一表示：四元数或欧拉角。每种方式都有自己的用途和缺点。Unity 在内部使用四元数表示，但在 Inspector 中显示等效的欧拉角值以便于进行编辑。</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 欧拉角</span></span><br><span class="line"></span><br><span class="line">​欧拉角由按顺序应用的 X、Y 和 Z 三个角度值来表示。要将欧拉旋转应用于特定游戏对象，则依次应用每个旋转值，作为围绕其对应轴的旋转。</span><br><span class="line"></span><br><span class="line">* 优点：具有直观的“可读”格式，由三个角度组成；可表示通过大于 <span class="number">180</span> 度转向从一个方向到另一个方向的旋转</span><br><span class="line"></span><br><span class="line">* 局限性：欧拉角受到[万向锁 (Gimbal Lock)](https:<span class="comment">//en.wikipedia.org/wiki/Gimbal_lock) 的影响。当依次施加三个旋转时，第一个或第二个旋转可能导致第三个轴的方向与先前两个轴之一相同。这意味着已失去“自由度”，因为不能围绕唯一轴应用第三个旋转值。</span></span><br><span class="line"></span><br><span class="line">  &gt; 先浅浅了解一下万向锁：[“欧拉角旋转”产生“万向锁”的来源，以及如何避免万向锁_哔哩哔哩_bilibili](https:<span class="comment">//www.bilibili.com/video/BV1YJ41127qe?spm_id_from=333.337.search-card.all.click)</span></span><br><span class="line">  &gt;</span><br><span class="line">  &gt; [计算机动画 ：用unity引擎演示万向节死锁（Gimbal Lock）现象 - 知乎 (zhihu.com)](https:<span class="comment">//zhuanlan.zhihu.com/p/376468636)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#### 四元数</span></span><br><span class="line"></span><br><span class="line">​四元数可用于表示&lt;u&gt;游戏对象的方向或旋转&lt;/u&gt;。此表示方式在内部由四个数字组成（在 Unity 中称为 x、y、z 和 w），但是这些数字&lt;u&gt;不代表角度或轴&lt;/u&gt;，您通常不需要直接访问它们。除非特别想深入研究[四元数的数学原理](https:<span class="comment">//en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)，否则只需要知道四元数&lt;u&gt;代表 3D 空间中的旋转即可&lt;/u&gt;，通常不需要知道或修改 x、y 和 z 属性。</span></span><br><span class="line"></span><br><span class="line">- **优点**：四元数旋转不受万向锁的影响。</span><br><span class="line">- **局限性**：单个四元数不能表示任何方向超过 <span class="number">180</span> 度的旋转。</span><br><span class="line">- **局限性**：四元数的数字表示在直观上难以理解。</span><br><span class="line"></span><br><span class="line">​Unity 在内部将所有游戏对象旋转存储为四元数，因为这种表示方式的好处超过了局限性。</span><br><span class="line"></span><br><span class="line">​Transform Inspector 会使用欧拉角显示旋转，因为这种形式更容易理解和编辑。Unity 将 Inspector 中输入的用于旋转游戏对象的新值转换为该游戏对象的新四元数旋转值</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 对动画的影响</span></span><br><span class="line"></span><br><span class="line">​许多 <span class="number">3</span>D 制作包以及 Unity 自己的内部 [Animation 窗口](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/AnimationEditorGuide.html)均允许使用欧拉角来指定动画期间的旋转。</span></span><br><span class="line"></span><br><span class="line">​这些旋转值通常可能超过四元数可表示的范围。例如，如果一个游戏对象旋转 <span class="number">720</span> 度，这可以用欧拉角“X：<span class="number">0</span>，Y：<span class="number">720</span>，Z：<span class="number">0</span>”表示。但这不能通过四元数值来表示。</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 四元数扩展</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">重要的类 - Quaternion - Unity 手册</span>](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/class-Quaternion.html)</span></span><br><span class="line"></span><br><span class="line">Unity 使用 Quaternion 类来存储游戏对象的三维方向，也使用它们来描述从一个方向到另一个方向的相对旋转。</span><br><span class="line"></span><br><span class="line">&lt;u&gt;处理脚本中的旋转时，应使用 Quaternion 类及其函数来创建和修改旋转值。&lt;/u&gt;在某些情况下，使用欧拉角也是有效的，但应记住： - 应使用处理欧拉角的 Quaternion 类函数 - 从旋转中检索、修改和重新应用欧拉值可能会导致意外的副作用</span><br><span class="line"></span><br><span class="line"><span class="meta">##### 直接创建和操作四元数</span></span><br><span class="line"></span><br><span class="line">* 创建旋转</span><br><span class="line"></span><br><span class="line">  ```csharp</span><br><span class="line">  <span class="comment">//Quaternion.LookRotaion</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Vector3 relativePos = target.position - transform.position;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// the second argument, upwards, defaults to Vector3.up</span></span><br><span class="line">          Quaternion rotation = Quaternion.LookRotation(relativePos, Vector3.up);</span><br><span class="line">          transform.rotation = rotation;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.Angle</span></span><br><span class="line">  <span class="comment">//返回两个旋转 a 和 b 之间的角度（以度为单位）</span></span><br><span class="line">  <span class="built_in">float</span> angle = Quaternion.Angle(transform.rotation, target.rotation);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.AngleAxis</span></span><br><span class="line">  <span class="comment">//创建一个围绕 axis 旋转 angle 度的旋转</span></span><br><span class="line">  transform.rotation = Quaternion.AngleAxis(<span class="number">30</span>, Vector3.up);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.FromToRotation</span></span><br><span class="line">  <span class="comment">//创建一个从 fromDirection 旋转到 toDirection 的旋转</span></span><br><span class="line">  transform.rotation = Quaternion.FromToRotation(Vector3.up, transform.forward);</span><br></pre></td></tr></table></figure></li><li><p>操作旋转</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Quaternion.Slerp</span></span><br><span class="line"><span class="comment">//Quaternion 在四元数 a 和 b 之间进行球形插值的四元数,参数 t 限制在范围 [0, 1] 内</span></span><br><span class="line"><span class="comment">//这可用于创建一个旋转，以基于参数的值 a，在第一个四元数 a 到第二个四元数 b 之间平滑进行插值。如果参数的值接近于 0，则输出会接近于 /a/，如果参数的值接近于 1，则输出会接近于 /b/</span></span><br><span class="line"><span class="keyword">public</span> Transform <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timeCount = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.rotation = Quaternion.Slerp(<span class="keyword">from</span>.rotation, to.rotation, timeCount);</span><br><span class="line">        timeCount = timeCount + Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quaternion.Inverse</span></span><br><span class="line"><span class="comment">//返回 rotation 的反转</span></span><br><span class="line">Transform target;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.rotation = Quaternion.Inverse(target.rotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quaternion.RotateTowards</span></span><br><span class="line"><span class="comment">//将旋转 from 向 to 旋转。将 from 四元数朝 to 旋转 maxDegreesDelta 的角度步长（但请注意， 该旋转不会过冲）。 如果 maxDegreesDelta 为负值，则向远离 to 的方向旋转，直到旋转 恰好为相反的方向。</span></span><br><span class="line"><span class="comment">// The object whose rotation we want to match.</span></span><br><span class="line">Transform target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Angular speed in degrees per sec.</span></span><br><span class="line"><span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The step size is equal to speed times frame time.</span></span><br><span class="line">    <span class="keyword">var</span> step = speed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate our transform a step closer to the target&#x27;s.</span></span><br><span class="line">    transform.rotation = Quaternion.RotateTowards(transform.rotation, target.rotation, step);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用欧拉角</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某些情况下，更适合在脚本中使用欧拉角。这时，请务必注意，必须将角度保存在变量中，在使用它们的时候，仅将它们作为欧拉角应用于旋转，最终仍应存储为 Quaternion。虽然可从四元数中获取欧拉角，但在获取、修改和重新应用时，可能会出现问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转脚本错误 #1</span></span><br><span class="line"><span class="comment">// 此处的错误在于我们正在修改四元数的 x 值</span></span><br><span class="line"><span class="comment">// 此值不表示角度，不会产生所需的结果</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> rot = transform.rotation;</span><br><span class="line">    rot.x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = rot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转脚本错误 #2</span></span><br><span class="line"><span class="comment">// 从四元数读取、修改并写入欧拉值。</span></span><br><span class="line"><span class="comment">// 因为这些值是从四元数计算的，</span></span><br><span class="line"><span class="comment">// 所以每个新的旋转可能会返回非常不同的欧拉角，而这可能会受到万向锁的影响。</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> angles = transform.rotation.eulerAngles;</span><br><span class="line">    angles.x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = Quaternion.Euler(angles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确使用欧拉角的旋转脚本。</span></span><br><span class="line"><span class="comment">// 将欧拉角存储在一个类变量中，并仅使用</span></span><br><span class="line"><span class="comment">// 该变量作为欧拉角进行应用，但从不依赖于读回欧拉值。</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">float</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = Quaternion.Euler(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="阳光变换过程中的处理"><a href="#阳光变换过程中的处理" class="headerlink" title="阳光变换过程中的处理"></a>阳光变换过程中的处理</h2><h3 id="阳光的强度"><a href="#阳光的强度" class="headerlink" title="阳光的强度"></a>阳光的强度</h3><p>（待研究</p><h3 id="阳光的颜色"><a href="#阳光的颜色" class="headerlink" title="阳光的颜色"></a>阳光的颜色</h3><h2 id="ui和时间的绑定"><a href="#ui和时间的绑定" class="headerlink" title="ui和时间的绑定"></a>ui和时间的绑定</h2><h2 id="Unity实时阴影"><a href="#Unity实时阴影" class="headerlink" title="Unity实时阴影"></a>Unity实时阴影</h2><p><a href="https://blog.csdn.net/qq_35711014/article/details/106746027">(34条消息) Unity角色实时阴影方案_一克拉绿豆的博客-CSDN博客_unity 实时阴影</a></p><h1 id="Nav-Mesh-Agent-导航网格代理"><a href="#Nav-Mesh-Agent-导航网格代理" class="headerlink" title="Nav Mesh Agent 导航网格代理"></a>Nav Mesh Agent 导航网格代理</h1><p>NavMeshAgent 组件可帮助您创建在朝目标移动时能够彼此避开的角色。代理 (Agent) 使用导航网格来推断游戏世界，并知道如何避开彼此以及其他移动障碍物。寻路和空间推断是使用导航网格代理的脚本 API 进行处理的。</p><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul><li>从一点走到一点</li><li>需要考虑：阻挡，路径选择，可行路径，地形特点（沙地草地等）……</li></ul><h2 id="游戏中常用的导航情况"><a href="#游戏中常用的导航情况" class="headerlink" title="游戏中常用的导航情况"></a>游戏中常用的导航情况</h2><ul><li>ai角色：纯导航</li><li>主角：ui交互控制下的导航——？</li></ul><h2 id="导航的常用算法"><a href="#导航的常用算法" class="headerlink" title="导航的常用算法"></a>导航的常用算法</h2><ul><li>A*算法（广度优先）<ul><li>广泛应用于2D格子型地图</li></ul></li><li>navigation mesh的寻路算法原理<ul><li>A*算法的变种</li><li>将A*算法的格子变成三角形或多边形网络<ul><li>如何构建合理高效的三角形网格，即navigation Mesh</li></ul></li><li>可以方便地从二维扩展到三维</li><li>3D游戏的主流寻路算法（基于三角形网格）</li></ul></li></ul><h2 id="导航网格制作"><a href="#导航网格制作" class="headerlink" title="导航网格制作"></a>导航网格制作</h2><h3 id="标记哪些物体是属于导航网格的"><a href="#标记哪些物体是属于导航网格的" class="headerlink" title="标记哪些物体是属于导航网格的"></a>标记哪些物体是属于导航网格的</h3><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/b2b81d3d8b6ef4db.png" alt="image-20220527210302934"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/a6914beef4d9ff26.png" alt="image-20220527210737542"></p><blockquote><p>可以在这个视图中查看到物体被纳入</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/0294525fcd76abd0.png" alt="image-20220527210825800"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/0423c1f54e4e0037.png" alt="image-20220527210839518"></p><blockquote><p>Bake会出现这些三角形网格。这些物体也是被设为navigation static的</p></blockquote><ul><li>一般会用虚拟物来自定义导航网格的面积，基于模型的话生成的结果可能偏差很大</li></ul><h2 id="控制物体在导航网格上行走"><a href="#控制物体在导航网格上行走" class="headerlink" title="控制物体在导航网格上行走"></a>控制物体在导航网格上行走</h2><ul><li><p>加上Nav Mesh Agent组件</p></li><li><p>脚本控制方法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*首先要声明using UnityEngine.AI*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1.自动导航到目标坐标（朝向默认为z轴）</span></span><br><span class="line">  NevMeshAgent agent = Get...</span><br><span class="line">  agent.SetDestination(<span class="keyword">new</span> Vector3(,,));</span><br><span class="line"></span><br><span class="line">​可以展示导航情况；目标在网格外的话就停在网格内</span><br><span class="line"></span><br><span class="line">&gt; 路线是提前设置好并算死了的而且不会考虑碰撞，如果路上遇到阻碍可能会卡在那儿；</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果物体离网格太远的话会无法生成代理？会发出警告</span><br><span class="line"></span><br><span class="line">* 组件的参数设置：[导航网格代理 (NavMesh Agent) - Unity 手册](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/class-NavMeshAgent.html)</span></span><br><span class="line">* 在实践中角色行走会很卡顿不流畅？</span><br><span class="line"></span><br><span class="line"><span class="meta">## Nav Mesh  Obstacle组件</span></span><br><span class="line"></span><br><span class="line">阻碍物（不可行走类型）可以随着移动而动态变化烘焙的网格。</span><br><span class="line"></span><br><span class="line"><span class="meta"># 鼠标对人物行走的控制</span></span><br><span class="line"></span><br><span class="line"><span class="meta">## 鼠标点击控制人物运动</span></span><br><span class="line"></span><br><span class="line"><span class="meta">### 鼠标点击的位置落在模型上</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">移动设备输入 - Unity 手册</span>](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/MobileInput.html)</span></span><br><span class="line"></span><br><span class="line">```<span class="function">csharp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Ray ray = cam.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">            RaycastHit hit;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;We hit&quot;</span> + hit.collider.name);</span><br><span class="line">                Debug.DrawRay(ray.origin, ray.direction * <span class="number">10</span>, Color.yellow,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>Camera.ScreenPointToRay()</p><p>public <a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Ray.html">Ray</a> <strong>ScreenPointToRay</strong> (<a href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.html">Vector3</a> <strong>pos</strong>);</p><ul><li>从摄像机的方向发出的一条到鼠标点方向的射线</li><li>易看出摄像机点是固定的，鼠标在屏幕周围映射到四方，呈现点射光的状态</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/938081b90cf4959a.png" alt="image-20220528101846438"></p><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/629ff5209bdefd99.png" alt="image-20220528102026215"></p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;We hit&quot;</span> + hit.collider.name);</span><br><span class="line">    Debug.DrawRay(ray.origin, ray.direction * <span class="number">10</span>, Color.yellow,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>生出光线之后，赋予物理属性，即可发生碰撞，这样就能与场景中的物体产生互动。</p></blockquote><h2 id="自动导航到目标点"><a href="#自动导航到目标点" class="headerlink" title="自动导航到目标点"></a>自动导航到目标点</h2><h2 id="导航造成动画卡顿和小鸡无法获得主角的动态位置"><a href="#导航造成动画卡顿和小鸡无法获得主角的动态位置" class="headerlink" title="导航造成动画卡顿和小鸡无法获得主角的动态位置"></a>导航造成动画卡顿和小鸡无法获得主角的动态位置</h2><ul><li><p>isKinematic:关闭动力学的模拟；覆盖use gravity，不受重力影响</p><p>由此position将完全由脚本或者动画控制。</p><p><a href="https://www.kchuhai.com/report/view-4168.html">改变Rigidbody组件中IsKinematic属性的实验 - 快出海 (kchuhai.com)</a></p></li><li><p>为什么主角加上Nav组件，rigidbody勾选use gravity就卡住不动，把动力学取消了就能艰难移动？</p></li><li><p>小鸡无法跟踪是因为之前把project的prefab拖进去了，要拖进hierarchy的才行……</p></li></ul><h1 id="自动导航与刚体运动的冲突"><a href="#自动导航与刚体运动的冲突" class="headerlink" title="自动导航与刚体运动的冲突"></a>自动导航与刚体运动的冲突</h1><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/01a2abb988c7094a.png" alt="image-20220530150307740"></p>]]></content>
    
    
    <summary type="html">结课作业第一波：第一次尝试想法先行，后操作</summary>
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity入门(二)</title>
    <link href="http://example.com/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://example.com/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/</id>
    <published>2022-04-10T16:00:00.000Z</published>
    <updated>2022-06-15T09:13:05.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3D动画"><a href="#3D动画" class="headerlink" title="3D动画"></a>3D动画</h1><p>终于弄懂是怎么回事了！！</p><h2 id="Avatar到底干啥用"><a href="#Avatar到底干啥用" class="headerlink" title="Avatar到底干啥用"></a>Avatar到底干啥用</h2><p>Avatar是得和模型部位一一对应的。</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/0f7dd9e233365448.png" alt="image-20220411165207704"></p><blockquote><p>avatar的对应的总的那个东西，点击进行修改</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/f4b8ac4b9f7308b6.png" alt="image-20220411165247758"></p></blockquote><h2 id="外部导入的动画设置成Humanoid"><a href="#外部导入的动画设置成Humanoid" class="headerlink" title="外部导入的动画设置成Humanoid"></a>外部导入的动画设置成Humanoid</h2><p>这是动画对应模型的关键部分！！比如跳拉丁舞的动画如何映射到僵尸身上——首先僵尸已经绑定了对应的Avatar，相当于绑定了每个主要关节、部位等等。然后unity通过Humanoid设置将动画也一一对应映射，所以模型和动画就能对应一起了！！</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/79d4bf8aeef02eb7.png" alt="image-20220411165328998"></p><blockquote><p>进avatar查看，发现会有对应的绑定部分。</p></blockquote><p>所以是模型对应了avatar，才能重用各种动画。要把顺序和逻辑理清啊！</p><p><img src="https://i.bmp.ovh/imgs/2022/04/11/86081fb00add0dd0.png" alt="image-20220411165521134"></p><blockquote><p>搞了好久，僵尸终于如愿以偿开始舞蹈</p></blockquote><h2 id="对动画片段的设置"><a href="#对动画片段的设置" class="headerlink" title="对动画片段的设置"></a>对动画片段的设置</h2><h3 id="设置是否循环Loop"><a href="#设置是否循环Loop" class="headerlink" title="设置是否循环Loop"></a>设置是否循环Loop</h3><p>要在Project面板上的资源那点击才会出现，在controller点击的话会见不到</p><h1 id="切水果简易版"><a href="#切水果简易版" class="headerlink" title="切水果简易版"></a>切水果简易版</h1><h2 id="2D视图3D游戏"><a href="#2D视图3D游戏" class="headerlink" title="2D视图3D游戏"></a>2D视图3D游戏</h2><p>将摄像机的background变成纯色，然后把y变成0，这样就创建的球体就能居中显示在画面中心。还有把透视改成正视Orthographic</p><h2 id="3D模型挂有Rigidbody2D＆Circle-Collider-2D"><a href="#3D模型挂有Rigidbody2D＆Circle-Collider-2D" class="headerlink" title="3D模型挂有Rigidbody2D＆Circle Collider 2D"></a>3D模型挂有Rigidbody2D＆Circle Collider 2D</h2><p>仍可下落</p><h2 id="鼠标移动＋切片"><a href="#鼠标移动＋切片" class="headerlink" title="鼠标移动＋切片"></a>鼠标移动＋切片</h2><h3 id="鼠标按下-松开的状态"><a href="#鼠标按下-松开的状态" class="headerlink" title="鼠标按下/松开的状态"></a>鼠标按下/松开的状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool isCutting = false;</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        //获取鼠标按下状态</span><br><span class="line">        if (Input.GetMouseButtonDown(0))</span><br><span class="line">        &#123;</span><br><span class="line">            StartCutting();</span><br><span class="line">        //获取鼠标松开状态</span><br><span class="line">        &#125;else if(Input.GetMouseButtonUp(0))</span><br><span class="line">        &#123;</span><br><span class="line">            StopCutting();</span><br><span class="line">        &#125;</span><br><span class="line">//如果正在切，将更新鼠标位置</span><br><span class="line">        if (isCutting)</span><br><span class="line">        &#123;</span><br><span class="line">            UpdateCut();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void UpdateCut()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">//更改鼠标状态值（这种写代码逻辑很清晰）</span><br><span class="line">    void StartCutting()&#123;</span><br><span class="line">        isCutting = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void StopCutting()&#123;</span><br><span class="line">        isCutting = false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="跟随鼠标位置"><a href="#跟随鼠标位置" class="headerlink" title="跟随鼠标位置"></a>跟随鼠标位置</h3><p>如何获取鼠标的位置？？有一个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input.MousePostition</span><br><span class="line">//但是由于鼠标位置是屏幕坐标，值会比想象中大很多？（为啥</span><br><span class="line">//所以要转换成世界坐标</span><br><span class="line">    </span><br><span class="line">//利用主摄像机来转换？（为什么是摄像机啊</span><br><span class="line">//在这里也用了rigidbody的position，为什么不直接用transfrom呢。transform是只读的，position好像没搞出来，不认</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/d535d7daead35026.png" alt="image-20220418145449652"></p><blockquote><p>把刀片的这个组件类型换成这个，不受重力或啥的影响</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void Start()&#123;</span><br><span class="line">    //获取主相机</span><br><span class="line">    cam = Camera.main;</span><br><span class="line">    rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">&#125;    </span><br><span class="line">void UpdateCut()&#123;</span><br><span class="line">    //转换坐标：待研究，竟然是用相机转换坐标空间，不在摄像机里面的就不能转吗</span><br><span class="line">    rb.position = cam.ScreenToWorldPoint(Input.MousePosition());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="根据鼠标位置生成轨迹：组件TrailRenderer"><a href="#根据鼠标位置生成轨迹：组件TrailRenderer" class="headerlink" title="根据鼠标位置生成轨迹：组件TrailRenderer"></a>根据鼠标位置生成轨迹：组件TrailRenderer</h3><p>在子对象添加这个组件（为什么在子对象添加更好呢？）不是LineRenderer!!笑死我自己，长得很像但老有参数找不着，太傻了</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/2fdbcae93a2670e7.png" alt="image-20220418151705532"></p><blockquote><p>Time：消失时间</p><p>Material：可以添加材质，shader可以改成Sprites默认值，这样就可以显示纯色，否则默认3D材质会有质感</p></blockquote><h3 id="解决轨迹随鼠标松开即消失的问题"><a href="#解决轨迹随鼠标松开即消失的问题" class="headerlink" title="解决轨迹随鼠标松开即消失的问题"></a>解决轨迹随鼠标松开即消失的问题</h3><p>设想如果鼠标点击很短然后又迅速点很多下，轨迹是不太好看的。而且希望在点击其它地方时之前的轨迹会留有余痕。因为带有轨迹渲染组件的对象是刀片的子对象，会立刻随着鼠标位置变化。所以希望在点击时是子对象，松开时是非子对象，这样就实现了捆绑＋及时脱离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void StartCutting()&#123;</span><br><span class="line">    isCutting = true;</span><br><span class="line">    //点击的时候才实例化一个轨迹对象</span><br><span class="line">    //构造函数好像包含了当前组件的transform，就能把当前对象认为父对象</span><br><span class="line">    //一个私有的对象引用它</span><br><span class="line">    currentBladeTrail = Instantiate(bladeTrailPrefab, transform);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void StopCutting()&#123;</span><br><span class="line">    isCutting = false;</span><br><span class="line">    //松开，取消父对象</span><br><span class="line">    currentBladeTrail.transform.SetParent(null);</span><br><span class="line">    //并在一定时间后删除这个对象</span><br><span class="line">    Destroy(currentBladeTrail, 2f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="轨迹＋碰撞"><a href="#轨迹＋碰撞" class="headerlink" title="轨迹＋碰撞"></a>轨迹＋碰撞</h2><p>拖尾的效果有了，而我们需要实际的碰撞来进行实际的切片。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/327d42dde8c3235a.png" alt="image-20220418163505743"></p><blockquote><p>添加这个组件。然后设为点击才启用这个玩意儿。具体代码不贴了，在相应的地方用enabled方法开启或关闭</p></blockquote><p>但是希望在鼠标划切时才有碰撞的力度，不然只是单击不拖动也会有碰撞效果，no no no</p><p>这时候测量的一个维度就是速度，本来刚体有velocity方法来获取当前速度，但刚体已经被更换成其它类型，不受力的作用，速度方法也就用不了了，所以需要自定义</p><h3 id="自定义测速"><a href="#自定义测速" class="headerlink" title="自定义测速"></a>自定义测速</h3><p>unity很重要的概念是实时，帧率，意味着固定时间。既然时间已经固定了，那么位移的大小就能代表速度的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void UpdateCut()&#123;</span><br><span class="line">    Vector2 newPosition = cam.ScreenToWorldPoint(Input.mousePosition);</span><br><span class="line">    rb.position = newPosition;</span><br><span class="line"></span><br><span class="line">    //涉及到固定时间的，用deltaTime固定一下【大概这样理解吧】</span><br><span class="line">    float velocity = (newPosition - previousPosition).magnitude * Time.deltaTime;</span><br><span class="line">    if( velocity &gt; minCuttingVelocity )&#123;</span><br><span class="line">        circleCollider.enabled = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //勿漏。实时更新前一个位置</span><br><span class="line">    previousPosition = newPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/69783902727cb5e9.png" alt="image-20220419162935961"></p><p>所以能获得一个非负数。</p></blockquote><p>以上是考虑当在切的时候的速度。因为prePosition记录的是点击的上一帧的位置，所以重新点击的时候还是用的这个数据。所以要改改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void StartCutting()&#123;</span><br><span class="line">    isCutting = true;</span><br><span class="line">    currentBladeTrail = Instantiate(bladeTrailPrefab, transform);</span><br><span class="line">    circleCollider.enabled = false;</span><br><span class="line">    //重新点击时，将上一帧位置赋为鼠标点击位置</span><br><span class="line">    previousPosition = cam.ScreenToWorldPoint(Input.mousePosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="鼠标和水果碰撞的本质"><a href="#鼠标和水果碰撞的本质" class="headerlink" title="鼠标和水果碰撞的本质"></a>鼠标和水果碰撞的本质</h2><p>归根到底其实也还是物理物体和物体的碰撞。定义一个有rigidbody和collider的游戏对象跟随鼠标位置，然后实际上能与水果发生碰撞（因为是屏幕空间，所以用2D，这样就不考虑z轴的差距）</p><h2 id="碰撞之后裂开"><a href="#碰撞之后裂开" class="headerlink" title="碰撞之后裂开"></a>碰撞之后裂开</h2><p>也就是在碰撞时原瓜消失，一个两半瓜实例生成，然后预先将俩瓜碰撞体相斥然后自然就裂开了。</p><h3 id="裂开的方向"><a href="#裂开的方向" class="headerlink" title="裂开的方向"></a>裂开的方向</h3><p>如果不做方向调整的话，瓜将始终朝一个方向裂开，这看起来会不太真实。所以得计算出裂开的方向。</p><p>跟着教程做了，但是裂开的西瓜总是乱飙，不但位置不对，旋转的方向也不对。这bug还是得细究一下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void OnTriggerEnter2D(Collider2D col)&#123;</span><br><span class="line"></span><br><span class="line">    if(col.tag == &quot;Blade&quot;)&#123;</span><br><span class="line">        //这个是被切西瓜的代码，col是鼠标的刚体</span><br><span class="line">        //碰撞的位置-西瓜的位置</span><br><span class="line">        //两者其实都是三维的物体，但用的是二维的碰撞体和刚体，所以位置都可以运算成三维向量</span><br><span class="line">        //鼠标碰撞的位置始终是x,y平面上，被切西瓜也是。所以计算出来的是z为0的三维向量。想象一下生成的二维向量怎么指：沿圆的半径。</span><br><span class="line">        Vector3 direction = (col.transform.position - transform.position).normalized;</span><br><span class="line"></span><br><span class="line">        //详见往后的四元数解析</span><br><span class="line">        Quaternion rotation = Quaternion.LookRotation(direction);</span><br><span class="line"></span><br><span class="line">        Instantiate(fruitSlicedPrefab, transform.position, rotation);</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/2a0032a405805e41.png" alt="image-20220419163104347"></p><p>所以这里获取了切的方向</p></blockquote><h2 id="四元数学习"><a href="#四元数学习" class="headerlink" title="四元数学习"></a>四元数学习</h2><p>首先这个方法是这样定义的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Quaternion LookRotation(Vector3 forward, Vector3 upwards = Vector3.up);</span><br></pre></td></tr></table></figure><p>forward又是什么？继续探究🧐</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/8b75ef443cbb2553.png" alt="image-20220419163822551"></p><blockquote><p>Vector3 里面有很多默认的简称。经测验，forward指向z轴，（0，0，1）</p><p>up就是y轴，（0，1，0）</p><p>其余根据这两条推导</p></blockquote><p>那么回到那个函数，官方回答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// You can also use transform.LookAt</span><br><span class="line"></span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class ExampleClass : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public Transform target;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 relativePos = target.position - transform.position;</span><br><span class="line"></span><br><span class="line">        // the second argument, upwards, defaults to Vector3.up</span><br><span class="line">        Quaternion rotation = Quaternion.LookRotation(relativePos, Vector3.up);</span><br><span class="line">        transform.rotation = rotation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我理解是第一个参数将是forward所要指向的方向，第二个可能考虑会沿z轴旋转，所以进行钳制</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/19/722081d4c805895e.png" alt="image-20220419165046179"></p><blockquote><p>由图可看出z轴方向会沿着计算的向量方向，为了使裂开的开口对着屏幕，开口应该平行于z轴。然后不确定y的话开口可能沿着z轴旋转，所以钳制y。按照图二进行坐标轴的修改，就达到了想要的效果！！🎉🎉🎉🎉🎉（尽管还有略微的差异</p></blockquote><ul><li>顺便提一嘴：碰撞体的形状也是有微妙差别，为啥我会一上手就胶囊碰撞体……碰撞的效果就很奇怪。</li></ul><h2 id="切的时候物体消失，和物理系统有关？"><a href="#切的时候物体消失，和物理系统有关？" class="headerlink" title="切的时候物体消失，和物理系统有关？"></a>切的时候物体消失，和物理系统有关？</h2><p>问题如上，把裂开西瓜的use gravity取消掉，切的时候是正常受力的，但是一打开就切了立马消失。但是裂开西瓜单独掉下的时候并没有问题。</p><p>难道是两者转换的时候物理系统出了冲突？</p><p>难道是刷新</p><h2 id="为游戏赋予自定的模型和贴图"><a href="#为游戏赋予自定的模型和贴图" class="headerlink" title="为游戏赋予自定的模型和贴图"></a>为游戏赋予自定的模型和贴图</h2><p>把完整的球体和裂开的球体分别设计成自己想要的。基本方法就是在maya展uv用Ps绘制，然后再导入maya，再导出fbx文件到unity（很麻烦就是说）</p><ul><li>遇到maya导出文件的材质丢失问题。应该是材质所需的图片也应该在unity工程上面，我以为maya导出的模型自带图片的信息，但是还得放进工程中。</li></ul><h2 id="脚本的prefab对象-一定要导入工程文件中的"><a href="#脚本的prefab对象-一定要导入工程文件中的" class="headerlink" title="脚本的prefab对象 一定要导入工程文件中的"></a>脚本的prefab对象 一定要导入工程文件中的</h2><p>一言难尽，就总是要么脚本中拖入的prefab突然消失，不生效什么的，很细节的东西顾东不及西的感觉，就很烦，希望不要再踩这个坑了，浪费时间</p><h2 id="水果汁喷溅效果（Particle-System）"><a href="#水果汁喷溅效果（Particle-System）" class="headerlink" title="水果汁喷溅效果（Particle System）"></a>水果汁喷溅效果（Particle System）</h2><p><img src="/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421145456159.png" alt="image-20220421145456159"></p><blockquote><p>看起来就是两个三角形组成的面片</p></blockquote><p><img src="/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421151339608.png" alt="image-20220421151339608"></p><blockquote><p>首先是基本的设置，鼠标移动到相应属性有说明，应该也能猜出</p></blockquote><p><img src="/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421151410665.png" alt="image-20220421151410665"></p><blockquote><p>发射器的形状，这里选了球体，因为只发射一粒所以没很大用处</p></blockquote><ul><li>Color over life time: 颜色变化</li><li>Size over Lifetime: 大小变化</li><li>Renderer：每个粒子的贴图</li><li>粒子发射器的参数非常地多也非常地灵活，还能点击右边的三角形进行下拉菜单选择</li></ul><p><img src="/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220421152714285.png" alt="image-20220421152714285"></p><blockquote><p>公告牌：意思是粒子始终面向摄像机。可以设置为拉伸等</p></blockquote><h2 id="spawn"><a href="#spawn" class="headerlink" title="spawn"></a>spawn</h2><p>字的正向要和发射点的轴方向一致才能出现效果。我刚开始想着非得朝前为z，然后没有考虑一致的问题，所以总是看不到正面。这玩意真的令人摸不着头脑</p><h2 id="随机发射实现"><a href="#随机发射实现" class="headerlink" title="随机发射实现"></a>随机发射实现</h2><ul><li>在哪发射，发射什么：先简略描述一下。设置不同位置不同角度的发射点组成一个数组，每一帧都随机挑取一个点发射物体，而物体是物体数组的随机一个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random.Range(num1, num2);</span><br></pre></td></tr></table></figure><ul><li><p>怎么发射：对于物体来说，一创建就受到力的作用；对于spawn来说，创建并将发射点的position和rotation赋给它们就好。</p></li><li><p>bug：还是不够深入了解rigidbody和collider。没有解决勾选use Gravity后划切就消失的问题；没有解决物体改成rigidbody但点击消失的问题。</p><p>【后续：不知为啥某天更改之后又可以了，这个bug并不明显…？】</p></li></ul><h2 id="加载场景后灯光变暗问题"><a href="#加载场景后灯光变暗问题" class="headerlink" title="加载场景后灯光变暗问题"></a>加载场景后灯光变暗问题</h2><ul><li>加载场景方法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SceneManager.Load(&quot;scene name&quot;);</span><br><span class="line">SceneManager.Load(SceneManager.GetActiveScene().name);//获得当前场景及其名字</span><br></pre></td></tr></table></figure><ul><li><p>发现问题：重新加载之后场景中的默认平行光和摄像机消失了，所以物体呈现变暗的效果。</p></li><li><p>解决办法：Lighting窗口—Scene—右下角的烘焙操作？？然后就可以了。不知道为什么，神奇，待深究。</p><p><img src="/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/hexo_github_blog\source_posts\pic\image-20220502160911194.png" alt="image-20220502160911194"></p></li></ul><h1 id="Unity协程（IE-numerator）"><a href="#Unity协程（IE-numerator）" class="headerlink" title="Unity协程（IE numerator）"></a>Unity协程（IE numerator）</h1><h2 id="如果没有协程"><a href="#如果没有协程" class="headerlink" title="如果没有协程"></a>如果没有协程</h2><ul><li>调用函数时，函数将运行到完成状态，然后返回。这实际上意味着在函数中发生的任何动作都必须在<strong>单帧更新</strong>内发生；函数调用不能用于包含程序性动画或随时间推移的一系列事件。一帧内就更新完了，比如几秒的动画或需要花时间的就执行不了。</li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程就像一个函数，🧐能够暂停执行并将控制权返还给 Unity，然后在下一帧继续执行🧐。在 C# 中，声明协程的方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//用返回类型IEnumerator声明的函数</span><br><span class="line">/*执行内容*/</span><br><span class="line">IEnumerator Fade() </span><br><span class="line">&#123;</span><br><span class="line">    for (float f = 1f; f &gt;= 0; f -= 0.1f) </span><br><span class="line">    &#123;</span><br><span class="line">        Color c = renderer.material.color;</span><br><span class="line">        c.a = f;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">        yield return null;  //在主体某个位置中；暂停执行并随后在下一帧恢复的点</span><br><span class="line">    &#125;//在这里，某次循环的结束暂停，然后在下一次循环之前（下一帧）开始</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*执行开始*/</span><br><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    if (Input.GetKeyDown(&quot;f&quot;)) </span><br><span class="line">    &#123;</span><br><span class="line">        StartCoroutine(&quot;Fade&quot;);//开始</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非逐帧执行，还想再延迟（WaitForSeconds）"><a href="#非逐帧执行，还想再延迟（WaitForSeconds）" class="headerlink" title="非逐帧执行，还想再延迟（WaitForSeconds）"></a>非逐帧执行，还想再延迟（WaitForSeconds）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator Fade() </span><br><span class="line">&#123;</span><br><span class="line">    for (float f = 1f; f &gt;= 0; f -= 0.1f) </span><br><span class="line">    &#123;</span><br><span class="line">        Color c = renderer.material.color;</span><br><span class="line">        c.a = f;</span><br><span class="line">        renderer.material.color = c;</span><br><span class="line">        yield return new WaitForSeconds(.1f);//</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用：在一段时间内传播效果；👉有用的优化"><a href="#作用：在一段时间内传播效果；👉有用的优化" class="headerlink" title="作用：在一段时间内传播效果；👉有用的优化"></a>作用：在一段时间内传播效果；👉有用的优化</h3><ul><li><p>定期执行的任务，不需要逐帧重复任务时，可以放在协程中来进行定期更新。</p><blockquote><p>实例：在附近有敌人时向玩家发出的警报</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function ProximityCheck() </span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; enemies.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Vector3.Distance(transform.position, enemies[i].transform.position) &lt; dangerDistance)  &#123;//每帧逐个检查敌人的位置远近，开销很大</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用协程，每0.1f调用一次</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IEnumerator DoCheck()&#123;</span><br><span class="line">    for(;;)&#123;</span><br><span class="line">        ProximityCheck;</span><br><span class="line">        yield return new WaitForSeconds(.1f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>协程并不会在Unity中开辟新的线程来执行，其执行<strong>仍然发生在主线程</strong>中。</p></li><li><p>调用协程的方法有两种</p><ul><li>StartCoroutine(//<em>这里直接调用方法，添加参数</em>//);</li><li>StartCoroutine(//<em>这里填写”字符串的方法名字”，方法参数</em>//);</li></ul><blockquote><p>前者</p><p>😏优势：可以调用多个参数的方法</p><p>🙃不足：不能通过StopCoroutine(/<em>这里填写”字符串的方法名”</em>/)来结束协程，只能通过StopAllCoroutines来结束</p><p>后者</p><p>🙃不足：只能调用不含参数或只包含一个参数的协程方法</p><p>😏优势：可以通过StopCoroutine来结束对正在执行的协程的调用</p></blockquote></li><li><p>当某一个脚本中的协程在执行过程中，如果我们将该脚本的enable设置为false，协程不会停止。只有将挂载该脚本的物体设置为SetActive(false)时才会停止。</p></li><li><p>Unity在调用StartCoroutine()后不会等待协程中的内容返回，会立即执行后续代码。</p></li><li><p>yield return的介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yield return null;//下一帧再执行后续代码</span><br><span class="line">yield return 0; //下一帧再执行后续代码</span><br><span class="line">yield return 6;//(任意数字) 下一帧再执行后续代码</span><br><span class="line"></span><br><span class="line">yield break; //直接结束该协程的后续操作</span><br><span class="line">yield return asyncOperation;//等异步操作结束后再执行后续代码</span><br><span class="line"></span><br><span class="line">yield return StartCoroution(/*某个协程*/);//等待某个协程执行完毕后再执行后续代码</span><br><span class="line"></span><br><span class="line">/*以下待深入了解*/</span><br><span class="line">yield return WWW();//等待WWW操作完成后再执行后续代码</span><br><span class="line">yield return new WaitForEndOfFrame();//等待帧结束,等待直到所有的摄像机和GUI被渲染完成后，在该帧显示在屏幕之前执行</span><br><span class="line"></span><br><span class="line">yield return new WaitForSeconds(0.3f);//等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间会受到Time.timeScale的影响）;</span><br><span class="line"></span><br><span class="line">yield return new WaitForSecondsRealtime(0.3f);//等待0.3秒，一段指定的时间延迟之后继续执行，在所有的Update函数完成调用的那一帧之后（这里的时间不受到Time.timeScale的影响）;</span><br><span class="line">yield return WaitForFixedUpdate();//等待下一次FixedUpdate开始时再执行后续代码</span><br><span class="line">yield return new WaitUntil()//将协同执行直到 当输入的参数（或者委托）为true的时候....如:yield return new WaitUntil(() =&gt; frame &gt;= 10);</span><br><span class="line">yield return new WaitWhile()//将协同执行直到 当输入的参数（或者委托）为false的时候.... 如:yield return new WaitWhile(() =&gt; frame &lt; 10);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">冲冲冲</summary>
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>作品集</title>
    <link href="http://example.com/2022/04/09/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    <id>http://example.com/2022/04/09/%E4%BD%9C%E5%93%81%E9%9B%86/</id>
    <published>2022-04-08T16:00:00.000Z</published>
    <updated>2022-06-15T12:37:34.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="课程作品集"><a href="#课程作品集" class="headerlink" title="课程作品集"></a>课程作品集</h1><h2 id="Unity（2021—2022大二下）"><a href="#Unity（2021—2022大二下）" class="headerlink" title="Unity（2021—2022大二下）"></a>Unity（2021—2022大二下）</h2><ul><li>计设负责的小游戏部分</li><li>两周时间期末周赶出来的……（？</li><li>之前学的一些shader</li></ul><iframe src="//player.bilibili.com/player.html?aid=342584589&bvid=BV1k94y127LP&cid=747610638&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"></iframe><h2 id="三维动画（2021—2022大二下）"><a href="#三维动画（2021—2022大二下）" class="headerlink" title="三维动画（2021—2022大二下）"></a>三维动画（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=385041465&bvid=BV1kZ4y1q7TM&cid=747529286&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="Maya建模（2021—2022-大二上）"><a href="#Maya建模（2021—2022-大二上）" class="headerlink" title="Maya建模（2021—2022 大二上）"></a>Maya建模（2021—2022 大二上）</h2><div class="justified-gallery"><p>]</p><p><img src="https://pic.jitudisk.com/public/2022/06/15/f7e8f1850ca36.jpg" alt="01.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/b5a4554d557da.jpg" alt="mmexport1640791718045.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/cffde7fcda8da.jpg" alt="mmexport1640791781564.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/1a1d5fe094b43.jpg" alt="mmexport1640791785491.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/5e27a27361ce4.jpg" alt="mmexport1640791786998.jpg"><img src="https://pic.jitudisk.com/public/2022/06/15/5983da104c11d.jpg" alt="mmexport1640791788750.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/b5069a03b7945.jpg" alt="mmexport1640791791369.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/9efdd7ff2e314.jpg" alt="mmexport1640791797689.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/7c9c11112130d.jpg" alt="mmexport1640791806708.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/068ea8e658fdf.jpg" alt="mmexport1640791809330.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/cb5fae721a7eb.jpg" alt="mmexport1640791811585.jpg"></p>          </div><h2 id="设计基础（2021-2022-大二上）"><a href="#设计基础（2021-2022-大二上）" class="headerlink" title="设计基础（2021-2022 大二上）"></a>设计基础（2021-2022 大二上）</h2><div class="justified-gallery"><p><img src="https://pic.jitudisk.com/public/2022/06/15/12f318d353df8.png" alt="1.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/44456f5c13d34.png" alt="2.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/754537fdd07a6.png" alt="3.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/ff3093e87db9a.png" alt="4.png"><img src="https://pic.jitudisk.com/public/2022/06/15/ece4595b56d5a.png" alt="5.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/fa18101b2d666.png" alt="6.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/b29470db77658.png" alt="7.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/16ec3d8061c61.png" alt="8.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/bedb06047220c.png" alt="9.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/1d666e6ca4767.png" alt="10.png"><br><img src="https://pic.jitudisk.com/public/2022/06/15/e5195260afd6c.png" alt="11.png"></p>          </div><h2 id="微电影创作（2021—2022大二下）"><a href="#微电影创作（2021—2022大二下）" class="headerlink" title="微电影创作（2021—2022大二下）"></a>微电影创作（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=215085519&bvid=BV1ya411s7bF&cid=747556490&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="看中国（2021—2022大二下）"><a href="#看中国（2021—2022大二下）" class="headerlink" title="看中国（2021—2022大二下）"></a>看中国（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=257544819&bvid=BV1FY411T7o4&cid=747615512&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="混剪（2021—2022大二下）"><a href="#混剪（2021—2022大二下）" class="headerlink" title="混剪（2021—2022大二下）"></a>混剪（2021—2022大二下）</h2><iframe src="//player.bilibili.com/player.html?aid=897560994&bvid=BV1xA4y1d747&cid=747597803&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height="450" width="100%"> </iframe><h2 id="视觉信息传达设计（2022-大二下）"><a href="#视觉信息传达设计（2022-大二下）" class="headerlink" title="视觉信息传达设计（2022 大二下）"></a>视觉信息传达设计（2022 大二下）</h2><h2 id="写生作品（2020-2021-大一暑假）"><a href="#写生作品（2020-2021-大一暑假）" class="headerlink" title="写生作品（2020-2021 大一暑假）"></a>写生作品（2020-2021 大一暑假）</h2><div class="justified-gallery"><p><img src="https://pic.jitudisk.com/public/2022/06/15/35bd6639f8fe9.jpg" alt="IMG_20210708_194148.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/55660a17c9f3e.jpg" alt="IMG_20210708_194257.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/db485e71b046e.jpg" alt="IMG_20210708_194921.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/43e59980878a0.jpg" alt="IMG_20210708_194936.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/44d5fd286c169.jpg" alt="IMG_20210709_154459.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/7ea66abaafd36.jpg" alt="IMG_20210712_181451.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/a216a4a4a260f.jpg" alt="IMG_20210712_181520.jpg"><br><img src="https://pic.jitudisk.com/public/2022/06/15/fd5084b0fe68a.jpg" alt="IMG_20210712_181542.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/0e640e01ccf1e.jpg" alt="IMG_20210712_181614.jpg"></p>          </div><h1 id="课外作品集"><a href="#课外作品集" class="headerlink" title="课外作品集"></a>课外作品集</h1><h2 id="学习画"><a href="#学习画" class="headerlink" title="学习画"></a>学习画</h2><div class="justified-gallery"><p><img src="https://pic.jitudisk.com/public/2022/06/15/9aa4f8699a71e.jpg" alt="03.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/aa0e5ff6e7cff.jpg" alt="04.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/0d2fe04f96ec0.jpg" alt="01.jpg"></p><p><img src="https://pic.jitudisk.com/public/2022/06/15/d04f479fb20c1.jpg" alt="02.jpg"></p>          </div>]]></content>
    
    
    <summary type="html">一些产出…？</summary>
    
    
    
    <category term="作品集" scheme="http://example.com/categories/%E4%BD%9C%E5%93%81%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>shader forge 从入门到放弃</title>
    <link href="http://example.com/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    <id>http://example.com/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/</id>
    <published>2022-04-05T16:00:00.000Z</published>
    <updated>2022-06-15T10:39:49.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="屏幕特效"><a href="#屏幕特效" class="headerlink" title="屏幕特效"></a>屏幕特效</h1><ul><li>将uv延展到屏幕上</li></ul><h2 id="顶点偏移"><a href="#顶点偏移" class="headerlink" title="顶点偏移"></a>顶点偏移</h2><p><img src="https://i.bmp.ovh/imgs/2022/04/08/c5d289facf3035bb.png" alt="image-20220406222529980"></p><blockquote><p>Vertex Offset：输入sin函数变化的值，模型顶点同时增加（-1，1）的值，所以就二维平面而言，它是沿对角线方向移动的。？</p></blockquote><h2 id="将uv展开到屏幕上"><a href="#将uv展开到屏幕上" class="headerlink" title="将uv展开到屏幕上"></a>将uv展开到屏幕上</h2><p>把顶点铺展到屏幕上🐎？</p><ul><li><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/221ca65ddacdcd3c.png" alt="image-20220406223510471"></p><blockquote><p>从数值来看，（先从一维来看）范围扩大了一倍，然后-1到0都是黑色的，可知黑色占了大半部分；总的来说变化是原来的被压缩，被填充更多其它值的颜色</p></blockquote></li><li><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/eab028ca62e74241.png" alt="image-20220406223735717"></p><blockquote><p>同时要更改属性值。第一个Face Culling换成Double Sided，就可以显示被展开的面了。</p><p>🧐我原本理解的uv可能和模型法线有直接的联系，或者说相当于把模型uv部分拿出来进行操作吧。所以为什么就改了一下范围就使它展开了呢？？🧐</p><p>😎经实验，改变范围只是表面亮度发生了相应的变化。真正做到展uv是Vertex Position这个输出通道。这个通道解释如下👇</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/544e58a96f021f45.png" alt="image-20220406225019710"></p><p>😎经实验，原uv连VP结果如下👇或许是没有z这个值，所以干脆就没有了？（不是说偏移量嘛？！）</p><p>🧐尝试理解为什么会展开：假设模型最亮点值为1，对应uv值为1那，然后1+1=2…那模型的每个表面点都进行了二倍乘，同时z没了…这时候所见的展开图是原来uv那个样子，只是位置变了</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/b627dee83287b5b3.png" alt="image-20220406225212089"></p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/4c35ae058cf87c7c.png" alt="image-20220406230108815"></p><p>😎这时候看到展开的uv由于长宽各加一倍，所以面积增加了3倍。此时uv的后面是不可见的</p><p>👉回到设置，把Face Culling变成Double Sided，两面可见；</p><p>​     Vertex Positioning： Clip space，映射到屏幕上</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/aa861fedf8f2f770.png" alt="image-20220406230637600"></p><p>🧐但是上下边缘出现了难看的锯齿，我暂时把Remap范围扩大来解决。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/a838c447941cd91d.png" alt="image-20220406230923055"></p><p>🧐把Remap范围扩大时发现效果与理解有所出入。变化越大边界值越强硬。先从极值来想，-2<del>0是黑色，0</del>1是原色，1~2可能是增强色（？），比例分别为2：1：1。也就是说原来的颜色范围比例会更小，在多余的变化范围中显得生存空间狭小…</p></blockquote></li></ul><h2 id="双变量反正切ArcTan2"><a href="#双变量反正切ArcTan2" class="headerlink" title="双变量反正切ArcTan2"></a>双变量反正切ArcTan2</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/dbe530d1d2c1ea3a.png" alt="image-20220408175644145"></p><blockquote><p>这个着实是不知道咋得来的哇…啥时候研究一下（flag缓缓升起又缓缓倒下）</p></blockquote><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/dfd5cff71d3f9d92.png" alt="image-20220408175922508"></p><blockquote><p>这个啥，双变量反正切得到的效果和uv合在一起！由于ArcTan2输出的是一维，惯例append升维。</p></blockquote><h2 id="Rotator节点"><a href="#Rotator节点" class="headerlink" title="Rotator节点"></a>Rotator节点</h2><p>顾名思义，也就是旋转啦！！试了下，嗯，就是普通的旋转（魔力转圈圈）对uv的旋转</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/1ae7ce69612b54ec.png" alt="image-20220408180434114"></p><blockquote><p>Spd也就是速度</p></blockquote><h2 id="Distance节点"><a href="#Distance节点" class="headerlink" title="Distance节点"></a>Distance节点</h2><p>现在开始实现四周向中心渐变透明的效果。</p><p>🧐到现在发现很多Texture显示的区域规划都用到了黑白效果。比如利用黑白遮罩…啊。黑白可能最简单的表明数值变化给图像带来的显示……以后见多了可以回来总结一下</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/a375fa9d226c497a.png" alt="image-20220408203955698"></p><blockquote><p>快速理解：现在见到的是输入了一个uv和一个二维坐标值。设想经过二维坐标生成一条直线，然后直线变成坐标轴，想象离原点的距离变化。然后再铺展成（旋转）一个平面</p></blockquote><h2 id="透明通道"><a href="#透明通道" class="headerlink" title="透明通道"></a>透明通道</h2><p>在这里，形成的黑白图连到了透明通道……</p><p>🧐透明通道到底是怎样判断哪里该透明呢？主要是输入什么样的值呢？进行实验。👇</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/bbe614040e06e88c.png" alt="image-20220408205350042"><img src="https://s3.bmp.ovh/imgs/2022/04/08/2d594e3e801b731e.png" alt="image-20220408205525227"></p><blockquote><p>验证了猜想：值为0时透明度最大。值为1时没有透明。但是值再大，会有一种奇怪的高饱和且有种差值的效果？为什么呢？</p></blockquote><p>由此可见黑白值（或者可能是普遍的数值）都在shader forge里面有对应表现的设定。得多多体验和比较了</p><p>🦁连入透明通道后要把左边属性栏的Blending——Blend Mode 改成 alpha blended，否则会警告</p><h2 id="改变透明的范围（Power节点"><a href="#改变透明的范围（Power节点" class="headerlink" title="改变透明的范围（Power节点"></a>改变透明的范围（Power节点</h2><p>现在需要对透明的范围进行调整，也就是要动态改变uv上0—1的值。</p><ul><li>可用multiply节点进行相乘。在这里目标是拉大对比度，所以只能乘以小于1的非负数.首先从极端来看，乘0则全黑，乘1则原样，所以从左到右是由全黑逐渐显现。</li><li>或者用power。Val是底数，Exp是指数，Exp为0时，是全白，为1时，是原样。可见当Exp从0到1变化时，由全白到原样。越靠近0的底数的函数值越往下陡峭，越黑；</li><li>要说两者还有啥区别的话…感觉差不多，暂时。因为看不出变化过程的大的区别（看过渡程度变化速度），所以就先这样吧。</li></ul><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/1a7bf527fe4017a0.png" alt="image-20220408210531868"></p><blockquote><p>还要记得用Clamp0-1限制一下范围。Multiply这个倒还好，power那个可能就负数有点厉害了？</p></blockquote><h2 id="锐化过渡灰区域（Remap节点"><a href="#锐化过渡灰区域（Remap节点" class="headerlink" title="锐化过渡灰区域（Remap节点"></a>锐化过渡灰区域（Remap节点</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/4ae1e874ebc6ce15.png" alt="image-20220408212829571"></p><p>之前是扩展到负数区域，还好理解一些。现在都是0-1，目标也不想弄出负数来，那么怎么办呢？现在重新思考Remap这个节点。🧐范围的变化实际上是映射？？</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/3101bb264873e845.png" alt="image-20220408213145933"></p><blockquote><p>这是一个粗糙的草图。将关键点进行了二倍的映射，可见可以理解原来的一半都变成了大于0.5的，结果就白的区域更多了。</p></blockquote><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/0f0e647c49e7fe5e.png" alt="image-20220408214321709"></p><ul><li>😎其实为了效果更加明显，加了Multiply节点。但是需要调整的参数就变成了两个，而且可适用范围较小，一旦调猛了就容易出现过度的情况。有没有优化的方法呢？待定。</li></ul><h2 id="Texture-Assets"><a href="#Texture-Assets" class="headerlink" title="Texture Assets"></a>Texture Assets</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/026fbb85fb90349e.png" alt="image-20220408214913855"></p><blockquote><p>一张图多用，节约性能</p></blockquote><h1 id="后处理（Post-Processing之类）"><a href="#后处理（Post-Processing之类）" class="headerlink" title="后处理（Post Processing之类）"></a>后处理（Post Processing之类）</h1><p>教程是有个插件的，直接生成屏幕特效，找不到了，算了吧</p><h1 id="旗飘动效果"><a href="#旗飘动效果" class="headerlink" title="旗飘动效果"></a>旗飘动效果</h1><h2 id="sinx＋time"><a href="#sinx＋time" class="headerlink" title="sinx＋time"></a>sinx＋time</h2><p>之前做屏幕特效的时候弄了这个，time作为函数的x而且是不断递增的，所以sin time 会在-1到1的范围内游动。</p><p>想象这个sin图……（绝不是因为画图懒）假设旗飘动基本是sin波浪的效果，那么顶点就作为x轴上的变量。</p><p><img src="/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/hexo_github_blog\source_posts\pic\image-20220415184513656.png" alt="image-20220415184513656"></p><blockquote><p>sin x＋ 物体顶点【World Pos.】。这时候就有个样子啦！怎么让它动呢？加上time就好啦，让顶点加上流动的值所以也进行了流动。</p></blockquote><p><img src="/2022/04/06/Shader%20Forge%E4%B9%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/hexo_github_blog\source_posts\pic\image-20220415185407650.png" alt="image-20220415185407650"></p><blockquote><p>World Pos.节点，物体的世界坐标。如果直接把xyz三维向量放进sin函数的话…反正没反应。所以用xyz分别的一维向量数据来add相加啦。反正先理解的是每个维度都分别与时间相加？虽然add出的是一维向量……有点难理解，算了……</p></blockquote><h2 id="Multiply-uv"><a href="#Multiply-uv" class="headerlink" title="Multiply uv"></a>Multiply uv</h2><p>🚩是一条边几乎不同的，而离得越远动得越明显。怎么实现这个效果呢？怎么样的数值满足这种需求呢？【由0到大过渡】</p><p>👉那就是uv啦！取出u/v，就是这种效果。和x变量相乘，就能实现啦</p><p>注意：物体的顶点其实是不同的，只是（渲染的时候？）顶点发生了偏移。</p>]]></content>
    
    
    <summary type="html">炫酷！美！</summary>
    
    
    
    <category term="shader" scheme="http://example.com/categories/shader/"/>
    
    
  </entry>
  
  <entry>
    <title>Android Context</title>
    <link href="http://example.com/2022/04/05/Android%20Context/"/>
    <id>http://example.com/2022/04/05/Android%20Context/</id>
    <published>2022-04-04T16:00:00.000Z</published>
    <updated>2022-04-10T01:33:15.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h1><p>getActivity(), getContext(), this…是不是特别常见？当看到方法报错要填Context类型时，一个个试就对了！！……？是时候认识一下context了！（下次瞎填也有理有据了）</p><h1 id="什么是Context"><a href="#什么是Context" class="headerlink" title="什么是Context"></a>什么是Context</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Activity mActivity = <span class="keyword">new</span> Activity()<span class="comment">//??</span></span><br></pre></td></tr></table></figure><p>Activity可以new吗？Android的应用程序开发采用JAVA语言，Activity本质上也是一个对象，但这是不可行的。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能运行，Android应用模型是<strong>基于组件的应用设计模式</strong>。Context是维持Android程序中各组件能够正常工作的一个核心功能类。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/5b045dda33f98e78.png" alt="image-20220409203722884"></p><ul><li><p>用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）</p><blockquote><p>比如微信聊天，此时的“环境”是指聊天的界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与</p></blockquote></li><li><p>一个应用程序可以认为是一个工作环境，用户在这个环境中会切换到不同的场景，这就像一个前台秘书，她可能需要接待客人，可能要打印文件，还可能要接听客户电话，而这些就称之为不同的场景，前台秘书可以称之为一个应用程序。</p></li></ul><h1 id="Context类"><a href="#Context类" class="headerlink" title="Context类"></a>Context类</h1><ul><li>Context提供了关于👉应用环境全局信息👈的接口（描述一个应用程序环境的信息）</li><li>一个抽象类，Android提供了该抽象类的具体实现类</li><li>通过它我们可以获取😍<u>应用程序的资源和类</u>😍（包括应用级别操作，如启动Activity，发广播，接受Intent等）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/04/08/f1d1f7d515455953.png" alt="image-20220408161403621"></p><blockquote><p>Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中👉都会创建ContextImpl对象，由ContextImpl实现Context中的方法👈。</p><p>🧐ContextWrapper？</p><p>👉如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。</p><p>【所以包装里只有context引用，要去取真正的Context对象。这……又能怎么样呢？？】</p><p>👉ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理</p><p>【wrapper还有装饰（主题）包装嘛？】</p><p>🧐ContextImp？</p><p>👉真正实现了Context中的所有函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。</p></blockquote><ul><li>那么一个应用中有多少个Context呢？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appContextCount = Application + ActivityCount + ServiceCount;</span><br><span class="line"><span class="comment">//Android应用程序只有四大组件，其中两大组件都继承自Context，另外每个应用程序还有一个全局的Application对象</span></span><br></pre></td></tr></table></figure><blockquote><p>Android 开发的四大组件分别是：😜活动（activity），用于表现功能；😜服务（service），后台运行服务，不提供界面呈现；😜广播接受者（Broadcast Receive），用于接收广播；😜内容提供者（Content Provider），支持多个应用中存储和读取数据，相当于数据库。</p></blockquote><h1 id="Context作用域"><a href="#Context作用域" class="headerlink" title="Context作用域"></a>Context作用域</h1><p>context可以实现的功能非常多！弹出toast，启动activity，启动service等等都需要context。虽然很神通广大，但不是随便拿到一个Context实例就能为所欲为，使用还是有限制的。</p><ul><li><p>由于Context的具体实例是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以<strong>通用</strong>的。【前面提到这三初始化时会创建ContextImp对象，用它的context方法，也就是拿到了context】</p></li><li><p>出于安全原因的考虑，Android是<strong>不允许</strong>Activity或Dialog凭空出现的，🦁一个<strong>Activity</strong>的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。🦁而<strong>Dialog</strong>则必须在一个Activity上面弹出，因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。</p><p><img src="https://upload-images.jianshu.io/upload_images/1187237-fb32b0f992da4781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/589/format/webp" alt="img"></p><blockquote><p>由图可知，Activity所持有的Context的作用域最广，无所不能。因为Activity继承自ContextThemeWrapper，而Application和Service继承自ContextWrapper，很显然😏<u>ContextThemeWrapper在ContextWrapper的基础上又做了一些操作使得Activity变得更强大</u>😏</p><p>【总结！】 凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p></blockquote></li></ul><h1 id="如何获取Context"><a href="#如何获取Context" class="headerlink" title="如何获取Context"></a>如何获取Context</h1><p>主要有以下四种方法！👇</p><ul><li><p>😀View.getContext()</p><p>返回当前View对象的Context对象，通常是当前正在展示的Activity对象</p></li><li><p>😏Activity.getApplicationContext()</p><p>获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context</p></li><li><p>😎ContextWrapper.getBaseContext()</p><p>用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用</p></li><li><p>😍Activity.this </p><p>返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用Application,Context也可以</p></li></ul><h1 id="一些常用方法的区别"><a href="#一些常用方法的区别" class="headerlink" title="一些常用方法的区别"></a>一些常用方法的区别</h1><h2 id="getApplication-和-getApplicationContext"><a href="#getApplication-和-getApplicationContext" class="headerlink" title="getApplication() 和 getApplicationContext()"></a>getApplication() 和 getApplicationContext()</h2><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/28c6fb61a9303d81.webp" alt="img"></p><ul><li><p>区别：getApplication() 方法语义性非常强，一看就知道是用来获取Application实例的，但这个方法只有在Activity和Service中才能调用得到。大多数场景中我们都是在Activity和Service中使用Application，但是如果在其他一些场景，比如BroadcastReceiver中也想获得Application实例，就可以借用getApplicationContext()方法了。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/fd3e5cced5a5dc3b.png" alt="image-20220409165536914"></p></li></ul><h1 id="Context引起的内存泄漏"><a href="#Context引起的内存泄漏" class="headerlink" title="Context引起的内存泄漏"></a>Context引起的内存泄漏</h1><h2 id="错误的单例模式"><a href="#错误的单例模式" class="headerlink" title="错误的单例模式"></a>错误的单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个Activity用了getInstance（this），那么这个静态的instance的生命周期要比Activity还长，它常驻内存，保存了传入的那个activity的对象并一直持有，即使Activity被销毁掉，它的引用还存在于一个Singleton中，就不可能被GC掉，就导致了内存泄漏。</p><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/784a0fb65045c1d3.png" alt="image-20220409163255669"></p><p>解决办法👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> Context mContext;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    ｝</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;<span class="comment">//区别在这里</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Application对象的生命周期和整个项目一样长，和单例对象一致。</p><h2 id="View持有Activity引用"><a href="#View持有Activity引用" class="headerlink" title="View持有Activity引用"></a>View持有Activity引用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Drawable mDrawable;<span class="comment">//静态</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle saveInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(saveInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ImageView iv = <span class="keyword">new</span> ImageView(<span class="keyword">this</span>);<span class="comment">//</span></span><br><span class="line">        mDrawable = getResources().getDrawable(R.drawable.ic_launcher);</span><br><span class="line">        iv.setImageDrawable(mDrawable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s3.bmp.ovh/imgs/2022/04/09/46cc57e444a01f3d.png" alt="image-20220409171311849"></p><p>有一个静态的Drawable对象，当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏</p><h2 id="正确使用Context"><a href="#正确使用Context" class="headerlink" title="正确使用Context"></a>正确使用Context</h2><p>一般Context造成的内存泄漏，🧧几乎都是当Context销毁的时候，却因为<strong>被引用</strong>导致销毁失败🧧，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势：<br> 1：当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。<br> 2：不要让生命周期长于Activity的对象持有到Activity的引用。<br> 3：尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。【？？？</p><h3 id="非静态内部类会隐式持有外部类实例的引用"><a href="#非静态内部类会隐式持有外部类实例的引用" class="headerlink" title="非静态内部类会隐式持有外部类实例的引用"></a>非静态内部类会隐式持有外部类实例的引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleOne();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    newThread() &#123;<span class="comment">//匿名内部类，非静态的匿名类会持有外部类的一个隐式引用</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function">publicvoid <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">          SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要非静态的匿名类对象没有被回收，MainActivity就不会被回收，MainActivity所关联的资源和视图都不会被回收，发生比较严重的内存泄漏。</p><p>要解决MainActivity的内存泄漏问题，只需把非静态的Thread匿名类定义成静态的内部类就行了（静态的内部类不会持有外部类的一个隐式引用）👇</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    exampleTwo();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exampleTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> MyThread().start();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在新创建的Thread不会持有MainActivity的一个隐式引用，当手机屏幕旋转时不会阻止垃圾回收器对旧MainActivity的回收工作。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://www.jianshu.com/p/fb0681f5f12b">Android基础之Context - 简书 (jianshu.com)</a></p><p><a href="https://www.jianshu.com/p/94e0f9ab3f1d">Context都没弄明白，还怎么做Android开发？ - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/zhongwcool/article/details/22886067">(34条消息) 非静态的内部类会持有外部类的一个隐式引用_zhongwcool的博客-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">打败context！！</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Java继承</title>
    <link href="http://example.com/2021/12/04/Java%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2021/12/04/Java%E7%BB%A7%E6%89%BF/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2022-04-09T11:41:43.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><ul><li>基于已存在的类构造一个新类</li></ul><h3 id="为何有继承"><a href="#为何有继承" class="headerlink" title="为何有继承"></a>为何有继承</h3><ul><li>复用（继承）原有类的方法和域</li><li>添加新的方法和域，满足新的需求</li></ul><h3 id="关于子类与父类"><a href="#关于子类与父类" class="headerlink" title="关于子类与父类"></a>关于子类与父类</h3><ol><li><p>声明关键字：sonClass extends FatherClass</p></li><li><p>继承层次</p><ul><li>继承层次：由一个<u>公共超类</u>派生出来的<u>所有类的集合</u></li><li>继承链：从某个特定的类到其祖先的路径</li></ul><p><img src="https://s2.loli.net/2021/12/04/HaFcZEeCABu9TxM.png" alt="image-20211201195725979.png"></p><ul><li><p>一个子类可以继承多个父类吗？</p><p><img src="https://s2.loli.net/2021/12/04/jmq4DF1QCdxiJe5.png" alt="image-20211203220706240.png"></p><ul><li>Java认为多继承弊大于利</li><li>为弥补，用接口</li></ul></li></ul></li></ol><h3 id="子类对继承内容的处理"><a href="#子类对继承内容的处理" class="headerlink" title="子类对继承内容的处理"></a>子类对继承内容的处理</h3><ul><li><p><strong>访问权限</strong>（借用cpp的说法）</p><p>——一般类中将域定义为private，方法定义为public。那什么情况下能访问父类的数据域、方法？</p><ul><li><p>public: 对所有类可见</p></li><li><p>protected：对本包和所有子类可见</p><p>——子类的域和方法用protected都是同样的效果吗？</p><ul><li>域：常用private，是为了强调其封装性，用protected意味着很多子类可以使用，存在被修改的风险，破坏了封装性</li><li>方法：常用public，用protected限制了使用范围</li></ul></li><li><p>private：仅对本类可见</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> money;</span><br><span class="line">    <span class="keyword">protected</span> String antique;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> books;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getFromFather</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(money);</span><br><span class="line">        System.out.println(antique);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>子类构造器</strong></p><ul><li><p>私有域。父类私有域不能被访问，所以要调用父类构造器对其初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">float</span> money, <span class="keyword">int</span> books)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(money);<span class="comment">//实现对父类构造器的调用；必须是子类构造器的第一条语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果没有调用父类构造器，直接用同名变量呢？</p><p>——子类的变量会覆盖掉父类的，即用子类的money是属于子类的，而不是父类的</p></blockquote></li><li><p>若没有显式调用超类构造器，将自动调用超类默认没有参数的构造器</p></li><li><p>超类有构造器，子类没有显式调用，将报错</p></li></ul></li><li><p><strong>覆盖方法</strong></p><ul><li><p>在原有的基础上更新新的功能</p></li><li><p>不同的方法体</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> money;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">(<span class="keyword">float</span> money)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money - <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么还是无法访问money域？</p><ul><li>尽管每个子类对象都有money域，子类的方法不能直接访问父类的私有域。只有父类方法才能访问（继承过来干嘛呢？</li><li>如何才能访问？借助公有的接口（调用父类的getSalary()方法）</li></ul></blockquote></li><li><p>问题又来了：子类同名方法调用父类的同名方法，能否成功？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getMoney() - <span class="number">100.0</span>;</span><br><span class="line">&#125;<span class="comment">//结果里面还是调用自己，无限循环</span></span><br></pre></td></tr></table></figure><blockquote><p>声明要调用的是父类方法：</p><p>super.getMoney();</p></blockquote></li><li><p>判断下面是不是覆盖方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">float</span> <span class="title">getMoney</span><span class="params">(<span class="keyword">float</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSalay() + add - <span class="number">100.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getSalay()- <span class="number">100.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载和重写</span></span><br></pre></td></tr></table></figure><blockquote><p>这里延伸出编译器如何寻找方法的知识点：</p><ul><li>查看对象的声明类型和方法名    float getMoney();</li><li>查看方法提供的参数类型           float getMoney(…);2</li></ul></blockquote></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>——父类对象和子类对象的奇妙转化(?</p><ul><li>出现父类对象的任何地方都可以用子类对象置换</li><li>多态：一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定</li><li>一个父类对象可以引用一个父类对象，也可以引用任何一个子类的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Father f;</span><br><span class="line">f = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Son s;</span><br><span class="line">s = <span class="keyword">new</span> Father();</span><br></pre></td></tr></table></figure><p>[java提高篇(四)—–理解java的三大特性之多态 - chenssy - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/chenssy/p/3372798.html#:~:text=%E6%89%80%E8%B0%93%E5%A4%9A%E6%80%81%E5%B0%B1%E6%98%AF%E6%8C%87%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%E5%9E%8B%E5%92%8C%E9%80%9A%E8%BF%87%E8%AF%A5%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%8F%91%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%9C%A8%E7%BC%96%E7%A8%8B%E6%97%B6%E5%B9%B6%E4%B8%8D%E7%A1%AE%E5%AE%9A%EF%BC%8C%E8%80%8C%E6%98%AF%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E6%89%8D%E7%A1%AE%E5%AE%9A%EF%BC%8C%E5%8D%B3%E4%B8%80%E4%B8%AA%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%80%92%E5%BA%95%E4%BC%9A%E6%8C%87%E5%90%91%E5%93%AA%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%AF%A5%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%8F%91%E5%87%BA%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%88%B0%E5%BA%95%E6%98%AF%E5%93%AA%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%94%B1%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E6%89%8D%E8%83%BD%E5%86%B3%E5%AE%9A%E3%80%82">https://www.cnblogs.com/chenssy/p/3372798.html#:~:text=所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</a>. 因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。.,比如你是一个酒神，对酒情有独钟。. 某日回家发现桌上有几个杯子里面都装了白酒，从外面看我们是不可能知道这是些什么酒，只有喝了之后才能够猜出来是何种酒。.)</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li><p>更为抽象，更通用。比如student和Employee的更高类Person类</p></li><li><p>为什么要高度抽象</p><p>——当我们存在一类事物，他们大多数结构和功能存在雷同，只有少部分存在不同，如果我们直接使用子类实现接口，那么结构和功能相同部分的代码将会造成大量冗余，因此我们需要一种结构，里面可以提供一部分已经实现了的共同的代码，剩下的<strong>一小部分</strong>由具体子类去实现即可，达到了代码的重用</p></li><li><p>抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象方法。子类继承这个类的时候再去实现里面的方法体</span></span><br><span class="line"><span class="comment">//相当于一个概括，具体实现看子类需求</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><ul><li>为了提高程序的清晰度， 包含一个或多个抽象方法的类本身必须被声明为抽象的</li><li>除了抽象方法之外，抽象类还可以包含具体数据和具体方法</li><li>对于抽象方法，子类继承可以具体实现，否则也是抽象类</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.抽象类不能被实例化（抽象类结构和功能一般不完整）</span></span><br><span class="line"><span class="comment">//2.但可以定义一个抽象类的对象变量（区别？）来引用具体子类的对象</span></span><br></pre></td></tr></table></figure><ul><li>再次解读一下书上的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person[] people = <span class="keyword">new</span> Person[<span class="number">2</span>];</span><br><span class="line">people[<span class="number">0</span>] = <span class="keyword">new</span> Emplyee(...);</span><br><span class="line">people[<span class="number">1</span>] = <span class="keyword">new</span> Student(...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Person p : people)&#123;</span><br><span class="line">    System.out.println(p.getName());<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Java继承</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity入门</title>
    <link href="http://example.com/2021/11/10/Unity%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2021/11/10/Unity%E5%85%A5%E9%97%A8/</id>
    <published>2021-11-09T16:00:00.000Z</published>
    <updated>2022-06-04T14:07:02.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-编辑器的结构"><a href="#第二章-编辑器的结构" class="headerlink" title="第二章 编辑器的结构"></a>第二章 编辑器的结构</h1><h2 id="2-1游戏项目"><a href="#2-1游戏项目" class="headerlink" title="2.1游戏项目"></a>2.1游戏项目</h2><ul><li>预制件：代表 <u>已设置组件的</u> 一个游戏对象或一组游戏对象；预制件就像一个<u>蓝图</u>，可用于轻松创建<u>同一对象的实例</u>；预制件的每个实例都关联到预制件资源，因此更改这个资源将更改所有场景中的所有预制件版本<ul><li>应用举例：在项目中，这种机制的第一个用途是让<strong>角色</strong>成为预制件。这意味着，如果您继续为游戏制作多个关卡，则无需为每个关卡重新制作 JohnLemon，只需实例化一个新的预制件即可。</li><li>识别：预制件可以在 Hierarchy 窗口中通过其<strong>蓝色名称和图标</strong>加以识别</li><li>（？？拖进Prefabs没有提示？）要从hierarchy拖动游戏对象，不是在project里面</li></ul></li><li>动画化角色（在预制件编辑）<ul><li>Animator组件第一个属性controller：有一个<strong>状态机</strong>用于<u>确定</u> Animator 组件在任何给定时间应该为其层级视图设置的<u>动画</u></li></ul></li><li>使角色对物理产生反应<ul><li>RigidBody组件（在预制件内编辑）</li><li>RootMotion（根运动）：<ul><li>动画大多数是相对于其<strong>父项</strong>完成的</li><li><strong>层级视图</strong>的<strong>父游戏对象</strong>没有父项，所以移动不是相对的</li><li>此父游戏对象可以称为根，运动就叫根运动</li><li>（概念是啥意思？？）</li></ul></li><li>更新循环：<ul><li>帧的运动，但是用户的操作对下一帧有影响，所以要快速运算要显示的下一幅图像</li><li>自定义组件的update方法被调用后，会在屏幕上渲染新图像</li><li>另一个单独的循环可以运行所有物理操作，不会改变更新的频率——&gt;FixedUpdate</li><li>默认？Animator在Update中移动角色，RigidBody同时在FixedUpdate中移动角色，造成问题</li></ul></li></ul></li><li>碰撞体（涵盖了许多不同的组件）<ul><li><u>定义了</u>用于物理碰撞的<u>对象的形状</u>，使角色<strong>能够碰撞</strong>其它对象以及<strong>被碰撞</strong></li><li>最简单的形状：**胶囊碰撞体 (Capsule Collider)**，要将模型覆盖</li></ul></li><li>脚本<ul><li>C#代码</li><li>可以像组件一样附加到游戏对象</li><li>像预制件一样，被创建为资源</li><li>为角色移动：<ul><li>从unity系统中获取移动数据（可用输入管理器）</li></ul></li></ul></li></ul><h1 id="TimeLine"><a href="#TimeLine" class="headerlink" title="TimeLine"></a>TimeLine</h1><h2 id="Playable-Director-component（用来关联时间线和游戏对象）"><a href="#Playable-Director-component（用来关联时间线和游戏对象）" class="headerlink" title="Playable Director component（用来关联时间线和游戏对象）"></a>Playable Director component（用来关联时间线和游戏对象）</h2><ul><li><p>stores the link between a Timeline instance and a Timeline Asset（实例和资产的区别？）</p></li><li><p>controls when the Timeline instance plays, how the Timeline instance updates its clock, and what happens when the Timeline instance finishes playing（操作控制，时间线的展示？结束之类的。时间线会有什么操作呢）</p><p><img src="/2021/11/10/Unity%E5%85%A5%E9%97%A8/hexo_github_blog\source_posts\pic\image-20211105170737785.png" alt="image-20211105170737785"></p><blockquote><p>当一个游戏对象被放进时间线的时候，属性栏里面会出现这个东西。其中Playable有它被放置的时间线</p></blockquote></li></ul><h1 id="Ruby’s-adventure-2D"><a href="#Ruby’s-adventure-2D" class="headerlink" title="Ruby’s adventure 2D"></a>Ruby’s adventure 2D</h1><h2 id="精灵渲染器平铺"><a href="#精灵渲染器平铺" class="headerlink" title="精灵渲染器平铺"></a>精灵渲染器平铺</h2><h3 id="游戏对象缩放为1：1：1"><a href="#游戏对象缩放为1：1：1" class="headerlink" title="游戏对象缩放为1：1：1"></a>游戏对象缩放为1：1：1</h3><h3 id="Sprite-Renderer组件"><a href="#Sprite-Renderer组件" class="headerlink" title="Sprite Renderer组件"></a>Sprite Renderer组件</h3><p>Draw Mode【绘制模式】：Tiled【平铺的】。如果不选择这个模式的话，是不会展开下面的设置面板的。</p><blockquote><p>Simple</p><p>Sliced 切片？</p></blockquote><p>Tile Mode【平铺模式】： Adaptive【可适应的】</p><blockquote><p>Continuous</p><p><img src="/2021/11/10/Unity%E5%85%A5%E9%97%A8/hexo_github_blog\source_posts\pic\image-20220410155057178.png" alt="image-20220410155057178"></p><p>Adaptive：达到一定的比例。比如两倍，三倍整才出现。</p><p><img src="/2021/11/10/Unity%E5%85%A5%E9%97%A8/hexo_github_blog\source_posts\pic\image-20220410155124012.png" alt="image-20220410155124012"></p></blockquote><h3 id="Mesh-Type网格类型（图片）"><a href="#Mesh-Type网格类型（图片）" class="headerlink" title="Mesh Type网格类型（图片）"></a>Mesh Type网格类型（图片）</h3><p>Full Rect 和Tight有什么区别？改成前者就能消去警告⚠。不然的话意思好像是不能正确地铺展。待研究</p><h3 id="碰撞体跟随铺展"><a href="#碰撞体跟随铺展" class="headerlink" title="碰撞体跟随铺展"></a>碰撞体跟随铺展</h3><p>Collider–Auto Tilling</p><h2 id="敌人上下移动"><a href="#敌人上下移动" class="headerlink" title="敌人上下移动"></a>敌人上下移动</h2><h3 id="对敌人的设置"><a href="#对敌人的设置" class="headerlink" title="对敌人的设置"></a>对敌人的设置</h3><ul><li><p>图片：像素是否更改</p></li><li><p>物理：Rigidbody，Collider</p><blockquote><p>Rigidbody中，</p><p>Gravity Scale改为0：为啥？？</p><p>Constraints：不让它受到旋转力的影响</p><p>Collider</p><p>Edit Collider：修改碰撞范围</p></blockquote></li></ul><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>计数器及状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Update()&#123;</span><br><span class="line">        moveTime -= Time.deltaTime;</span><br><span class="line">        if(moveTime &lt;= 0)&#123;</span><br><span class="line">            moveTime = initMoveTime;</span><br><span class="line">            moveDir = -moveDir;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void FixedUpdate()&#123;</span><br><span class="line">        Vector2 position = rigidbody2d.position;</span><br><span class="line">        if (moveDir)</span><br><span class="line">        &#123;</span><br><span class="line">            position.y = position.y + speed * Time.deltaTime;</span><br><span class="line">            moveTime -= Time.deltaTime;</span><br><span class="line">            if(moveTime &lt;= 0)</span><br><span class="line">                &#123;</span><br><span class="line">                moveTime = 2.0f;</span><br><span class="line">                moveDir = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            position.y = position.y - speed * Time.deltaTime;</span><br><span class="line">            moveTime -= Time.deltaTime;</span><br><span class="line">            if(moveTime &lt;= 0)</span><br><span class="line">                &#123;</span><br><span class="line">                moveTime = 2.0f;</span><br><span class="line">                moveDir = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        rigidbody2d.MovePosition(position);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是我原来写的代码，感觉很冗长。我的思路是把走的方向＋走的计时器＋移动都放成一块了（移动-计时-状态），而且放在了FixedUpdate()方法里面。那么这样的话，假如FixedUpdate刷新时间更慢一点，那么移动的是不是就慢一点？</p><p>官方把计时器和状态抽取出来放在了Update中，我觉得合理很多，因为和刷新的频率是一致的【计时器与物理无关】，而且只是两个状态的切换，其余逻辑相同，可以整合成很简洁的代码，而执行代码只需获取当前的状态就行，和其状态计算过程没有紧密的关联。</p><h2 id="与敌人实体碰撞受伤害"><a href="#与敌人实体碰撞受伤害" class="headerlink" title="与敌人实体碰撞受伤害"></a>与敌人实体碰撞受伤害</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void OnCollisionEnter2D(Collision2D other)</span><br><span class="line">&#123;</span><br><span class="line">    RubyController player = other.gameObject.GetComponent&lt;RubyController&gt;();</span><br><span class="line"></span><br><span class="line">    if (player != null)</span><br><span class="line">    &#123;</span><br><span class="line">        player.ChangeHealth(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数：<strong>刚体</strong>与某个对象碰撞时调用的函数</li><li>Collision2D🦁与Collider2D🦁的区别<ul><li>前者没有GetComponent函数，但是含有大量有关碰撞的数据，例如与敌人碰撞的游戏对象</li></ul></li></ul><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="Animator组件"><a href="#Animator组件" class="headerlink" title="Animator组件"></a>Animator组件</h3><p>创建controller加入进组件</p><h3 id="动画片段"><a href="#动画片段" class="headerlink" title="动画片段"></a>动画片段</h3><ul><li><p>精灵图集（Sprite Atlas/Sheet）</p><p>此处已经被切成多个不同精灵。把它们拖入Animation窗口中，形成序列帧</p></li><li><p>调整动画的速度</p><p>窗口的动画属性上方Sample设置：60，即每秒60帧</p><p>多少帧改为多少数值，（看情况吧</p></li><li><p>翻转帧</p><p>Add Property【大概是添加属性？】👉Sprite Renderer👉Flip X👉＋号来确定添加</p><p>Flip【快速翻转】</p><p><img src="/2021/11/10/Unity%E5%85%A5%E9%97%A8/hexo_github_blog\source_posts\pic\image-20220410173546850.png" alt="image-20220410173546850"></p><p>总结：大概意思就是，为整个片段添加了一个【快速翻转X】的属性，然后为第一帧和最后一帧打上【应用属性】的√，就把属性都应用上了</p></li></ul><h3 id="在controller编辑片段"><a href="#在controller编辑片段" class="headerlink" title="在controller编辑片段"></a>在controller编辑片段</h3><ul><li><p>混合树（Blend Tree）四段动画两两连接时会显得很混乱</p><ul><li><p>右键创建，打开节点</p></li><li><p>Blend Type：使用多少参数来选择要播放的动画</p><blockquote><p>在此处用两个参数来控制水平和垂直👉2D Simple Directional</p><p>水平：-1左，0无，1右；垂直：-1下，0无，1上</p><p>因此，水平为0时垂直移动…</p></blockquote><ul><li>Parameter：改为Move X，Move Y</li></ul></li><li><p><img src="/2021/11/10/Unity%E5%85%A5%E9%97%A8/hexo_github_blog\source_posts\pic\image-20220410184200636.png" alt="image-20220410184200636"></p><blockquote><ul><li>Move X 和 Move Y表示两个参数同时作用于动画的判断</li><li>Motion【运动】是自己添加的，暂时理解为动画的状态</li><li>对每个motion进行偏移点的设置，红点离谁最近就播放谁的动画</li><li>每个动画的连接成了一块区域？以更方便地进行切换吗？？太神奇了</li></ul><p>🧐和之前的状态机比较区别：</p><p>之前状态转换是由一个参数值决定的（是或否，数值的大小等）。现在是由两个参数来决定动画片段，乍一想好像很复杂，但是从混合树来看是很清晰明了的。上下左右分别代表了四个值，你或许想用一个int变量写1，2，3，4来表示，但四个动画之间是交叉相互的，所以这个不行；这里把共性提取了出来，正方向为1，负方向为0，分别是垂直、水平。而且从脚本的代码来看，这一一吻合，bool和int（-1，1）……反正多多体会吧，感觉挺妙的</p></blockquote></li></ul></li></ul><h3 id="用脚本把位置信息传递给controller"><a href="#用脚本把位置信息传递给controller" class="headerlink" title="用脚本把位置信息传递给controller"></a>用脚本把位置信息传递给controller</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (vertical)</span><br><span class="line">        &#123;</span><br><span class="line">            animator.SetFloat(&quot;Move X&quot;, 0);</span><br><span class="line">            animator.SetFloat(&quot;Move Y&quot;, moveDir);</span><br><span class="line">            position.y = position.y + speed * Time.deltaTime * moveDir;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            animator.SetFloat(&quot;Move X&quot;, moveDir);</span><br><span class="line">            animator.SetFloat(&quot;Move Y&quot;, 0);</span><br><span class="line">            position.x = position.x + speed * Time.deltaTime * moveDir;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>SetFloat()方法，指定某个参数来更改它的值</p><h3 id="关于动画过渡"><a href="#关于动画过渡" class="headerlink" title="关于动画过渡"></a>关于动画过渡</h3><ul><li>Has Exit Time：若取消选中，则立即响应，硬切动画；否则播完当前动画再换下一个</li><li>Conditions【条件】：没有条件的话，动画结束时过渡</li></ul><h3 id="对主角Ruby的动画研究"><a href="#对主角Ruby的动画研究" class="headerlink" title="对主角Ruby的动画研究"></a>对主角Ruby的动画研究</h3><p>机器人那个动画设置，不熟悉的话觉得还是挺复杂的。那么Ruby既有上下左右移动，还有不同的动作，又有视觉方向，是不是会变更麻烦呢？</p>]]></content>
    
    
    <summary type="html">冲</summary>
    
    
    
    <category term="Unity" scheme="http://example.com/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>Android常用的消息传递机制</title>
    <link href="http://example.com/2021/10/19/Android%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2021/10/19/Android%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</id>
    <published>2021-10-18T16:00:00.000Z</published>
    <updated>2022-04-09T11:41:10.382Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android常用的消息传递机制"><a href="#Android常用的消息传递机制" class="headerlink" title="Android常用的消息传递机制"></a>Android常用的消息传递机制</h1><h2 id="一、intent：Activity之间的跳转和数据传输"><a href="#一、intent：Activity之间的跳转和数据传输" class="headerlink" title="一、intent：Activity之间的跳转和数据传输"></a>一、intent：Activity之间的跳转和数据传输</h2><ul><li>内容：描述应用中一次操作的动作、动作涉及数据、附加数据等</li><li>对象 ：应用程序之间 / 应用程序内部的Activity或Service之间的交互</li><li>特点：媒介中介，实现调用者与被调用者的解耦</li></ul><p>😎—用法—</p><ul><li>启动Activity：<strong>Context.startActivity()</strong> 或 <strong>Activity.startActivityForResult()</strong></li><li>启动服务：Context.startService() </li><li>通过广播方法发给broadcast receivers：Context.sendBroadcast(), Context.sendOrderedBroadcast()…</li></ul><p>😊—intent属性设置—</p><ol><li><p>Action（要执行的动作）：(SDK标准动作 / 自定义动作)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.显示</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;http://google.com&quot;</span>); </span><br><span class="line">Intent it = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </span><br><span class="line">startActivity(it);</span><br><span class="line"><span class="comment">//2.打电话</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;tel:0800000123&quot;</span>); </span><br><span class="line">Intent it = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL, uri); </span><br><span class="line">startActivity(it); </span><br><span class="line"><span class="comment">//&lt;uses-permission id=&quot;android.permission.CALL_PHONE&quot; /&gt; 要加上</span></span><br><span class="line"><span class="comment">//3.传送Email</span></span><br><span class="line">Intent it=<span class="keyword">new</span> Intent(Intent.ACTION_SEND);<span class="comment">//动作属性   </span></span><br><span class="line">String[] tos=&#123;<span class="string">&quot;me@abc.com&quot;</span>&#125;;   </span><br><span class="line">String[] ccs=&#123;<span class="string">&quot;you@abc.com&quot;</span>&#125;;   </span><br><span class="line">it.putExtra(Intent.EXTRA_EMAIL, tos);    <span class="comment">//附加属性</span></span><br><span class="line">it.putExtra(Intent.EXTRA_CC, ccs);   </span><br><span class="line">it.putExtra(Intent.EXTRA_TEXT, <span class="string">&quot;The email body text&quot;</span>);   </span><br><span class="line">it.putExtra(Intent.EXTRA_SUBJECT, <span class="string">&quot;The email subject text&quot;</span>);   </span><br><span class="line">it.setType(<span class="string">&quot;message/rfc822&quot;</span>);   <span class="comment">//数据类型属性</span></span><br><span class="line">startActivity(Intent.createChooser(it, <span class="string">&quot;Choose Email Client&quot;</span>));</span><br><span class="line"><span class="comment">//4.播放新媒体</span></span><br><span class="line">Uri uri = Uri.parse(<span class="string">&quot;file:///sdcard/song.mp3&quot;</span>); <span class="comment">//url </span></span><br><span class="line">Intent it = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); <span class="comment">//显示动作</span></span><br><span class="line">it.setType(<span class="string">&quot;audio/mp3&quot;</span>);    <span class="comment">//数据格式</span></span><br><span class="line">startActivity(it);</span><br></pre></td></tr></table></figure></li><li><p>Data（<strong>执行动作</strong>要操作的数据）：</p><p>Android中采用<u>指向数据的一个URL</u>。如在联系人应用中，一个指向某联系人的URI可能为：content://contacts/1</p></li><li><p>type（数据类型）：显式指定Intent的数据类型。一般Intent的数据类型能够根据数据本身进行判定，而通过设置这个属性，可以强制采用显式指定的类型而不再进行推导</p></li><li><p>category（被执行动作的附加信息）：</p></li><li><p>component（组件）：</p><p>指定Intent的的目标组件的类名称。有指定的话，就不用根据属性来查找intent了。</p></li><li><p>extra（附加信息的集合）：</p></li></ol><p>😜—分类—</p><ul><li><p>显式intent：在构造对象时就指定接收者</p></li><li><p>隐式intent：构造intent对象时，不知道也不关心接收者是谁</p><ul><li><p>Android解析——将intent映射给接收者</p></li><li><p>解析机制：查找 已经注册在AndroidManifest.xml中的 所有IntentFilter——根据属性来判断——找到匹配的intent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;NotesList&quot;</span> android:label=<span class="string">&quot;@string/title_notes_list&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//1</span></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">             <span class="comment">//2</span></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;android.intent.action.EDIT&quot;</span> /&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;android.intent.action.PICK&quot;</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class="line">                &lt;data android:mimeType=<span class="string">&quot;vnd.android.cursor.dir/vnd.google.note&quot;</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">             <span class="comment">//3</span></span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=<span class="string">&quot;android.intent.action.GET_CONTENT&quot;</span> /&gt;</span><br><span class="line">                &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br><span class="line">                &lt;data android:mimeType=<span class="string">&quot;vnd.android.cursor.item/vnd.google.note&quot;</span> /&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>😍—Intent用法实例—</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.无参数的Activity跳转</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Activity.Main.<span class="keyword">this</span>, Activity2.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.向下一个Activity传递数据(Bundle -&gt; Intent.putExtras)</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Activity.Main.<span class="keyword">this</span>, Activity2.class);</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;This is from MainActivity!&quot;</span>);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">startActivity(intent);<span class="comment">//startActivityForResult(intent, REQUEST_CODE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对数据的获取</span></span><br><span class="line">Bundle bundle = getIntent().getExtras();</span><br><span class="line">String name = bundle.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.向上一个Activity返回结果</span></span><br><span class="line">Intent intent = getIntent();</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;This message is back!&quot;</span>);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">setResult(RESULT_OK, intent);<span class="comment">//针对第二种启动方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.回调上一个Activity的结果处理函数（onActivityResult）对不同结果的处理</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">        <span class="keyword">if</span> (requestCode==REQUEST_CODE)&#123;</span><br><span class="line">            <span class="keyword">if</span>(resultCode==RESULT_CANCELED)</span><br><span class="line">                  setTitle(<span class="string">&quot;cancle&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (resultCode==RESULT_OK) &#123;</span><br><span class="line">                 String temp=<span class="keyword">null</span>;</span><br><span class="line">                 Bundle bundle=data.getExtras();</span><br><span class="line">                 <span class="keyword">if</span>(bundle!=<span class="keyword">null</span>)   temp=bundle.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                 setTitle(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二、onSaveInstance-onRestoreInstanceState-Activity状态的保存和恢复"><a href="#二、onSaveInstance-onRestoreInstanceState-Activity状态的保存和恢复" class="headerlink" title="二、onSaveInstance onRestoreInstanceState: Activity状态的保存和恢复"></a>二、onSaveInstance onRestoreInstanceState: Activity状态的保存和恢复</h2><p><img src="https://i.loli.net/2021/10/23/dvJ6Y8mtXhOgqbQ.png" alt="1336983672_6102.png"></p><ul><li><p>Activity的销毁和重建 </p><ul><li><p>正常情况：back键，与调用finish方法；</p></li><li><p>特殊情况：当Activity处于onStop状态时，如：退到后台，并且长时间不用时，极有可能会被系统回收，用来释放一些内存；</p></li><li><p>旋屏情况：如果Activity支持旋屏，每次旋屏都会导致activity的销毁与重建；</p></li><li><p>回调函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>用户离开Activity——调用此函数——传递一个Bundle object——如果系统过会重建这个activity实例，会将这个Bundle object传到onRestoreInstanceState() 和 onCreate() 方法中去</p></blockquote></li></ul></li><li><p>恢复Activity状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        .....</span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果程序唤醒了</span></span><br><span class="line">        <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*拿到数据后进行操作*/</span></span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//举例：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveStateActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;SaveStateActivity&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState!=<span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.v(TAG, savedInstanceState.getString(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.main);</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;onCreate&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">Log.v(TAG, savedInstanceState.getString(<span class="string">&quot;data&quot;</span>));</span><br><span class="line"><span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">Log.v(TAG, <span class="string">&quot;onRestoreInstanceState&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">outState.putString(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;example&quot;</span>);</span><br><span class="line"><span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">Log.v(TAG, <span class="string">&quot;onSaveInstanceState&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onPause();</span><br><span class="line">Log.v(TAG, <span class="string">&quot;onPause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onResume();</span><br><span class="line">Log.v(TAG, <span class="string">&quot;onResume&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.onStart();</span><br><span class="line">   Log.v(TAG, <span class="string">&quot;onStart&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onRestart();</span><br><span class="line">Log.v(TAG, <span class="string">&quot;onRestart&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有id为editText1的editText</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到主页</p><p><img src="https://i.loli.net/2021/10/21/DPCOFoBteLjEqHd.png" alt="image-20211021191045506.png"></p><p>回到app，调用了onRestart方法，并没有调用 onRestoreInstanceState方法</p><p><img src="https://i.loli.net/2021/10/21/a8kvQtyMZF6lHUj.png" alt="image-20211021191255180.png"></p><p>back键，表明用户明确退出，直接退出没保存<img src="https://i.loli.net/2021/10/21/gzD7aWsvQK96R3t.png" alt="image-20211021191434961.png"></p><p>输入editText，旋转屏幕，仍可见，状态保存，说明UI是自动保存和恢复的（前提是给组件id）</p></li></ul><p><img src="https://i.loli.net/2021/10/21/FfS2Eg84RZaYDBz.png" alt="image-20211021191734476.png"></p><h2 id="三、callback-interface-接口回调机制"><a href="#三、callback-interface-接口回调机制" class="headerlink" title="三、callback interface 接口回调机制"></a>三、callback interface 接口回调机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callbacks</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(String a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自己实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Myself</span> <span class="keyword">implements</span> <span class="title">Callbacks</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Others other = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOther</span><span class="params">()</span></span>&#123;</span><br><span class="line">        other = <span class="keyword">new</span> Others(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        System.out(<span class="string">&quot;hello&quot;</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//别人将回调接口传入,调用方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Others</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Callbacks callback = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Others</span><span class="params">(Callbacks callback)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callback = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getA</span><span class="params">(Callbacks callback)</span></span>&#123;</span><br><span class="line">        callback.method(<span class="string">&quot;I am waawa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callbackTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Others other = <span class="keyword">new</span> Others();</span><br><span class="line">    other.getA(Myself.<span class="keyword">this</span>);<span class="comment">//转型之类，待研究</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>callback.method()。利用接口变量 相当于通知 实现具体方法的类 实行操作。</li><li>优点：代码量小，很容易理解，处理效率高</li><li>缺点：不利于修改和扩展，接口一变更，发送方和接收方都需要修改参数。并且必须提供一个获取接口的入口。</li></ul><h2 id="四、broadcast-receiver"><a href="#四、broadcast-receiver" class="headerlink" title="四、broadcast receiver"></a>四、broadcast receiver</h2><ul><li><p>四大组件之一（Activity，Service，ContentProvider）</p></li><li><p>BroadcastReceiver：（系统内部）消息型组件，用于在不同的组件乃至不同的应用之间传递消息。</p><p>①广播注册：静态和动态注册。</p><p>​    静态👉在AndroidManifest中注册广播——广播应用安装时就被解析——不需要应用启动就可以收到广播</p><p>​    动态👉应用启动才能注册并接收广播</p><p>②特点：发送方并不关心接收方是否接到数据，也不关心接收方是如何处理数据的，通过这样的    形式来达到接、收双方的完全解耦合</p></li></ul><h3 id="广播接收者"><a href="#广播接收者" class="headerlink" title="广播接收者"></a>广播接收者</h3><ul><li>代码，onReceive方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;on receive action = &quot;</span> + intent.getAction());</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        <span class="comment">//拿到intent该干嘛干嘛</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="广播注册者"><a href="#广播注册者" class="headerlink" title="广播注册者"></a>广播注册者</h3><ul><li><p>静态注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name = <span class="string">&quot;.Myreceiver&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name = <span class="string">&quot;com.ryg.receiver.LAUNCH&quot;</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line"> &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IntentFilter就是提过的 隐式地启动系统组件的时候，就会根据IntentFilter来筛选出合适的进行启动</span></span><br><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">&quot;com.ryg.receiver.LAUNCH&quot;</span>);</span><br><span class="line">registerReceiver(<span class="keyword">new</span> MyReceiver(), filter);</span><br></pre></td></tr></table></figure></li><li><p>前两步完成之后，通过send方法来发送广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">&quot;com.ryg.receiver.LAUNCH&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></li></ul><h3 id="🐱‍🏍举例"><a href="#🐱‍🏍举例" class="headerlink" title="🐱‍🏍举例"></a>🐱‍🏍举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*接收方*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TestReceiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//注册。IntentFilter对象负责过滤掉组件无法响应和处理的Intent，只将自己关心的Intent接收进来进行处理</span></span><br><span class="line">        receiver = <span class="keyword">new</span> TestReceiver();</span><br><span class="line">        IntentFilter filter = <span class="keyword">new</span> IntentFilter(<span class="comment">/*这里填你自定义的这个广播过滤的名字NAME*/</span>);</span><br><span class="line">        registerReceiver(receiver, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//为防止内存泄漏，需要及时注销接收器</span></span><br><span class="line">        unregisterReceiver(receiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            String type = intent.getStringExtra(<span class="comment">/*这里填你自定义的发送消息的类型TYPE*/</span>);</span><br><span class="line">            <span class="keyword">switch</span>(type)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;TYPE1&quot;</span>:</span><br><span class="line">                    <span class="keyword">int</span> i = intent.getIntExtra(<span class="string">&quot;testInteger&quot;</span>, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;TYPE2&quot;</span>:</span><br><span class="line">                    String s = intent.getStringExtra(<span class="string">&quot;testString&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送方*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendService</span> <span class="keyword">extends</span> <span class="title">Service</span></span>&#123;<span class="comment">//??</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="comment">/*这里填刚才你写的那个NAME*/</span>);</span><br><span class="line">        intent.putExtra(<span class="comment">/*这里填刚才你写的那个消息类型TYPE*/</span>,<span class="string">&quot;TYPE1&quot;</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;testInteger&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="comment">/*这里填刚才你写的那个NAME*/</span>);</span><br><span class="line">        intent.putExtra(<span class="comment">/*这里填刚才你写的那个消息类型TYPE*/</span>,<span class="string">&quot;TYPE2&quot;</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;testString&quot;</span>, <span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>优点：发送方和接收方实现了完全解耦，发送方将消息发送出去后，这条消息就与他无关了，收没收到也不管。 </li><li>缺点：广播的接收和发送得依赖context的环境。每次调用都需要写繁琐的intent和putExtra。数据传递方式类比handler，在接收时存在类型转换异常的风险。</li></ul><h2 id="五、observer-subject（观察者模式）"><a href="#五、observer-subject（观察者模式）" class="headerlink" title="五、observer-subject（观察者模式）"></a>五、observer-subject（观察者模式）</h2><ul><li><p>观察者接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">newMsg</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主题接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个<strong>观察者管理类</strong>实现主题接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverManager</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObserverManager instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; Observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ObserverManager</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ObserverManager <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ObserverManager.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ObserverManager();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        Observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        Observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer: Observers)&#123;</span><br><span class="line">            observer.newMsg(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>观察者即接收方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取manager</span></span><br><span class="line">    <span class="keyword">private</span> ObserverManager manager = ObserverManager.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//被纳入观察者队列</span></span><br><span class="line">        manager.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//非常重要！！！！！！！！！！</span></span><br><span class="line">        manager.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newMsg</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;Get a new msg&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>主题即发送方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sender</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ObserverManager manager = ObserverManager.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNewMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">        manager.notify(<span class="string">&quot;This is a new msg from sender.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>manager对观察者和发送者都进行了干预；可以随时增删观察者；</p></li><li><p>优点：同广播，高度解耦。接口自定义，扩展性强。<br>缺点：一对一时或者接收方数量少时，“杀鸡焉用牛刀”。接口修改时需要到处改动，同callback。</p></li></ul><p>参考博客：</p><p><a href="https://www.cnblogs.com/feisky/archive/2010/01/16/1649081.html">Android Activity和Intent机制学习笔记 - feisky - 博客园 (cnblogs.com)</a></p><p><a href="https://www.runoob.com/android/android-intents-filters.html">Android 意图(Intent)和过滤器(Filter) | 菜鸟教程 (runoob.com)</a></p><p><a href="https://my.oschina.net/u/1389206/blog/1798642">Android四种常用的消息传递机制/模式的比较 - 当空皓月的个人空间 - OSCHINA - 中文开源技术交流社区</a></p><p><a href="https://www.cnblogs.com/whoislcj/p/5590615.html">Android消息传递之Handler消息机制 - 总李写代码 - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/lixiang0522/article/details/7565401">(22条消息) Android中Activity状态的保存和恢复：onSaveInstanceState和onRestoreInstanceState方法_小何才露尖尖角-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">Android常用的消息传递机制</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 四大组件</title>
    <link href="http://example.com/2021/10/19/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    <id>http://example.com/2021/10/19/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/</id>
    <published>2021-10-18T16:00:00.000Z</published>
    <updated>2022-04-09T11:42:55.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="四大组件的运行状态"><a href="#四大组件的运行状态" class="headerlink" title="四大组件的运行状态"></a>四大组件的运行状态</h1><ul><li><p>Activity：（前台 ）展示型组件，向用户展示一个界面并且可以接收用户的输入信息进行交互。</p><p>①面向用户；</p><p>②启动👈显式隐式intent；</p><p>③finish结束</p></li><li><p>Service：（后台执行）计算型组件，在后台执行一系列任务。</p><p>①启动状态👉内部做后台计算；</p><p>②绑定状态👉后台计算＋和外界通信；</p><p>③停止：stopService和unBindService两个方法</p></li><li><p>BroadcastReceiver：（系统内部）消息型组件，用于在不同的组件乃至不同的应用之间传递消息。</p><p>①广播注册：静态和动态注册。</p><p>​    静态👉在AndroidManifest中注册广播——广播应用安装时就被解析——不需要应用启动就可以收到广播</p><p>​    动态👉应用启动才能注册并接收广播</p><p>②特点：发送方并不关心接收方是否接到数据，也不关心接收方是如何处理数据的，通过这样的    形式来达到接、收双方的完全解耦合</p></li><li><p>ContentProvider：数据共享型组件，用于向其他组件乃至其它应用共享数据。</p><p>①内部维持着一份数据集合。增删查改</p></li></ul><h1 id="BroadcastReceiver的工作过程（注册、发送和接收）"><a href="#BroadcastReceiver的工作过程（注册、发送和接收）" class="headerlink" title="BroadcastReceiver的工作过程（注册、发送和接收）"></a>BroadcastReceiver的工作过程（注册、发送和接收）</h1><h2 id="广播接收者"><a href="#广播接收者" class="headerlink" title="广播接收者"></a>广播接收者</h2><ul><li>代码，onReceive方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">&quot;on receive action = &quot;</span> + intent.getAction());</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        <span class="comment">//拿到intent该干嘛干嘛</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广播注册者"><a href="#广播注册者" class="headerlink" title="广播注册者"></a>广播注册者</h2><ul><li><p>静态注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver android:name = <span class="string">&quot;.Myreceiver&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">    &lt;action android:name = <span class="string">&quot;com.ryg.receiver.LAUNCH&quot;</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line"> &lt;/receiver&gt;</span><br></pre></td></tr></table></figure></li><li><p>动态注册</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(<span class="string">&quot;com.ryg.receiver.LAUNCH&quot;</span>);</span><br><span class="line">registerReceiver(<span class="keyword">new</span> MyReceiver(), filter);</span><br></pre></td></tr></table></figure></li><li><p>前两步完成之后，通过send方法来发送广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setAction(<span class="string">&quot;com.ryg.receiver.LAUNCH&quot;</span>);</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Android 四大组件</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
  <entry>
    <title>Liu Cixin</title>
    <link href="http://example.com/2021/10/10/deeply_touched_again/"/>
    <id>http://example.com/2021/10/10/deeply_touched_again/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2022-04-09T11:41:32.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Part-one-the-speech"><a href="#Part-one-the-speech" class="headerlink" title="Part one: the speech"></a>Part one: the speech</h1><p>Ladies and Gentleman,</p><p>女士们，先生们：</p><p>Good evening!</p><p>晚上好！</p><p>It’s my great honor to receive the Clarke Award for Imagination in Service to Society. Thank you.</p><p>很荣幸获得克拉克想象力服务社会奖。</p><p>This award is a reward for imagination. Imagination is a capability that should have exclusive belonged to God but we, as human beings, luckily have this too. It is far beyond our imagination to grasp the meaning of the existence of imagination. A historian used to say that the main reason why human beings have been able to surpass other species on earth and to build civilizations is that we are able to create something in our heads that does not exist in reality. In the future, when artificial intelligence becomes smarter than us, imagination may be the only advantage we have over AI.</p><p>这个奖项是对想象力的奖励，而想象力是人类所拥有的一种似乎只应属于神的能力，它存在的意义也远超出我们的想象。有历史学家说过，人类之所以能够超越地球上的其他物种建立文明，主要是因为他们能够在自己的大脑中创造出现实中不存在的东西。在未来，当人工智能拥有超过人类的智力时，想象力也许是我们所拥有的惟一优势。</p><p>Science fiction is a literary genre based on imagination. And the first sci-fi works that impressed me were those by Arthur C. Clarke. Together with Jules Verne and George Wells, Arthur Clarke was among the first Western modern sci-fi writers to enter China. In the early 1980s, the two novels 2001: A Space Odyssey and Rendezvous With Rama were published in my country. At that time, the Cultural Revolution just ended. While the old life and faith had collapsed, the new ones had not yet been established. Like other young people, I felt lost during that period. These two books, for the first time, however, brought my imagination to life. My mind opened up like it has never before. I felt like a narrow stream finally embracing the sea.</p><p>科幻小说是基于想象力的文学，而最早给我留下深刻印象的是亚瑟·克拉克的作品。除了儒勒·凡尔纳（Jules Verne）和赫伯特·乔治·威尔斯（Herbert George Wells）外，克拉克的作品是最早进入中国的西方现代科幻小说。在上世纪80年代初，中国出版了他的《2001：太空漫游》和《与拉玛相会》。当时文革刚刚结束，旧的生活和信仰已经崩塌，新的还没有建立起来，我和其他年轻人一样，心中一片迷茫。这两本书第一次激活了我的想象力，思想豁然开阔许多，有小溪流进大海的感觉。</p><p>At midnight when I finished reading 2001: A Space Odyssey, I walked out of the house and stared at the starry sky. I was able to see the galaxy, thanks to the unpolluted sky of China back then. That night, I noticed that the starry sky looked nothing like before. For the first time in my life, I was awed by the magnitude and mystery of our universe, the feeling which you only get facing religion. Later on, the novel Rendezvous With Rama stunned me by showing how imagination could build a lifelike, fantastic world. It was Arthur Clarke who opened up this world of feelings to me, and who paved my way to become a sci-fi writer.</p><p>读完《2001：太空漫游》的那天深夜，我走出家门仰望星空，那时的中国的天空还没有太多的污染，能够看到银河，在我的眼中，星空与过去完全不一样了，我第一次对宇宙的宏大与神秘产生了敬畏感，这是一种宗教般的感觉。而后来读到的《与拉玛相会》，也让我惊叹想象力是如何构造出一个栩栩如生的想象世界的。正是克拉克带给我的这些感受，让我后来成为一名科幻作家。</p><p>Today, more than 30 years later, it gradually dawns on me that people like me, who were born in the 1960s in China, are probably the luckiest people in human history. No generation is like us, no generation has been able to witness such tremendous changes in the world around us. The world we are living in today is completely different from that of our childhood. And such changes are taking place with even greater speed.</p><p>现在，三十多年过去了，我渐渐发现，我们这一代在上世纪60年代出生于中国的人，很可能是人类历史上最幸运的人。因为之前没有任何一代人，像我们这样目睹周围的世界发生了如此巨大的变化。我们现在生活的世界，与我们童年的世界已经完全是两个不同的世界，而这种变化还在加速发生着。</p><p>China is a highly futuristic country. It is true that the future of China may be full of challenges and risks, but never has this country been so attractive like today. This reality provides fertile soil for the growth of science fiction, and it is enjoying unprecedented attention in the country. As a Chinese sci-fi author, who was born in the 1960s, I’m the luckiest from the luckiest generation.</p><p>中国是一个充满着未来感的国度，中国的未来可能充满着挑战和危机，但从来没有像现在这样具有吸引力，这就给科幻小说提供了肥沃的土壤，使其在中国受到了空前的关注。作为一个在60年代出生在中国的科幻小说家，我则是幸运中的幸运。</p><p>I started writing sci-fi because I looked for a way to escape the dull life, and to reach out, with imagination, to the mysterious time and space that I could never truly reach. But then I realized that the world around me became more and more like science fiction, and this process is speeding up. Future is like pouring rain. It reaches us even before we have time to open the umbrella. Meanwhile, when sci-fi becomes reality, it loses all its magic, and that frustrates me. Sci-fi will soon become part of our lives. The only thing I can do, is to push my imagination further to even more distant time and space to hunt for the mysteries of sci-fi. As a sci-fi author, I think my job is to write things down before they get really boring.</p><p>我最初创作科幻小说的目的，是为了逃离平淡的生活，用想象力去接触那些我永远无法到达的神奇时空。但后来我发现，周围的世界变得越来越像科幻小说了。这种进程还在飞快地加速，未来像盛夏的大雨，在我们还不及撑开伞时就扑面而来。同时我也沮丧地发现，当科幻变为现实时，没人会感到神奇，它们很快会成为生活中的一部分。所以我只有让想象力前进到更为遥远的时间和空间中去寻找科幻的神奇，科幻小说将以越来越快的速度变成平淡生活的一部分，作为一名科幻作家，我想我们的责任就是在事情变得平淡之前把它们写出来。</p><p><img src="https://t12.baidu.com/it/u=929537066,855089247&fm=173&app=49&f=JPEG?w=640&h=388&s=5EA7AD44CE941A45748525040300C0D9" alt="img"></p><p>This being said, the world is moving in the direction opposite to Clarke’s predictions. In 2001: A Space Odyssey, in the year of 2001, which has already passed, human beings have built magnificent cities in space, and established permanent colonies on the moon, and huge nuclear-powered spacecraft have sailed to Saturn. However, today, in 2018, the walk on the moon has become a distant memory. And the furthest reach of our manned space flights is just as long as the two-hour mileage of a high-speed train passing through my city.</p><p>但另一方面，世界却向着与克拉克的预言相反的方向发展。在《2001：太空漫游》中，在已经过去的2001年，人类已经在太空中建立起壮丽的城市，在月球上建立起永久性的殖民地，巨大的核动力飞船已经航行到土星。而在现实中的2018年，再也没有人登上月球，人类的太空中航行的最远的距离，也就是途经我所在的城市的高速列车两个小时的里程。</p><p>At the same time, information technology is developing at an unimaginable speed. The entire world is connected via the internet and people have gradually lost their interest in space, as they find themselves increasingly comfortable in the space created by IT. Instead of an exploration of the real space, which is full of difficulties, people now just prefer to experiencing virtual space through VR. Just like someone said, “You promised me an ocean of stars, but you actually gave me Facebook.”</p><p>与此同时，信息技术却以超乎想象的速度发展，网络覆盖了整个世界。在IT所营造的越来越舒适的安乐窝中，人们对太空渐渐失去了兴趣。相对于充满艰险的真实的太空探索，他们更愿意在VR中体验虚拟的太空。这像有一句话说的：“说好的星辰大海，你却只给了我Facebook。”</p><p>This reality is also reflected in science fiction. Arthur Clarke’s magnificent imagination about space has gradually faded away. People stopped looking at starry skies. In the sci-fi works today, there are more imagination about how we live in cyber utopia or dystopia. Writers focus more on various problems we encounter in reality. The imagination of science fiction is abandoning the vastness and profoundness that Arthur Clarke once opened up, instead people are now embracing the narrowness and introversion of cyberpunk.</p><p>这样的现实也反映在科幻小说中，克拉克对太空的瑰丽想象已经渐渐远去，人们的目光从星空收回。现在的科幻小说，更多地想象人类在网络乌托邦或反乌托邦中的生活，更多地关注现实中所遇到的各种问题，科幻的想象力由克拉克的广阔和深远，变成赛博朋克的狭窄和内向。</p><p>As a sci-fi writer, I have been striving to continue Arthur Clarke’s imagination. I believe that the boundless space is still the best direction and destination for human imagination. I have always written about the magnitude and mysteries of the universe, interstellar expeditions, and the lives and civilizations happening in distant worlds. This remains today, although this may seem childish or even outdated. It says on Arthur Clarke’s epitaph, “He never grew up, but he never stopped growing.”</p><p>作为科幻作家，我一直在努力延续着克拉克的想象，我相信，无垠的太空仍然是人类想象力最好的去向和归宿，我一直在描写宇宙的宏大神奇，描写星际探险，描写遥远世界中的生命和文明，尽管在现在的科幻作家中，这样会显得有些幼稚，甚至显得跟不上时代。正如克拉克的墓志铭所说：“他从未长大，但从未停止成长。”</p><p><img src="https://t10.baidu.com/it/u=2347439895,1473061571&fm=173&app=49&f=JPEG?w=640&h=428&s=41EEB044CC40244D4A185CBA0300E090" alt="img"></p><p>Many people misunderstand sci-fi as trying to predict the future, but this is not true. It just makes a list of possibilities of what may happen in the future, like displaying a pile of cobblestones for people to see and play with. Science fiction can never tell which scenario of the future will actually become the real future. This is not its job. It’s also beyond its capabilities.</p><p>与人们常有的误解不同，科幻小说并不是在预测未来，它只是把未来的各种可能性排列出来，就像一堆想象力的鹅卵石，摆在那里供人们欣赏和把玩。这无数个可能的未来哪一个会成为现实，科幻小说并不能告诉我们，这不是它的任务，也超出了它的能力。</p><p>But one thing is certain: in the long run, for all these countless possible futures, any future without space travel is gloomy, no matter how prosperous our own planet becomes.</p><p>但有一点可以确定：从长远的时间尺度来看，在这无数可能的未来中，不管地球达到了怎样的繁荣，那些没有太空航行的未来都是暗淡的。</p><p>Sci-fi was writing about the age of digital information and it eventually became true. I now look forward to the time when space travel finally becomes the ordinary. By then, Mars and the asteroid belts will be boring places and countless people are building a home over there. Jupiter and its many satellites will be tourist attractions. The only obstacle preventing people from going there for good, will be the crazy price.</p><p>我期待有那么一天，像那些曾经描写过信息时代的科幻小说一样，描写太空航行的科幻小说也变得平淡无奇了，那时的火星和小行星带都是乏味的地方，有无数人在那里谋生；木星和它众多的卫星已成为旅游胜地，阻止人们去那里的唯一障碍就是昂贵的价格。</p><p>But even at that time, the universe is still unimaginably big that even our wildest imagination fails to catch its edge. And even the closest star remains out of reach. The vast ocean of stars can always carry our infinite imagination.</p><p>但即使在这个时候，宇宙仍是一个大得无法想象的存在，距我们最近的恒星仍然遥不可及。浩瀚的星空永远能够承载我们无穷的想象力。</p><p>Thank you all.</p><p>谢谢大家。</p><p><a href="https://baijiahao.baidu.com/s?id=1616893285923782963&wfr=spider&for=pc">精彩！刘慈欣首次英文演讲，文稿深情优美，看完想背诵全文 (baidu.com)</a></p><p>文章来源：中国日报双语微信</p><p><a href="http://yingyu.xdf.cn/yd/career/201508/10330525.html">雨果奖《三体》作者刘慈欣英文简介（双语）-新东方网 (xdf.cn)</a></p><h1 id="Part-two-introduction"><a href="#Part-two-introduction" class="headerlink" title="Part two: introduction"></a>Part two: introduction</h1><p>　　Liu Cixin, China’s most popular science-fiction writer, is 52 year sold and has written thirteen books. He worked as a software engineer at a power plant in Shanxi. In China, he is about as famous as William Gibson in the United States; he’s often compared to Arthur C. Clarke, whom he cites as an influence. His most popular book, “The Three-Body Problem,” has been translated into English by the American sci-fi writer Ken Liu, and in China it’s being made into a movie, along with its sequels.</p><p>　　刘慈欣是中国最受欢迎的科幻作家，现年52岁的他著有13作品。刘慈欣曾担任山西省某发电厂的软件工程师。他在中国的知名度可以和美国科幻作家威廉·吉布森(William Gibson)相媲美。人们常将刘慈欣与亚瑟·克拉克(Arthur C. Clarke)相提并论，而刘慈欣称自己受到了克拉克的影响。刘慈欣最受欢迎的小说《三体》(The Three-Body Problem)已经被美籍华裔科幻作家刘宇昆(Ken Liu)译成了英文。在中国，《三体》三部曲的电影也已在拍摄中。</p><p>　　Liu Cixin’s writing evokes the thrill of exploration and the beauty of scale. “In my imagination,”he told me, in an e-mail translated by Ken Liu, “abstract concepts like the distance marked by alight-year or the diameter of the universe become concrete images that inspire awe.”</p><p>　　刘慈欣的作品唤起了人们对探索和宏观之美的兴奋感。在一封经刘宇昆翻译的电子邮件中，刘慈欣告诉我：“在我的想象中，以光年计量的距离和宇宙直径这类抽象概念变成了具体的形象，令人心生敬畏。”</p><p>　　American science fiction draws heavily on American culture, of course—the war for independence,the Wild West, film noir, sixties psychedelia—and so humanity’s imagined future often looks a lotlike America’s past. For an American reader, one of the pleasures of reading Liu is that his storiesdraw on entirely different resources.</p><p>　　毋庸置疑，美国科幻小说很大程度上取材于美国文化，包括独立战争、西部荒野、黑色电影、60年代的迷幻风潮，因此，人文科学所构想的未来世界与美国的过去存在很大程度的相似性。对美国读者来说，阅读刘慈欣作品的乐趣之一在于他的故事取材完全不同。</p><p>　　Much of “The Three-Body Problem” is set during the Cultural Revolution. In “The Wages of Humanity,” visitors from space demand the redistribution of Earth’s wealth, and explain that runaway capitalism almost destroyed their civilization. I doubt that any Western sci-fi writer has so thoroughly explored the theme of filial piety.</p><p>　　小说《三体》的故事背景大抵都是文化大革命(the Cultural Revolution)期间。在《赡养人类》(The Wages of Humanity)这部小说中，太空来客要求重新分配地球财富，并解释说失控的资本主义几乎摧毁了他们的文明。我不太确定西方科幻作家会如此全面深入地探讨“孝道”这一主题。</p><p>　　But it’s not cultural difference that makes Liu’s writing extraordinary. His stories are fables about human progress—concretely imagined but abstract. Take the novella “Sun of China,” which follows Ah Quan, a young man from a rural village that has been impoverished by drought. In the first three chapters, Ah Quan sets out from the village and finds work in a mine; he travels to a regional city, where he learns to shine shoes, and moves to Beijing, where he works as a skyscraper-scaling window-washer. Then the story takes a turn.</p><p>　　刘慈欣作品的特别之处并非在于文化差异。他的故事都是一些有关人类发展的寓言——既是具体的想象，同时又是抽象的概念。在他的短篇小说《中国太阳》(Sun of China)中，主人公是个叫做阿全的年轻小伙子，他来自一个遭受旱灾的贫困乡村。在小说的前三章里，阿全离开了村子，到矿上找工作;接着他又到了一个地级市，在那里学会了擦皮鞋，之后辗转来到北京，当起了一名高楼外墙玻璃清洗工。后来，故事情节出现了一个转折。</p><p>　　We discover that it’s the future: China has constructed a huge mirror in space called the China Sun, and is using it to engineer the climate. Ah Quan gets a job cleaning the reflective surface of the China Sun. It turns out that Stephen Hawking is living in orbit, where the low gravity has helped to prolong his life; Hawking and Ah Quan become friends and go on space walks together. The physicist teaches the worker about the laws of physics and about the vastness of the universe,and Ah Quan’s mind begins to dwell on the question of humanity’s fate: Will we explore the stars,or live and die on Earth? Soon afterward, he is saying goodbye to his parents and setting out on a one-way mission to explore interstellar space. By the end of the story, Ah Quan’s progress is representative of humanity’s. He has traversed an enormous social and material distance, but it pales in comparison to the journey ahead.</p><p>　　我们发现书中描述的是未来的世界：中国在太空建造了一面巨大的镜子，它被称为“中国太阳”，用于调节气候。阿全的工作是清洁“中国太阳”反光表面。原来斯蒂芬·霍金(Stephen Hawking)生活在轨道上，因为那里的重力小，他的生命得以延长;后来霍金和阿全成为了朋友，一起去太空漫步。这位物理学家向这个工人讲授了物理学定律和宇宙的浩瀚，阿全的内心开始思考人类命运：我们要去探索其他星球吗?还是就在地球上度过一生?不久，他就向父母告别，踏上了探索星际的单程之旅。故事结尾，阿全取得的进步代表着全人类的进步，尽管他跨越了巨大的社会和物质距离，但与未知的旅程相比，这显得微不足道。</p><p>　　Liu’s stories aren’t always so tender; in imagining the human future, his romantic sweetness is balanced with harsh objectivity. In “The Wandering Earth,” scientists discover that the sun is about to swell into a red giant. In response, they build enormous engines capable of pushing the entire planet toward another star—an “exodus” that will last a hundred generations, during which everything on the surface will be destroyed. Watching the deadly sun recede and transform into a star like any other, the protagonist cries out, “Earth, oh my wandering Earth!” And yet the story suggests that this is just the sort of outrageous project we’ll need in order to insure humanity’s long-term survival.</p><p>　　刘慈欣的故事不完全是这么温和的;在想象人类的未来时，他笔下的浪漫甜蜜与残酷现实是相辅相成的。在《流浪地球》(The Wandering Earth)中，科学家们发现太阳将要膨胀为巨大的红色星体。因此，他们建造了巨大的引擎，这些引擎能够将整个地球推向另一颗恒星——一场持续上百代的“大迁移”就此展开。在此期间，地球表面的一切都将被摧毁。看着致命的太阳渐渐远去，变得模糊，最后变得与其他星体无异，主人公哭喊着“地球，我流浪的地球啊!”然而，这个故事向我们暗示了，我们需要种种匪夷所思的解决方案来保证人类的长存。</p><p>　　“In the distant future, if human civilization survives and spreads through the cosmos, humanitymust create technological marvels at ultra-grand scales,” Liu wrote to me.</p><p>　　刘慈欣在邮件中写道：“在遥远的未来，如果人类文明在宇宙间生存繁衍的话，人类必需创造超乎寻常的科技奇迹。”</p><p>　　I believe science and technology can bring us a bright future, but the journey to achieve it will be filled with difficulties and exact a price from us. Some of these obstacles and costs will be quite terrible, but in the end we will land on the sunlit further shore. Let me quote the Chinese poet Xu Zhimo from the beginning of the last century, who, after a trip to the Soviet Union, said, “Over there, they believe in the existence of Heaven, but there is a sea of blood that lies between Heaven and Hell, and they’ve decided to cross the sea.”</p><p>　　我深信，科学技术能够给我们带来光明美好的未来，但是实现的过程会充满艰难险阻，我们要为此付出代价。其中有些阻碍非常艰难，有些代价非常高昂，但是我们终将抵达阳光明媚的彼岸。请允许我援引上世纪初中国诗人徐志摩在游历前苏联(Soviet Union)之后写下的诗句：“他们相信天堂是有的，可以实现的，但在现实世界与那天堂的中间隔着一座海，一座血污海，人类泅得过这血海，才能登彼岸，他们决定先实现那血海。”</p><p>　　But to what end? Humanity can’t survive everything; the last volume of the “Three-Body” trilogyis set, in part, during the heat-death of the universe. Liu’s stories see life from two angles, as both a titanic struggle for survival and as a circumscribed exercise in finitude. In my favorite of histories, “The Mountain”—it’s available in English in a short-fiction collection called “The Wandering Earth”—mountain climbing is proposed as a metaphor for this contradiction. “It is the nature of intelligent life to climb mountains,” inter-dimensional alien explorers explain. But the universe is so unknowable that “we are all always at the foot,” and will never reach the peak. In another story, “The Devourer,” a character asks, “What is civilization? Civilization is devouring, ceaselessly eating, endlessly expanding.” But you can’t expand forever; perhaps it would be better, another character suggests, to establish a “self-sufficient, introspective civilization.” At the core of Liu’s sensibility, in short, is a philosophical interest in the problem of limits. How should we react to the inherent limitations of life? Should we push against them or acquiesce?</p><p>　　但是，终点在哪里呢?人类无法保存一切;《三体》三部曲的最后一部中，部分情节设定在宇宙热死亡期间。刘慈欣的故事从两个不同角度来审视生命：一个是为生存而顽强斗争，一个是在界限内受限制的行为。在他所有作品中，我最喜欢的是《山》(The Mountain)——在短篇小说集《流浪地球》中有它的英文译本——此文以登山作为这个矛盾的隐喻。跨纬度的外星探索者解释“登山是智慧生命的本质”。但是宇宙神秘而不可知，以至于“我们总是在山脚下，”且永远也到不了顶峰。在另一个故事《吞食者》中，书中人物问“什么是文明?文明就是吞食，不停地吃啊吃，不停地扩张和膨胀。”但是你不可能永远在扩张，另一个人物建议道，也许建立一个“自给自足的、内省的文明”会更好，另一个人物这样建议。简而言之，一言以蔽之，刘慈欣的理性内核是对极限问题的哲学思考。我们应该如何应对生命固有的局限性?我们应该反抗，还是认命?</p><p>　　“Everything ends,” Liu said, in his e-mail, “and describing what is inevitable should not be viewed as a form of pessimism. Take the example of a romantic tale: ‘The lovers lived happily ever after’ would clearly be viewed as an optimistic story. But if you add a coda—‘A hundred years later,they were both dead’—does that turn the story pessimistic? Only science fiction can go as far as ‘a hundred years later’ at the scale of the universe.”</p><p>　　刘慈欣在邮件中提到：“没什么是永恒的，描述必然性不应当被视为一种悲观主义。就拿爱情故事来说，‘恋人从此幸福快乐地生活在一起’我们当然认为这是一个乐观的故事。但如果你在结尾再加一句——‘百年过后，他们两个都去世了’——难道就变成了一个悲观的故事了吗?只有科幻小说可以描写‘百年之后’的浩瀚宇宙。”</p>]]></content>
    
    
    <summary type="html">just be touched</summary>
    
    
    
    <category term="随便" scheme="http://example.com/categories/%E9%9A%8F%E4%BE%BF/"/>
    
    
  </entry>
  
  <entry>
    <title>UnityShader入门</title>
    <link href="http://example.com/2021/10/10/Unity%20shader/"/>
    <id>http://example.com/2021/10/10/Unity%20shader/</id>
    <published>2021-10-09T16:00:00.000Z</published>
    <updated>2022-06-15T10:39:37.953Z</updated>
    
    <content type="html"><![CDATA[<p>学习shader：</p><ul><li>前提要了解整个渲染流程是如何进行的</li><li>更多是面向GPU的工作方式</li><li>基本知识了解<ul><li>OpenGL ＆ DirectX：两种图像应用编程接口。直接操作硬件是很难受滴，所以为上层应用程序和底层GPU架起了沟通桥梁。</li></ul></li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/9cbbce53043dfae55a4ae7adadff7c54.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><ul><li>着色语言：专门用于编写着色器<ul><li>OpenGL的GLSL：跨平台性，只要显卡驱动支持GLSL的编译就能运行（依赖硬件—取决于硬件供应商）</li><li>DirectX的HLSL：微软平台</li><li>NVIDIA的CG：真正意义上的跨平台；和HLSL非常相像；无法发挥出OpenGL的最新特性</li></ul></li></ul><h1 id="第2章-渲染流水线"><a href="#第2章-渲染流水线" class="headerlink" title="第2章 渲染流水线"></a>第2章 渲染流水线</h1><h2 id="2-1什么是渲染流水线"><a href="#2-1什么是渲染流水线" class="headerlink" title="2.1什么是渲染流水线"></a>2.1什么是渲染流水线</h2><ul><li><p>shader：着色器，是渲染流水线中的一个环节</p></li><li><p>渲染流水线：</p><ul><li>最终目的，由一个三维场景出发，生成或者渲染一张二维纹理图像（通常由CPU和GPU共同完成）</li><li>输入一个虚拟摄像机，光源，shader以及纹理等等</li><li>渲染流程可以分为三个阶段：</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/721d712f2f7ee8657003926b18c91cd9.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><ul><li><strong>应用阶段</strong>：（CPU）开发者主导；准备场景数据、粗粒度剔除工作（剔除不可见物体）、设置好每个模型的渲染状态……【最重要的输出时渲染所需的几何信息，即<u>渲染图元</u>】</li><li>几何阶段：（GPU）用于处理所有 和我们要绘制的 几何相关的 东西。比如需要绘制的图元是什么，怎样绘制，在哪里绘制。【把顶点坐标（每个顶点对应的深度值，着色等相关信息）变换到屏幕空间中，再交给光栅器进行处理】</li><li>光栅化阶段：（GPU）使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。</li></ul></li><li><p>以上是概念流水线。</p></li><li><p>GPU流水线——硬件 真正用于实现上述概念的 流水线</p></li></ul><h2 id="2-2-CPU和GPU之间的通信"><a href="#2-2-CPU和GPU之间的通信" class="headerlink" title="2.2 CPU和GPU之间的通信"></a>2.2 CPU和GPU之间的通信</h2><p>应用阶段：（渲染流水线的起点是CPU）</p><h4 id="把数据加载到显存中"><a href="#把数据加载到显存中" class="headerlink" title="把数据加载到显存中"></a>把数据加载到显存中</h4><ul><li>所有渲染的数据都要从🥰硬盘（HDD）中加载到🥰系统内存（RAM）</li><li>然后，网格和纹理等数据又被加载到【🥰显卡（VRAM）上的存储空间——显存】中（显卡对显存的访问速度更快；大多数显卡对RAM没有直接访问的权利）</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/1f6f715e90046a41a9637631a191c978.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><p>​            两纹理＋三网格</p><ul><li><p>数据加载到显存后，RAM的数据就可以删除了</p><ul><li><p>但有些数据，CPU仍需要（通过RAM？）访问它们，比如访问网格数据进行碰撞检测）；如果重新加载，硬盘加载到RAM的过程是十分耗时的</p></li><li><p>开发者通过CPU来设置渲染状态（不知道和上面这点有何联系？？），“指导”GPU如何进行渲染工作</p><p>🧐总结：硬盘-RAM-显存是数据流通，幕后操控是CPU和GPU，其中GPU只操控显存（大概先这样吧）</p></li></ul></li></ul><h4 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h4><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/716ca7c6a58f624dd44812261c4dd5e7.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><p>​        （同一状态下渲染三个网格）</p><ul><li><p>这些状态定义了场景中的网格是怎样被渲染的（有不同的打扮方式嘛？！）</p><ul><li>做法：使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等【应用阶段？？具体怎么做嘛】</li></ul></li></ul><h4 id="调用Draw-Call"><a href="#调用Draw-Call" class="headerlink" title="调用Draw Call"></a>调用Draw Call</h4><p>在我看来很像画画。大脑就是GPU，把看到的模型光线什么的放在脑海里（素描关系色彩什么的），然后除了传递这些数据给（会画画的大脑部分），还得告诉它要主观加工成什么样（一个渲染规范？目标？）。然后会画画的大脑部分就要开始画画啦（接到指令和资料！</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/4c18f630c7caa3211c8bc011cfc95d8a.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><ul><li><p>附加说明：深入理解CPU和GPU与Draw Call之间的关系</p><ul><li><p>GPU和CPU如何实现并行工作？- 命令缓冲区</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/35344c10842212ea69c28174e89e49d7.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>添加命令和读取命令是独立分开的（小小知识点：改变渲染状态的命令比渲染模型更耗时）</p></blockquote></li><li><p>为什么Draw Call多了会影响帧率？</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/e6aa7f1cbae85ff4ed99efdbb96f41e5.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>GPU渲染能力很强，速度往往快于CPU提交命令的速度；如果操作过多，额外的工作量会过于繁琐，很慢，比不上别人，效率很低。</p></blockquote></li><li><p>如何减少Draw Call？</p><p>这里选取<strong>批处理</strong>的方法。</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/084d5694f465bcd8f245d6234e16e82c.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>打包一次性发送（一个包同一种渲染状态）</p><p>但是打包（在CPU的内存中合并网格）也是消耗时间的。所以批处理更适合静态的物体。动态的话每一帧都要合并，会对空间和时间造成一定影响</p></blockquote><p>so，避免使用大量很小的网格；避免使用过多的材质。</p></li></ul></li></ul><h2 id="2-3GPU流水线"><a href="#2-3GPU流水线" class="headerlink" title="2.3GPU流水线"></a>2.3GPU流水线</h2><ul><li><p>几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，但是GPU向开发者开放了很多控制权👇</p></li><li><p>这两个阶段可以分为更小的流水线阶段；每个阶段GPU提供不同的可配置性（设置每一步的操作细节）或可编程性</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/b8e1a2f6d7a5e52cb3d0e9eeaf356b0e.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>绿色：完全可编程控制</p><p>黄色：可配置不可编程</p><p>蓝色：没有任何控制权</p><p>？实线：该shader必须由开发者编程实现【为什么有蓝色的实线？没有控制权的必须编程实现？】</p><p>？虚线：该shader可选</p><p>各个介绍见4%</p></blockquote></li></ul><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><ul><li><p>接受的顶点数据：（GPU接受的数据）由应用阶段加载到显存中；再由DrawCall指定（再次顺一顺上面学到的）</p></li><li><p>干嘛的：坐标变换和逐顶点光照（就是加颜色？）</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/f11f63aa6d913ccf4465950387392444.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><ul><li>坐标变换</li></ul><p>-改变顶点的位置，在顶点动画中非常有用，水面、布料等。</p><p>最基本的工作：把顶点坐标从模型<strong>空间</strong>转换到齐次裁剪<strong>空间</strong>（区别？）——&gt;由硬件做透视除法——&gt;归一化的设备坐标（NDC）【待深究，首先理解坐标变换大概是什么个意思】</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/5829e63db9281058e493ef933d238602.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>对右边空间的思考：</p><p><img src="https://img-blog.csdn.net/20171016201356967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWQ4ODI4MjI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="&lt;image1&gt;"><img src="https://img-blog.csdn.net/20171016201416205?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWQ4ODI4MjI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="&lt;image2&gt;"></p><p>搜了下资料，这是视锥体，分别是透视投影和正交投影。资料所说，裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。那么相当于把自己的视角看作一个固定范围的空间，然后都投影在这个范围里面。</p><p>这个空间大小似乎有规范大小，如图，坐标范围是OpenGL同时也是Unity使用的NDC，z在【-1，1】之间，而在DirectX中，NDC的z【0，1】</p></blockquote></li><li><p>光照相互独立性：本身不可以创建或者销毁任何顶点+获得顶点之间的联系——GPU可以利用本身的特性并行优化处理每一个顶点，处理速度会很快</p></li></ul><h4 id="曲面细分着色器"><a href="#曲面细分着色器" class="headerlink" title="曲面细分着色器"></a>曲面细分着色器</h4><ul><li>可选</li><li>用于细分图元（之前提到的渲染图元？到底有什么数据长什么样？）</li></ul><h4 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h4><ul><li>可选</li><li><u>逐图元</u>【是一个啥东西？】的着色操作，或者被用于产生更多的图元</li></ul><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><ul><li><p>可配置</p></li><li><p>目的：不在摄像机视野范围内的物体不需要被处理</p></li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/e9c4a625643a99425c64f1a195b59c94.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>立方体范围内，图元保留、舍弃、裁剪（生成新的点）；这里还是立方体哇！😎</p></blockquote><h4 id="屏幕映射Screen-Mapping（二维）"><a href="#屏幕映射Screen-Mapping（二维）" class="headerlink" title="屏幕映射Screen Mapping（二维）"></a>屏幕映射Screen Mapping（二维）</h4><ul><li><p>三维坐标数据因为已经由NDC规定好了，但是屏幕的大小/分辨率又会有不同，那么怎么做适配呢？</p></li><li><p>每个图元的x和y坐标转换到屏幕坐标系👇</p></li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/541c691775294b2af9f32af727505ea2.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>🧐所以是有缩放的效果了……可能有点变形？还有z坐标直接被剔去了？前后关系怎么表示咧</p></blockquote><ul><li><p>不会对输入的z坐标做任何处理。屏幕坐标系和z坐标【还在啊…？】一起构成了一个坐标系——&gt;<strong>窗口坐标系</strong>（Window Coordinates），这些值会一起被传递到光栅化阶段</p></li><li><p>然鹅屏幕坐标系对于OpenGL和DirectX仍有所区别，起始点不同（反正要考虑这种差异可能会导致效果倒转）</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/b4ff49d945948ea577003130621b6da9.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p></li></ul><hr><p>顶点已经在二维屏幕集结好啦！还附带了一些信息（深度值z值（原来是它吖，法线方向（见了好多次到底是咋样，视角方向等）可以开始进一步打扮了。👇光栅化阶段：点与点之间覆盖的范围和颜色👇</p><h4 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h4><ul><li>干嘛：计算光栅化一个三角网格所需的信息</li><li>三角网格怎么组成的？三角形的点知道了，那么用多少行多少列表示啊？得整个<strong>三角网格表示数据</strong>哇</li></ul><h4 id="三角形遍历（扫描变换）"><a href="#三角形遍历（扫描变换）" class="headerlink" title="三角形遍历（扫描变换）"></a>三角形遍历（扫描变换）</h4><ul><li>🦁<strong>检查</strong>每个像素是否被一个三角网格覆盖——&gt;覆盖，生成一个片元。网格好了，边范围也知道了，开始填填乐呗</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/5990d470b57bfcdca705c250ed5b45df.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>生成像素，对应像素生成一个<strong>片元</strong>（并不是真正意义上的像素，是包含<u>很多状态的集合</u>，这些状态用于计算每个像素的最终颜色）。整个输出<strong>片元序列</strong>。</p><p><strong>片元的状态</strong>是对三个顶点的信息进行<strong>插值</strong>【这又是什么哇？】得到。状态比如有屏幕坐标，深度信息，法线，纹理坐标等等</p><p>总结：填填乐怎么得来？插值？填的计算方法嘛？而且不是颜色，是生成片元的状态。</p></blockquote><h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><ul><li><u>以上阶段</u>实际上不影响像素的颜色值，而是产生一系列的数据信息（一个三角网络是怎样覆盖每个像素的）</li><li><u>每个片元</u>负责存储这样一系列数据。</li><li>片元着色器的输入输出（欧，就先想象是每个顶点带着自己的捆绑包经历千辛万苦坐火车做安检什么的，终于在片元着色器完成了资源的计算完成了修炼，完成华丽的蜕变/有了该片元的输出颜色…）</li></ul><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/52837b327f33ad1730daba41dc3ad66c.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>输入：上一个阶段对顶点信息插值得到的结果（片元带）</p><p>输出：一个或多个颜色值</p></blockquote><ul><li><p>补充：纹！理！采！样！？（片元着色器中）</p><ul><li><p>纹理坐标：从顶点着色器阶段输出每个点对应的纹理坐标（怎么来好像没稀奇，所以到底是啥</p><p>​                    ——插值——顶点们覆盖的片元的纹理坐标（就是顶点包裹里面的一个东西嘛，所以是啥？!</p></li></ul></li><li><p>局限：仅可以影响单个片元</p></li></ul><h4 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h4><ul><li><p>高度可配置性</p></li><li><p>任务：</p><ol><li><p>决定每个片元的可见性，涉及很多测试操作（测试？从种种角度来看能不能可见吧）</p></li><li><p>若一个片元通过了所有测试，其颜色值+已经存储在颜色缓冲区中的颜色（好的已经可见啦，就得有颜色来展示；相当于投了简历，即使到了最后一面被刷到也还是没有offer啊！！！）</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/a6ffc86900aa747f898d07a55c729193.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>颜色缓冲区？为啥会有这个。怎么混合啊</p><ul><li>像素的颜色信息被存储在名为颜色缓冲的地方</li><li>往往有上次渲染之后的颜色结果</li><li>so，是覆盖呢，还是进行其它处理?</li></ul></blockquote><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/0428aea75587eb49eaaafb64d6bf043f.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>这个是其中两个测试的具体过程，嗯，跳过！</p><p>回来了。原理关键是矩形内容。深度这个，透明度或许有解答</p></blockquote></li></ol></li><li><p>混合！</p><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/1afda4956ed174150b5324174c29d126.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p><blockquote><p>不透明物体：<strong>开发者</strong>可以关闭混合条件。源颜色会覆盖掉颜色缓冲区的像素值</p><p>半透明：混合操作。</p></blockquote></li><li><p>测试顺序：对于大多数GPU来说，尽可能在片元着色器之前进行这些测试，为了节省力气（直接把简历筛下去的意思嘛？！</p></li><li><p>提前的话可能会有些冲突；性能下降（GPU判断提前测试是否有冲突，此时会有更多的片元需要被处理</p></li><li><p>显示到屏幕上之后，GPU会双重缓冲。后置缓冲：对场景的渲染是在幕后发生，前置缓冲：之前显示在屏幕中的图像。两者交换以保证图像连续。</p></li></ul><hr><p>（气喘吁吁🙃）</p><p>大概了解了整个渲染流程，而shader所在阶段就是渲染流水线的一部分，所以shader就是：</p><ul><li>GPU流水线上一些可高度编程的阶段</li></ul><h1 id="第3章-Unity-Shader基础"><a href="#第3章-Unity-Shader基础" class="headerlink" title="第3章 Unity Shader基础"></a>第3章 Unity Shader基础</h1><p>对一些操作进行了封装，方便更好地编程和设置</p><h2 id="Unity-Shader概述"><a href="#Unity-Shader概述" class="headerlink" title="Unity Shader概述"></a>Unity Shader概述</h2><h3 id="材质和Unity-Shader"><a href="#材质和Unity-Shader" class="headerlink" title="材质和Unity Shader"></a>材质和Unity Shader</h3><p>没有细读这本书之前，按照一贯的操作思路，就是先弄一个shader，然后根据它创建一个材质，这样效果就能赋给模型了。为什么shader和材质会产生这种割裂，还有联系?</p><p>Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等），而😏<strong>材质则允许我们调节这些属性</strong>，<strong>并将其最终赋给相应的模型</strong>。</p><h3 id="Unity中的材质"><a href="#Unity中的材质" class="headerlink" title="Unity中的材质"></a>Unity中的材质</h3><p>有面板可更改数值</p><h3 id="Unity中的Shader"><a href="#Unity中的Shader" class="headerlink" title="Unity中的Shader"></a>Unity中的Shader</h3><ul><li>Standard Surface Shader：会产生一个包含了标准光照模型的<u>表面着色器</u>（啥玩意，没见过）模板</li><li>Unlit Shader：不包含光照（但包含雾效）的基本的顶点/片元着色器</li><li>Image Effect Shader：为屏幕后处理效果提供模板</li><li>Compute Shader：（略</li></ul><blockquote><p>这些基本的理解，或许在其它的shader插件或者什么中有共性</p></blockquote><ul><li>可以在shader面板中查看各种东西，是否为Surface shader啊，Fixed function啊，等等，有需要我再细看吧</li></ul><h2 id="Unity-Shader的基础：ShaderLab"><a href="#Unity-Shader的基础：ShaderLab" class="headerlink" title="Unity Shader的基础：ShaderLab"></a>Unity Shader的基础：ShaderLab</h2><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/4b9a50ca2993153f23d86a7786580f3e.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p><blockquote><p>　Unity Shader为控制渲染过程提供了一层抽象。如果没有使用UnityShader（左图），开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果；而在Unity Shader的帮助下（右图），开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作</p></blockquote><ul><li>ShaderLab: 是Unity提供的编写Unity Shader的一种说明性语言</li><li>一个Unity Shader的基础结构如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot; &#123;    </span><br><span class="line">Properties &#123;        </span><br><span class="line">// 属性</span><br><span class="line">    &#125;    </span><br><span class="line">    SubShader &#123;        </span><br><span class="line">    // 显卡A使用的子着色器</span><br><span class="line">    &#125;    </span><br><span class="line">    SubShader &#123;        </span><br><span class="line">    // 显卡B使用的子着色器</span><br><span class="line">    &#125;        </span><br><span class="line">    Fallback &quot;VertexLit&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="Unity-Shader的结构"><a href="#Unity-Shader的结构" class="headerlink" title="Unity Shader的结构"></a>Unity Shader的结构</h2><p>上节见到了一些ShaderLab的语义，如Properties、SubShader、Fallback等。这些语义定义了Unity Shader的结构，从而帮助Unity分析该Unity Shader文件，以便进行正确的编译。</p><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h3 id="材质和Unity-Shader-的桥梁：Properties（属性）"><a href="#材质和Unity-Shader-的桥梁：Properties（属性）" class="headerlink" title="材质和Unity Shader 的桥梁：Properties（属性）"></a>材质和Unity Shader 的桥梁：Properties（属性）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;    </span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue    </span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue    // 更多属性</span><br><span class="line">&#125;</span><br><span class="line">//比如 _int (&quot;Int&quot;, Int) = 2;</span><br><span class="line">//在Shader中访问属性， 通过Name，通常由一个下划线开始</span><br><span class="line">//显示的名称display name则是出现在材质面板上的名字</span><br><span class="line">//指定类型 PropertyType</span><br><span class="line">//默认值</span><br><span class="line"></span><br><span class="line">//虽然不是C#但为了代码染色</span><br></pre></td></tr></table></figure><ul><li><p>数字类型的属性</p></li><li><p>Color， Vector（1，2，3，4）</p></li><li><p>2D，Cube，3D “”{}  </p><blockquote><p>具体怎么填详情看书，不知道现在还通用不</p></blockquote></li><li><p>还能重载默认的材质面板</p></li></ul><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><ul><li><p>数量要求：每个Unity Shader文件可以包含多个SubShader语义块，最少要一个</p></li><li><p>运行机制：当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader。如果都不支持的话，Unity就会使用Fallback语义指定的UnityShader。</p><blockquote><p>原因：不同的显卡具有不同的能力。例如，一些旧的显卡仅能支持一定数目的操作指令，而一些更高级的显卡可以支持更多的指令数，那么我们希望在旧的显卡上使用计算复杂度较低的着色器，而在高级的显卡上使用计算复杂度较高的着色器，以便提供更出色的画面。【可选择，确实挺照顾玩家的，所以游戏会有最低配置最高配置？】</p></blockquote></li><li><p>```c#<br>SubShader {    </p><pre><code>// 可选的“标签”[Tags]    // 可选的“状态”[RenderSetup]    Pass &#123;    &#125;    // Other Passes</code></pre><p>}<br>//每个pass定义了一次完整的渲染流程；但数目过多会造成渲染性能的下降</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 👉状态设置👈</span><br><span class="line"></span><br><span class="line">  ShaderLab提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等（首先渲染状态是什么玩意儿？都看不懂，希望后面有实例说明）</span><br><span class="line"></span><br><span class="line">  - 当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。如果我们不想这样可以在Pass语义块中单独进行上面的设置。</span><br><span class="line"></span><br><span class="line">* 👉标签👈</span><br><span class="line"></span><br><span class="line">  是一个键值对，键和值都是字符串类型；这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：我希望&lt;u&gt;怎样以及何时渲染这个对象&lt;/u&gt;。</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  Tags &#123; </span><br><span class="line">      &quot;TagName1&quot; =&quot;Value1&quot; </span><br><span class="line">      &quot;TagName2&quot; =&quot;Value2&quot; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>巴拉巴拉详细举例和介绍等等，有用到就细看。</p><p><img src="/2021/10/10/Unity%20shader/hexo_github_blog\source_posts\pic\image-20220426193126888.png" alt="image-20220426193126888"></p><ul><li>仅可以在SubShader中声明，不可以在Pass块声明</li></ul></li><li><p>👉Pass语义块👈</p><ul><li>```c#<br>Pass{<pre><code>[Name]             //Name &quot;MyPassName&quot;[Tags][RenderSetup]//other code</code></pre>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; * 名称：通过名称，可以使用ShaderLab的UsePass命令来直接使用其它Unity Shader中的Pass。例如：</span><br><span class="line">&gt;</span><br><span class="line">&gt;   ```c#</span><br><span class="line">&gt;   UsePass &quot;MyShader/MYPASSNAME&quot;</span><br><span class="line">&gt;   //这样提高代码的复用性。Unity内部会把所有的Pass名称转换成大写字母</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>渲染状态：SubShader的状态设置同样适用于Pass；还能使用固定管线的着色器命令。</p></li><li><p>标签：不同于SubShader标签。用于告诉渲染引擎希望怎样来渲染物体</p></li></ul><p>（例子见9%）</p></blockquote></li></ul></li><li><p>Fallback</p><p>下下策：最低级的Unity Shader</p><p>还会影响阴影的投射</p></li></ul><h2 id="Unity-Shader的形式"><a href="#Unity-Shader的形式" class="headerlink" title="Unity Shader的形式"></a>Unity Shader的形式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;        </span><br><span class="line">    // 所需的各种属性</span><br><span class="line">    &#125;    </span><br><span class="line">SubShader &#123;        </span><br><span class="line">    // 真正意义上的Shader代码会出现在这里</span><br><span class="line">    // 表面着色器（Surface Shader）或者</span><br><span class="line">    // 顶点/片元着色器（Vertex/Fragment Shader）或者</span><br><span class="line">    // 固定函数着色器（Fixed Function Shader）</span><br><span class="line">    &#125;    </span><br><span class="line">SubShader &#123;        </span><br><span class="line">    // 和上一个SubShader类似</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unity的宠儿：表面着色器"><a href="#Unity的宠儿：表面着色器" class="headerlink" title="Unity的宠儿：表面着色器"></a>Unity的宠儿：表面着色器</h3><ul><li>Unity自己创造的一种着色器代码类型</li><li>所需代码量少，Unity在背后做了很多工作，但渲染的代价比较大</li><li>本质和其它着色器一样/ 是它们的更高抽象</li><li>unity为我们处理了很多光照细节</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot; &#123;</span><br><span class="line">    //在SubShader语句块里面（而非Pass语句块里面）</span><br><span class="line">    SubShader &#123;        </span><br><span class="line">        Tags &#123; &quot;RenderType&quot; =&quot;Opaque&quot; &#125;</span><br><span class="line">        CGPROGRAM/**/        </span><br><span class="line">        #pragma surface surf Lambert        </span><br><span class="line">        struct Input &#123;            </span><br><span class="line">            float4 color : COLOR;        </span><br><span class="line">        &#125;;        </span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o) &#123;            </span><br><span class="line">            o.Albedo =1;        </span><br><span class="line">        &#125;        </span><br><span class="line">        ENDCG/**/    </span><br><span class="line">    &#125;    </span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不需要开发者关心使用多少个Pass、每个Pass如何渲染等问题，Unity会处理</span><br><span class="line">//CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的，也就是说，我们需要把Cg/HLSL语言嵌套在ShaderLab语言中。值得注意的是，这里的Cg/HLSL是Unity经封装后提供的，它的语法和标准的Cg/HLSL语法几乎一样，但还是有细微的不同，例如有些原生的函数和用法Unity并没有提供支持</span><br></pre></td></tr></table></figure><h3 id="最聪明：顶点-片元着色器"><a href="#最聪明：顶点-片元着色器" class="headerlink" title="最聪明：顶点/片元着色器"></a>最聪明：顶点/片元着色器</h3><ul><li><p>在Unity中我们可以使用Cg/HLSL语言来编写顶点/片元着色器（Vertex/FragmentShader）</p></li><li><p>更加复杂，灵活性也更高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple VertexFragment Shader&quot; &#123;</span><br><span class="line">    SubShader &#123;  </span><br><span class="line">        //Pass语义块里面</span><br><span class="line">        Pass &#123;            </span><br><span class="line">        CGPROGRAM            </span><br><span class="line">        #pragma vertex vert            </span><br><span class="line">        #pragma fragment frag            </span><br><span class="line">         float4 vert(float4 v : POSITION) :SV_POSITION &#123;                return mul (UNITY_MATRIX_MVP, v);            </span><br><span class="line">            &#125;            </span><br><span class="line">            fixed4 frag() : SV_Target &#123;                </span><br><span class="line">                return fixed4(1.0, 0.0, 0.0, 1.0);            </span><br><span class="line">            &#125;            </span><br><span class="line">            ENDCG        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="被抛弃：固定函数着色器"><a href="#被抛弃：固定函数着色器" class="headerlink" title="被抛弃：固定函数着色器"></a>被抛弃：固定函数着色器</h3><ul><li>上面两种unity shader都用了可编程管线。</li><li>这个不可编程，效果简单，用在旧设备</li></ul><h3 id="Unity-Shader形式的选择"><a href="#Unity-Shader形式的选择" class="headerlink" title="Unity Shader形式的选择"></a>Unity Shader形式的选择</h3><ul><li>和各种光源打交道：表面着色器；移动平台性能可能欠佳</li><li>光照数目非常少，顶点/片元着色器</li></ul>]]></content>
    
    
    <summary type="html">learn sth</summary>
    
    
    
    <category term="shader" scheme="http://example.com/categories/shader/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2021/08/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2021/08/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-08-29T16:00:00.000Z</published>
    <updated>2021-08-30T07:42:39.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>首先甩上dp“见面礼”：53/0801</p><p>初识算法的我自然是懵逼的很，但不妨了解一下</p><p>现在在看17.16，非常困想睡觉，在这假装在认真思考。</p><h2 id="第一步：设计状态"><a href="#第一步：设计状态" class="headerlink" title="第一步：设计状态"></a>第一步：设计状态</h2><ul><li>状态转移：才明白大概是什么意思，例如最大子序列和中，从结果来看，每个数都可能是最大子序列的最后一项，而这个数之前的最大和和它本身就决定了两种情况只能取其一：要么是选之前最大和加它本身/本身作为新子序列第一项（后者更大的话因为最大和削减了本身的数）。</li></ul><p>那么这道题的状态转移是什么呢？不知头尾，不知长度，从头开始只能穷举，从尾开始也和头差不多，都是无法得知“积累的已知小问题答案”。【思路是根据53比较得来的】</p><p>——状态依赖？大概是某个状态是依赖某种相关的之前的状态的。</p><p>比如53，最大子序列和的完成是由末尾数及其前max决定的（产生了两种情况，见上）。</p><p>而这道题中，唯一明显的状态依赖就是当前这一天，按摩师有两种选择：（1）接预约（2）不接预约，这两种情况受到昨天影响。</p><p>——怎么表示呢？从上讨论可知无论是从头还是从尾都无法控制确定最优解</p><ul><li>无后效性：1.后面的决策不影响前面的决策  2.之前的状态怎么来的并不重要。那么为了后效性（控制确定最优解），增加一个维度，即把预约和不预约都考虑进去，定义dp[i] [0]和dp[i] [1]分别表示不接受/接受，而区间[0..i]表示接受预约请求（</li></ul><p>——一般的情况是，只要有约束，就可以增加一个维度消除这种约束带来的影响…（?</p><h2 id="第二步：状态转移方程"><a href="#第二步：状态转移方程" class="headerlink" title="第二步：状态转移方程"></a>第二步：状态转移方程</h2><ul><li>有人说可以理解为”不同阶段之间的联系“</li></ul><p><u>今天</u>只和<u>昨天</u>的状态有关：</p><ul><li>今天不接受预约：可能是昨天不受预约或者昨天接受了预约，取二者最大值，即dp[i] [0] = max(dp[i - 1] [0] , dp[i - 1] [1]) ;</li><li>今天接受预约：只能是昨天不接受预约，加上今天的时长，即：dp[i] [1] = dp[i - 1] [0] + nums[i]</li></ul><h2 id="第三步：考虑初始化"><a href="#第三步：考虑初始化" class="headerlink" title="第三步：考虑初始化"></a>第三步：考虑初始化</h2><p>从第2天开始，每天的状态值只与前一天有关，所以第1天：dp[0] [0] = 0 // dp[0] [1] = nums[0] ;</p><p>#第四步：考虑输出</p><ul><li>前缀性：当前的状态考虑了之前的相关的状态值</li></ul><p>由于状态值的定义既有前缀性质又无后效性，因此最后一天的状态值就考虑了之前所有的天数的情况。按摩师最后一天可以接受或者不接受预约，取两者最大值。</p><h2 id="第五步：考虑是否可以优化空间"><a href="#第五步：考虑是否可以优化空间" class="headerlink" title="第五步：考虑是否可以优化空间"></a>第五步：考虑是否可以优化空间</h2><hr><p>根据上面提示进行敲代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//特殊情况 或者 不在循环（包含return）考虑范围内</span></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//第一天不预约</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];<span class="comment">//第一天预约</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">            sum = Math.max(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">dp</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android基本布局</title>
    <link href="http://example.com/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/</id>
    <published>2021-08-14T16:00:00.000Z</published>
    <updated>2021-10-23T08:07:02.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Android基本布局"><a href="#一、Android基本布局" class="headerlink" title="一、Android基本布局"></a>一、Android基本布局</h1><p>　　布局是一种可以放置多个控件的容器，它可以按照一定规律调整内部控件的位置，而且布局内部除了可以放置控件外，还可以放置布局，实现多层布局嵌套。布局和控件、布局和布局之间的关系如下图所示：</p><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\image-20210801155718907.png" alt="image-20210801155718907"></p><h1 id="二、线性布局（LinearLayout）"><a href="#二、线性布局（LinearLayout）" class="headerlink" title="二、线性布局（LinearLayout）"></a>二、线性布局（LinearLayout）</h1><p>　　<strong>1</strong>、LinearLayout布局是一种非常常用的布局文件，它内部所包含的控件在线性方向上依次排列。线性方向有水平和垂直两种，通过android：orientation属性来指定线性排列方向，可选值有两种：horizontal（控件在水平方向排列）、vertical（控件在垂直方向排列），默认排列方式是水平排列</p><p>接下来通过代码来直观感受一下：</p><p>第一步：创建三个按钮：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;first button&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/second_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;second button&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/third_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;third button&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>第二步：运行程序，效果如下（左），如果将android：orientation的值选为horizontal（水平），效果如下（右）</p><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\image-20210801160722025.png" alt="image-20210801160722025"></p><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\image-20210801160823903.png" alt="image-20210801160823903"></p><p><strong>注意：</strong></p><p>　　如果LinearLayout的排列方向是：horizontal（水平），那么其内部的控件就绝对不能将宽度指定为：match_parent（与父布局一样宽），因为这样的话，单独一个控件就会将整个水平方向占满，其他的控件就没有可以放置的位置了。同理，如果LinearLayout的排列方向是：vertical（垂直），那么内部控件的高度就绝对不能指定为：match_parent</p><p><strong>2</strong>、<strong>android：layout_gravity属性与android：gravity属性</strong></p><p>　  android：layout_gravity属性：用于指定<u>控件</u>在布局中的对齐方式</p><p>　  android：gravity属性：用于指定<u>文字</u>在控件中的对齐方式</p><p>注意：</p><p>　　使用android：layout_gravity属性时，如果LinearLayout的排列方向是：horizontal（水平方向）时，只有垂直方向上的对齐方式才会生效，因为水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会变，无法指定该方向上的对齐方式。同理，如果LinearLayout的排列方向是：vertical（垂直方向），那么只有水平方向的对齐方式有效。</p><p>下面通过代码来感受一下：</p><p>第一步：在activity_main.xml中指定：LinearLayout布局的排列方向为：horizontal（水平方向），first button对齐方式为：top，second button对齐方式为：center_vertical，third button对齐方式为：bottom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;horizontal&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;top&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;first button&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/second_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;center_vertical&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;second button&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/third_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;bottom&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;third button&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>第二步：运行程序，效果如下：</p><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\image-20210801161943925.png" alt="image-20210801161943925"></p><p><strong>3</strong>、android：layout_weight属性：这是一个很重要的属性，它允许我们使用比例的方式来指定控件的大小，在手机屏幕的适配性方面起到非常重要的作用。</p><p>我们先来看一下代码和效果：编写一个消息发送界面（一个文本编辑框，一个发送按钮）</p><p>第一步：在布局中添加一个文本编辑框和发送按钮</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;horizontal&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;EditText</span><br><span class="line">        android:id=<span class="string">&quot;@+id/eidt_text&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_weight=<span class="string">&quot;4&quot;</span></span><br><span class="line">        android:hint=<span class="string">&quot;Type something&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/edit_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;0dp&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_weight=<span class="string">&quot;1&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;发送&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>第二步：效果展示：</p><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\image-20210801162639288.png" alt="image-20210801162639288"></p><p><strong>代码分析：</strong></p><p>　　1、代码中将EditText控件和Button控件的宽度都指定为0dp，然后使用了android：layout_weight属性，此时，控件的宽度就由android：layout_weight属性来控制了</p><p>　　2、系统是通过控件中android：layout_weight的值来分配屏幕宽度的，计算方法是：先把每个控件中layout_weight的值相加，得到一个总值，然后根据每个控件的值除以总值得到所占的比例。比如上面EditText控件所占的屏幕宽度为：4/(1+4)=4/5，同样，Button所占屏幕宽度即为：1/5.</p><p><strong>拓展：</strong></p><p>　　其实对于上面的代码我们还可以进行优化：将Button控件的宽度改回：wrap_content，这时，Button的宽度依然按wrap_content来计算，而EditText控件就会占据屏幕剩下的所有空间，使用这种方式编辑界面，不仅在各种屏幕的适配方面会非常好，而且看起来也更加舒服。</p><h1 id="三、相对布局（RelativeLayout）"><a href="#三、相对布局（RelativeLayout）" class="headerlink" title="三、相对布局（RelativeLayout）"></a>三、相对布局（RelativeLayout）</h1><p>　　RelativeLayout布局也是一种非常常用的布局。和LinearLayout的排列方式不同，RelativeLayout显得更加随意，它可以通过相对定位的方式让控件出现在布局的任何位置，也正因为如此，RelativeLayout中的属性非常的多，不过这些属性都是有规律可循的。</p><p>先看代码和效果：</p><p>第一步：在RelativeLayout布局中加入五个Button，分别位于左上角、右上角、布局中间、左下角、右下角</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_alignParentLeft=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:layout_alignParentTop=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;first button&quot;</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/second_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_alignParentRight=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:layout_alignParentTop=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;second button&quot;</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/third_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_centerInParent=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;third button&quot;</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/four_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_alignParentLeft=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;four button&quot;</span> /&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/five_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_alignParentRight=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:layout_alignParentBottom=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;five button&quot;</span>/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\image-20210801163026688.png" alt="image-20210801163026688"></p><p><strong>代码分析：</strong></p><p>　　layout_alignParent<strong>Left</strong>、Layout_aligntParent<strong>Top</strong>：控件位于父布局的左上角</p><p>　　layout_alignParent<strong>Right</strong>、Layout_aligntParent<strong>Top</strong>：控件位于父布局的右上角</p><p>　　layout_alignParent<strong>Left</strong>、Layout_aligntParent<strong>Bottom</strong>：控件位于父布局的左下角</p><p>　　layout_alignParent<strong>Right</strong>、Layout_aligntParent<strong>Bottom</strong>：控件位于父布局的右下角</p><p>　　Layout_centerInParent：控件位于父布局的中心</p><p><strong>拓展：</strong></p><p>　　上面的控件都是相对于布局进行定位的，其实在RelativeLayout布局中，控件也可以相对于控件进行定位，下面是代码和效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_centerInParent=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;first button&quot;</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/second_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_above=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;second button&quot;</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/third_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_above=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;third button&quot;</span>/&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/four_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_below=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;four button&quot;</span> /&gt;</span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/five_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_below=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:layout_toRightOf=<span class="string">&quot;@id/first_button&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;five button&quot;</span>/&gt;</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\1505274-20181113084019327-1019670695.png" alt="1505274-20181113084019327-1019670695"></p><p><strong>代码分析：</strong></p><p>　　android：layout_above属性：一个控件位于另一个控件的上方</p><p>　　android：layout_below属性：一个控件位于另一个控件的下方</p><p>　　android：layout_toLfetOf属性：一个控件位于另一个控件的左边</p><p>　　android：layout_toRightOf属性：一个控件位于另一个控件的右边</p><p>除此之外，还有另外一组<u>相对于控件定位</u>的属性：</p><p>　　android：layout_aligntLeft属性：一个控件的左边缘与另外一个控件的左边缘对齐</p><p>　　android：layout_aligntRight属性：一个控件的右边缘与另外一个控件的右边缘对齐</p><p>　　android：layout_aligntTop属性：一个控件的上边缘与另外一个控件的上边缘对齐</p><p>　　android：layout_aligntBottom属性：一个控件的下边缘与另外一个控件的下边缘对齐</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_centerInParent=<span class="string">&quot;true&quot;</span></span><br><span class="line">        android:hint=<span class="string">&quot;Type something&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/second_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_alignTop=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:layout_toLeftOf=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;发送&quot;</span>/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Button</span><br><span class="line">        android:id=<span class="string">&quot;@+id/third_button&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">        android:layout_above=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:layout_alignRight=<span class="string">&quot;@+id/first_button&quot;</span></span><br><span class="line">        android:text=<span class="string">&quot;third button&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><p><img src="/2021/08/15/Android%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/hexo_github_blog\source_posts\pic\1505274-20181113111700051-1088220877.png" alt="1505274-20181113111700051-1088220877"></p>]]></content>
    
    
    <summary type="html">layout</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Java线程初学（一）</title>
    <link href="http://example.com/2021/07/24/Java%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2021/07/24/Java%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-07-23T16:00:00.000Z</published>
    <updated>2022-04-09T11:41:53.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h3><p><strong>进程</strong>：理解——操作系统中的多任务，即在同一刻运行多个程序的能力——操作系统将CPU的时间片分配给每一份线程</p><p><strong>线程：</strong>一个程序可以执行多个任务。每一个任务叫做线程（线程控制）。可以同时运行一个以上线程的程序——多线程程序。</p><p><strong>两者区别</strong>：每个进程有<u>自己的</u>一整套变量，线程共享数据（共享，优：一种任务分步执行？劣：非法读取并更改？）。共享变量使线程之间的通信比进程之间的通信更有效，更容易；</p><h2 id="14-1-什么是线程"><a href="#14-1-什么是线程" class="headerlink" title="14.1 什么是线程"></a>14.1 什么是线程</h2><p>举例：球的无法停止。用户不愿意用这种方式完成十分耗时的程序，比如停止加载正在下载的图片而不是等它下完。</p><h3 id="14-1-1-使用线程给其它任务提供机会"><a href="#14-1-1-使用线程给其它任务提供机会" class="headerlink" title="14.1.1 使用线程给其它任务提供机会"></a>14.1.1 使用线程给其它任务提供机会</h3><ul><li>开启线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.用实现Runnable接口的类的实例，其中任务代码在接口的run方法中。</span></span><br><span class="line"><span class="comment">//2.或者用lambda表达式建立一个实例：</span></span><br><span class="line">Runnable r = ()-&gt;&#123;</span><br><span class="line">    <span class="comment">//任务代码</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Thread.sleep(DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.start();</span><br><span class="line"><span class="comment">//3.也可以构建Thread类的子类定义一个线程（但这个方法不再被推荐，可以帮助理解）</span></span><br><span class="line"><span class="comment">//Thread线程对应运行任务，Runnable对应运行机制，应该对两者解耦合。（假设分别对应路和车？）如果有很多任务，要为每个任务创建一个独立的线程多付出的代价太大了。可以使用线程池来解决问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//task code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后构建一个子类的对象，并调用start方法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//警告：不要调用Thread类或Runnable对象的run方法。直接调用run方法，只会执行同一个线程中的任务， 而不会启动新线程。应该调用 Thread.start 方法。这个方法将创建一个执行 run 方法的新线程。</span></span><br></pre></td></tr></table></figure><ul><li>方法总结<ul><li>java.lang.Thread</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread(Runnable target)</span><br><span class="line"><span class="comment">//构造一个新线程， 用于调用给定目标的 run() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//启动这个线程， 将引发调用 run() 方法。这个方法将立即返回， 并且新线程将并发运行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//调用关联的Runnable的run方法</span></span></span><br></pre></td></tr></table></figure><ul><li>java.lang.Runnable</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//必须覆盖这个方法， 并在这个方法中提供所要执行的任务指令</span></span></span><br></pre></td></tr></table></figure><h2 id="14-2中断线程"><a href="#14-2中断线程" class="headerlink" title="14.2中断线程"></a>14.2中断线程</h2><ul><li><p>线程终止的情况</p><ul><li>线程的run方法执行方法体中的最后一条语句后，并经由执行 return 语句返回时</li><li>出现了在方法中没有捕获的异常时</li></ul></li><li><p>没有可以强制线程终止的方法。然而，interrupt 方法可以用来<strong>请求终止线程</strong></p><blockquote><p>每个线程具有是否中断线程的boolean状态(检测是否应该中断而不是强制中断)</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Thread.currentThread().islnterrupted() &amp;&amp; more work to <span class="keyword">do</span>) &#123;</span><br><span class="line"><span class="comment">//do more work</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread.currentThread()获得当前线程</span></span><br></pre></td></tr></table></figure><ul><li><p>如果线程被阻塞,就无法检测中断状态.这就是产生InterruptedException异常的地方.例如:阻塞时（sleep或wait）用此方法时，阻塞调用会被那个异常中断。</p></li><li><p>被中断的线程：</p><ul><li><p>中断一个线程为的是引起它的注意（？，被中断的线程可以决定如何响应中断。</p></li><li><p>更普遍的状况是，线程将简单地将中断作为一个终止的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//被中断的时候做的事</span></span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()&amp;&amp;...)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cleanup,ifrequired</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//先判断线程是否被中断，再写run方法？  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是当在每次工作迭代之后都调用sleep方法，检测中断就没有用，反而会清除阻塞状态。应该改为：</span></span><br><span class="line">Runnable r = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">while</span>(more work to <span class="keyword">do</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> more work</span><br><span class="line">            Thread.sleep(delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InterruptedException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//thread was interrupted during sleep</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cleanup,if required</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//exiting the run method terminates the thread</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="14-3-线程状态"><a href="#14-3-线程状态" class="headerlink" title="14.3 线程状态"></a>14.3 线程状态</h2><h3 id="1-新创建线程（New）"><a href="#1-新创建线程（New）" class="headerlink" title="1.新创建线程（New）"></a>1.新创建线程（New）</h3><p>还未开始运行</p><h3 id="2-可运行线程（Runnable）"><a href="#2-可运行线程（Runnable）" class="headerlink" title="2.可运行线程（Runnable）"></a>2.可运行线程（Runnable）</h3><ul><li>一旦调用start方法，线程处于runnable状态</li><li>一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供的运行时间</li><li>一旦一个线程开始运行，它不必始终保持运行。运行中的线程被中断，目的是为了让其它线程获得运行机会</li><li><u>线程调度</u>的细节依赖于操作系统提供的服务。<u>抢占式调度系统</u>给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权， 并给另一个线程运行机会。当选择下一个线程时， 操作系统考虑线程的优先级。现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用<u>协作式调度</u>。在这样的设备中，一个线程只有在调用 <strong>yield</strong> 方法、 或者被阻塞或等待时，线程才失去控制权。</li></ul><h3 id="3-被阻塞线程和等待线程（Blocked）"><a href="#3-被阻塞线程和等待线程（Blocked）" class="headerlink" title="3.被阻塞线程和等待线程（Blocked）"></a>3.被阻塞线程和等待线程（Blocked）</h3><blockquote><p>当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源。直到线程调度器重新激活它。细节取决于它是<u>怎样达到非活动状态</u>的。</p></blockquote><ul><li>阻塞：一个线程试图获取一个内部的对象🔒（被其它线程持有），则线程进入阻塞状态。所有其他线程释放该🔒＋线程调度器允许本线程持有它时，该线程变成非阻塞状态。</li><li>等待：当线程等待  另一个线程通知调度器一个条件时（14.5.4）</li><li>计时等待状态：有几个方法有一个超时参数。状态保持到超时期满或者接收到适当的通知。带有超时参数的方法有<strong>Thread</strong>.<strong>sleep</strong> 和 <strong>Object</strong>.<strong>wait</strong>、<strong>Thread</strong>.<strong>join</strong>、 <strong>Lock</strong>.<strong>tryLock</strong> 以及 <strong>Condition</strong>.<strong>await</strong> 的计时版</li></ul><blockquote><p>当一个线程被阻塞或等待时（或终止时)，另一个线程被调度为运行状态。当一个线程被重新激活（例如， 因为超时期满或成功地获得了一个锁)，调度器<u>检查它是否具有比当前运行线程更高的优先级</u>。如果是这样，调度器从当前运行线程中挑选一个， 剥夺其运行权，选择一个新的线程运行。</p></blockquote><p><img src="/2021/07/24/Java%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/hexo_github_blog\source_posts\pic\image-20210802152611261.png"></p><h3 id="4-被终止的线程（Waiting）"><a href="#4-被终止的线程（Waiting）" class="headerlink" title="4.被终止的线程（Waiting）"></a>4.被终止的线程（Waiting）</h3><p>线程被终止的原因：</p><ul><li>因为run方法正常退出而自然死亡</li><li>因为一个没有捕获的异常终止了run方法而意外死亡</li></ul><h3 id="5-（Timed-waiting）"><a href="#5-（Timed-waiting）" class="headerlink" title="5.（Timed waiting）"></a>5.（Timed waiting）</h3><h3 id="6-（Terminated）"><a href="#6-（Terminated）" class="headerlink" title="6.（Terminated）"></a>6.（Terminated）</h3><h2 id="14-4-线程属性"><a href="#14-4-线程属性" class="headerlink" title="14.4 线程属性"></a>14.4 线程属性</h2><h3 id="1-线程优先级"><a href="#1-线程优先级" class="headerlink" title="1.线程优先级"></a>1.线程优先级</h3><ul><li><p>每一个线程有一个优先级</p></li><li><p>默认情况下，一个线程继承它的父线程的优先级</p></li><li><p>可以用setPriority方法提高或降低任何一个线程的优先级,其值在</p><p>MIN_PRIORITY(1)~MAX_PRIORITY(10)之间。NORM_PRIORITY被定义为5</p></li><li><p>每当线程调度器有机会选择新线程时， 它首先选择具有较高优先级的线程。但是，线程优先级是<u>高度依赖于系统</u>的。当虚拟机依赖于宿主机平台的线程实现机制时， <strong>Java</strong> 线程的优先级被映射到宿主机平台的优先级上， 优先级个数也许更多，也许更少。（根据操作系统变化？）</p></li></ul><h3 id="2-守护线程"><a href="#2-守护线程" class="headerlink" title="2.守护线程"></a>2.守护线程</h3><p>调用 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.setDaemon(<span class="keyword">true</span>);<span class="comment">//必须在线程启动之前调用</span></span><br></pre></td></tr></table></figure><p>将线程转化为<strong>守护线程</strong>（deamon thread）。</p><ul><li>唯一用途是为其它线程提供服务（？）</li></ul><h3 id="3-未捕获异常处理器"><a href="#3-未捕获异常处理器" class="headerlink" title="3.未捕获异常处理器"></a>3.未捕获异常处理器</h3><ul><li>线程的run方法不能抛出任何受查异常,但非受查异常会导致线程终止，即死亡。但不需要任何catch子句来处理可以被传播的异常。<u>在线程死亡之前， 异常被传递到一个用于未捕获异常的处理器</u></li></ul><blockquote><p>Java中的异常分为受检查的异常和不受检查的异常。</p><p>（1）受检查的异常：这种在编译时被强制检查的异常称为”受检查的异常”。即在方法的声明中声明的异常。</p><p>（2）不受检查的异常：在方法的声明中没有声明，但在方法的运行过程中发生的各种异常被称为”不被检查的异常”。这种异常是错误，会被自动捕获。</p></blockquote><ul><li><p>该处理器必须属于一个实现 Thread.UncaughtExceptionHandler <strong>接口</strong>的类。这个接口只有—个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span></span></span><br></pre></td></tr></table></figure></li><li><p>可以用 setUncaughtExceptionHandler 方法为任何线程<strong>安装一个处理器</strong>。也可以用 Thread类的静态方法 setDefaultUncaughtExceptionHandler 为<strong>所有线程</strong>安装一个默认的处理器。<strong>替换</strong>处理器可以使用日志 API 发送未捕获异常的报告到日志文件。</p></li><li><p>如果不安装默认的处理器， 默认的处理器为空。但是， 如果不为独立的线程安装处理器，此时的处理器就是该线程的 <u>ThreadGroup 对象。👇</u> （？附加线程组解释：一个可以统一管理的线程集合。建议不要在自己的程序中用）</p></li><li><p><u>ThreadGroup 类</u>实现 Thread.UncaughtExceptionHandler 接口。它的 uncaughtException 方法做如下操作：（看不懂哈哈主要是不想了解，详情看p640😊）</p></li></ul><h2 id="14-5-同步"><a href="#14-5-同步" class="headerlink" title="14.5 同步"></a>14.5 同步</h2><ul><li>在大多数实际的多线程应用中， 两个或两个以上的线程需要共享对同一数据的存取，都想拿那个对象，都想修改它的状态——&gt;<strong>竞争条件</strong></li></ul><h3 id="1-竞争条件的一个例子"><a href="#1-竞争条件的一个例子" class="headerlink" title="1.竞争条件的一个例子"></a>1.竞争条件的一个例子</h3><ul><li>为了避免多线程引起的对共享数据的讹误，必须学习如何同步存取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个bank对象有一组double数组accounts</span></span><br><span class="line"><span class="comment">//循环每一个account进行开线程并实现transfer方法</span></span><br><span class="line"><span class="comment">//结果银行余额发生变化，出错</span></span><br></pre></td></tr></table></figure><h3 id="2-竞争条件详解"><a href="#2-竞争条件详解" class="headerlink" title="2.竞争条件详解"></a>2.竞争条件详解</h3><p>例如线程①和线程②试图同时更改一个对象（a=1）时：</p><p>①：获取a=1——&gt;a+2=4——&gt;(stop)</p><p>②：获取a=1——&gt;a+1=2——&gt;(stop)</p><p>①：（继续）——&gt;结果写回数组，②执行无效</p><p><img src="/2021/07/24/Java%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/hexo_github_blog\source_posts\pic\image-20210803175713458.png" alt="image-20210803175713458"></p><ul><li><p>出现讹误的可能性</p><p>减少每个线程的工作量，则调度器在计算过程中剥夺线程的运行权可能性小，但风险并没有完全消失</p></li></ul><h3 id="3-锁对象"><a href="#3-锁对象" class="headerlink" title="3.锁对象"></a>3.锁对象</h3><ul><li><p>两种机制防止代码块受并发访问干扰。</p><ul><li><p>synchronized关键字</p></li><li></li></ul></li><li><p>```java<br>myLock.lock(); // a ReentrantLock object<br>try<br>{</p><pre><code>//critical section</code></pre><p>}<br>finally<br>{</p><pre><code>myLock.unlock();// make sure the lock is unlocked even if an exception is thrown 异常，🔒必须被释放。否则其它线程将永远阻塞</code></pre><p>}</p><p>/* 这一结构确保任何时刻只有一个线程进入临界区</p><ul><li> 一旦一个线程封锁了锁对象， 其他任何线程都无法通过 lock 语句</li><li> 当其他线程调用 lock 时，它们被阻塞，直到第一个线程释放锁对象</li><li>/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-20210804202234857.png](https://i.loli.net/2021/10/10/KUszcioluGAXkQ1.png)</span><br><span class="line"></span><br><span class="line">* 🔒是*可重入*的，线程可以&lt;u&gt;重复地获得&lt;/u&gt;已经持有的🔒</span><br><span class="line"></span><br><span class="line">* 🔒保持一个 *持有计数* 来跟踪对lock方法的&lt;u&gt;嵌套调用&lt;/u&gt;。（拿了A🔒，里面还有B🔒。每一次调用lock都要用unlock来解🔒）</span><br><span class="line"></span><br><span class="line">### 4.条件对象</span><br><span class="line"></span><br><span class="line">* 通常， 线程进人&lt;u&gt;临界区&lt;/u&gt;，却发现在某一条件满足之后它才能执行。要使用一个条件对象来管理那些已经获得了一个锁但是却不能做有用工作的线程。（有🔒但还要条件才能干活？👷‍♀️）</span><br><span class="line"></span><br><span class="line">* 举例：当银行账户余额不足，等其它线程注入资金，但自己有🔒（用来执行转账操作的），所以别人给不了💴👉👉👉👉所以需要条件对象</span><br><span class="line"></span><br><span class="line">* 一个锁对象可以有一个或多个相关的条件对象</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  class Bank</span><br><span class="line">  &#123;</span><br><span class="line">      private Condition sufficientFunds;</span><br><span class="line">      ...</span><br><span class="line">      public Bank()</span><br><span class="line">      &#123;</span><br><span class="line">          ...</span><br><span class="line">          sufficientFunds = bankLock.newCondition();//方法</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //如果transfer方法发现余额不足(无法执行🔒内的东西),调用sufficientFunds.await();则当前线程被阻塞了,并放弃了🔒</span><br></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>等待获得🔒的线程和调用await方法的线程本质上的不同:</p><p>①.await : 线程一旦调用，则进入该条件的等待集（没💴💴了）。当🔒可用（🧧有了），该线程不能马上解除阻塞，反而在阻塞状态，直到<strong>其它线程</strong>调用同一条件上的signalAll方法为止。这将激活因为这一条件而等待的所有线程——&gt;可运行——&gt;获得🔒继续运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sufficientFunds.signalAll();</span><br><span class="line"></span><br><span class="line"><span class="comment">//signal则是随机解除某个等待线程的阻塞状态</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>死锁：没有其它线程来激活等待的线程，永远不运行。</li></ul><h3 id="5-synchronized关键字"><a href="#5-synchronized关键字" class="headerlink" title="5.synchronized关键字"></a>5.synchronized关键字</h3><blockquote><p>关于Lock和Condition对象的总结：</p><ul><li>🔒用来保护代码片段, 任何时刻只有一个线程来执行被保护的代码</li><li>🔒可以管理试图进入被保护代码段的线程</li><li>🔒可以<u>拥有</u>一个或多个相关的条件对象(锁拥有??)</li><li>每个条件对象管理已经进入被锁住的代码但还不能执行的线程</li></ul></blockquote><ul><li>以上是用两个<u>接口</u>来锁定。大多数情况下可以使用一种<u>嵌入Java语言内部的机</u><u>制</u>。<strong>每一个对象有一个内部锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个方法用synchronized声明,对象的锁将保护整个方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//method body              [内部对象锁]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----等价于-----</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.intrinsicLock.lock();<span class="comment">//[显式的锁]</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span>&#123;<span class="keyword">this</span>.intrinsicLock.unLock()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接着来看条件对象怎么处理：</p><p>wait/notify 等价于 await/signalAll</p></li><li><p>总结：每一个对象有一个内部锁，并且该锁有一个内部条件</p></li></ul><h3 id="6-同步阻塞"><a href="#6-同步阻塞" class="headerlink" title="6.同步阻塞"></a>6.同步阻塞</h3><ul><li>获得java对象的锁两种方法：<ul><li>线程通过调用同步方法获得锁</li><li>通过进入一个同步阻塞</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程进入如下形式的阻塞,获得obj的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (obj)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//特殊情况:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span>...)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//lock对象被创建仅仅是用来使用每个java对象持有的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-监视器概念"><a href="#7-监视器概念" class="headerlink" title="7.监视器概念"></a>7.监视器概念</h3><blockquote><p>锁和条件严格地来说不是面向对象的；如何在不需要考虑如何加锁的情况下保证多线程的安全性——监视器。</p></blockquote><ul><li>监视器的特性：<ul><li>是只包含私有域的类</li><li>每个监视器类的对象有一个相关的锁</li><li>这个锁呢，可以对所有的方法进行加锁。如果用obj.method()，obj对象的锁在方法调用开始时就自动获得了；而且方法返回时自动释放该锁。因为所有域都是私有的，可以确保一个线程在对对象操作时，没有其它线程能访问该域。</li><li>该锁可以有任意多个相关条件</li></ul></li><li>（待补充…😳）</li></ul><h3 id="8-Volatile域"><a href="#8-Volatile域" class="headerlink" title="8.Volatile域"></a>8.Volatile域</h3><blockquote><p>用锁来保护被多个线程保护的代码：编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应，并且不能不正当地重新排序指令。</p></blockquote><ul><li><p>volatile关键字为实例域的同步访问提供了一种免锁机制。（有时候仅仅为了读写一个或两个实例域同步，好像开销过大了，但是这小细节还是很容易处理出问题的）所以一个域被声明为volatile的时候，编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*假设一个对象有一个boolean域done，它的值——被线程A设置却被线程B查询*/</span></span><br><span class="line"><span class="comment">//①.考虑将set和get方法(改变值嘛)设置锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> done;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setDone</span><span class="params">()</span></span>&#123;</span><br><span class="line">    done = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//锁方法的问题是什么呢,如果线程C已经对该对象加锁,方法可能阻塞(我只是想把值改变而已啊)</span></span><br><span class="line"><span class="comment">//将域声明为volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> done;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDone</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>volatile变量不能提供原子性——不能保证读取、翻转和写入不被中断。</p></li></ul><h3 id="9-final变量"><a href="#9-final变量" class="headerlink" title="9.final变量"></a>9.final变量</h3><blockquote><p>如何安全地访问多个线程的一个共享域：</p><ul><li>使用锁</li><li>volatile修饰符</li><li>声明这个域为final</li></ul></blockquote><h3 id="10-原子性"><a href="#10-原子性" class="headerlink" title="10.原子性"></a>10.原子性</h3><ul><li>假设对共享变量除了赋值以外并不完成其它操作，可以将这些变量声明为volatile</li><li>java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令（而不是使用锁） 来保证其他操作的原子性</li></ul>]]></content>
    
    
    <summary type="html">Java</summary>
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
  </entry>
  
</feed>

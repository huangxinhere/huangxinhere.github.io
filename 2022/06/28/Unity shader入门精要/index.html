<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>UnityShader 入门精要/基础篇＋初级篇 笔记 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="learn sth">
<meta property="og:type" content="article">
<meta property="og:title" content="UnityShader 入门精要&#x2F;基础篇＋初级篇 笔记">
<meta property="og:url" content="https://huangxinhere.github.io/2022/06/28/Unity%20shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="learn sth">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huangxinhere.github.io/img/ta.jpg">
<meta property="article:published_time" content="2022-06-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-12-09T09:58:28.829Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huangxinhere.github.io/img/ta.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2022/06/28/Unity%20shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UnityShader 入门精要/基础篇＋初级篇 笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-09 17:58:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_pic_3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/ta.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hx's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UnityShader 入门精要/基础篇＋初级篇 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-27T16:00:00.000Z" title="发表于 2022-06-28 00:00:00">2022-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-09T09:58:28.829Z" title="更新于 2022-12-09 17:58:28">2022-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/shader/">shader</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UnityShader 入门精要/基础篇＋初级篇 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>学习shader：</p>
<ul>
<li>前提要了解整个渲染流程是如何进行的</li>
<li>更多是面向GPU的工作方式</li>
<li>基本知识了解<ul>
<li>OpenGL ＆ DirectX：两种图像应用编程接口。直接操作硬件是很难受滴，所以为上层应用程序和底层GPU架起了沟通桥梁。</li>
</ul>
</li>
</ul>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/9cbbce53043dfae55a4ae7adadff7c54.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<ul>
<li>着色语言：专门用于编写着色器<ul>
<li>OpenGL的GLSL：跨平台性，只要显卡驱动支持GLSL的编译就能运行（依赖硬件—取决于硬件供应商）</li>
<li>DirectX的HLSL：微软平台</li>
<li>NVIDIA的CG：真正意义上的跨平台；和HLSL非常相像；无法发挥出OpenGL的最新特性</li>
</ul>
</li>
</ul>
<h1 id="第2章-渲染流水线"><a href="#第2章-渲染流水线" class="headerlink" title="第2章 渲染流水线"></a>第2章 渲染流水线</h1><h2 id="2-1什么是渲染流水线"><a href="#2-1什么是渲染流水线" class="headerlink" title="2.1什么是渲染流水线"></a>2.1什么是渲染流水线</h2><ul>
<li><p>shader：着色器，是渲染流水线中的一个环节</p>
</li>
<li><p>渲染流水线：</p>
<ul>
<li>最终目的，由一个三维场景出发，生成或者渲染一张二维纹理图像（通常由CPU和GPU共同完成）</li>
<li>输入一个虚拟摄像机，光源，shader以及纹理等等</li>
<li>渲染流程可以分为三个阶段：</li>
</ul>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/721d712f2f7ee8657003926b18c91cd9.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<ul>
<li><strong>应用阶段</strong>：（CPU）开发者主导；准备场景数据、粗粒度剔除工作（剔除不可见物体）、设置好每个模型的渲染状态……【最重要的输出时渲染所需的几何信息，即<u>渲染图元</u>】</li>
<li>几何阶段：（GPU）用于处理所有 和我们要绘制的 几何相关的 东西。比如需要绘制的图元是什么，怎样绘制，在哪里绘制。【把顶点坐标（每个顶点对应的深度值，着色等相关信息）变换到屏幕空间中，再交给光栅器进行处理】</li>
<li>光栅化阶段：（GPU）使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。</li>
</ul>
</li>
<li><p>以上是概念流水线。</p>
</li>
<li><p>GPU流水线——硬件 真正用于实现上述概念的 流水线</p>
</li>
</ul>
<h2 id="2-2-CPU和GPU之间的通信"><a href="#2-2-CPU和GPU之间的通信" class="headerlink" title="2.2 CPU和GPU之间的通信"></a>2.2 CPU和GPU之间的通信</h2><p>应用阶段：（渲染流水线的起点是CPU）</p>
<h4 id="把数据加载到显存中"><a href="#把数据加载到显存中" class="headerlink" title="把数据加载到显存中"></a>把数据加载到显存中</h4><ul>
<li>所有渲染的数据都要从🥰硬盘（HDD）中加载到🥰系统内存（RAM）</li>
<li>然后，网格和纹理等数据又被加载到【🥰显卡（VRAM）上的存储空间——显存】中（显卡对显存的访问速度更快；大多数显卡对RAM没有直接访问的权利）</li>
</ul>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/1f6f715e90046a41a9637631a191c978.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<p>​            两纹理＋三网格</p>
<ul>
<li><p>数据加载到显存后，RAM的数据就可以删除了</p>
<ul>
<li><p>但有些数据，CPU仍需要（通过RAM？）访问它们，比如访问网格数据进行碰撞检测）；如果重新加载，硬盘加载到RAM的过程是十分耗时的</p>
</li>
<li><p>开发者通过CPU来设置渲染状态（不知道和上面这点有何联系？？），“指导”GPU如何进行渲染工作</p>
<p>🧐总结：硬盘-RAM-显存是数据流通，幕后操控是CPU和GPU，其中GPU只操控显存（大概先这样吧）</p>
</li>
</ul>
</li>
</ul>
<h4 id="设置渲染状态"><a href="#设置渲染状态" class="headerlink" title="设置渲染状态"></a>设置渲染状态</h4><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/716ca7c6a58f624dd44812261c4dd5e7.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<p>​        （同一状态下渲染三个网格）</p>
<ul>
<li><p>这些状态定义了场景中的网格是怎样被渲染的（有不同的打扮方式嘛？！）</p>
<ul>
<li>做法：使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）、光源属性、材质等【应用阶段？？具体怎么做嘛】</li>
</ul>
</li>
</ul>
<h4 id="调用Draw-Call"><a href="#调用Draw-Call" class="headerlink" title="调用Draw Call"></a>调用Draw Call</h4><p>在我看来很像画画。大脑就是GPU，把看到的模型光线什么的放在脑海里（素描关系色彩什么的），然后除了传递这些数据给（会画画的大脑部分），还得告诉它要主观加工成什么样（一个渲染规范？目标？）。然后会画画的大脑部分就要开始画画啦（接到指令和资料！</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/4c18f630c7caa3211c8bc011cfc95d8a.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<ul>
<li><p>附加说明：深入理解CPU和GPU与Draw Call之间的关系</p>
<ul>
<li><p>GPU和CPU如何实现并行工作？- 命令缓冲区</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/35344c10842212ea69c28174e89e49d7.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p>
<blockquote>
<p>添加命令和读取命令是独立分开的（小小知识点：改变渲染状态的命令比渲染模型更耗时）</p>
</blockquote>
</li>
<li><p>为什么Draw Call多了会影响帧率？</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/e6aa7f1cbae85ff4ed99efdbb96f41e5.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p>
<blockquote>
<p>GPU渲染能力很强，速度往往快于CPU提交命令的速度；如果操作过多，额外的工作量会过于繁琐，很慢，比不上别人，效率很低。</p>
</blockquote>
</li>
<li><p>如何减少Draw Call？</p>
<p>这里选取<strong>批处理</strong>的方法。</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/084d5694f465bcd8f245d6234e16e82c.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p>
<blockquote>
<p>打包一次性发送（一个包同一种渲染状态）</p>
<p>但是打包（在CPU的内存中合并网格）也是消耗时间的。所以批处理更适合静态的物体。动态的话每一帧都要合并，会对空间和时间造成一定影响</p>
</blockquote>
<p>so，避免使用大量很小的网格；避免使用过多的材质。</p>
</li>
</ul>
</li>
</ul>
<h2 id="2-3GPU流水线"><a href="#2-3GPU流水线" class="headerlink" title="2.3GPU流水线"></a>2.3GPU流水线</h2><ul>
<li><p>几何阶段和光栅化阶段，开发者无法拥有绝对的控制权，但是GPU向开发者开放了很多控制权👇</p>
</li>
<li><p>这两个阶段可以分为更小的流水线阶段；每个阶段GPU提供不同的可配置性（设置每一步的操作细节）或可编程性</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/b8e1a2f6d7a5e52cb3d0e9eeaf356b0e.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>绿色：完全可编程控制</p>
<p>黄色：可配置不可编程</p>
<p>蓝色：没有任何控制权</p>
<p>？实线：该shader必须由开发者编程实现【为什么有蓝色的实线？没有控制权的必须编程实现？】</p>
<p>？虚线：该shader可选</p>
<p>各个介绍见4%</p>
</blockquote>
</li>
</ul>
<h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><ul>
<li><p>接受的顶点数据：（GPU接受的数据）由应用阶段加载到显存中；再由DrawCall指定（再次顺一顺上面学到的）</p>
</li>
<li><p>干嘛的：坐标变换和逐顶点光照（就是加颜色？）</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/f11f63aa6d913ccf4465950387392444.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p>
<ul>
<li>坐标变换</li>
</ul>
<p>-改变顶点的位置，在顶点动画中非常有用，水面、布料等。</p>
<p>最基本的工作：把顶点坐标从模型<strong>空间</strong>转换到齐次裁剪<strong>空间</strong>（区别？）——&gt;由硬件做透视除法——&gt;归一化的设备坐标（NDC）【待深究，首先理解坐标变换大概是什么个意思】</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/5829e63db9281058e493ef933d238602.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>对右边空间的思考：</p>
<p><img src="https://img-blog.csdn.net/20171016201356967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWQ4ODI4MjI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="&lt;image1&gt;"><img src="https://img-blog.csdn.net/20171016201416205?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYWQ4ODI4MjI4NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="&lt;image2&gt;"></p>
<p>搜了下资料，这是视锥体，分别是透视投影和正交投影。资料所说，裁剪空间的目标是能够方便地对渲染图元进行裁剪：完全位于这块空间内部的图元将会被保留，完全位于这块空间外部的图元将会被剔除，而与这块空间边界相交的图元就会被裁剪。那么相当于把自己的视角看作一个固定范围的空间，然后都投影在这个范围里面。</p>
<p>这个空间大小似乎有规范大小，如图，坐标范围是OpenGL同时也是Unity使用的NDC，z在【-1，1】之间，而在DirectX中，NDC的z【0，1】</p>
</blockquote>
</li>
<li><p>光照相互独立性：本身不可以创建或者销毁任何顶点+获得顶点之间的联系——GPU可以利用本身的特性并行优化处理每一个顶点，处理速度会很快</p>
</li>
</ul>
<h4 id="曲面细分着色器"><a href="#曲面细分着色器" class="headerlink" title="曲面细分着色器"></a>曲面细分着色器</h4><ul>
<li>可选</li>
<li>用于细分图元（之前提到的渲染图元？到底有什么数据长什么样？）</li>
</ul>
<h4 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h4><ul>
<li>可选</li>
<li><u>逐图元</u>【是一个啥东西？】的着色操作，或者被用于产生更多的图元</li>
</ul>
<h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><ul>
<li><p>可配置</p>
</li>
<li><p>目的：不在摄像机视野范围内的物体不需要被处理</p>
</li>
</ul>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/e9c4a625643a99425c64f1a195b59c94.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>立方体范围内，图元保留、舍弃、裁剪（生成新的点）；这里还是立方体哇！😎</p>
</blockquote>
<h4 id="屏幕映射Screen-Mapping（二维）"><a href="#屏幕映射Screen-Mapping（二维）" class="headerlink" title="屏幕映射Screen Mapping（二维）"></a>屏幕映射Screen Mapping（二维）</h4><ul>
<li><p>三维坐标数据因为已经由NDC规定好了，但是屏幕的大小/分辨率又会有不同，那么怎么做适配呢？</p>
</li>
<li><p>每个图元的x和y坐标转换到屏幕坐标系👇</p>
</li>
</ul>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/541c691775294b2af9f32af727505ea2.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>🧐所以是有缩放的效果了……可能有点变形？还有z坐标直接被剔去了？前后关系怎么表示咧</p>
</blockquote>
<ul>
<li><p>不会对输入的z坐标做任何处理。屏幕坐标系和z坐标【还在啊…？】一起构成了一个坐标系——&gt;<strong>窗口坐标系</strong>（Window Coordinates），这些值会一起被传递到光栅化阶段</p>
</li>
<li><p>然鹅屏幕坐标系对于OpenGL和DirectX仍有所区别，起始点不同（反正要考虑这种差异可能会导致效果倒转）</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/b4ff49d945948ea577003130621b6da9.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
</li>
</ul>
<hr>
<p>顶点已经在二维屏幕集结好啦！还附带了一些信息（深度值z值（原来是它吖，法线方向（见了好多次到底是咋样，视角方向等）可以开始进一步打扮了。👇光栅化阶段：点与点之间覆盖的范围和颜色👇</p>
<h4 id="三角形设置"><a href="#三角形设置" class="headerlink" title="三角形设置"></a>三角形设置</h4><ul>
<li>干嘛：计算光栅化一个三角网格所需的信息</li>
<li>三角网格怎么组成的？三角形的点知道了，那么用多少行多少列表示啊？得整个<strong>三角网格表示数据</strong>哇</li>
</ul>
<h4 id="三角形遍历（扫描变换）"><a href="#三角形遍历（扫描变换）" class="headerlink" title="三角形遍历（扫描变换）"></a>三角形遍历（扫描变换）</h4><ul>
<li>🦁<strong>检查</strong>每个像素是否被一个三角网格覆盖——&gt;覆盖，生成一个片元。网格好了，边范围也知道了，开始填填乐呗</li>
</ul>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/5990d470b57bfcdca705c250ed5b45df.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>生成像素，对应像素生成一个<strong>片元</strong>（并不是真正意义上的像素，是包含<u>很多状态的集合</u>，这些状态用于计算每个像素的最终颜色）。整个输出<strong>片元序列</strong>。</p>
<p><strong>片元的状态</strong>是对三个顶点的信息进行<strong>插值</strong>【这又是什么哇？】得到。状态比如有屏幕坐标，深度信息，法线，纹理坐标等等</p>
<p>总结：填填乐怎么得来？插值？填的计算方法嘛？而且不是颜色，是生成片元的状态。</p>
</blockquote>
<h4 id="片元着色器"><a href="#片元着色器" class="headerlink" title="片元着色器"></a>片元着色器</h4><ul>
<li><u>以上阶段</u>实际上不影响像素的颜色值，而是产生一系列的数据信息（一个三角网络是怎样覆盖每个像素的）</li>
<li><u>每个片元</u>负责存储这样一系列数据。</li>
<li>片元着色器的输入输出（欧，就先想象是每个顶点带着自己的捆绑包经历千辛万苦坐火车做安检什么的，终于在片元着色器完成了资源的计算完成了修炼，完成华丽的蜕变/有了该片元的输出颜色…）</li>
</ul>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/52837b327f33ad1730daba41dc3ad66c.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>输入：上一个阶段对顶点信息插值得到的结果（片元带）</p>
<p>输出：一个或多个颜色值</p>
</blockquote>
<ul>
<li><p>补充：纹！理！采！样！？（片元着色器中）</p>
<ul>
<li><p>纹理坐标：从顶点着色器阶段输出每个点对应的纹理坐标（怎么来好像没稀奇，所以到底是啥</p>
<p>​                    ——插值——顶点们覆盖的片元的纹理坐标（就是顶点包裹里面的一个东西嘛，所以是啥？!</p>
</li>
</ul>
</li>
<li><p>局限：仅可以影响单个片元</p>
</li>
</ul>
<h4 id="逐片元操作"><a href="#逐片元操作" class="headerlink" title="逐片元操作"></a>逐片元操作</h4><ul>
<li><p>高度可配置性</p>
</li>
<li><p>任务：</p>
<ol>
<li><p>决定每个片元的可见性，涉及很多测试操作（测试？从种种角度来看能不能可见吧）</p>
</li>
<li><p>若一个片元通过了所有测试，其颜色值+已经存储在颜色缓冲区中的颜色（好的已经可见啦，就得有颜色来展示；相当于投了简历，即使到了最后一面被刷到也还是没有offer啊！！！）</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/a6ffc86900aa747f898d07a55c729193.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>颜色缓冲区？为啥会有这个。怎么混合啊</p>
<ul>
<li>像素的颜色信息被存储在名为颜色缓冲的地方</li>
<li>往往有上次渲染之后的颜色结果</li>
<li>so，是覆盖呢，还是进行其它处理?</li>
</ul>
</blockquote>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/0428aea75587eb49eaaafb64d6bf043f.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>这个是其中两个测试的具体过程，嗯，跳过！</p>
<p>回来了。原理关键是矩形内容。深度这个，透明度或许有解答</p>
</blockquote>
</li>
</ol>
</li>
<li><p>混合！</p>
<p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/1afda4956ed174150b5324174c29d126.jpg?x-oss-process=image/resize,w_1858,m_lfit" alt="img"></p>
<blockquote>
<p>不透明物体：<strong>开发者</strong>可以关闭混合条件。源颜色会覆盖掉颜色缓冲区的像素值</p>
<p>半透明：混合操作。</p>
</blockquote>
</li>
<li><p>测试顺序：对于大多数GPU来说，尽可能在片元着色器之前进行这些测试，为了节省力气（直接把简历筛下去的意思嘛？！</p>
</li>
<li><p>提前的话可能会有些冲突；性能下降（GPU判断提前测试是否有冲突，此时会有更多的片元需要被处理</p>
</li>
<li><p>显示到屏幕上之后，GPU会双重缓冲。后置缓冲：对场景的渲染是在幕后发生，前置缓冲：之前显示在屏幕中的图像。两者交换以保证图像连续。</p>
</li>
</ul>
<hr>
<p>（气喘吁吁🙃）</p>
<p>大概了解了整个渲染流程，而shader所在阶段就是渲染流水线的一部分，所以shader就是：</p>
<ul>
<li>GPU流水线上一些可高度编程的阶段</li>
</ul>
<h1 id="第3章-Unity-Shader基础"><a href="#第3章-Unity-Shader基础" class="headerlink" title="第3章 Unity Shader基础"></a>第3章 Unity Shader基础</h1><p>对一些操作进行了封装，方便更好地编程和设置</p>
<h2 id="Unity-Shader概述"><a href="#Unity-Shader概述" class="headerlink" title="Unity Shader概述"></a>Unity Shader概述</h2><h3 id="材质和Unity-Shader"><a href="#材质和Unity-Shader" class="headerlink" title="材质和Unity Shader"></a>材质和Unity Shader</h3><p>没有细读这本书之前，按照一贯的操作思路，就是先弄一个shader，然后根据它创建一个材质，这样效果就能赋给模型了。为什么shader和材质会产生这种割裂，还有联系?</p>
<p>Unity Shader定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等），而😏<strong>材质则允许我们调节这些属性</strong>，<strong>并将其最终赋给相应的模型</strong>。</p>
<h3 id="Unity中的材质"><a href="#Unity中的材质" class="headerlink" title="Unity中的材质"></a>Unity中的材质</h3><p>有面板可更改数值</p>
<h3 id="Unity中的Shader"><a href="#Unity中的Shader" class="headerlink" title="Unity中的Shader"></a>Unity中的Shader</h3><ul>
<li>Standard Surface Shader：会产生一个包含了标准光照模型的<u>表面着色器</u>（啥玩意，没见过）模板</li>
<li>Unlit Shader：不包含光照（但包含雾效）的基本的顶点/片元着色器</li>
<li>Image Effect Shader：为屏幕后处理效果提供模板</li>
<li>Compute Shader：（略</li>
</ul>
<blockquote>
<p>这些基本的理解，或许在其它的shader插件或者什么中有共性</p>
</blockquote>
<ul>
<li>可以在shader面板中查看各种东西，是否为Surface shader啊，Fixed function啊，等等，有需要我再细看吧</li>
</ul>
<h2 id="Unity-Shader的基础：ShaderLab"><a href="#Unity-Shader的基础：ShaderLab" class="headerlink" title="Unity Shader的基础：ShaderLab"></a>Unity Shader的基础：ShaderLab</h2><p><img src="https://staticcdn1-5.umiwi.com/epms_ebook/4b9a50ca2993153f23d86a7786580f3e.jpg?x-oss-process=image/resize,w_1920,m_lfit" alt="img"></p>
<blockquote>
<p>　Unity Shader为控制渲染过程提供了一层抽象。如果没有使用UnityShader（左图），开发者需要和很多文件和设置打交道，才能让画面呈现出想要的效果；而在Unity Shader的帮助下（右图），开发者只需要使用ShaderLab来编写Unity Shader文件就可以完成所有的工作</p>
</blockquote>
<ul>
<li>ShaderLab: 是Unity提供的编写Unity Shader的一种说明性语言</li>
<li>一个Unity Shader的基础结构如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;ShaderName&quot; &#123;    </span><br><span class="line">	Properties &#123;        </span><br><span class="line">		// 属性</span><br><span class="line">    &#125;    </span><br><span class="line">    SubShader &#123;        </span><br><span class="line">    	// 显卡A使用的子着色器</span><br><span class="line">    &#125;    </span><br><span class="line">    SubShader &#123;        </span><br><span class="line">    	// 显卡B使用的子着色器</span><br><span class="line">    &#125;        </span><br><span class="line">    Fallback &quot;VertexLit&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unity-Shader的结构"><a href="#Unity-Shader的结构" class="headerlink" title="Unity Shader的结构"></a>Unity Shader的结构</h2><p>上节见到了一些ShaderLab的语义，如Properties、SubShader、Fallback等。这些语义定义了Unity Shader的结构，从而帮助Unity分析该Unity Shader文件，以便进行正确的编译。</p>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><h3 id="材质和Unity-Shader-的桥梁：Properties（属性）"><a href="#材质和Unity-Shader-的桥梁：Properties（属性）" class="headerlink" title="材质和Unity Shader 的桥梁：Properties（属性）"></a>材质和Unity Shader 的桥梁：Properties（属性）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;    </span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue    </span><br><span class="line">    Name (&quot;display name&quot;, PropertyType) = DefaultValue    // 更多属性</span><br><span class="line">&#125;</span><br><span class="line">//比如 _int (&quot;Int&quot;, Int) = 2;</span><br><span class="line">//在Shader中访问属性， 通过Name，通常由一个下划线开始</span><br><span class="line">//显示的名称display name则是出现在材质面板上的名字</span><br><span class="line">//指定类型 PropertyType</span><br><span class="line">//默认值</span><br><span class="line"></span><br><span class="line">//虽然不是C#但为了代码染色</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数字类型的属性</p>
</li>
<li><p>Color， Vector（1，2，3，4）</p>
</li>
<li><p>2D，Cube，3D “”{}  </p>
<blockquote>
<p>具体怎么填详情看书，不知道现在还通用不</p>
</blockquote>
</li>
<li><p>还能重载默认的材质面板</p>
</li>
</ul>
<h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><ul>
<li><p>数量要求：每个Unity Shader文件可以包含多个SubShader语义块，最少要一个</p>
</li>
<li><p>运行机制：当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块，然后选择第一个能够在目标平台上运行的SubShader。如果都不支持的话，Unity就会使用Fallback语义指定的UnityShader。</p>
<blockquote>
<p>原因：不同的显卡具有不同的能力。例如，一些旧的显卡仅能支持一定数目的操作指令，而一些更高级的显卡可以支持更多的指令数，那么我们希望在旧的显卡上使用计算复杂度较低的着色器，而在高级的显卡上使用计算复杂度较高的着色器，以便提供更出色的画面。【可选择，确实挺照顾玩家的，所以游戏会有最低配置最高配置？】</p>
</blockquote>
</li>
<li><p>```c#<br>SubShader {    </p>
<pre><code>// 可选的“标签”
[Tags]    
// 可选的“状态”
[RenderSetup]    
Pass &#123;    &#125;    // Other Passes
</code></pre>
<p>}<br>//每个pass定义了一次完整的渲染流程；但数目过多会造成渲染性能的下降</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 👉状态设置👈</span><br><span class="line"></span><br><span class="line">  ShaderLab提供了一系列渲染状态的设置指令，这些指令可以设置显卡的各种状态，例如是否开启混合/深度测试等（首先渲染状态是什么玩意儿？都看不懂，希望后面有实例说明）</span><br><span class="line"></span><br><span class="line">  - 当在SubShader块中设置了上述渲染状态时，将会应用到所有的Pass。如果我们不想这样可以在Pass语义块中单独进行上面的设置。</span><br><span class="line"></span><br><span class="line">* 👉标签👈</span><br><span class="line"></span><br><span class="line">  是一个键值对，键和值都是字符串类型；这些键值对是SubShader和渲染引擎之间的沟通桥梁。它们用来告诉Unity的渲染引擎：我希望&lt;u&gt;怎样以及何时渲染这个对象&lt;/u&gt;。</span><br><span class="line"></span><br><span class="line">  ```c#</span><br><span class="line">  Tags &#123; </span><br><span class="line">      &quot;TagName1&quot; =&quot;Value1&quot; </span><br><span class="line">      &quot;TagName2&quot; =&quot;Value2&quot; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>巴拉巴拉详细举例和介绍等等，有用到就细看。</p>
<p><img src="/2022/06/28/Unity%20shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/hexo_github_blog\source_posts\pic\image-20220426193126888.png" alt="image-20220426193126888"></p>
<ul>
<li>仅可以在SubShader中声明，不可以在Pass块声明</li>
</ul>
</li>
<li><p>👉Pass语义块👈</p>
<ul>
<li>```c#<br>Pass{<pre><code>[Name]             //Name &quot;MyPassName&quot;
[Tags]
[RenderSetup]
//other code
</code></pre>
}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; * 名称：通过名称，可以使用ShaderLab的UsePass命令来直接使用其它Unity Shader中的Pass。例如：</span><br><span class="line">&gt;</span><br><span class="line">&gt;   ```c#</span><br><span class="line">&gt;   UsePass &quot;MyShader/MYPASSNAME&quot;</span><br><span class="line">&gt;   //这样提高代码的复用性。Unity内部会把所有的Pass名称转换成大写字母</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>渲染状态：SubShader的状态设置同样适用于Pass；还能使用固定管线的着色器命令。</p>
</li>
<li><p>标签：不同于SubShader标签。用于告诉渲染引擎希望怎样来渲染物体</p>
</li>
</ul>
<p>（例子见9%）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>Fallback</p>
<p>下下策：最低级的Unity Shader</p>
<p>还会影响阴影的投射</p>
</li>
</ul>
<h2 id="Unity-Shader的形式"><a href="#Unity-Shader的形式" class="headerlink" title="Unity Shader的形式"></a>Unity Shader的形式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;        </span><br><span class="line">    // 所需的各种属性</span><br><span class="line">    &#125;    </span><br><span class="line">SubShader &#123;        </span><br><span class="line">    // 真正意义上的Shader代码会出现在这里</span><br><span class="line">    // 表面着色器（Surface Shader）或者</span><br><span class="line">    // 顶点/片元着色器（Vertex/Fragment Shader）或者</span><br><span class="line">    // 固定函数着色器（Fixed Function Shader）</span><br><span class="line">    &#125;    </span><br><span class="line">SubShader &#123;        </span><br><span class="line">    // 和上一个SubShader类似</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unity的宠儿：表面着色器"><a href="#Unity的宠儿：表面着色器" class="headerlink" title="Unity的宠儿：表面着色器"></a>Unity的宠儿：表面着色器</h3><ul>
<li>Unity自己创造的一种着色器代码类型</li>
<li>所需代码量少，Unity在背后做了很多工作，但渲染的代价比较大</li>
<li>本质和其它着色器一样/ 是它们的更高抽象</li>
<li>unity为我们处理了很多光照细节</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple Surface Shader&quot; &#123;</span><br><span class="line">    //在SubShader语句块里面（而非Pass语句块里面）</span><br><span class="line">    SubShader &#123;        </span><br><span class="line">        Tags &#123; &quot;RenderType&quot; =&quot;Opaque&quot; &#125;</span><br><span class="line">        CGPROGRAM/**/        </span><br><span class="line">        #pragma surface surf Lambert        </span><br><span class="line">        struct Input &#123;            </span><br><span class="line">            float4 color : COLOR;        </span><br><span class="line">        &#125;;        </span><br><span class="line">        void surf (Input IN, inout SurfaceOutput o) &#123;            </span><br><span class="line">            o.Albedo =1;        </span><br><span class="line">        &#125;        </span><br><span class="line">        ENDCG/**/    </span><br><span class="line">    &#125;    </span><br><span class="line">    Fallback &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不需要开发者关心使用多少个Pass、每个Pass如何渲染等问题，Unity会处理</span><br><span class="line">//CGPROGRAM和ENDCG之间的代码是使用Cg/HLSL编写的，也就是说，我们需要把Cg/HLSL语言嵌套在ShaderLab语言中。值得注意的是，这里的Cg/HLSL是Unity经封装后提供的，它的语法和标准的Cg/HLSL语法几乎一样，但还是有细微的不同，例如有些原生的函数和用法Unity并没有提供支持</span><br></pre></td></tr></table></figure>

<h3 id="最聪明：顶点-片元着色器"><a href="#最聪明：顶点-片元着色器" class="headerlink" title="最聪明：顶点/片元着色器"></a>最聪明：顶点/片元着色器</h3><ul>
<li><p>在Unity中我们可以使用Cg/HLSL语言来编写顶点/片元着色器（Vertex/FragmentShader）</p>
</li>
<li><p>更加复杂，灵活性也更高</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Custom/Simple VertexFragment Shader&quot; &#123;</span><br><span class="line">    SubShader &#123;  </span><br><span class="line">        //Pass语义块里面</span><br><span class="line">        Pass &#123;            </span><br><span class="line">        	CGPROGRAM            </span><br><span class="line">        	#pragma vertex vert            </span><br><span class="line">        	#pragma fragment frag            </span><br><span class="line">         	float4 vert(float4 v : POSITION) :SV_POSITION &#123;                				return mul (UNITY_MATRIX_MVP, v);            </span><br><span class="line">            &#125;            </span><br><span class="line">            fixed4 frag() : SV_Target &#123;                </span><br><span class="line">                return fixed4(1.0, 0.0, 0.0, 1.0);            </span><br><span class="line">            &#125;            </span><br><span class="line">            ENDCG        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="被抛弃：固定函数着色器"><a href="#被抛弃：固定函数着色器" class="headerlink" title="被抛弃：固定函数着色器"></a>被抛弃：固定函数着色器</h3><ul>
<li>上面两种unity shader都用了可编程管线。</li>
<li>这个不可编程，效果简单，用在旧设备</li>
</ul>
<h3 id="Unity-Shader形式的选择"><a href="#Unity-Shader形式的选择" class="headerlink" title="Unity Shader形式的选择"></a>Unity Shader形式的选择</h3><ul>
<li>和各种光源打交道：表面着色器；移动平台性能可能欠佳</li>
<li>光照数目非常少，顶点/片元着色器</li>
</ul>
<h1 id="第4章-数学基础"><a href="#第4章-数学基础" class="headerlink" title="第4章 数学基础"></a>第4章 数学基础</h1><h2 id="矩阵的几何意义：变换"><a href="#矩阵的几何意义：变换" class="headerlink" title="矩阵的几何意义：变换"></a>矩阵的几何意义：变换</h2><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p>把一些数据，如点、方向矢量甚至是颜色等，通过某种方式进行转换的过程</p>
<h3 id="线性变换：矢量加-标量乘"><a href="#线性变换：矢量加-标量乘" class="headerlink" title="线性变换：矢量加 / 标量乘"></a>线性变换：矢量加 / 标量乘</h3><p><strong>缩放、旋转</strong>、错切、镜像、正交投影等</p>
<h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><ul>
<li>非线性变换</li>
</ul>
<h3 id="仿射变换——齐次坐标空间"><a href="#仿射变换——齐次坐标空间" class="headerlink" title="仿射变换——齐次坐标空间"></a>仿射变换——齐次坐标空间</h3><ul>
<li>合并线性变换和平移变换的变换类型</li>
<li>可以用一个4×4矩阵来表示——需要把矢量扩展到四维空间上，这就是<strong>齐次坐标空间</strong></li>
</ul>
<h3 id="常见变换种类及矩阵"><a href="#常见变换种类及矩阵" class="headerlink" title="常见变换种类及矩阵"></a>常见变换种类及矩阵</h3><table>
<thead>
<tr>
<th align="center">变换名称</th>
<th align="center">线性变换？</th>
<th align="center">仿射变换？</th>
<th align="center">可逆矩阵？</th>
<th align="center">正交矩阵？</th>
</tr>
</thead>
<tbody><tr>
<td align="center">平移矩阵</td>
<td align="center">N</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">绕坐标轴旋转的旋转矩阵</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">绕任意轴旋转的旋转矩阵</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">按坐标轴缩放的缩放矩阵</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">错切矩阵</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">镜像矩阵</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">正交投影矩阵</td>
<td align="center">Y</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">透视投影矩阵</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
</tbody></table>
<h2 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h2><ul>
<li>4×4矩阵可以表示平移，所以将3×3扩展到4×4（四维矢量</li>
<li>转换过程：将其w分量设为1（如果是方向矢量，将其设为0）</li>
<li>这样转换的结果是：当4×4矩阵对一个点进行变换时，平移、旋转、缩放都会施加于该点；若是变换一个方向矢量的话，平移的效果就会被忽略。</li>
</ul>
<h2 id="分解基础变换矩阵"><a href="#分解基础变换矩阵" class="headerlink" title="分解基础变换矩阵"></a>分解基础变换矩阵</h2><ul>
<li><p><strong>基础变换矩阵</strong>：纯平移、纯旋转、纯缩放的变换矩阵</p>
</li>
<li><p>共同特点：</p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/ba7742d8009ef.png" alt="image-20220629191518926"></p>
</li>
</ul>
<h3 id="平移矩阵"><a href="#平移矩阵" class="headerlink" title="平移矩阵"></a>平移矩阵</h3><ul>
<li><p>使用矩阵乘法来表示对一个点进行平移变换：</p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/423d0ad4e0b0e.png" alt="image-20220629191614399"></p>
<ul>
<li><p>如果对一个方向矢量变换：</p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/05d98f05cbcf1.png" alt="image-20220629191710238"></p>
<blockquote>
<p>平移变换对方向矢量没有任何影响。矢量没有位置属性，可以在任何一点</p>
</blockquote>
</li>
<li><p>平移矩阵的逆矩阵：反向平移</p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/2e9aae0d2b481.png" alt="image-20220629191840641"></p>
</li>
</ul>
</li>
</ul>
<h3 id="缩放矩阵"><a href="#缩放矩阵" class="headerlink" title="缩放矩阵"></a>缩放矩阵</h3><ul>
<li><p>沿空间x/y/z进行缩放</p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/52828875a3e72.png" alt="image-20220629192302319"></p>
</li>
<li><p>对于方向矢量</p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/519c35ffd1954.png" alt="image-20220629192329883"></p>
</li>
<li><p>缩放矩阵的逆矩阵</p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/9577ade991ffc.png" alt="image-20220629192403028"></p>
</li>
<li><p>在任意方向上进行缩放：复合变换。其中一个重要思想是将缩放轴变换成标准坐标轴，然后进行沿坐标轴的缩放，<u>再使用逆变换得到原来的缩放轴朝向</u>（？逐渐脱离控制）。</p>
</li>
</ul>
<h3 id="旋转矩阵（绕空间坐标轴"><a href="#旋转矩阵（绕空间坐标轴" class="headerlink" title="旋转矩阵（绕空间坐标轴"></a>旋转矩阵（绕空间坐标轴</h3><ul>
<li>绕X轴旋转θ度</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/0f3d1e1db0b0f.JPG" alt="IMG_0242"></p>
<ul>
<li>绕Y轴旋转θ度</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/ccd73fa6809c0.JPG" alt="IMG_0243"></p>
<ul>
<li>绕Z轴旋转θ度</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/0167dd7b2dd2a.JPG" alt="IMG_0244"></p>
<ul>
<li>旋转矩阵的逆矩阵：旋转相反角度得到的变换矩阵。旋转矩阵是正交矩阵，且多个旋转矩阵之间的串联同样是正交的。</li>
</ul>
<h3 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h3><ul>
<li>由于使用的是列矩阵，阅读顺序从右往左（？</li>
<li>绝大多数情况下，约定变换的顺序就是先缩放，再旋转，最后平移</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/c1aa9f08f8af1.JPG" alt="IMG_0245"></p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/fbd887a63e638.JPG" alt="IMG_0246"></p>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/14aa3946cfc65.JPG" alt="IMG_0247"></p>
<ul>
<li>世界坐标下（坐标轴不变），Unity中旋转顺序是zxy</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/06/29/c843828f47d5f.JPG" alt="IMG_0248"></p>
<h2 id="坐标空间"><a href="#坐标空间" class="headerlink" title="坐标空间"></a>坐标空间</h2><ul>
<li>关注如何使用以上这些基本变换来对坐标空间进行变换</li>
<li>一些概念只有在特定的坐标空间下才有意义</li>
</ul>
<h3 id="坐标空间的变换"><a href="#坐标空间的变换" class="headerlink" title="坐标空间的变换"></a>坐标空间的变换</h3><ul>
<li><p>例子：需求——点/矢量在父子空间之间互换</p>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/d1b2d09b35430.png" alt="image-20220629202408397"></p>
</li>
<li><p>过程：坐标空间原点，沿x移动a个单位，沿y轴移动b个单位，沿z轴移动c个单位</p>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/70243e098437d.png" alt="image-20220629202654052"></p>
</li>
<li><p>结果分析</p>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/cc8a250f07cb5.png" alt="image-20220629202855142"></p>
<blockquote>
<p>到最后式子还存在加法表达式，即平移变换。为了得到更漂亮的结果，把式子扩展到齐次坐标空间中</p>
</blockquote>
</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/4af7ca20407de.png" alt="image-20220629202807457"></p>
<blockquote>
<p>具体是怎么算的已经看晕，有缘再解</p>
<ul>
<li>两种空间转换可通过求逆矩阵得</li>
<li><strong>变换矩阵</strong>：3个坐标轴依次放入矩阵的前3列，把原点矢量放到最后一列，再用0和1填充最后一行</li>
</ul>
</blockquote>
<ul>
<li><p>反向推导子空间的原点和坐标轴方向（待机中……</p>
</li>
<li><p>对方向矢量的坐标空间变换</p>
<ul>
<li>平移坐标系的原点是不会对矢量造成影响的（与位置无关。那么对矢量的坐标空间变换就可以用3×3的矩阵来表示，因为不需要平移变换。</li>
</ul>
<blockquote>
<p>在Shader中，常常看到截取变换矩阵的前3行3列来对法线方向、光照方向来进行空间变换，这就是原因所在</p>
</blockquote>
</li>
<li><p>如果变换矩阵是正交矩阵，则逆矩阵直接等于其转置矩阵。</p>
</li>
</ul>
<h3 id="顶点的坐标空间变换过程"><a href="#顶点的坐标空间变换过程" class="headerlink" title="顶点的坐标空间变换过程"></a>顶点的坐标空间变换过程</h3><h4 id="模型空间（model-object-local-space"><a href="#模型空间（model-object-local-space" class="headerlink" title="模型空间（model/object/local space)"></a>模型空间（model/object/local space)</h4><ul>
<li>自然方向：前后左右上下</li>
<li>Unity在模型空间中使用的是左手坐标系，+x轴、+y轴、+z轴分别对应模型的右、上和前</li>
<li>模型空间的原点和坐标轴通常是由美术人员制定好的</li>
<li>可以在<u>顶点着色器</u>访问到模型的顶点信息，这些坐标都是相对于<u>模型空间</u>中的原点定义的</li>
</ul>
<h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><ul>
<li>最外层的坐标空间</li>
<li>同样使用了左手坐标系</li>
</ul>
<h4 id="第一步：模型空间——-gt-世界空间【模型变换】"><a href="#第一步：模型空间——-gt-世界空间【模型变换】" class="headerlink" title="第一步：模型空间——&gt;世界空间【模型变换】"></a>第一步：模型空间——&gt;世界空间【模型变换】</h4><p><img src="https://pic.jitudisk.com/public/2022/07/05/787b53086b5ec.png" alt="image-20220630151833057"></p>
<h4 id="第二步：世界空间——-gt-观察空间【观察变换】"><a href="#第二步：世界空间——-gt-观察空间【观察变换】" class="headerlink" title="第二步：世界空间——&gt;观察空间【观察变换】"></a>第二步：世界空间——&gt;观察空间【观察变换】</h4><ul>
<li>观察空间：<ul>
<li>在此空间中，摄像机位于原点</li>
<li>Unity中观察空间的坐标轴：+x指向右方，+y指向上方，+z指向<strong>后方</strong>（右手坐标系，符合OpenGL传统）</li>
</ul>
</li>
<li>方法①【父子空间】：子——&gt;父的变换矩阵，再求逆</li>
<li>方法②【空间变换】：观察空间和顶点同时进行同样的变换而保持相对位置不变，这样的话保证拍出来的东西是一样的。为什么要把摄像机弄到原点呢？因为摄像机可能的位置角度非常多，而放在原点像坐标轴那样规范放好，有利于简化计算。摄像机放回原点的变换矩阵不好求，那就逆向来想。这样求得的矩阵变回逆矩阵就好。</li>
</ul>
<blockquote>
<p>注意区分同一空间的顶点变换 和 顶点坐标空间的变换。就所学到的而言，顶点变换就是旋转缩放平移，而后者则需要子空间的原点和坐标轴信息。</p>
</blockquote>
<h4 id="第三步：观察空间——-gt-（齐次）裁剪空间"><a href="#第三步：观察空间——-gt-（齐次）裁剪空间" class="headerlink" title="第三步：观察空间——&gt;（齐次）裁剪空间"></a>第三步：观察空间——&gt;（齐次）裁剪空间</h4><ul>
<li><p><u>用于变换的矩阵</u>叫做裁剪矩阵，也称为投影矩阵</p>
</li>
<li><p>目标：能够方便地对渲染图元进行裁剪</p>
</li>
<li><p>空间：视锥体，六个平面包围而成，平面也被称为裁剪平面。</p>
<ul>
<li>正交投影</li>
<li>透视投影</li>
</ul>
</li>
<li><p>如果直接使用视锥体定义的空间来进行裁剪，不同的视锥体就要有不同的处理过程。用一种更加通用、方便和简洁的方式来进行裁剪工作——通过一个投影矩阵把顶点转换到一个<strong>裁剪空间</strong>中。</p>
</li>
<li><p>投影矩阵的目的：为投影做准备；对x、y、z分量进行缩放。</p>
</li>
</ul>
<blockquote>
<p>透视投影(详细看书，还需斟酌)</p>
</blockquote>
<ul>
<li>**构成投影矩阵M(frustum)**：建立在Unity坐标系上。根据已知的Near（近裁剪平面）、Far、FOV（视觉上下角度）和Aspect（摄像机的纵横比：由Game视图的纵横比和ViewPort Rect中的W和H属性共同决定）的值来确定</li>
<li>顶点和投影矩阵相乘，从<strong>观察空间转换到裁剪空间</strong>：P(clip) = M(frustum) P(view)<ul>
<li>矩阵本质就是对x、y、z分量进行了不同程度的缩放，缩放的目的是为了方便裁剪。而w分量不再是1，而是原先z分量的取反结果</li>
</ul>
</li>
<li><strong>判断</strong>顶点是否位于视锥体内：如果在，变换后的坐标必须满足-w≤x/y/z≤w.</li>
</ul>
<blockquote>
<p>正交投影</p>
</blockquote>
<ul>
<li>确定裁剪矩阵：根据Near、Far、Size和Aspect</li>
<li>P(clip) = M(otho) P(view)</li>
<li>变换后w分量仍为1</li>
<li>判断如上</li>
</ul>
<h4 id="第四步：裁剪空间——-gt-屏幕空间"><a href="#第四步：裁剪空间——-gt-屏幕空间" class="headerlink" title="第四步：裁剪空间——&gt;屏幕空间"></a>第四步：裁剪空间——&gt;屏幕空间</h4><ul>
<li>完成了所有的裁剪工作后，进行真正的投影。</li>
</ul>
<blockquote>
<p>①标准齐次除法（透视除法）</p>
</blockquote>
<ul>
<li>用齐次坐标系的w分量去除x、y、z分量。在这OpenGL中，把这一步得到的坐标叫做<strong>归一化的设备坐标(Normalized Device Coordinates, NDC)</strong>. 变换到一个立方体内</li>
</ul>
<blockquote>
<p>②根据变换后的x和y坐标来映射输出窗口的对应像素坐标</p>
</blockquote>
<ul>
<li>在Unity中，屏幕空间左下角的像素坐标是（0，0）.由于当前x和y坐标都是[-1,1]，所以这个映射的过程就是一个缩放的过程。</li>
</ul>
<blockquote>
<p>齐次除法和屏幕映射的过程可以用一个公式来总结</p>
</blockquote>
<ul>
<li>关于z分量：通常z分量会被用于深度缓冲。，，，</li>
<li>顶点着色器：在Unity中，裁剪空间到屏幕空间的转换是底层帮助完成的。顶点着色器只需要把顶点转换到裁剪空间即可。</li>
</ul>
<h4 id="补充【games101】"><a href="#补充【games101】" class="headerlink" title="补充【games101】"></a>补充【games101】</h4><p>这个思路是直接从观察空间压缩到<strong>归一化的齐次</strong>裁剪空间。而精要是先把观察空间转换到裁剪空间中，然后再通过w分量除x、y、z分量来归一化。所以变换矩阵会有所区别？</p>
<ul>
<li>正交投影</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/33b561a6b67dd.png" alt="image-20220703092233636"></p>
<blockquote>
<p>先平移，后缩放</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/6feb671426107.png" alt="image-20220703092548255"></p>
<ul>
<li>透视投影</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/d8c309ec0b56c.png" alt="image-20220703093014365"></p>
<blockquote>
<p>远裁剪平面按照规则缩放成右图。</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/59046d7783ab6.png" alt="image-20220703093303961"></p>
<blockquote>
<p>先从侧面看，找到变换前后的关系。【注意，这里的分母用了z。如果对于近远平面都适用的话，z可以等于n，也可以等于f。】</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/6b1e483b977a2.png" alt="image-20220703093823668"></p>
<blockquote>
<p>从顶视图来看，再找到x的关系；</p>
<p>下面：（x,y,z,1）T变换成右侧样式，然后再乘以z，点不变。</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/e5147459cac46.png" alt="image-20220703094052599"></p>
<blockquote>
<p>上：透视投影变换成正交投影的结果。变换矩阵M 坐标点 = 远坐标点。</p>
<p>下：推导出变换矩阵。还剩余一行需要被填补</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/5bd00b03d64c4.png" alt="image-20220703094418291"></p>
<blockquote>
<p>可利用信息：近/远裁剪平面的z都不变</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/5bb48f0451857.png" alt="image-20220703094827259"></p>
<blockquote>
<p>【如果近远通用的前提成立】那么近平面的条件可以使用：z=n时，变化前后都相等，但是都乘以n后，保持不变的同时格式也相符。</p>
<p>下：变换矩阵第三行肯定与x，y无关，所以头两个先确定为0</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/2c282bbb59eda.png" alt="image-20220703100254697"></p>
<blockquote>
<p>上：从近平面来说</p>
<p>下：从远平面来说，中心点不变，得出来一个等式</p>
</blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/eda9864f60191.png" alt="image-20220703100647123"></p>
<blockquote>
<p>完成变换矩阵的补充。</p>
</blockquote>
<h3 id="法线变换"><a href="#法线变换" class="headerlink" title="法线变换"></a>法线变换</h3><ul>
<li><p>在游戏中，模型的一个顶点往往会携带额外的信息，而顶点法线就是其中一种</p>
</li>
<li><p>变换一个模型的时候，不仅要变换顶点，<strong>还要变换法线</strong>，以便在后续处理（如片元着色器）中计算光照等</p>
</li>
<li><p><strong>切线</strong>是由两个顶点之间的差值计算得到的，因此可以直接使用用于变换顶点的变换矩阵来变换切线。</p>
</li>
<li><p>进行非统一缩放时，如果使用<u>变换顶点的变换矩阵</u>来变换法线，会得到<strong>错误结果</strong></p>
</li>
<li><p>经推导，应用原变换矩阵的逆矩阵。避免计算逆矩阵的情况如下：</p>
<blockquote>
<p>原变换矩阵是正交矩阵，只需转置；</p>
<p>只包括旋转——变换矩阵是正交矩阵；</p>
<p>只包括旋转和统一缩放——系数k；</p>
<p>而包含了统一变换则必须求解逆矩阵。</p>
</blockquote>
</li>
</ul>
<h1 id="第5章-开始Shader代码编写"><a href="#第5章-开始Shader代码编写" class="headerlink" title="第5章 开始Shader代码编写"></a>第5章 开始Shader代码编写</h1><h2 id="一个最简单的顶点-片元着色器"><a href="#一个最简单的顶点-片元着色器" class="headerlink" title="一个最简单的顶点/片元着色器"></a>一个最简单的顶点/片元着色器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter5/SimpleShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM   //---CG代码片段</span><br><span class="line"></span><br><span class="line">            /*编译指令*/</span><br><span class="line">            //告诉Unity，第一个自定义函数vert包含了顶点着色器代码</span><br><span class="line">            //第二个自定义函数frag包含了片元着色器代码</span><br><span class="line">            #pragma vertex vert     </span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            /*顶点着色器*/</span><br><span class="line">            //逐顶点执行</span><br><span class="line">            //语法：类型 函数名（输入参数）：语义 //主要是限制返回类型的含义</span><br><span class="line">            //例：vert函数返回裁剪空间（SV_POSITION）中的float4类型坐标</span><br><span class="line">            //    其中输入参数v被限制为模型的顶点坐标</span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITION &#123;</span><br><span class="line">                return UnityObjectToClipPos (v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag() : SV_TARGET&#123;</span><br><span class="line">                return fixed4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG       //---CG代码片段</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Unity升级到5.6及以后，所有跟UNITY_MATRIX_MVP运算的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">矩阵</a>或者向量的mul方法，会被自动转成UnityObjectToClipPos方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float4×4 m = mul(UNTIY_MATRIX_MVP, RM);</span><br><span class="line"></span><br><span class="line">float4×4 m = UnityObjectToClipPos(RM);</span><br></pre></td></tr></table></figure>

<p>In the past, we uses <code>mul(UNITY_MATRIX_MVP, v.vertex)</code> to convert vertex position from local to world space. <em>v.vertex</em> is <em>float4</em> which has w component.</p>
<p>But in most cases w is = 1. To make vertex shader run faster, Unity replaced it with <code>UnityObjectToClipPos(float3 pos)</code>, which ignores w component even you pass a <em>float4</em> position instead of <em>float3</em>.</p>
<p>For some advanced users who still need the w component in their custom shaders, here is a cheaper <strong>UnityObjectToClipPos()</strong> function which respects the w component!</p>
</blockquote>
<h3 id="获取更多的模型数据"><a href="#获取更多的模型数据" class="headerlink" title="获取更多的模型数据"></a>获取更多的模型数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    CGPROGRAM   //---CG代码片段</span><br><span class="line"></span><br><span class="line">    #pragma vertex vert     </span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    struct a2v&#123;</span><br><span class="line">    	float4 vertex : POSITION;</span><br><span class="line">    	float3 normal : NORMAL;     //模型空间的法线</span><br><span class="line">    	float4 texcoord : TEXCOORD; //模型的第一套纹理坐标填充texcoord变量</span><br><span class="line">    &#125;;                          	//不要漏了分号</span><br><span class="line"></span><br><span class="line">    float4 vert(a2v v) : SV_POSITION &#123;</span><br><span class="line">    	return UnityObjectToClipPos (v.vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag() : SV_TARGET&#123;</span><br><span class="line">    	return fixed4(1.0, 1.0, 1.0, 1.0);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG       //---CG代码片段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取模型更多的信息：结构体。结构体必须包含语义；</p>
<p>a2v命名含义：把数据从应用阶段传递到顶点着色器；</p>
<p>语义中的数据来源：Unity中该材质的Mesh Render组件提供。每帧调用Draw Call时，会把它负责渲染的模型数据发送给Unity Shader。</p>
</blockquote>
<h3 id="顶点着色器和片元着色器之间如何通信"><a href="#顶点着色器和片元着色器之间如何通信" class="headerlink" title="顶点着色器和片元着色器之间如何通信"></a>顶点着色器和片元着色器之间如何通信</h3><p>​    在实践中往往希望从顶点着色器输出一些数据，例如把模型的法线、纹理坐标等递给片元着色器。顶点着色器是逐顶点用的，片元着色器是逐片元用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">    CGPROGRAM  </span><br><span class="line"></span><br><span class="line">    #pragma vertex vert     </span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    struct a2v&#123;</span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float3 normal : NORMAL;     </span><br><span class="line">        float4 texcoord : TEXCOORD; </span><br><span class="line">    &#125;;       </span><br><span class="line"></span><br><span class="line">    /*顶点着色器的输出*/</span><br><span class="line">    struct v2f&#123;</span><br><span class="line">        float4 pos : SV_POSITION;</span><br><span class="line">        fixed3 color : COLOR0;      //COLOR0可以用于存储颜色信息</span><br><span class="line">    &#125;;                       </span><br><span class="line"></span><br><span class="line">    v2f vert(a2v v) &#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.color = v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">    	return fixed4(i.color, 1.0);</span><br><span class="line">    &#125;</span><br><span class="line">    ENDCG      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何使用属性"><a href="#如何使用属性" class="headerlink" title="如何使用属性"></a>如何使用属性</h3><p>Properties语义块以及参数使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">        _Color(&quot;Color Tint&quot;, Color) = (1.0, 1.0, 1.0, 1.0)  //没有分号</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM  </span><br><span class="line"></span><br><span class="line">            #pragma vertex vert     </span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;      //需要在Cg代码中定义一个与属性名称和类型都匹配的变量</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;     </span><br><span class="line">                float4 texcoord : TEXCOORD; </span><br><span class="line">            &#125;;       </span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR0;     </span><br><span class="line">            &#125;;                       </span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.color = v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                fixed3 c = i.color;</span><br><span class="line">                c *= _Color.rgb;    //使用属性来控制颜色</span><br><span class="line">                return fixed4(c, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Unity-提供的内置文件和变量"><a href="#Unity-提供的内置文件和变量" class="headerlink" title="Unity 提供的内置文件和变量"></a>Unity 提供的内置文件和变量</h2><p>为了方便开发者的编码过程，Unity提供了很多内置文件，包含了很多提前定义的函数、变量和宏。</p>
<ul>
<li>一些常用包含文件以及定义的结构体、函数等。</li>
</ul>
<h1 id="第6章-Unity中的基础光照"><a href="#第6章-Unity中的基础光照" class="headerlink" title="第6章 Unity中的基础光照"></a>第6章 Unity中的基础光照</h1><h2 id="我们是如何看到这个世界的"><a href="#我们是如何看到这个世界的" class="headerlink" title="我们是如何看到这个世界的"></a>我们是如何看到这个世界的</h2><ul>
<li>光源</li>
<li>光线和场景中的一些物体相交：一些光线被物体吸收了，另一些被散射到其它方向</li>
<li>摄像机吸收了一些光，产生了一张图像</li>
</ul>
<h3 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h3><ul>
<li><strong>方向</strong>：通常把光源当作一个没有体积的点，用**/**来表示它的方向。</li>
<li><strong>辐照度</strong>：量化光。对于平行光来说，可通过计算 垂直于/的单位面积上 单位时间内 穿过的能量来得到。在计算光照模型时需要知道一个物体表面的辐射度。</li>
</ul>
<h3 id="吸收和散射"><a href="#吸收和散射" class="headerlink" title="吸收和散射"></a>吸收和散射</h3><p>光线从光源发射出来后，就会与一些物体相交。通常相交的结果有两个：散射（scattering）和吸收（absorption）。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">改变光线的密度和颜色</th>
<th align="center">改变光线的方向</th>
</tr>
</thead>
<tbody><tr>
<td align="center">散射</td>
<td align="center">N</td>
<td align="center">Y</td>
</tr>
<tr>
<td align="center">吸收</td>
<td align="center">Y</td>
<td align="center">N</td>
</tr>
</tbody></table>
<blockquote>
<p>散射</p>
</blockquote>
<ul>
<li>散射到<strong>物体内部</strong>，这种现象被称为折射或透射。</li>
</ul>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/727ed048952d1.png" alt="image-20220703154358052"></p>
<blockquote>
<p>对于不透明物体，折射的光线会在物体内部继续传播，最终有一部分光线会重新从物体表面被发射出去</p>
</blockquote>
<ul>
<li><p>散射到<strong>外部</strong>——反射。</p>
</li>
<li><p>为了区分两种不同的散射方向，在光照模型中使用了不同的部分来计算它们</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高光反射</td>
<td align="center">表示物体是如何反射光线的</td>
</tr>
<tr>
<td align="center">漫反射</td>
<td align="center">表示有多少光线会被折射、吸收和散射出表面</td>
</tr>
</tbody></table>
<ul>
<li><strong>出射度</strong>：出射光线的数量和方向；辐射度和出射度之间满足线性关系，比值就是材质的漫反射和高光反射属性（本章假定漫反射没有方向性，光线在所有方向上都是平均分布的）</li>
</ul>
<h3 id="着色（shading）"><a href="#着色（shading）" class="headerlink" title="着色（shading）"></a>着色（shading）</h3><table>
<thead>
<tr>
<th align="center">条件1</th>
<th align="center">条件2</th>
<th align="center">结果</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center">光源信息（如光源方向、辐照度）</td>
<td align="center">材质属性（如漫反射属性等）</td>
<td align="center">沿某个观察方向的出射度（一个等式计算）</td>
<td>这个等式被称为<strong>光照模型</strong></td>
</tr>
</tbody></table>
<h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p>①只关心直接光照：直接从光源发射出来照射到物体表面后，经过物体表面的<strong>一次反射</strong>直接进入摄像机的光线；无法表现很多重要的物理现象（菲涅尔/各向异性的表面如毛发等）。</p>
<p>②基本方法——把进入到摄像机内的光线分成4个部分，每个部分用一种方法来计算它的贡献度：</p>
<p>​    自发光（emissive）：一个表面本身，向给定的方向<u>发射</u>多少辐射量。</p>
<p>​    高光反射（specular）：在<strong>完全镜面反射方向</strong><u>散射</u>多少辐射量。</p>
<p>​    漫反射（diffuse）：模型表面向<strong>每个方向</strong><u>散射</u>多少辐射量。</p>
<p>​    环境光（ambient）：其它所有的间接光照。</p>
<blockquote>
<p>体现了多种情况下，光源信息和材质属性共同作用下得出不同的出射度。</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>公式</th>
</tr>
</thead>
<tbody><tr>
<td>环境光</td>
<td>近似模拟间接光照（全局变量）</td>
<td><img src="https://pic.jitudisk.com/public/2022/07/05/2e12deaf0ecab.JPG" alt="IMG_0255"></td>
</tr>
<tr>
<td>自发光</td>
<td>不经过物体反射的光源（？</td>
<td><img src="https://pic.jitudisk.com/public/2022/07/05/be1f4e23df8b5.JPG" alt="IMG_0257"></td>
</tr>
<tr>
<td>漫反射</td>
<td>视角位置不重要，入射光线角度很重要；兰伯特定律①</td>
<td><img src="https://pic.jitudisk.com/public/2022/07/05/7b74d4490f615.JPG" alt="IMG_0258">②</td>
</tr>
<tr>
<td>高光反射</td>
<td>沿着完全镜面反射方向被反射的光线</td>
<td><img src="https://pic.jitudisk.com/public/2022/07/05/0ba4f260dfc25.JPG" alt="IMG_0260(20220703-164839)"><img src="https://pic.jitudisk.com/public/2022/07/05/b06af7ceb1579.JPG" alt="IMG_0259">③</td>
</tr>
</tbody></table>
<blockquote>
<p>①反射光线的强度与 表面法线和光源方向之间夹角的余弦值 成正比（夹角越小cosθ越大，反射越强）</p>
<p>②兰伯特公式符号：<strong>n</strong>是表面法线，l是指向光源的单位向量，<strong>m</strong>（diffuse）是材质的漫反射颜色，<strong>c</strong>（light）是光源颜色。要防止法线和光源方向点乘的结果是负值。【与法线、光线有关】</p>
<p>③高光反射还和观察视角有关。其中反射方向<strong>r</strong>可由法线方向<strong>n</strong>、光线方向<strong>l</strong>求出；</p>
<ul>
<li><p>Phong模型：如表格所示公式。与漫反射比较，主要区别是<strong>观察＆反射</strong>方向，漫反射因为和观察角度无关，注重光线和法线（？。其他的，<strong>m</strong>（gloss）是材质的光泽度（gloss），也称为反光度（shininess），用于控制高光区域的”亮点“有多宽，值越大，亮点越小。<strong>m</strong>（specular）是材质的高光反射颜色。</p>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/8d3b94eac7eeb.JPG" alt="IMG_0263"></p>
</li>
<li><p>Blinn模型：相比于Phong提出一个简单的修改方法来得到类似的效果。基本思想：避免计算反射方向<strong>r</strong>。因此引用了一个新的矢量<strong>h</strong>。</p>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/4343d9404308b.JPG" alt="IMG_0261"></p>
<p><strong>h</strong>由<strong>v</strong>和<strong>l</strong>取平均后再归一化得到的。</p>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/8702f4c0be8d0.JPG" alt="IMG_0262"></p>
<p>然后再用<strong>n</strong>和<strong>h</strong>的夹角进行计算。</p>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/4937a0d403a89.JPG" alt="IMG_0264(20220703-170923)"></p>
</li>
</ul>
</blockquote>
<p>【夹角——向量点乘cos——反映光照强度】那颜色点乘……？</p>
<h3 id="逐像素还是逐顶点"><a href="#逐像素还是逐顶点" class="headerlink" title="逐像素还是逐顶点"></a>逐像素还是逐顶点</h3><ul>
<li><p><strong>逐像素光照</strong>（per-pixel lighting）：在<strong>片元着色器</strong>中计算基本光照模型的数学公式。</p>
<p>以每个像素为基础，得到它的<strong>法线</strong>（对顶点法线插值得到 || 从法线纹理中采样得到），然后进行光照模型的计算。这种<u>在面片之间对顶点法线进行插值的技术被称为Phong着色</u>（Phong Shading）。这不同于Phong光照模型。</p>
</li>
<li><p><strong>逐顶点光照</strong>（per-vertex lighting）：在顶点着色器。</p>
<p>在每个顶点中计算光照，然后会在渲染图元内部进行线性插值，最后输出像素颜色。</p>
</li>
<li><p>由于顶点数目往往远远小于像素数目，因此逐顶点光照<strong>计算量</strong>往往远远小于像素光照；</p>
<p>顶点依赖于【线性插值？】</p>
</li>
</ul>
<h2 id="在Unity-Shader中实现漫反射光照模型"><a href="#在Unity-Shader中实现漫反射光照模型" class="headerlink" title="在Unity Shader中实现漫反射光照模型"></a>在Unity Shader中实现漫反射光照模型</h2><h3 id="逐顶点光照"><a href="#逐顶点光照" class="headerlink" title="逐顶点光照"></a>逐顶点光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_World2Object&#x27; with &#x27;unity_WorldToObject&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Chapter6/DiffuseVertexLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            //LightMode标签是Pass标签的一种</span><br><span class="line">            //用于定义该Pass在Unity的光照流水线中的角色</span><br><span class="line">            //只有正确定义了正确的LightMode，才能得到一些Unity的内置光照变量</span><br><span class="line">            //Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                /*漫反射光照*/</span><br><span class="line">                //法线和光源处在同一坐标空间下点积才有意义</span><br><span class="line">                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));</span><br><span class="line">                //_WorldSpaceLightPos0只适用于平行光</span><br><span class="line">                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));  //saturate：把参数截取在[0,1]内</span><br><span class="line">                o.color = diffuse + ambient;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                return fixed4(i.color, 1.0);</span><br><span class="line">                //return fixed4(0.5,0.5,0.5,1);   //sucess</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：Tags { “LightMode” = “ForwardBase” }这句话好像导致基本的颜色都输出不了。去掉之后，ambient和diffuse也没起效果。这是为什么呢？？？经测验是项目的问题，不知道动了哪里就生成很多警告，可能和警告有关。再进一步，可能和渲染管线有关，没有URP的话是正常的，有了URP即使新建了项目没有警告效果还是紫色没有生效……</p>
</blockquote>
<p>而对于细分程度较低的模型，可能会出现锯齿。（因为顶点较疏？</p>
<h3 id="逐像素光照"><a href="#逐像素光照" class="headerlink" title="逐像素光照"></a>逐像素光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// Upgrade NOTE: replaced &#x27;_World2Object&#x27; with &#x27;unity_WorldToObject&#x27;</span><br><span class="line"></span><br><span class="line">Shader &quot;Chapter6/DiffusePixelLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            Name &quot;FORWARD&quot;</span><br><span class="line">            //LightMode标签是Pass标签的一种</span><br><span class="line">            //用于定义该Pass在Unity的光照流水线中的角色</span><br><span class="line">            //只有正确定义了正确的LightMode，才能得到一些Unity的内置光照变量</span><br><span class="line">            Tags &#123; </span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot; </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 worldNormal : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //只需把法线传给片元着色器</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"></span><br><span class="line">                float lambert = saturate(dot(worldLightDir, worldNormal));</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line">                fixed3 color = ambient + diffuse;</span><br><span class="line"></span><br><span class="line">                return fixed4(color, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack &quot;Diffuse&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取顶点的法线，然后在片元着色器内进行处理，生成颜色。逐像素关照可以得到更加平滑的光照效果。</p>
</blockquote>
<h3 id="半兰伯特模型"><a href="#半兰伯特模型" class="headerlink" title="半兰伯特模型"></a>半兰伯特模型</h3><p>点积的值*0.5 + 0.5，思想是将值统一映射到[0,1]内，没有物理依据。</p>
<h2 id="实现高光反射光照模型"><a href="#实现高光反射光照模型" class="headerlink" title="实现高光反射光照模型"></a>实现高光反射光照模型</h2><h3 id="逐顶点光照-1"><a href="#逐顶点光照-1" class="headerlink" title="逐顶点光照"></a>逐顶点光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter6/SpecularVertexLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2f&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                fixed3 color : COLOR;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2f v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                /*漫反射部分*/</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                /*高光部分*/</span><br><span class="line">                //reflect(i,n):n为法线方向，i是入射，要求由光源指向交点处</span><br><span class="line">                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - UnityObjectToClipPos(v.vertex).xyz);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                o.color = ambient + diffuse + specular;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                return fixed4(i.color, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/f8c88a6609c2d.png" alt="image-20220705104418177"></p>
<p>高光部分明显不平滑。主要因为高光反射部分的计算是非线性的，而在顶点着色器中计算光照再插值的过程是线性的【具体在哪里体现？】，破坏了原计算的非线性关系，就会出现较大的视觉问题。</p>
</blockquote>
<h3 id="逐像素光照-1"><a href="#逐像素光照-1" class="headerlink" title="逐像素光照"></a>逐像素光照</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter6/SpecularPixelLevel&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Diffuse (&quot;Diffuse&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Diffuse;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2f&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float3 worldNormal : TEXCOORD0;</span><br><span class="line">                float3 worldPos : TEXCOORD1;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2f v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line"></span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                //世界空间下的法线方向和顶点坐标</span><br><span class="line">                o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                o.worldPos = o.pos.xyz;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET &#123;</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br><span class="line"></span><br><span class="line">                fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br><span class="line"></span><br><span class="line">                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br><span class="line"></span><br><span class="line">                return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback &quot;Specular&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/ea90e1c8995ee.png" alt="image-20220705105908989"></p>
<p>明显会更光滑些</p>
</blockquote>
<h3 id="Blinn-Phong-模型"><a href="#Blinn-Phong-模型" class="headerlink" title="Blinn-Phong 模型"></a>Blinn-Phong 模型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);</span><br><span class="line">fixed3 halfDir = normalize(worldLightDir + viewDir);	//</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(worldNormal, halfDir)), _Gloss);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://pic.jitudisk.com/public/2022/07/05/a6042a7c86767.png" alt="image-20220705110710127"></p>
<p>（右三）可以看出这个模型的高光更大更亮一些，是通常情况下的选择。这两种光照模型都是<strong>经验模型</strong>【对真实场景进行理想化和简化后的模型。并不能真实地反映物体和光线之间的交互】</p>
</blockquote>
<h2 id="使用Unity内置的函数"><a href="#使用Unity内置的函数" class="headerlink" title="使用Unity内置的函数"></a>使用Unity内置的函数</h2><p>麻烦之处：手动找变量并计算很麻烦；判断特殊光源如点光源等就很复杂。</p>
<ul>
<li>UnityCG.cgnic中一些常用的帮助函数。（实践当中其实只加了Lighting.cginc，但还是正常）</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">输入</th>
<th align="center">返回</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WorldSpaceViewDir()</td>
<td align="center">float4 v：一个模型空间中的顶点位置</td>
<td align="center">float3：世界空间中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td align="center">UnityWorldSpaceViewDir()</td>
<td align="center">float4 v:一个世界空间中的顶点位置</td>
<td align="center">float3：世界空间中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td align="center">ObjSpaceViewDir()</td>
<td align="center">float4 v:一个模型空间中的顶点位置</td>
<td align="center">float3：模型空间中从该点到摄像机的观察方向</td>
</tr>
<tr>
<td align="center">WorldSpaceLightDir()*</td>
<td align="center">float4 v：一个模型空间中的顶点位置</td>
<td align="center">float3：世界空间中从该点到光源的光照方向</td>
</tr>
<tr>
<td align="center">UnityWorldSpaceLightDir()*</td>
<td align="center">float4 v：一个世界空间中的顶点位置</td>
<td align="center">float3：世界空间中从该点到光源的光照方向</td>
</tr>
<tr>
<td align="center">ObjSpaceLightDir()*</td>
<td align="center">float4 v：一个模型空间中的顶点位置</td>
<td align="center">float3：模型空间中从该点到光源的光照方向</td>
</tr>
<tr>
<td align="center">UnityObjectToWorldNormal()</td>
<td align="center">float3 norm：模型空间的法线</td>
<td align="center">float3：转换到世界空间中</td>
</tr>
<tr>
<td align="center">UnityObjectToWorldDir()</td>
<td align="center">float3 dir：模型空间中的方向矢量</td>
<td align="center">float3：转换到世界空间中</td>
</tr>
<tr>
<td align="center">UnityWorldToObjectDir()</td>
<td align="center">float3 dir：世界空间中的方向矢量</td>
<td align="center">float3：转换到模型空间中</td>
</tr>
</tbody></table>
<p>*：仅可用于前向渲染中。</p>
<p>PS：这些函数得到的方向都是没有归一化的。</p>
<p>这些函数让我们不需要考虑光源情况。</p>
<h1 id="第7章-基础纹理"><a href="#第7章-基础纹理" class="headerlink" title="第7章 基础纹理"></a>第7章 基础纹理</h1><ul>
<li><strong>纹理映射技术</strong>：把一张图“黏”在模型表面，逐纹素地控制模型颜色。</li>
<li><strong>纹理映射坐标（uv坐标）</strong>：把模型顶点对应的2D坐标存储在每个顶点上。<ul>
<li>归一化：纹理大小多种多样，但顶点uv坐标的范围通常都是被归一化到【0，1】内。有时纹理采样时的纹理坐标不在这范围内，但是有时会非常有用。</li>
<li>纹理的平铺模式：决定渲染引擎在遇到不在【0，1】范围内的纹理坐标如何进行纹理采样。</li>
</ul>
</li>
<li>OpenGL和DirectX在二维纹理空间中的坐标系差异：OpenGL——原点在左下角；后者在左上角。Unity中使用的一般是OpenGL的（会处理这种差异问题）。</li>
</ul>
<h2 id="单张纹理"><a href="#单张纹理" class="headerlink" title="单张纹理"></a>单张纹理</h2><p>（a2f）texcoord : TEXCOORD0 ——&gt;①顶点着色器（纹理坐标变换—&gt;uv:TEXCOORD2）——&gt;②片元着色器（纹理采样——&gt;albedo）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">struct a2v&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct v2f&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float3 worldPos : TEXCOORD1;</span><br><span class="line">    float2 uv : TEXCOORD2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//①</span><br><span class="line">v2f vert(a2v v)&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    ...</span><br><span class="line">    o.uv = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">    //o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line">    //使用纹理坐标的属性值 来对 顶点纹理坐标 进行变换</span><br><span class="line">    //内置函数，是把纹理名字传进去找到对应的 _ST</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//②</span><br><span class="line">fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">    //纹理*固有色——材质的反射率albedo</span><br><span class="line">    //tex2D(_MainTex, i.uv):对纹理进行采样；</span><br><span class="line">    //第一个参数：需要被采样的纹理；第二个：纹理坐标，返回计算得到的纹素值</span><br><span class="line">    fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">    fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="纹理的属性"><a href="#纹理的属性" class="headerlink" title="纹理的属性"></a>纹理的属性</h3><h4 id="Texture-Type"><a href="#Texture-Type" class="headerlink" title="Texture Type"></a>Texture Type</h4><h4 id="Wrap-Mode"><a href="#Wrap-Mode" class="headerlink" title="Wrap Mode"></a>Wrap Mode</h4><p>决定了当纹理坐标超过【0，1】范围后将会如何被平铺。</p>
<ul>
<li>Repeat：如果纹理坐标超过了1，整数部分被舍弃，而直接使用小数部分来采样（取余重复）。</li>
<li>Clamp：纹理坐标大于1，那么将会截取到1，小于0则截取到0.</li>
</ul>
<h4 id="Filter-Mode"><a href="#Filter-Mode" class="headerlink" title="Filter Mode"></a>Filter Mode</h4><p>当纹理由于变换而产生拉伸时将会采用哪种滤波方式。支持三种模式：Point，Bilinear，Trilinear。它们得到的图片滤波效果逐渐提升，但需要耗费的性能也依次增大。<strong>纹理滤波</strong>会影响放大或缩放纹理时得到的图片质量（马赛克糊度）。</p>
<ul>
<li>多级渐远纹理（mipmapping）</li>
</ul>
<p>将原纹理提前用滤波处理来得到更多更小的图像，形成了一个图像金字塔，每一层都是对上一层图像降采样的结果。这样在运行时可以快速得到结果像素，例如物体远离摄像机时可以直接使用较小的纹理。缺点是空间存储较大。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/60299f7bf30b6748.png" alt="image-20220705222204054"></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/711f00732d7267ef.png" alt="image-20220705220943067"></p>
<h4 id="纹理的最大尺寸和纹理模式"><a href="#纹理的最大尺寸和纹理模式" class="headerlink" title="纹理的最大尺寸和纹理模式"></a>纹理的最大尺寸和纹理模式</h4><p>不同平台的纹理尺寸和质量不同。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/b28daa560046705e.png" alt="image-20220705221219288"></p>
<ul>
<li><p>Max Size</p>
<p>如果导入的纹理大小超过了Max Size中的值，Unity会把这个图像压缩为最大分辨率。</p>
<p>理想情况下，导入的纹理可以是非正方形的，但长宽的大小最好是2的幂，如2，4，8等。如果用了非2的幂大小（Non Power of Two, NPOT)，这些纹理往往会占用更多的内存空间，而且GPU读取该纹理的速度也会有所下降。<u>出于性能和空间的考虑，应该尽量使用2的幂大小纹理。</u></p>
</li>
<li><p>Format</p>
<p>决定Unity内部使用哪种格式来存储该纹理。如果精度要求不高，尽量使用压缩格式。</p>
</li>
</ul>
<h2 id="凹凸映射-bump-mapping"><a href="#凹凸映射-bump-mapping" class="headerlink" title="凹凸映射 bump mapping"></a>凹凸映射 bump mapping</h2><p>使用一张纹理来修改模型表面的法线，以便为模型提供更多的细节。</p>
<h3 id="高度纹理-height-map"><a href="#高度纹理-height-map" class="headerlink" title="高度纹理 height map"></a>高度纹理 height map</h3><p>使用一张高度纹理来模拟表面位移（displacement），然后得到一个修改后的法线值。</p>
<p><strong>高度图</strong>：存储的是强度值（intensity），用于表示模型表面局部的海拔高度。缺点是计算更加复杂，在实时计算时不能直接得到表面法线，而是需要由<strong>像素的灰度值计算</strong>而得，因此需要消耗更多的性能。</p>
<p>高度图通常会和法线映射一起使用，用于给出表面凹凸的额外信息。</p>
<h3 id="法线纹理-normal-map"><a href="#法线纹理-normal-map" class="headerlink" title="法线纹理 normal map"></a>法线纹理 normal map</h3><p>存储的是表面的法线方向。</p>
<ul>
<li><strong>映射</strong>：法线方向的分量范围在[-1,1]，像素分量范围是[0,1]，因此需要做一个映射——pixel = （normal + 1）/ 2.</li>
<li><strong>反映射</strong>：在Shader中对法线纹理进行纹理采样后，还需要对结果进行一次反映射的过程来得到原先的法线方向。normal = pixel * 2 - 1</li>
<li><strong>坐标空间</strong></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th align="center">模型空间</th>
<th align="center">切线空间</th>
</tr>
</thead>
<tbody><tr>
<td>法线纹理特征</td>
<td align="center">五颜六色：同一空间下法线方向各异</td>
<td align="center">浅蓝色：每个点在各自切线空间中的法线扰动方向；若法线方向不变(0,0,1)-(0.5,0.5,1)</td>
</tr>
<tr>
<td>优点</td>
<td align="center">计算更少；纹理坐标的缝合处和尖锐的尖角部分可见的缝隙较少（？</td>
<td align="center">相对法线信息—不同模型/uv动画/可重用/可压缩（仅存储xy方向推导z）</td>
</tr>
</tbody></table>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/d7b1bd096f2bca3b.png" alt="image-20220706092200233"></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/bc5ae8e6d0fb36e4.png" alt="image-20220706092217872"></p>
<h3 id="在切线空间下进行光照计算"><a href="#在切线空间下进行光照计算" class="headerlink" title="在切线空间下进行光照计算"></a>在切线空间下进行光照计算</h3><p>把光照方向、视觉方向变换到切线空间下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter7/NormalMapTangentSpace&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Colot Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0          //控制凹凸程度</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;       //float4 tangent.w分量决定切线空间中副切线的方向性</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                float3 lightDir : TEXCOORD1;</span><br><span class="line">                float3 viewDir : TEXCOORD2;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                /*纹理坐标变换*/</span><br><span class="line">                //_MainTex 和 _BumpMap 通常使用同一组纹理坐标，减少插值寄存器的使用数目</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                /*空间转换*/</span><br><span class="line">                //法线空间下的副法线：叉积得来</span><br><span class="line">                float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;</span><br><span class="line">                float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br><span class="line"></span><br><span class="line">                o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">                o.viewDir = mul(rotation, ObjSpaceViewDir(v.vertex)).xyz;</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                //获取切线空间下的观察/光源方向</span><br><span class="line">                fixed3 tangentLightDir = normalize(i.lightDir);</span><br><span class="line">                fixed3 tangentViewDir = normalize(i.viewDir);</span><br><span class="line"></span><br><span class="line">                //法线纹理采样</span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 tangentNormal;</span><br><span class="line">                tangentNormal = UnpackNormal(packedNormal);</span><br><span class="line">                tangentNormal.xy *= _BumpScale; //？？</span><br><span class="line">                tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));//？？</span><br><span class="line"></span><br><span class="line">                //贴图纹理采样</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                //光照</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(tangentLightDir, tangentNormal));</span><br><span class="line">                fixed3 halfDir = normalize(tangentLightDir + tangentViewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular * pow(saturate(dot(halfDir, tangentNormal)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>插值寄存器</strong>：这些被TEXCOORD0、TEXCOORD1、TEXCOORD2…等修饰的变量是会被存储在特定的寄存器里，然后这些数值会被<strong>插值</strong>后传递给fragment shader，因此简称为插值寄存器。除了Unity特定语义修饰的插值寄存器变量（比如SV_POSITION）等外，其他插值寄存器里存储的什么没有规定，可以是纹理坐标也可以是其他需要从vertex shader传递给fragment shader的值。</p>
<h3 id="在世界空间下进行光照计算"><a href="#在世界空间下进行光照计算" class="headerlink" title="在世界空间下进行光照计算"></a>在世界空间下进行光照计算</h3><p>把采样到的法线方向变换【需要在顶点着色器中求得变换矩阵】到世界空间下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter7/NormalMapWorldSpace&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color (&quot;Colot Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">        _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0          //控制凹凸程度</span><br><span class="line">        _Specular (&quot;Specular&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        _Gloss (&quot;Gloss&quot;, Range(8.0, 256)) = 20</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line">            sampler2D _BumpMap;</span><br><span class="line">            float4 _BumpMap_ST;</span><br><span class="line">            float _BumpScale;</span><br><span class="line">            fixed4 _Specular;</span><br><span class="line">            float _Gloss;</span><br><span class="line"></span><br><span class="line">            struct a2v&#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">                float4 tangent : TANGENT;       //float4 tangent.w分量决定切线空间中副切线的方向性</span><br><span class="line">                float4 texcoord : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f&#123;</span><br><span class="line">                float4 pos : SV_POSITION;</span><br><span class="line">                float4 uv : TEXCOORD0;</span><br><span class="line">                //一个插值寄存器（TEXCOORDn是其中一种）最多存放float4大小的变量</span><br><span class="line">                //对于矩阵，可以按行拆分成多个变量</span><br><span class="line">                //依次存储了从切线空间到世界空间的变换矩阵的行</span><br><span class="line">                //对方向矢量的变换只需要3×3矩阵</span><br><span class="line">                //但为了充分利用存储空间，把世界空间下的顶点位置存在w分量中</span><br><span class="line">                float4 TtoW0 : TEXCOORD1;</span><br><span class="line">                float4 TtoW1 : TEXCOORD2;</span><br><span class="line">                float4 TtoW2 : TEXCOORD3;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vert(a2v v)&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line"></span><br><span class="line">                /*纹理坐标变换*/</span><br><span class="line">                //_MainTex 和 _BumpMap 通常使用同一组纹理坐标，减少插值寄存器的使用数目</span><br><span class="line">                o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">                o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line"></span><br><span class="line">                /*空间转换*/</span><br><span class="line">                //世界空间下的坐标分量</span><br><span class="line">                float3 worldPos = o.pos;</span><br><span class="line">                fixed3 worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">                fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);</span><br><span class="line">                fixed3 worldBinormal = cross(worldNormal, worldTangent) * v.tangent.w;</span><br><span class="line"></span><br><span class="line">                o.TtoW0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);</span><br><span class="line">                o.TtoW1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);</span><br><span class="line">                o.TtoW2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);</span><br><span class="line"></span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag(v2f i) : SV_TARGET&#123;</span><br><span class="line">                float3 worldPos = float3(i.TtoW0.w, i.TtoW1.w, i.TtoW2.w);</span><br><span class="line">                //获取世界空间下的观察/光源方向</span><br><span class="line">                fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));</span><br><span class="line">                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));</span><br><span class="line"></span><br><span class="line">                //法线纹理采样</span><br><span class="line">                fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">                fixed3 bump = UnpackNormal(packedNormal);</span><br><span class="line">                bump.xy *= _BumpScale; //？？</span><br><span class="line">                bump.z = sqrt(1.0 - saturate(dot(bump.xy, bump.xy)));//？？</span><br><span class="line">                bump = normalize(half3(dot(i.TtoW0.xyz, bump), dot(i.TtoW1.xyz, bump), dot(i.TtoW2.xyz, bump)));</span><br><span class="line"></span><br><span class="line">                //贴图纹理采样</span><br><span class="line">                fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line"></span><br><span class="line">                //光照</span><br><span class="line">                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">                fixed3 diffuse = _LightColor0.rgb * albedo * saturate(dot(lightDir, bump));</span><br><span class="line">                fixed3 halfDir = normalize(lightDir + viewDir);</span><br><span class="line">                fixed3 specular = _LightColor0.rgb * _Specular * pow(saturate(dot(halfDir, bump)), _Gloss);</span><br><span class="line">                </span><br><span class="line">                return fixed4(ambient + diffuse + specular, 1.0);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">切线空间下</th>
<th align="center">世界空间下</th>
</tr>
</thead>
<tbody><tr>
<td align="center">效率</td>
<td align="center"><strong>√</strong> 在顶点着色器中就能完成变换</td>
<td align="center">由于要先对法线纹理进行采样，变换过程必须在frag</td>
</tr>
<tr>
<td align="center">通用性</td>
<td align="center"></td>
<td align="center"><strong>√</strong> 有时需要在世界空间下进行计算（如使用Cubemap进行环境映射）</td>
</tr>
</tbody></table>
<h3 id="Unity中的法线纹理类型"><a href="#Unity中的法线纹理类型" class="headerlink" title="Unity中的法线纹理类型"></a>Unity中的法线纹理类型</h3><p>把纹理类型设置成Normal map时到底发生了什么，为什么要这么做？</p>
<p>👉这么做可以让Unity根据不同平台对纹理进行压缩，再通过UnpackNormal函数来针对不同的压缩格式对法线纹理进行正确的采样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//UnityCG.cginc中UnpackNormal函数实现</span><br><span class="line"></span><br><span class="line">inline fixed3 UnpackNormal(fixed4 packedNormal)&#123;</span><br><span class="line">#if defined(UNITY_NO_DXT5nm)</span><br><span class="line">	return packednormal.xyz * 2 - 1;</span><br><span class="line">#else</span><br><span class="line">	return UnpackNormalDXT5nm(packedNormal);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见某些平台由于用了DXT5nm格式，需要针对这种格式对法线进行解码。</p>
</blockquote>
<p>📍<strong>DXT5nm格式</strong>的法线纹理：</p>
<p>纹素的α通道对应法线的x分量，g通道—法线的y分量，纹理的r和b通道则会被舍弃，法线的z分量可以由xy分量推导而得。因为实际上法线只有两个通道时必不可少的，使用这种压缩方法能减少法线纹理占用的内存空间。</p>
<p>📍在高度图生成法线纹理</p>
<p>导入高度图——纹理类型：Normal map——勾选Create from Grayscale</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/6e97128dffc51abd.png" alt="image-20220706163533300"></p>
<p>-Bumpiness: 凹凸程度；Filtering：使用哪种方式来计算凹凸程度（smooth使得生成后的法线纹理比较平滑/ Sharp使用Sobel滤波来生成法线）</p>
<h2 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h2><p>🦁纹理其实可以用于存储任何表面属性。其中一种常见用法就是使用渐变纹理来控制漫反射光照效果【Lambert的值映射到纹理上】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br></pre></td></tr></table></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/fd4674374f495ed3.png" alt="image-20220706172525205"></p>
<blockquote>
<p>左图在高光区域有一些黑点。这是由浮点精度造成的，当使用fixed2对渐变纹理进行采样时，理论上halfLambert的值在【0，1】之间，但可能会有1.00001这样的值出现。Repeat保留小数部分对应的是黑色，所以会有黑点。改成Clamp就能解决。</p>
</blockquote>
<h2 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h2><p>遮罩允许我们可以保护某些区域，使它们免于某些修改。</p>
<p>🎈例子1：模型的高光的反光某些区域亮一些，某些区域弱一些；</p>
<p>🎈例子2：制作地形材质要混合多张照片。</p>
<p>一般流程：通过采样得到遮罩纹理的纹素值，然后使用其中<strong>某个（某几个）通道的值来与某种表面属性进行相乘</strong>，这样，当该通道的值为0时，可以保护表面不受该属性的影响。</p>
<blockquote>
<p>遮罩纹理可以<strong>存储任何逐像素控制的表面属性</strong>。通常会充分利用一张纹理的RGBA四个通道，用于存储不同的属性。例如，把高光反射的强度存储在R通道，把边缘光照的强度存储在G通道…</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//一个实践例子</span><br><span class="line">...</span><br><span class="line">fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular * pow(saturate(dot(tangentNormal, halfDir)), _Gloss) * specularMask;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="第8章-透明效果"><a href="#第8章-透明效果" class="headerlink" title="第8章 透明效果"></a>第8章 透明效果</h1><p>🎃<strong>透明度</strong>：开启透明混合后，当一个物体被渲染到屏幕上时，每个片元除了颜色值和深度值，还有这个属性。</p>
<p>🎃<strong>实现透明效果的两种方法</strong>：透明度测试（Alpha Test）；透明度混合（Alpha Blending）。</p>
<p>​    👉透明度测试：只要一个片元的透明度不满足条件（通常是小于某个阈值），那么它对应的片元就会被舍弃。被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲产生任何影响；否则，就会按照普通的不透明物体的处理方式来处理它。不需要关闭深度写入。</p>
<p>​    👉透明度混合：这种方法可以得到真正的半透明效果。使用当前片元的透明度作混合因子，与<strong>已经存储</strong>在颜色缓冲中的颜色值进行混合，得到新的颜色。</p>
<p>🎃<strong>深度缓冲</strong>：渲染一个片元时，需要把它的深度值和已经存在于深度缓冲中的值比较（如果开启了<u>深度测试</u>）——值距离摄像机更远，不应该被渲染到屏幕上（被遮挡）；否则覆盖掉此时<u>颜色缓冲</u>中的像素值，并把深度值更新到<u>深度缓冲</u>中（如果开启了<u>深度写入</u>）。</p>
<blockquote>
<p>按这种方式的话，如果透明物体在前面，后面的不透明就被剔除掉了，导致不能透过半透明来看到后面的物体了。所以就把深度写入（ZWrite）关掉，也就是半透明的深度写入关了，这样不透明后面物体就直接进入颜色缓冲？</p>
<p>关闭深度写入意味着破坏了深度缓冲的工作机制，导致渲染顺序将变得非常重要。</p>
</blockquote>
<h2 id="渲染顺序"><a href="#渲染顺序" class="headerlink" title="渲染顺序"></a>渲染顺序</h2><p>📍应该在不透明物体渲染完后再渲染半透明物体。（不透明才有深度写入，半透明要和<u>已经存储</u>在颜色缓冲区的颜色混合，而不是直接被后来的关掉ZWrite的不透明的颜色直接覆盖）</p>
<p>📍半透明物体之间也要符合一定的渲染顺序（颜色缓冲中的混合也分先后顺序）</p>
<p>👉所以渲染引擎一般都会对物体<strong>先排序，再渲染</strong>：先渲染所有不透明物体，并开启它们的深度测试和深度写入；把半透明物体按距离摄像机的远近排序，再从后往前渲染这些半透明物体，并开启它们的深度测试但关闭深度写入。</p>
<p>🧐但是是按照整个半透明物体来进行远近区分的，所以当物体出现重叠 / 错位等情况时，就会出现错误的遮挡问题。为了减少错误排序情况， 可以尽可能让模型是凸面体，并且考虑将复杂的模型拆分成可以独立排序的多个子模型等。</p>
<h2 id="Unity-Shader的渲染顺序"><a href="#Unity-Shader的渲染顺序" class="headerlink" title="Unity Shader的渲染顺序"></a>Unity Shader的渲染顺序</h2><p><strong>渲染队列（render queue）</strong>：Unity在内部使用一系列整数索引来表示每个渲染队列，且索引号越小表示越早被渲染。使用SubShader的Queue标签来决定模型归于哪个渲染对列。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">队列索引号</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Background</td>
<td align="center">1000</td>
<td align="center">最先渲染，通常绘制背景上的物体</td>
</tr>
<tr>
<td align="center">Geometry</td>
<td align="center">2000</td>
<td align="center">默认的渲染队列。不透明物体</td>
</tr>
<tr>
<td align="center">AlphaTest</td>
<td align="center">2450</td>
<td align="center">需要透明度测试的物体</td>
</tr>
<tr>
<td align="center">Transparent</td>
<td align="center">3000</td>
<td align="center">使用透明度混合的物体</td>
</tr>
<tr>
<td align="center">Overlay</td>
<td align="center">4000</td>
<td align="center">实现叠加效果。最后渲染的物体</td>
</tr>
</tbody></table>
<h2 id="透明度测试"><a href="#透明度测试" class="headerlink" title="透明度测试"></a>透明度测试</h2><p>🦁通常在片元着色器中使用<strong>clip函数</strong>来进行透明度测试。clip是Cg中的一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void clip(float/float2/float3/float4 x);</span><br><span class="line">//参数：裁剪时使用的标量或者矢量条件</span><br><span class="line"></span><br><span class="line">void clip(float4 x)&#123;</span><br><span class="line">	if(any(x &amp;lt; 0))</span><br><span class="line">		discard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🎏实践</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">fixed4 texColor = tex2D(_MainTex, i.uv);</span><br><span class="line">//当texColor.α小于材质参数_Cutoff时，该片元就会产生完全透明效果</span><br><span class="line">clip(texCoor.a - _Cutoff);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">//不仅保证在编写的SubShader无法在当前显卡上工作时可以有代替的Shader</span><br><span class="line">//还能保证使用透明度测试的物体可以正确地向其它物体投射阴影</span><br><span class="line">Fallback &quot;Transparent/Cutout/VertexLit&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/38d198e643972a97.png" alt="image-20220707160939337"></p>
<p>🧐效果极端，要么完全透明，要么完全不透明；而且得到的透明效果在边缘处往往参差不齐，有锯齿，这是因为在边界处纹理的透明度的变化精度问题。</p>
<h2 id="透明度混合"><a href="#透明度混合" class="headerlink" title="透明度混合"></a>透明度混合</h2><p>🎃回顾透明度混合原理：使用当前片元透明度作为<strong>混合因子</strong>，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。需要关闭深度写入；打开混合模式。</p>
<p>🦁Unity提供的混合命令——<strong>Blend</strong>：混合时的函数由该指令决定。</p>
<table>
<thead>
<tr>
<th align="center">语义</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Blend Off</td>
<td align="center">关闭混合</td>
</tr>
<tr>
<td align="center">Blend SrcFactor DstFactor</td>
<td align="center">开启混合，并设置混合因子。源颜色（该片元产生的颜色）<em>SrcFactor + 目标颜色（已经存在于颜色缓存的颜色）</em>DstFactor —颜色缓存</td>
</tr>
<tr>
<td align="center">Blend SrcFactor DstFactor,  SrcFactorA DstFactorA</td>
<td align="center">和上面几乎一样，只是使用不同的因子来混合透明通道</td>
</tr>
<tr>
<td align="center">BlendOp BlendOperation</td>
<td align="center">并非把源颜色和目标颜色简单相加后混合，而使用BlendOperation对它们进行其它操作</td>
</tr>
</tbody></table>
<p>🎏实践。在此使用第二种语义，把SrcFactor 设为SrcAlpha，DstFactor设为OneMinusSrcAlpha</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123; </span><br><span class="line">            &quot;Queue&quot; = &quot;Transparent&quot;		 //</span><br><span class="line">            &quot;IgnoreProjector&quot; = &quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot; = &quot;Transparent&quot; //</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            //关闭深度写入</span><br><span class="line">            ZWrite Off</span><br><span class="line">            //开启并设置该Pass的混合模式</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            </span><br><span class="line">            ....</span><br><span class="line">            </span><br><span class="line">            //片元着色器内</span><br><span class="line">            return fixed4(ambient + diffuse, texColor.a * _AlphaScale);</span><br><span class="line">            ....</span><br><span class="line">            </span><br><span class="line">  Fallback &quot;Transparent/VertexLit&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看来透明度混合操作已经被封装成了一个命令，只要开启设置就好。</p>
</blockquote>
<h2 id="开启深度写入的半透明效果"><a href="#开启深度写入的半透明效果" class="headerlink" title="开启深度写入的半透明效果"></a>开启深度写入的半透明效果</h2><p>关闭了深度写入后，无法对模型进行像素级别的深度排序。其中一种办法时分割网络，但很多情况下这往往是不切实际的。这时我们可以想办法重新利用深度写入。</p>
<p>🦁一种解决办法：使用两个Pass来渲染模型</p>
<p>​    👉第一个Pass开启深度写入，但不输出颜色，目的仅仅是为了把该模型的深度值写入深度缓冲中；</p>
<p>​    👉第二个Pass进行正常的透明度混合。由于上一个Pass得到了逐像素的正确的深度信息，该Pass就可以按照像素级别的深度排序结果来进行透明渲染。</p>
<p>🧐缺点：使用多个Pass会对性能造成一定影响。</p>
<p>🎏实践</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//只需在原来的Pass之前再增加这个Pass</span><br><span class="line">Pass&#123;</span><br><span class="line">    ZWrite On</span><br><span class="line">    ColorMask 0	//意味着该Pass不写入任何颜色通道，即不会输出任何颜色</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ShaderLab的混合命令"><a href="#ShaderLab的混合命令" class="headerlink" title="ShaderLab的混合命令"></a>ShaderLab的混合命令</h2><p>实际上，混合还有许多其它用处，不仅仅是用于透明度混合。</p>
<p>🎃混合是如何实现的</p>
<p>​    👉<strong>源颜色（source color）</strong>:用S表示，指的是由片元着色器产生的颜色值</p>
<p>​    👉<strong>目标颜色（destination color）</strong>：用D表示，指的是从颜色缓冲中读取到的颜色值</p>
<p>​    👉<strong>输出颜色</strong>：用O表示，它会重新写入到颜色缓冲中</p>
<p>​    它们都包含了RGBA四个通道的值；想要使用混合，必须先开启它。在Unity中使用Blend命令时也开启了混合。但是在其他图形API中是需要手动开启的。</p>
<h3 id="混合等式和参数"><a href="#混合等式和参数" class="headerlink" title="混合等式和参数"></a>混合等式和参数</h3><p>😎混合是一个逐片元的操作，而且不是可编程的，但是可高度配置的。配置：混合时的运算操作、混合因子。</p>
<p>​    👉<strong>混合等式 blend equation</strong>：源颜色S、目标颜色D——输出颜色O。当混合时需要使用两个混合等式：一个用于混合RGB通道，一个用于混合A通道。</p>
<p>​    👉混合时的<strong>运算操作</strong>：默认情况下都是加操作。</p>
<p>​    👉<strong>混合因子</strong>：由于需要两个等式，分别都有两个因子（S/D），因此共需要4个因子。</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Blend SrcFactor DstFactor</td>
<td align="center">开启混合并设置混合因子。使用同样的混合因子来混合RGB/A通道</td>
</tr>
<tr>
<td align="center">Blend SrcFactor DstFactor,  SrcFactorA DstFactorA</td>
<td align="center">和上面不同的是使用不同的因子</td>
</tr>
</tbody></table>
<blockquote>
<p>ShaderLab中的混合因子👇</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">One</td>
<td align="center">因子为1</td>
</tr>
<tr>
<td align="center">Zero</td>
<td align="center">因子为0</td>
</tr>
<tr>
<td align="center">SrcColor</td>
<td align="center">因子为源颜色值</td>
</tr>
<tr>
<td align="center">SrcAlpha</td>
<td align="center">因子为源颜色的透明度值（A通道</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<h3 id="混合运算操作"><a href="#混合运算操作" class="headerlink" title="混合运算操作"></a>混合运算操作</h3><p>Add、Sub（减）、Min等，详情见表8.5</p>
<h3 id="常见的混合类型"><a href="#常见的混合类型" class="headerlink" title="常见的混合类型"></a>常见的混合类型</h3><p>通过混合操作和混合因子命令的组合，可以得到一些类似于Photoshop混合模式中的混合效果（详情见8.6.3</p>
<h2 id="双面渲染的透明效果"><a href="#双面渲染的透明效果" class="headerlink" title="双面渲染的透明效果"></a>双面渲染的透明效果</h2><p>🦁默认情况下渲染引擎剔除了物体背面（相对于摄像机方向）的渲染图元，只渲染物体的正面。所以在之前的透明物体都无法看到其内部结构。如果想得到双面渲染的结果，可以使用Cull指令来控制需要剔除哪个面的渲染图元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cull Back | Front | Off</span><br><span class="line">//剔除后面 | 剔除前面 | 关闭剔除功能（所有的渲染图元都被渲染）</span><br></pre></td></tr></table></figure>

<h3 id="透明度测试的双面渲染"><a href="#透明度测试的双面渲染" class="headerlink" title="透明度测试的双面渲染"></a>透明度测试的双面渲染</h3><p>只需要在Pass渲染设置中使用Cull命令来关闭剔除即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	Tags &#123;...&#125;</span><br><span class="line">	Cull Off</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="透明度混合的双面渲染"><a href="#透明度混合的双面渲染" class="headerlink" title="透明度混合的双面渲染"></a>透明度混合的双面渲染</h3><p>🧐由于关闭了深度写入，无法保证同一个物体的正面和背面图元的渲染顺序，直接关闭剔除功能的话就可能得到错误的半透明效果。</p>
<p>📍为此把渲染工作分成两个Pass：第一个Pass只渲染背面，第二个Pass只渲染正面，由于Unity是顺序执行各个Pass，因此可以保证背面总是在正面被渲染之前渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">	Tags &#123;...&#125;</span><br><span class="line">	Cull Front</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">Pass &#123;</span><br><span class="line">	Tags &#123;...&#125;</span><br><span class="line">	Cull Back</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/ta.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/img/dp_pic.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UnityShader 入门精要/中级篇 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/04/202264-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame2/"><img class="next-cover" src="/img/myGame03.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity入门(三)——MyGame2</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(●ˇ∀ˇ●)</div><div class="author-info__description">someone very lazy</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huangxinhere"><i class="fab fa-github"></i><span>Don't Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.</span> <span class="toc-text">第2章 渲染流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.1.</span> <span class="toc-text">2.1什么是渲染流水线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-CPU%E5%92%8CGPU%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.</span> <span class="toc-text">2.2 CPU和GPU之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%98%BE%E5%AD%98%E4%B8%AD"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">把数据加载到显存中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">设置渲染状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8Draw-Call"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">调用Draw Call</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3GPU%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.3.</span> <span class="toc-text">2.3GPU流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">顶点着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B2%E9%9D%A2%E7%BB%86%E5%88%86%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">曲面细分着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">几何着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%81%E5%89%AA"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">裁剪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84Screen-Mapping%EF%BC%88%E4%BA%8C%E7%BB%B4%EF%BC%89"><span class="toc-number">1.3.0.5.</span> <span class="toc-text">屏幕映射Screen Mapping（二维）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.3.0.6.</span> <span class="toc-text">三角形设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86%EF%BC%88%E6%89%AB%E6%8F%8F%E5%8F%98%E6%8D%A2%EF%BC%89"><span class="toc-number">1.3.0.7.</span> <span class="toc-text">三角形遍历（扫描变换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">1.3.0.8.</span> <span class="toc-text">片元着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%90%E7%89%87%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.0.9.</span> <span class="toc-text">逐片元操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-Unity-Shader%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">第3章 Unity Shader基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">Unity Shader概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8%E5%92%8CUnity-Shader"><span class="toc-number">2.1.1.</span> <span class="toc-text">材质和Unity Shader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84%E6%9D%90%E8%B4%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">Unity中的材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84Shader"><span class="toc-number">2.1.3.</span> <span class="toc-text">Unity中的Shader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader%E7%9A%84%E5%9F%BA%E7%A1%80%EF%BC%9AShaderLab"><span class="toc-number">2.2.</span> <span class="toc-text">Unity Shader的基础：ShaderLab</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">Unity Shader的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">2.3.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%90%E8%B4%A8%E5%92%8CUnity-Shader-%E7%9A%84%E6%A1%A5%E6%A2%81%EF%BC%9AProperties%EF%BC%88%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">材质和Unity Shader 的桥梁：Properties（属性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SubShader"><span class="toc-number">2.3.3.</span> <span class="toc-text">SubShader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">Unity Shader的形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E7%9A%84%E5%AE%A0%E5%84%BF%EF%BC%9A%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">Unity的宠儿：表面着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%81%AA%E6%98%8E%EF%BC%9A%E9%A1%B6%E7%82%B9-%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">最聪明：顶点&#x2F;片元着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E6%8A%9B%E5%BC%83%EF%BC%9A%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">被抛弃：固定函数着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity-Shader%E5%BD%A2%E5%BC%8F%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">2.4.4.</span> <span class="toc-text">Unity Shader形式的选择</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">第4章 数学基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89%EF%BC%9A%E5%8F%98%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">矩阵的几何意义：变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E6%8D%A2"><span class="toc-number">3.1.1.</span> <span class="toc-text">变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2%EF%BC%9A%E7%9F%A2%E9%87%8F%E5%8A%A0-%E6%A0%87%E9%87%8F%E4%B9%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">线性变换：矢量加 &#x2F; 标量乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2"><span class="toc-number">3.1.3.</span> <span class="toc-text">平移变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E2%80%94%E2%80%94%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.4.</span> <span class="toc-text">仿射变换——齐次坐标空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%8F%98%E6%8D%A2%E7%A7%8D%E7%B1%BB%E5%8F%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">3.1.5.</span> <span class="toc-text">常见变换种类及矩阵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87"><span class="toc-number">3.2.</span> <span class="toc-text">齐次坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E5%9F%BA%E7%A1%80%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5"><span class="toc-number">3.3.</span> <span class="toc-text">分解基础变换矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB%E7%9F%A9%E9%98%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">平移矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE%E7%9F%A9%E9%98%B5"><span class="toc-number">3.3.2.</span> <span class="toc-text">缩放矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%EF%BC%88%E7%BB%95%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4"><span class="toc-number">3.3.3.</span> <span class="toc-text">旋转矩阵（绕空间坐标轴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8F%98%E6%8D%A2"><span class="toc-number">3.3.4.</span> <span class="toc-text">复合变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4"><span class="toc-number">3.4.</span> <span class="toc-text">坐标空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E7%9A%84%E5%8F%98%E6%8D%A2"><span class="toc-number">3.4.1.</span> <span class="toc-text">坐标空间的变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9A%84%E5%9D%90%E6%A0%87%E7%A9%BA%E9%97%B4%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">顶点的坐标空间变换过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%EF%BC%88model-object-local-space"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">模型空间（model&#x2F;object&#x2F;local space)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">世界空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E6%A8%A1%E5%9E%8B%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94-gt-%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E3%80%90%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2%E3%80%91"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">第一步：模型空间——&gt;世界空间【模型变换】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94-gt-%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4%E3%80%90%E8%A7%82%E5%AF%9F%E5%8F%98%E6%8D%A2%E3%80%91"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">第二步：世界空间——&gt;观察空间【观察变换】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E8%A7%82%E5%AF%9F%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94-gt-%EF%BC%88%E9%BD%90%E6%AC%A1%EF%BC%89%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">第三步：观察空间——&gt;（齐次）裁剪空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E8%A3%81%E5%89%AA%E7%A9%BA%E9%97%B4%E2%80%94%E2%80%94-gt-%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">第四步：裁剪空间——&gt;屏幕空间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E3%80%90games101%E3%80%91"><span class="toc-number">3.4.2.7.</span> <span class="toc-text">补充【games101】</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E5%8F%98%E6%8D%A2"><span class="toc-number">3.4.3.</span> <span class="toc-text">法线变换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%BC%80%E5%A7%8BShader%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-number">4.</span> <span class="toc-text">第5章 开始Shader代码编写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B6%E7%82%B9-%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">一个最简单的顶点&#x2F;片元着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9B%B4%E5%A4%9A%E7%9A%84%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.1.</span> <span class="toc-text">获取更多的模型数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8%E5%92%8C%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">4.1.2.</span> <span class="toc-text">顶点着色器和片元着色器之间如何通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">4.1.3.</span> <span class="toc-text">如何使用属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-%E6%8F%90%E4%BE%9B%E7%9A%84%E5%86%85%E7%BD%AE%E6%96%87%E4%BB%B6%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">Unity 提供的内置文件和变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-Unity%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%A1%80%E5%85%89%E7%85%A7"><span class="toc-number">5.</span> <span class="toc-text">第6章 Unity中的基础光照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E7%9C%8B%E5%88%B0%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E7%9A%84"><span class="toc-number">5.1.</span> <span class="toc-text">我们是如何看到这个世界的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%89%E6%BA%90"><span class="toc-number">5.1.1.</span> <span class="toc-text">光源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%B8%E6%94%B6%E5%92%8C%E6%95%A3%E5%B0%84"><span class="toc-number">5.1.2.</span> <span class="toc-text">吸收和散射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%EF%BC%88shading%EF%BC%89"><span class="toc-number">5.1.3.</span> <span class="toc-text">着色（shading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.1.4.</span> <span class="toc-text">标准光照模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%83%8F%E7%B4%A0%E8%BF%98%E6%98%AF%E9%80%90%E9%A1%B6%E7%82%B9"><span class="toc-number">5.1.5.</span> <span class="toc-text">逐像素还是逐顶点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Unity-Shader%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">在Unity Shader中实现漫反射光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E9%A1%B6%E7%82%B9%E5%85%89%E7%85%A7"><span class="toc-number">5.2.1.</span> <span class="toc-text">逐顶点光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E7%85%A7"><span class="toc-number">5.2.2.</span> <span class="toc-text">逐像素光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%85%B0%E4%BC%AF%E7%89%B9%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.3.</span> <span class="toc-text">半兰伯特模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%85%89%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">实现高光反射光照模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E9%A1%B6%E7%82%B9%E5%85%89%E7%85%A7-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">逐顶点光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E5%83%8F%E7%B4%A0%E5%85%89%E7%85%A7-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">逐像素光照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blinn-Phong-%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.3.3.</span> <span class="toc-text">Blinn-Phong 模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Unity%E5%86%85%E7%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">使用Unity内置的函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%BA%B9%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">第7章 基础纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%BC%A0%E7%BA%B9%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">单张纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">6.1.1.</span> <span class="toc-text">纹理的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Texture-Type"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">Texture Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wrap-Mode"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">Wrap Mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Filter-Mode"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">Filter Mode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B0%BA%E5%AF%B8%E5%92%8C%E7%BA%B9%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">纹理的最大尺寸和纹理模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%B9%E5%87%B8%E6%98%A0%E5%B0%84-bump-mapping"><span class="toc-number">6.2.</span> <span class="toc-text">凹凸映射 bump mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%BA%A6%E7%BA%B9%E7%90%86-height-map"><span class="toc-number">6.2.1.</span> <span class="toc-text">高度纹理 height map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86-normal-map"><span class="toc-number">6.2.2.</span> <span class="toc-text">法线纹理 normal map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.3.</span> <span class="toc-text">在切线空间下进行光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4%E4%B8%8B%E8%BF%9B%E8%A1%8C%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97"><span class="toc-number">6.2.4.</span> <span class="toc-text">在世界空间下进行光照计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84%E6%B3%95%E7%BA%BF%E7%BA%B9%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.5.</span> <span class="toc-text">Unity中的法线纹理类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E5%8F%98%E7%BA%B9%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">渐变纹理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%AE%E7%BD%A9%E7%BA%B9%E7%90%86"><span class="toc-number">6.4.</span> <span class="toc-text">遮罩纹理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">7.</span> <span class="toc-text">第8章 透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.1.</span> <span class="toc-text">渲染顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader%E7%9A%84%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">Unity Shader的渲染顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">7.3.</span> <span class="toc-text">透明度测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88"><span class="toc-number">7.4.</span> <span class="toc-text">透明度混合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%B7%B1%E5%BA%A6%E5%86%99%E5%85%A5%E7%9A%84%E5%8D%8A%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">7.5.</span> <span class="toc-text">开启深度写入的半透明效果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ShaderLab%E7%9A%84%E6%B7%B7%E5%90%88%E5%91%BD%E4%BB%A4"><span class="toc-number">7.6.</span> <span class="toc-text">ShaderLab的混合命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E7%AD%89%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0"><span class="toc-number">7.6.1.</span> <span class="toc-text">混合等式和参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="toc-number">7.6.2.</span> <span class="toc-text">混合运算操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.6.3.</span> <span class="toc-text">常见的混合类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C"><span class="toc-number">7.7.</span> <span class="toc-text">双面渲染的透明效果</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B5%8B%E8%AF%95%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">7.7.1.</span> <span class="toc-text">透明度测试的双面渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B7%B7%E5%90%88%E7%9A%84%E5%8F%8C%E9%9D%A2%E6%B8%B2%E6%9F%93"><span class="toc-number">7.7.2.</span> <span class="toc-text">透明度混合的双面渲染</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By (●ˇ∀ˇ●)</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks to watch my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
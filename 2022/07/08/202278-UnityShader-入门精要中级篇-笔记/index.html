<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>UnityShader 入门精要/中级篇 笔记 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="learn sth">
<meta property="og:type" content="article">
<meta property="og:title" content="UnityShader 入门精要&#x2F;中级篇 笔记">
<meta property="og:url" content="https://huangxinhere.github.io/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="learn sth">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huangxinhere.github.io/img/dp_pic.jpg">
<meta property="article:published_time" content="2022-07-07T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-20T04:24:17.985Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huangxinhere.github.io/img/dp_pic.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'UnityShader 入门精要/中级篇 笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-20 12:24:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_pic_3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/dp_pic.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hx's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">UnityShader 入门精要/中级篇 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-07T16:00:00.000Z" title="发表于 2022-07-08 00:00:00">2022-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-20T04:24:17.985Z" title="更新于 2023-02-20 12:24:17">2023-02-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/shader/">shader</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="UnityShader 入门精要/中级篇 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="更复杂的光照"><a href="#更复杂的光照" class="headerlink" title="更复杂的光照"></a>更复杂的光照</h1><h2 id="Unity的渲染路径"><a href="#Unity的渲染路径" class="headerlink" title="Unity的渲染路径"></a>Unity的渲染路径</h2><p>🎃<strong>渲染路径</strong></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/900390e3ad846f99.png" alt="image-20220708155451967"></p>
<p>👉<strong>类型以及设置</strong></p>
<p>前向渲染路径 Forward Rendering Path、延迟渲染 Deferred Rendering Path、后两个待了解。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/039e6e1d51099a3d.png" alt="image-20220708153924773"></p>
<blockquote>
<p>大多数情况下一个项目只使用一种渲染路径，因此可以为整个项目设置渲染路径。☝️</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/1bc03255962a057d.png" alt="image-20220708154504563"></p>
<blockquote>
<p>也可以在每个摄像机的渲染路径设置中 设置该摄像机使用的渲染路径，以覆盖Project Setting中的设置。☝️</p>
</blockquote>
<p>📍如果当前显卡不支持所选择的渲染路径，Unity会自动使用更低一层的渲染路径。</p>
<p>🦁不同类型的渲染路径可能包含多种标签，在Pass中用“<strong>LightMode</strong>”指定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	Tags&#123;</span><br><span class="line">		&quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	//该Pass使用前向渲染路径中的ForwardBase路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">标签名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Always</td>
<td align="center">不管使用哪种路径，该Pass总是会被渲染，但不会计算光照</td>
</tr>
<tr>
<td align="center">ForwardBase</td>
<td align="center">用于前向渲染。该Pass会计算环境光、最重要的平行光、逐顶点/SH光源和Lightmaps</td>
</tr>
<tr>
<td align="center">ForwardAdd</td>
<td align="center">前向渲染。会计算额外的逐像素光源，每个Pass对应一个光源</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">(用到再进行补充)</td>
</tr>
</tbody></table>
<blockquote>
<p>LightMode标签支持的渲染路径设置选项。☝️</p>
</blockquote>
<h3 id="前向渲染路径"><a href="#前向渲染路径" class="headerlink" title="前向渲染路径"></a>前向渲染路径</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>大致过程：(伪代码)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Pass&#123;</span><br><span class="line">	for (each primitive in this model)&#123;</span><br><span class="line">		//对于每个渲染图元</span><br><span class="line">		for (each fragment covered by this primitive)&#123;</span><br><span class="line">			//1.深度测试</span><br><span class="line">			if (failed in depth test)&#123;</span><br><span class="line">				discard;</span><br><span class="line">			&#125;else &#123;</span><br><span class="line">			//2.光照计算</span><br><span class="line">				float4 color = Shading(materialInfo, pos, normal, lightDir, viewDir);</span><br><span class="line">			//3.更新帧缓冲</span><br><span class="line">				writeFrameBuffer(fragment, color);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于每个逐像素光源，都要进行上面一次完整的渲染流程。</p>
<p>📍如果一个物体受到<strong>多个光源</strong>影响，该物体就要执行多个Pass，每个Pass计算一个逐像素光源的光照结果，然后在<strong>帧缓冲</strong>中把这些光照结果混合起来得到最终的颜色值。</p>
</blockquote>
<h4 id="Unity中的前向渲染"><a href="#Unity中的前向渲染" class="headerlink" title="Unity中的前向渲染"></a>Unity中的前向渲染</h4><p><img src="https://s3.bmp.ovh/imgs/2022/07/08/6a2acfa2da41391c.png" alt="image-20220708165228451"></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/07/08/db68f3b086f971a5.png" alt="image-20220708165419564"></p>
<blockquote>
<p>两者具体说明：….</p>
</blockquote>
<h4 id="内置的光照变量和函数"><a href="#内置的光照变量和函数" class="headerlink" title="内置的光照变量和函数"></a>内置的光照变量和函数</h4><p>根据使用的渲染路径（即Pass标签中LightMode的值），Unity会把不同的光照变量传递给Shader。</p>
<blockquote>
<p>前向渲染可以使用的内置光照变量👇</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">类型</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">_LightColor0</td>
<td align="center">float4</td>
<td align="center">该Pass处理的逐像素<strong>光源的颜色</strong></td>
</tr>
<tr>
<td align="center">_WorldSpaceLightPos0</td>
<td align="center">float4</td>
<td align="center">_WorldSpaceLightPos0.xyz是该Pass处理的逐像素<strong>光源的位置</strong></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<p>前向渲染可以使用的内置光照函数👇</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">输入</th>
<th align="center">返回</th>
</tr>
</thead>
<tbody><tr>
<td align="center">WorldSpaceLightDir()*</td>
<td align="center">float4 v：一个模型空间中的顶点位置</td>
<td align="center">float3：世界空间中从该点到光源的光照方向</td>
</tr>
<tr>
<td align="center">UnityWorldSpaceLightDir()*</td>
<td align="center">float4 v：一个世界空间中的顶点位置</td>
<td align="center">float3：世界空间中从该点到光源的光照方向</td>
</tr>
<tr>
<td align="center">ObjSpaceLightDir()*</td>
<td align="center">float4 v：一个模型空间中的顶点位置</td>
<td align="center">float3：模型空间中从该点到光源的光照方向</td>
</tr>
</tbody></table>
<h3 id="顶点照明渲染路径"><a href="#顶点照明渲染路径" class="headerlink" title="顶点照明渲染路径"></a>顶点照明渲染路径</h3><p>😺对硬件配置最少、运算性能最高，但同时也是得到的效果最差的一种类型；仅仅是前向渲染的一个子集。【由于不被重视，需要再继续了解】</p>
<h3 id="延迟渲染路径"><a href="#延迟渲染路径" class="headerlink" title="延迟渲染路径"></a>延迟渲染路径</h3><p>🧐前向渲染的问题是：当场景中包含大量实时光源时，前向渲染的性能会急速下降。每个物体执行多个Pass的计算可能很多都是重复的。</p>
<p>🦁<strong>原理</strong>：主要包含两个Pass。</p>
<p>​    👉第一个Pass：通过深度缓冲技术，计算哪个片元是可见的，若可见就把相关信息存储到<u>屏幕空间的</u><strong>G缓冲区（G-buffer）</strong>中。【G缓冲区存储了我们所关心的表面（通常指的是离摄像机最近的表面）的其它信息，例如该表面的法线、位置、用于光照计算的材质属性等】</p>
<p>​    👉第二个Pass：利用G缓冲区的各个片元信息（表面法线、视角方向等），进行真正的光照计算。</p>
<blockquote>
<p>可看出延迟渲染跟场景中的光源数目无关，也就是不依赖于场景的复杂度，而是<strong>和使用的屏幕大小有关</strong>。这是因为，我们需要的信息都存储在缓冲区中，而这些缓冲区可以理解成是一张张2D图像，我们的计算实际上就是在这些图像空间中进行的。</p>
</blockquote>
<p>📍如果游戏中使用了<strong>大量的实时光照</strong>，那么可能希望选择延迟渲染路径，但这种路径需要一定的硬件支持</p>
<p>📍延迟渲染路径中每个光源都可以按<strong>逐像素</strong>的方式处理</p>
<p>📍【<strong>缺点</strong>】不支持真正的抗锯齿（anti-aliasing）功能；不能处理半透明物体；对显卡有一定要求</p>
<h3 id="选择哪种路径"><a href="#选择哪种路径" class="headerlink" title="选择哪种路径"></a>选择哪种路径</h3><p>有需要查阅官方文档Rendering Path的有关内容。</p>
<h2 id="Unity的光源类型"><a href="#Unity的光源类型" class="headerlink" title="Unity的光源类型"></a>Unity的光源类型</h2><p>Unity一共支持4种光源类型：平行光、点光源、聚光灯和面光源（area light）/仅在烘培时才发挥作用</p>
<p>📍从Shader中使用的5个光源属性来理解不同光源类型。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">平行光</th>
<th align="center">点光源（球体）</th>
<th align="center">聚光灯（锥型）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">光源位置</td>
<td align="center">没有唯一位置</td>
<td align="center">有位置属性</td>
<td align="center">有</td>
</tr>
<tr>
<td align="center">到某点的方向</td>
<td align="center">照亮的范围没有限制/几何属性只有方向</td>
<td align="center">点光源位置-某点位置</td>
<td align="center">同左</td>
</tr>
<tr>
<td align="center">衰减</td>
<td align="center">无</td>
<td align="center">会衰减；球体边界值为0</td>
<td align="center">点光源衰减公式更复杂，需要判断点是否在锥体内</td>
</tr>
<tr>
<td align="center">强度</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">颜色</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="mul-unity-ObjectToWorld-v-vertex-xyz和UnityObjectToClipPos-v-vertex-的区别"><a href="#mul-unity-ObjectToWorld-v-vertex-xyz和UnityObjectToClipPos-v-vertex-的区别" class="headerlink" title="mul(unity_ObjectToWorld,v.vertex).xyz和UnityObjectToClipPos(v.vertex);的区别"></a>mul(unity_ObjectToWorld,v.vertex).xyz和UnityObjectToClipPos(v.vertex);的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br></pre></td></tr></table></figure>

<p>这是把顶点从模型空间（物体的本地坐标空间）转化到世界空间中，并取xyz分量；其中，unity_ObjectToWorld是转化矩阵。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnityObjectToClipPos(v.vertex);</span><br></pre></td></tr></table></figure>


<p>这个是把顶点从模型空间直接转化到裁剪空间，也就是进行了M-V-P三次转化，这个函数是unity重新封装过一次，其实它最初是mul(UNITY_MATRIX_MVP,v.vertex);其中，UNITY_MATRIX_MVP是转化矩阵。</p>
<h3 id="在前向渲染中处理不同的光源类型"><a href="#在前向渲染中处理不同的光源类型" class="headerlink" title="在前向渲染中处理不同的光源类型"></a>在前向渲染中处理不同的光源类型</h3><p>🎏<strong>实践1</strong>：场景中有一个平行光和一个点光源。这里使用了Blinn-Phong类型，并为前向渲染定义了Base Pass和Additional Pass来处理多个光源。</p>
<p>👉第一个Pass——Base Pass</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*Pass for ambient light &amp; first pixel light(directional light)*/</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags&#123;</span><br><span class="line">                &quot;LightMode&quot; = &quot;ForwardBase&quot;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            #pragma multi_compile_fwdbase		//可以保证在Shader中使用光照衰减等光照变量可以被正确赋值</span><br><span class="line"></span><br><span class="line">            #include &quot;Lighting.cginc&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//我们希望环境光计算一次就好，因此在后面的Additional Pass不会再计算这个部分</span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);			//平行光方向</span><br><span class="line">...</span><br><span class="line">fixed atten = 1.0;//衰减</span><br><span class="line">return fixed4(ambient + (diffuse + specular) * atten, 1.0);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在Base Pass中处理了场景中最重要的平行光</span><br><span class="line">//如果场景中包含了多个平行光，Unity会选择最亮的平行光传递给Base Pass进行逐像素处理</span><br><span class="line">	//其它平行光会按照逐顶点或者在Additional Pass中按逐像素处理</span><br><span class="line">	//如果场景中没有平行光，那么Base Pass会当成全黑的光源处理</span><br></pre></td></tr></table></figure>

<p>👉第二个Pass——Additional Pass</p>
<p>📍思路：①设置好指令；②判断光源类型；③计算光源的5个属性（其中颜色和强度仍然可以用_LightColor0来得到，其它需要分别计算）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/*①*/</span><br><span class="line">pass</span><br><span class="line">&#123;</span><br><span class="line">    Tags&#123;</span><br><span class="line">    	&quot;LightMode&quot; = &quot;ForwardAdd&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    //开启和设置了混合模式</span><br><span class="line">    //希望AP计算得到的光照结果可以在*帧缓存*中与之前的光照结果进行叠加</span><br><span class="line">    //否则会直接覆盖掉之前的光照结果 </span><br><span class="line">    Blend One One</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line">    //保证在Additional Pass访问到正确的光照变量</span><br><span class="line">    #pragma multi_compile_fwdadd    </span><br><span class="line"></span><br><span class="line">    #include &quot;Lighting.cginc&quot;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②判断光源类型👇AP和BP的光照处理方式一样，因此只需要把BP的顶点和片元着色器代码粘贴到AP中，再稍微修改一下即可。修改往往是为了<u>去掉BP的环境光、自发光、逐顶点光照、SH光照的部分，并添加一些对不同光源类型的支持</u>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*相关变量*/</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line"></span><br><span class="line">//------判断光源类型：求光源方向</span><br><span class="line">#ifdef USING_DIRECTIONAL_LIGHT</span><br><span class="line">	fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">#else</span><br><span class="line">	fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz);</span><br><span class="line">#endif</span><br><span class="line">//------</span><br><span class="line"></span><br><span class="line">fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*光照衰减*/</span><br><span class="line">#ifdef USING_DIRECTIONAL_LIGHT</span><br><span class="line">	fixed atten = 1.0</span><br><span class="line">#else</span><br><span class="line">    #if defined (POINT)</span><br><span class="line">    	float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br><span class="line">    	fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">    #elif defined (SPOT)</span><br><span class="line">    	float4 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br><span class="line">    	fixed atten = (lightCoord.z &gt; 0) </span><br><span class="line">   		     * tex2D(_LightTexture0, lightCoord.xy / lightCoord.w + 0.5).w </span><br><span class="line">    		* tex2D(_LightTextureB0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br><span class="line">    #else</span><br><span class="line">    	fixed atten = 1.0;</span><br><span class="line">    #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可看出主要修改的是光源的位置、方向和衰减属性。先判断，再分别做处理。</p>
<p>📍#ifdef指令判断，并注意格式</p>
<p>📍如果是点光源或者聚光灯，**_WorldSpaceLightPos0.xyz**表示的是世界空间下的光源位置，要得到光源方向，就要减去世界空间下的顶点位置</p>
<p>📍两种光源的衰减用数学计算的话计算量较大，因此Unity选择了使用<strong>一张纹理</strong>作为<strong>查找表（Lookup Table，LUT）</strong>，以在片元着色器中得到光源的衰减。首先得到<strong>光源空间下的坐标</strong>，然后使用该坐标<strong>对衰减纹理进行采样得到衰减值</strong>。</p>
</blockquote>
<p>🎏<strong>实践2</strong>：一个环境光＋四个点光源——BP和AP的调用</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709153034654.png" alt="image-20220709153034654"></p>
<p>👉决定哪些光源是逐像素光照</p>
<p>​    光源创建后默认情况下它的Render Mode（Light组件内）是Auto。这意味着，Unity会在背后为我们判断那些光源会按照逐像素处理，而哪些按逐顶点或SH的方式处理。<strong>总逐像素光源数</strong>在（Project Settings——Graphics）Pixel Light Count中设置，默认情况下一个物体可以接受<u>除最亮的平行光外</u>的4个逐像素光照。</p>
<p>​    📍该场景中，平行光按照逐像素处理；其余4个点光源刚好符合余下4个位置，也按照逐像素处理，因此每个光源都会调用一次物体的Additional Pass。</p>
<p>👉帧调试器查看场景绘制过程</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709154302348.png" alt="image-20220709154302348"></p>
<p>​    橙色箭头：是比书本多出来的两个流程，不知道是啥。</p>
<p>​    黄色框框：6个渲染事件。第一个渲染事件：Unity首先清除颜色、深度和模板缓冲，为后面的渲染做准备；第二个事件：利用第一个Pass，将平行光的光照渲染到帧缓存中；后面4个渲染事件按照AP渲染。</p>
<blockquote>
<p>Unity处理点光源的顺序是按照它们的重要度排序的。和距离物体远近、光源强度、颜色有关。</p>
<p>物体在某个光源的范围内才会调用相应的Pass来处理光源</p>
</blockquote>
<p>​    右侧：渲染设置以及变量。</p>
<p>👉如果设置成Not Important，将不会按照逐像素来处理；如果也没有在BP计算逐顶点和SH光源，那么这个光源不会对物体有任何影响。</p>
<h2 id="Unity的光照衰减"><a href="#Unity的光照衰减" class="headerlink" title="Unity的光照衰减"></a>Unity的光照衰减</h2><h3 id="用于光照衰减的纹理"><a href="#用于光照衰减的纹理" class="headerlink" title="用于光照衰减的纹理"></a>用于光照衰减的纹理</h3><p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709162511273.png" alt="image-20220709162511273"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//先得到光源空间下点的位置</span><br><span class="line">float3 lightCoord = mul(unity_WorldToLight, float4(i.worldPos, 1)).xyz;</span><br><span class="line"></span><br><span class="line">//使用这个坐标的模的平方【应该是与点光源的距离的平方，避免开方操作】对衰减纹理进行采样</span><br><span class="line">//使用宏UNITY_ATTEN_CHANNEL来得到衰减纹理中衰减值所在的分量，以得到最终的衰减值</span><br><span class="line">fixed atten = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).UNITY_ATTEN_CHANNEL;</span><br></pre></td></tr></table></figure>

<h2 id="Unity的阴影"><a href="#Unity的阴影" class="headerlink" title="Unity的阴影"></a>Unity的阴影</h2><p>如何在Unity中让一个物体向其它物体投射阴影，以及如何让一个物体接受来自其他物体的阴影。</p>
<h3 id="阴影是如何实现的"><a href="#阴影是如何实现的" class="headerlink" title="阴影是如何实现的"></a>阴影是如何实现的</h3><p>😏<strong>Shadow Map</strong>：真实生活中阴影的产生是因为光线无法到达这些区域。在实时渲染中，最常使用的是Shadow Map技术。它首先把摄像机的位置放在和光源重合的位置上，那么场景中该光源的阴影区域就是那些摄像机看不到的地方。（摄像机的FOV不会影响吗？还是自动调节成光源那样）Unity用的就是这种技术。</p>
<p>😏<strong>阴影映射纹理(shadowmap)<strong>：在</strong>前向渲染路径</strong>中，如果场景中<strong>最重要的平行光开启了阴影</strong>，Unity就会为该光源计算它的阴影映射纹理。这张阴影映射纹理本质上也是一张<strong>深度图</strong>，记录了从该光源的位置出发、能看到的场景中距离它最近的表面位置（深度信息）</p>
<p>😏<strong>LightMode</strong>标签被设置为<strong>ShadowCaster</strong>的Pass：渲染目标是阴影映射纹理（深度纹理）。Unity把摄像机放在光源位置上；调用该Pass，通过顶点变换后得到<strong>光源空间下的位置</strong>；据此来输出深度信息到阴影映射纹理中。</p>
<p>​    👉Unity的阴影运算过程：当开启了光源的阴影效果后，底层渲染引擎首先会在当前渲染物体的Unity Shader中找到有<strong>ShadowCaster</strong>的Pass，没有就在<strong>Fallback指定的Shader</strong>中继续寻找，还没找到，该物体就<strong>无法</strong>向其它物体投射阴影（但还能接受阴影）。</p>
<p>😏<strong>屏幕空间的阴影映射技术(Screenspace Shadow Map)<strong>：Unity首先通过调用LightMode为ShadowCaster的Pass来得到<u>可投射阴影的光源</u>的<u>阴影映射纹理①</u>以及<u>摄像机的深度纹理②</u>。然后根据①和②来得到<u>屏幕空间的阴影图</u>。如果</strong>摄像机</strong>的深度图中记录的表面深度＞转换到<strong>阴影映射纹理</strong>中的深度值，就说明表面虽然是可见的，但是却处在光源的阴影当中。</p>
<p>​    👉通过这种方式，阴影图就包含了屏幕空间中所有有阴影的区域。【停下来想一想，为什么弄阴影要这么大费周章呢？之前的光照模型都是一部分一部分手动还原出来的，当然不包括阴影。实现阴影也不能用常规的做法……】</p>
<p>​    👉如果想要一个物体<strong>接收</strong>来自其他物体的阴影，只需要<strong>在Shader中对阴影图进行采样</strong>。阴影图是在屏幕空间下的，因此需要<u>把表面坐标从模型空间变换到屏幕空间</u>中，然后使用这个<u>坐标对阴影进行采样</u>即可。</p>
<p>🎈总结</p>
<p>​    📍如果想要一个物体<strong>接收</strong>来自其它物体的阴影，就必须在Shader中对阴影映射纹理（包括屏幕空间的阴影图）进行<strong>采样</strong>，把采样结果和最后的光照结果相乘来产生阴影效果。</p>
<p>​    📍如果想要一个物体向其它物体<strong>投影</strong>，就必须把物体<strong>加入到光源的阴影映射纹理的计算中</strong>，从而让其它物体在对阴影映射纹理采样时可以得到该物体的相关信息。在Unity中，这个过程是通过为该物体<u>执行LightMode为ShadowCaster的Pass</u>来实现的。如果使用了<u>屏幕空间的投影映射技术</u>，Unity还会使用这个Pass产生一张<u>摄像机的深度纹理</u>。</p>
<h3 id="不透明物体的阴影"><a href="#不透明物体的阴影" class="headerlink" title="不透明物体的阴影"></a>不透明物体的阴影</h3><p>🎏实践</p>
<p>👉让平行光可以收集阴影信息，在组件中开启阴影</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709215721097.png" alt="image-20220709215721097"></p>
<p><strong>😎让物体投射阴影</strong></p>
<p>在Unity中，可以选择是否让一个物体投射或接收阴影👇</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709215952239.png" alt="image-20220709215952239"></p>
<blockquote>
<ul>
<li>Cast Shader（On）：unity会把该物体加入到光源的阴影映射纹理的计算中。</li>
<li>Receive Shadows则可以选择是否让物体接受来自其它物体的阴影。</li>
</ul>
</blockquote>
<p>🧐<strong>Fallback回调到内置的VertexLit</strong>，内含一个LightMode为ShadowCaster的Pass，所以会自动产生投影。手动Pass可以更加灵活地控制阴影的产生；Fallback可以在多个Pass之间通用，所以更加方便。</p>
<p>🧐<strong>物体背面问题</strong></p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709221309408.png" alt="image-20220709221309408"></p>
<blockquote>
<p>平面的正面朝外，产生阴影。</p>
</blockquote>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220709221416658.png" alt="image-20220709221416658"></p>
<blockquote>
<p>平面的正面朝内，没有投下阴影。默认情况下，在计算光源的阴影映射纹理时会<strong>剔除掉物体的背面</strong>。由于右侧的平面在光源空间下没有任何正面，因此不会添加到阴影纹理中。可以将Cast Shadows设置为Two Sided（面板中）来<strong>允许对物体的所有面都计算阴影信息</strong>。</p>
</blockquote>
<p><strong>😎让物体接收阴影</strong></p>
<p>👉在Base Pass中包含新的内置文件；下面<strong>计算阴影时所用的宏</strong>都是在这个文件声明的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;AutoLight.cginc&quot;</span><br></pre></td></tr></table></figure>

<p>👉<strong>顶点着色器的输出结构体v2f</strong>添加一个内置宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD2;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float2 uv : TEXCOORD1;</span><br><span class="line">    //阴影相关的内置宏:声明一个用于对阴影纹理采样的坐标</span><br><span class="line">    //宏的参数:下一个可用的插值寄存器的索引值</span><br><span class="line">    SHADOW_COORDS(3)                    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>👉<strong>顶点着色器返回前</strong>添加一个另一个内置宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    //用于在顶点着色器中 计算上一步中声明的 阴影纹理坐标</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和纹理挺相似的。在结构体声明一个寄存器， 然后在vert处理坐标，接着在frag采样</p>
</blockquote>
<p>👉在<strong>片元着色器</strong>中计算阴影值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">    /*阴影*/</span><br><span class="line">    fixed shadow = SHADOW_ATTENUATION(i);</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">    return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>📍Unity为了处理不同光源类型、不同平台定义了多个版本的宏。</p>
<p>📍需要保证<strong>自定义的变量名和这些宏使用的变量名相匹配</strong>。保证：a2f / v2f中的顶点坐标必须是vertex / pos，顶点着色器的输入结构体a2v必须为v</p>
<h3 id="统一管理光照衰减和阴影"><a href="#统一管理光照衰减和阴影" class="headerlink" title="统一管理光照衰减和阴影"></a>统一管理光照衰减和阴影</h3><p>实际上，光照衰减和阴影对物体最终的渲染结果的影响 本质上时相同的——都是把<u>光照衰减因子</u>和<u>阴影值</u>及<u>光照结果</u>相乘得到最终的渲染效果。Unity提供了**内置宏 *UNITY_LIGHT_ATTENUATION *来同时计算两个信息**。</p>
<p>👉头文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Lighting.cginc&quot;</span><br><span class="line">#include &quot;AutoLight.cginc&quot;</span><br></pre></td></tr></table></figure>

<p>👉v2f</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct v2f</span><br><span class="line">&#123;</span><br><span class="line">    float4 pos : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD2;</span><br><span class="line">    float3 worldNormal : TEXCOORD0;</span><br><span class="line">    float2 uv : TEXCOORD1;</span><br><span class="line"></span><br><span class="line">    SHADOW_COORDS(3)                    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>👉vert</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRANSFER_SHADOW(o);</span><br></pre></td></tr></table></figure>

<p>👉frag</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">return fixed4(ambient + (diffuse + specular) * atten * shadow, 1.0);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>atten</strong>：UNITY_LIGHT_ATTENUATION会帮我们声明这个变量；存储两者相乘后的<strong>结果</strong></p>
<p><strong>i</strong>：结构体v2f，传递给SHADOW_ATTENUATION来计算<strong>阴影值</strong></p>
<p><strong>i.worldPos</strong>：世界空间的坐标，用于计算光源空间下的坐标，再对光照衰减纹理采样来得到<strong>光照衰减</strong>。</p>
<p>📍这个宏版本也有多个，保证多种情况的正确运行。</p>
</blockquote>
<h3 id="透明物体的阴影"><a href="#透明物体的阴影" class="headerlink" title="透明物体的阴影"></a>透明物体的阴影</h3><p>​    对于大多数不透明物体来说，把Fallback设为VertLit就能得到正确的阴影。但对于透明物体来说，其实现通常会使用透明度测试或透明度混合；透明度测试中要在片元着色器舍弃某些片元，而VertLit中的阴影投射纹理并没有这样的操作。</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710101850265.png" alt="image-20220710101850265"></p>
<blockquote>
<p>透明度测试中，阴影结果是错误的</p>
</blockquote>
<p>👉和阴影处理相同，主要是改Fallback</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fallback &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>内置的VertLit并没有进行任何透明度测试的计算，所以会把整个物体的 深度信息 渲染到深度图和 阴影映射纹理中。因此要提供一个<strong>有透明度测试功能的</strong>ShadowCaster Pass。</p>
<p>📍Transparent/Cutout/VertexLit使用了 <em>_Cutoff</em> 属性来进行透明度测试，这要求Shader中也必须提供名为 <em>_Cutoff</em> 的属性。否则也不能得到正确的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Cutoff (&quot;Alpha Cutoff&quot;, Range(0, 1)) = 0.5</span><br></pre></td></tr></table></figure>
</blockquote>
<p>👉把正方体的Caster Shadows属性设置为Two Sided</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710105627578.png" alt="image-20220710105627578"></p>
<blockquote>
<p>否则下面的面（相当于背面）无法正常投影</p>
</blockquote>
<p>🧐为使用<strong>透明度混合</strong>的物体<strong>添加阴影</strong>是一件比较复杂的事情</p>
<p>📍所有内置的透明度混合的Unity Shader，如Transparent / VertexLit 等，<strong>都没有包含阴影投射的Pass</strong>。不能产生投影也不能接收投影</p>
<blockquote>
<p>由于透明度混合<strong>需要关闭深度写入</strong>，带来的问题也影响了阴影的生成。要想为这些半透明物体产生正确的阴影，<u>需要在每个光源空间下仍然严格按照从后往前的顺序进行渲染</u>，这会让阴影处理变得非常复杂，而且也会影响性能。</p>
</blockquote>
<h2 id="标准Unity-Shader"><a href="#标准Unity-Shader" class="headerlink" title="标准Unity Shader"></a>标准Unity Shader</h2><p>材质：颜色、纹理、法线纹理</p>
<p>光照：环境光、<u>平行光（主要光源）、其它光源（衰减）</u>【兰伯特、高光】、阴影</p>
<p>是否透明</p>
<h1 id="高级纹理"><a href="#高级纹理" class="headerlink" title="高级纹理"></a>高级纹理</h1><h2 id="立方体纹理"><a href="#立方体纹理" class="headerlink" title="立方体纹理"></a>立方体纹理</h2><p>🦁立方体纹理（Cubemap）是<strong>环境映射（Environment Mapping）</strong>的一种实现方法。环境映射可以模拟物体周围的环境。</p>
<p>​    👉<strong>如何采样</strong>：需要提供一个三维的纹理坐标，表示了在世界空间的一个方向。这个方向矢量从中心出发，向外部延伸时就会和6个纹理之一发生相交，而采样得到的结果就是由该交点计算得来的。</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710153839600.png" alt="image-20220710153839600"></p>
<p>​    👉<strong>好处</strong>：实现简单快速，效果也较好。</p>
<p>​    👉<strong>缺点</strong>：当场景中引入了新的物体、光源或者物体发生移动时需要重新生成立方体纹理；仅可以反射环境，但不能反射使用了该立方体纹理的物体本身。</p>
<h3 id="天空盒子"><a href="#天空盒子" class="headerlink" title="天空盒子"></a>天空盒子</h3><p>可以为摄像机添加skybox组件来覆盖默认的天空盒子。</p>
<h3 id="创建用于环境映射的立方体纹理"><a href="#创建用于环境映射的立方体纹理" class="headerlink" title="创建用于环境映射的立方体纹理"></a>创建用于环境映射的立方体纹理</h3><p>通过环境映射，我们可以模拟出金属质感的材质。</p>
<p>👉方法一：提供一张<strong>具有特殊布局的纹理</strong>（如立方体展开图的交叉布局、全景布局等），然后把该纹理的Texture Type<strong>设置成Cubemap</strong>即可，Unity会做好剩下的事。在基于物理的渲染中，通常会使用一张HDR图像来生成高质量的Cubemap。</p>
<p>👉方法二：Unity5之前的版本。在项目资源中创建一个Cubemap，把6张纹理拖进去。官方推荐第一种方法。</p>
<p>👉方法三：前两种方法都是提前准备好立方体纹理的图像，得到的立方体纹理往往是被场景中的物体所共用的。在理想情况下，希望根据物体在场景中位置的不同，生成<strong>各自不同的立方体纹理</strong>。这时可以在Unity中使用脚本来创建。这是利用Unity提供的<strong>Camera.RenderToCubemap函数</strong>来实现的。这个函数可以把<strong>从任意位置观察到的场景图像</strong>存储到6张图像中，从而创建出该位置上对应的立方体纹理。实现如下👇</p>
<p>​    👉创建（Project）Editor文件夹下的一个脚本（关键代码如下）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void OnWizardCreate () &#123;</span><br><span class="line">    // create temporary camera for rendering</span><br><span class="line">    GameObject go = new GameObject( &quot;CubemapCamera&quot;);</span><br><span class="line">    go.AddComponent&lt;Camera&gt;();</span><br><span class="line">    // place it on the object</span><br><span class="line">    go.transform.position = renderFromPosition.position;</span><br><span class="line">    </span><br><span class="line">    // render into cubemap-----重点理解		</span><br><span class="line">    go.GetComponent&lt;Camera&gt;().RenderToCubemap(cubemap);</span><br><span class="line"></span><br><span class="line">    // destroy temporary camera</span><br><span class="line">    DestroyImmediate( go );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    👉上面脚本添加了Unity的菜单GameObject——Render into Cubemap。所以点击菜单会出现一个小面板。</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710164355981.png" alt="image-20220710164355981"></p>
<p>​    👉把一个位置放进去，和一个Project创建的Legacy——Cubemap资源，然后就能点击生成效果</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710164527816.png" alt="image-20220710164527816"></p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>🎃通过入射光线的方向和表面法线方向来计算<strong>反射方向</strong>，再利用反射方向<strong>对立方体纹理采样</strong>。</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710184521883.png" alt="image-20220710184521883"></p>
<blockquote>
<p>对书的说法不是很理解，暂时理解为纹理（也就是环境）发出的光经过物体表面反射到达人眼。而这光线到达点o就是物体表面o点记录的纹理信息。</p>
</blockquote>
<p>👉【关键部分】在<strong>顶点着色器</strong>计算该点处的<strong>反射方向</strong>；也就是入射光线的方向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v2f vert(a2v v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line">    // Compute the reflect dir in world space</span><br><span class="line">    o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉在<strong>片元着色器</strong>中利用反射方向来对立方体进行<strong>采样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 1.Use the reflect dir in world space to access the cubemap</span><br><span class="line">    fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb * _ReflectColor.rgb;</span><br><span class="line"></span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    // 2.Mix the diffuse color with the reflected color</span><br><span class="line">    fixed3 color = ambient + lerp(diffuse, reflection, _ReflectAmount) * atten;</span><br><span class="line"></span><br><span class="line">    return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.对立方体纹理的采样需要使用CG的<strong>texCUBE</strong>函数</p>
<p>2.也可以在片元着色器中计算反射方向，效果会更加细腻，但是对于大多数人来说这种差别是可以忽略不计的，因此出于<strong>性能方面</strong>的考虑，选择在顶点着色器中计算反射方向。<strong>lerp</strong>混合</p>
</blockquote>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105454256.png" alt="image-20220711105454256"></p>
<h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p>😎<strong>斯涅尔定律（Snell‘s Law）</strong>：n1 sinθ1 = n2 sinθ2。其中n1和n2分别是两个介质的<strong>折射率（index of refraction）</strong></p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710215958986.png" alt="image-20220710215958986"></p>
<p>👉更准确的模拟方法需要计算两次折射——一次是当光线进入它的内部时，而另一次则是从它内部射出时。但是想在实时渲染中模拟出第二次折射方向是比较复杂的，仅仅模拟一次的效果在视觉上也没有很大差异。所以通常只模拟<strong>第一次折射</strong>。</p>
<p>👉【过程和反射类似，只是属性/公式不同】属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    _RefractColor (&quot;Refraction Color&quot;, Color) = (1, 1, 1, 1)    //折射颜色</span><br><span class="line">    _RefractAmount (&quot;Refraction Amount&quot;, Range(0, 1)) = 1       //材质的折射程度</span><br><span class="line">    _RefractRatio (&quot;Refraction Ratio&quot;, Range(0.1, 1)) = 0.5     //不同介质的透射比</span><br><span class="line">    _Cubemap (&quot;Refraction Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;        //模拟折射的环境映射纹理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>👉顶点着色器：计算<strong>折射方向</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    o.worldRefr = refract(-normalize(o.worldViewDir), normalize(o.worldNormal), _RefractRatio);</span><br><span class="line">    ...</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一个参数：入射光线方向，必须<strong>归一化</strong></p>
<p>第二个参数：表面法线，法线方向同样必须<strong>归一化</strong></p>
<p>第三个参数：<u>入射光线所在介质</u>的折射率和<u>折射光线所在介质</u>的折射率之间的比值</p>
</blockquote>
<p>👉片元着色器：使用折射方向<strong>对立方体纹理进行采样</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    fixed3 refraction = texCUBE(_Cubemap, i.worldRefr).rgb * _RefractColor.rgb;</span><br><span class="line">    UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">    fixed3 color = ambient + lerp(diffuse, refraction, _RefractAmount) * atten;</span><br><span class="line"></span><br><span class="line">    return fixed4(color, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>同样也没有对i.worldRefr进行归一化操作，因为对立方体纹理的采样只需要提供方向即可</p>
</blockquote>
<h3 id="菲涅尔反射"><a href="#菲涅尔反射" class="headerlink" title="菲涅尔反射"></a>菲涅尔反射</h3><p>😎描述了一种光学现象：当光线照射到物体表面上时，一部分发生<strong>反射</strong>，一部分进入物体内部，发生<strong>折射或散射</strong>。</p>
<p>😎不仅仅是水、玻璃这样的反光物体具有菲涅尔效果，几乎任何物体都或多或少包含了这个效果，这是基于物理渲染中<strong>非常重要</strong>的一项高光反射计算因子。</p>
<p>😎真实世界的菲涅尔等式是非常复杂的，在实时渲染中会使用一些<strong>近似公式</strong>来计算。</p>
<p>​    👉<strong>Schlick</strong>菲涅尔近似等式</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710225656237.png" alt="image-20220710225656237"></p>
<blockquote>
<p>F0是一个反射系数，用于控制菲涅尔<strong>反射的强度</strong>；v是视角方向；n是表面法线</p>
</blockquote>
<p>​    👉<strong>Empricial</strong>菲涅尔近似等式</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220710225754600.png" alt="image-20220710225754600"></p>
<blockquote>
<p>bias、scale和power是控制项</p>
</blockquote>
<p>🎈属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">    _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">    _FresnelScale (&quot;Fresnel Scale&quot;, Range(0, 1)) = 0.5   	//F0</span><br><span class="line">    _Cubemap (&quot;Reflection Cubemap&quot;, Cube) = &quot;_Skybox&quot; &#123;&#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🎈顶点着色器：世界空间下的法线方向、视角方向和<strong>反射方向</strong>【加入了反射】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</span><br><span class="line">    o.worldNormal = UnityObjectToWorldNormal(v.normal);</span><br><span class="line">    o.worldViewDir = UnityWorldSpaceViewDir(o.worldPos);</span><br><span class="line"></span><br><span class="line">    o.worldRefl = reflect(-o.worldViewDir, o.worldNormal);	//反射</span><br><span class="line">    TRANSFER_SHADOW(o);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>🎈片元着色器：菲涅尔反射；<strong>混合漫反射光照和反射光照</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">//反射</span><br><span class="line">fixed3 reflection = texCUBE(_Cubemap, i.worldRefl).rgb;</span><br><span class="line">//菲涅尔</span><br><span class="line">fixed fresnel = _FresnelScale + (1 - _FresnelScale) * pow(1 - dot(worldViewDir, worldNormal), 5);</span><br><span class="line"></span><br><span class="line">UNITY_LIGHT_ATTENUATION(atten, i, i.worldPos);</span><br><span class="line"></span><br><span class="line">//使用fresnel变量来混合漫反射光照和反射光照</span><br><span class="line">fixed3 color = ambient + lerp(diffuse, reflection, saturate(fresnel)) * atten;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>水面：菲涅尔反射混合反射和折射光照。</p>
</blockquote>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105324097.png" alt="image-20220711105324097"></p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105401193.png" alt="image-20220711105401193"></p>
<blockquote>
<p>F0为0/1的两种效果</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反射、折射与菲涅尔：</p>
<p>都与视觉方向和法线方向有关，在vert中处理反射 / 折射方向；在frag处理采样。</p>
<p>都与天空盒有关：采样</p>
<h2 id="渲染纹理"><a href="#渲染纹理" class="headerlink" title="渲染纹理"></a>渲染纹理</h2><p>😺<strong>渲染目标纹理（Render Target Texture，RTT）</strong>：现代的GPU允许我们把整个三维场景渲染到一个<strong>中间缓冲</strong>中，而不是传统的帧缓冲或者后备缓冲（back buffer）。【场景直接渲染到纹理中而不是屏幕上】</p>
<p>​    👉与之相关的是<strong>多重渲染目标（Multiple Render Target，MRT）</strong>：把场景<strong>同时</strong>渲染到<strong>多个渲染目标纹理</strong>中，而不再需要为每个渲染目标纹理单独渲染完整的场景。</p>
<h3 id="镜子效果"><a href="#镜子效果" class="headerlink" title="镜子效果"></a>镜子效果</h3><p>😺主要思路：把渲染纹理【也就是另一个设置好的摄像机视角】赋给镜子，并在脚本中进行水平翻转。</p>
<p>👉创建渲染纹理：Project—Create—Render Texture</p>
<p>👉创建渲染纹理对应的摄像机：调整好画面后，【Camera组件面板】Target Texture–上一步创建的渲染纹理</p>
<p>👉Shader控制，也就是当作基本纹理来使用，翻转一下，采样就OK </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.texcoord;</span><br><span class="line">    o.uv.x = 1 - o.uv.x;		//翻转【纹理范围为0，1】</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">	return tex2D(_MainTex, i.uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711105238093.png" alt="image-20220711105238093"></p>
<h3 id="玻璃效果"><a href="#玻璃效果" class="headerlink" title="玻璃效果"></a>玻璃效果</h3><p>🐽<strong>GrabPass</strong>：一种特殊的Pass，来<strong>获取屏幕图像</strong>。当在Shader中定义了一个GrabPass后，Unity会把当前屏幕的图像绘制在一张纹理中，以便我们在后续的Pass中访问它。</p>
<p>​    👉通常会使用这个来实现诸如<strong>玻璃等透明材质的模拟</strong>，与使用简单的透明混合不同，使用GrabGrass可以让我们<strong>对物体后面的图像进行更复杂的处理</strong>，例如使用法线模拟折射效果。</p>
<p>​    👉需要小心物体的渲染队列设置。GrabPass<strong>通常用于渲染透明物体</strong>，尽管代码里并<strong>不包含混合指令</strong>[就不会默认开启透明队列]，但还是要把渲染队列设置成透明队列{“Queue” = “Transparent”}</p>
<p>🐽思路：法线；通过Cubemap来模拟玻璃的<strong>反射</strong>；用Grab Pass获取玻璃后面的屏幕图像来模拟<strong>折射</strong>，并使用切线空间下的<u>法线来对屏幕纹理坐标偏移</u>后，再对屏幕图像进行采样来模拟近似的折射效果。（之前折射的物体表面是光滑的，这次加了法线纹理，凹凸也会影响折射）</p>
<p>​    👉【再详细说明】反射：关键语句——反射方向：reflect (-worldViewDir, bump);  采样：reflCol = texCUBE(_Cubemap, reflDir).rgb * texColor.rgb; bump是法线方向，由于这里采用了法线纹理，所以要对法线纹理进行采样。(一般来说是世界空间)然后是环境纹理</p>
<p>​    👉折射：不同于之前的用环境纹理，这里用的是屏幕渲染纹理。直接用坐标的偏移来模拟折射。</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220711164141728.png" alt="image-20220711164141728"></p>
<h3 id="渲染纹理-vs-GrabPass"><a href="#渲染纹理-vs-GrabPass" class="headerlink" title="渲染纹理 vs GrabPass"></a>渲染纹理 vs GrabPass</h3><table>
<thead>
<tr>
<th></th>
<th align="center">渲染纹理</th>
<th align="center">GrabPass</th>
</tr>
</thead>
<tbody><tr>
<td>好处</td>
<td align="center"><strong>效率高</strong>（尤其在移动设备）：可以自定义纹理大小</td>
<td align="center"><strong>实现简单</strong>：在Shader中几行代码实现</td>
</tr>
<tr>
<td>坏处</td>
<td align="center">较复杂：创建渲染纹理＆相机—设置RenderTarget—传递渲染纹理给Shader</td>
<td align="center">获取的图像分辨率和屏幕一致；在移动设备上，往往需要CPU直接读取后备缓冲中的数据，破坏了CPU和GPU的并行性，这是比较耗时的</td>
</tr>
</tbody></table>
<h2 id="程序纹理-Procedural-Texture"><a href="#程序纹理-Procedural-Texture" class="headerlink" title="程序纹理 Procedural Texture"></a>程序纹理 Procedural Texture</h2><p>由计算机生成的图像。通过一些特定的算法来创建个性化图案或者非常真实的自然元素。</p>
<h3 id="在Unity中实现简单的程序纹理"><a href="#在Unity中实现简单的程序纹理" class="headerlink" title="在Unity中实现简单的程序纹理"></a>在Unity中实现简单的程序纹理</h3><p>🥰基本思想：程序图案由脚本生成；脚本挂载在游戏对象上，生成的纹理影响本对象的Material材质。</p>
<p>👇主要研究脚本编写：如何生成纹理（绘制基本流程）？如何传递给Material？</p>
<p>​    【小技巧】在编辑模式下/非Play模式运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ExecuteInEditMode]</span><br><span class="line">public class ProcedualTextureGeneration : MonoBehaviour</span><br></pre></td></tr></table></figure>

<p>​    【主要变量】脚本生成的一张纹理Texture；纹理将要赋给的材质Material</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public Material material = null;</span><br><span class="line">private Texture2D m_generatedTexture = null;</span><br></pre></td></tr></table></figure>

<p>​    【变量的关键操作】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//-----Material------</span><br><span class="line">private void Start() &#123;</span><br><span class="line">    if (material == null)</span><br><span class="line">    &#123;</span><br><span class="line">    	Renderer renderer = gameObject.GetComponent&lt;Renderer&gt;();</span><br><span class="line">        if (renderer == null)</span><br><span class="line">        &#123;</span><br><span class="line">       	 	Debug.Log(&quot;Cannot find a renderer&quot;);</span><br><span class="line">        	return;</span><br><span class="line">        &#125;</span><br><span class="line">        material = renderer.sharedMaterial;					//获取不为空的material</span><br><span class="line">    &#125;</span><br><span class="line">    _UpdateMaterial();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void _UpdateMaterial()&#123;</span><br><span class="line">    if (material != null)</span><br><span class="line">    &#123;</span><br><span class="line">    	m_generatedTexture = _GenerateProceduralTexture();</span><br><span class="line">    	material.SetTexture(&quot;_MainTex&quot;, m_generatedTexture);	//纹理赋给material</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//-----Texture-----</span><br><span class="line">proceduralTexture.SetPixel(w, h, pixel);			//新的纹理：长/宽还有像素</span><br><span class="line">proceduralTexture.Apply();						   //Apply函数：强制把像素值写入纹理中</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由此可见对纹理是逐像素操作。</p>
</blockquote>
<h1 id="让画面动起来"><a href="#让画面动起来" class="headerlink" title="让画面动起来"></a>让画面动起来</h1><h2 id="Unity-Shader中的内置变量（时间篇）"><a href="#Unity-Shader中的内置变量（时间篇）" class="headerlink" title="Unity Shader中的内置变量（时间篇）"></a>Unity Shader中的内置变量（时间篇）</h2><h2 id="纹理动画"><a href="#纹理动画" class="headerlink" title="纹理动画"></a>纹理动画</h2><p>可以用纹理动画来代替复杂的粒子系统等模拟各种动画效果。</p>
<h3 id="序列帧动画"><a href="#序列帧动画" class="headerlink" title="序列帧动画"></a>序列帧动画</h3><p>优点：灵活性很大，不需要进行任何物理运算；缺点：所需美术工程量大（关键帧图像）。</p>
<p>🐽【关键】计算出每个时刻需要播放的关键帧在纹理中的位置：即关键帧所在的行列索引数</p>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220716221140400.png" alt="image-20220716221140400"></p>
<blockquote>
<p>原本是这样理解的，但行不通</p>
</blockquote>
<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220716221128192.png" alt="image-20220716221128192"></p>
<blockquote>
<p>目前是比较说的通的一种理解</p>
</blockquote>
<p>【渲染设置】透明度</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;</span><br><span class="line">            &quot;Queue&quot; = &quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot; = &quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>【frag】实质上是uv坐标的偏移。首先把uv“裁剪”到小方块，再进行索引的偏移。（或者偏移了再裁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    float time = floor(_Time.y * _Speed);</span><br><span class="line">    float row = floor(time / _HorizontalAmount);</span><br><span class="line">    float column = time - row * _HorizontalAmount;</span><br><span class="line"></span><br><span class="line">    //方法一（原理）</span><br><span class="line">    //half2 uv = float2(i.uv.x / _HorizontalAmount, i.uv.y / _VerticalAmount);</span><br><span class="line">    //uv.x += column / _HorizontalAmount;</span><br><span class="line">    //uv.y -= row / _VerticalAmount;</span><br><span class="line"></span><br><span class="line">    //方法二（改进）</span><br><span class="line">    half2 uv = i.uv + half2(column, -row);</span><br><span class="line">    uv.x /= _HorizontalAmount;</span><br><span class="line">    uv.y /= _VerticalAmount;</span><br><span class="line"></span><br><span class="line">    fixed4 c = tex2D(_MainTex, uv);</span><br><span class="line">    c.rgb *= _Color;</span><br><span class="line"></span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/08/202278-UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%AD%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/hexo_github_blog\source_posts\pic\image-20220716224957493.png" alt="image-20220716224957493"></p>
<h3 id="滚动的背景"><a href="#滚动的背景" class="headerlink" title="滚动的背景"></a>滚动的背景</h3><p>【关键】纹理坐标在水平方向的偏移；不同层（纹理）叠加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">v2f vert (a2v v)</span><br><span class="line">&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.pos = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv.xy = TRANSFORM_TEX(v.texcoord, _MainTex) + frac(float2(_ScrollX, 0.0) * _Time.y);</span><br><span class="line">    o.uv.zw = TRANSFORM_TEX(v.texcoord, _DetailTex) + frac(float2(_Scroll2X, 0.0) * _Time.y);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fixed4 frag (v2f i) : SV_Target</span><br><span class="line">&#123;</span><br><span class="line">    fixed4 firstLayer = tex2D(_MainTex, i.uv.xy);</span><br><span class="line">    fixed4 secondLayer = tex2D(_DetailTex, i.uv.zw);</span><br><span class="line">    fixed4 c = lerp(firstLayer, secondLayer, secondLayer.a);</span><br><span class="line"></span><br><span class="line">    c.rgb *= _Multiplier;</span><br><span class="line">    return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顶点动画"><a href="#顶点动画" class="headerlink" title="顶点动画"></a>顶点动画</h3><h4 id="流动的河流"><a href="#流动的河流" class="headerlink" title="流动的河流"></a>流动的河流</h4><p>（待理解完善）</p>
<p>即使代码写好了，效果不佳，锯齿很明显。可能是<strong>四边形Quad和平面Plane</strong>的区别导致。前者是由两个三角形构成，后者是由两百多个三角形构成，所以从效率上来说，四方形比平面更好。比如要在游戏里显示图片或者视频，这个非常合适。还有在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=GUI&spm=1001.2101.3001.7020">GUI</a>里显示一些图片，以及在粒子系统的粒子显示，精灵和伪图片等等。</p>
<h4 id="广告牌技术-Billboarding"><a href="#广告牌技术-Billboarding" class="headerlink" title="广告牌技术 Billboarding"></a>广告牌技术 Billboarding</h4><p>😎根据视角方向来旋转一个被纹理着色的多边形，使得多边形看起来好像总是面对着摄像机。</p>
<p>😺广告牌技术的本质是构建旋转矩阵，而一个变换矩阵需要<strong>三个基向量</strong>；通常是表面法线（normal）、指向上的方向（up）以及指向右的方向（right）。除此之外，还要指定一个锚点（anchor location），在旋转过程中是固定不变的。</p>
<p>🧐如何根据需求构建三个相互正交的基向量？</p>
<p>【要求】其中一个基向量是固定的，固定向上/法线等。</p>
<p>​    👉up固定：比如模拟草丛，想象一个草片立在地上，草尖固定对着天空，但是面片是一直朝向镜头的，所以玩家视角来看草就是立体的，除非从上往下看</p>
<p>​    👉normal固定：还是那片草，但始终面向摄像机。所以一般模拟粒子效果、烟雾等。</p>
<p>【条件】up和normal在同一平面上。</p>
<p>【构建】up和normal叉积出right，再用up和right叉积，以此类推。</p>
<p>🎏实践</p>
<p>【渲染设置】透明；取消批处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Chapter11/Billboard&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        _Color (&quot;Color Tint&quot;, Color) = (1, 1, 1, 1)</span><br><span class="line">        //用于调整是固定法线还是固定指向上的方向</span><br><span class="line">        _VerticalBillboarding (&quot;Vertical Restraints&quot;, Range(0, 1)) = 1</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Tags &#123;</span><br><span class="line">            &quot;Queue&quot; = &quot;Transparent&quot;</span><br><span class="line">            &quot;IgnoreProjector&quot; = &quot;True&quot;</span><br><span class="line">            &quot;RenderType&quot;=&quot;Transparent&quot;</span><br><span class="line">            //需要使用物体的模型空间下的位置来作为锚点进行计算</span><br><span class="line">            //所以要取消对该Shader的批处理操作</span><br><span class="line">            &quot;DisableBatching&quot; = &quot;True&quot; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">            Tags &#123; &quot;LightMode&quot; = &quot;ForwardBase&quot; &#125;</span><br><span class="line">            ZWrite Off</span><br><span class="line">            Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">            Cull Off</span><br></pre></td></tr></table></figure>

<p>【vert】所有计算都是在模型空间下完成的，所以主要在vert。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">v2f o;</span><br><span class="line"></span><br><span class="line">o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);</span><br><span class="line"></span><br><span class="line">/*向量准备：原点和视角位置*/</span><br><span class="line">float3 center = float3(0, 0, 0);</span><br><span class="line">float3 viewer = mul(unity_WorldToObject, float4(_WorldSpaceCameraPos, 1));</span><br><span class="line"></span><br><span class="line">/*计算正交矢量*/</span><br><span class="line">//1.固定法线方向</span><br><span class="line">float3 normalDir = viewer - center;</span><br><span class="line">//若_VerticalBillboarding为1，normalDir不变，说明法线方向固定（因为一直随摄像机）</span><br><span class="line">//若_VerticalBillboarding为0，normalDir的y变0，说明此时normalDir只能在xoz平面上。这就保证up固定不变</span><br><span class="line">normalDir.y *= _VerticalBillboarding;</span><br><span class="line">normalDir = normalize(normalDir);</span><br><span class="line"></span><br><span class="line">//2.判断并得出正确的向上分量，最后得出三个基向量</span><br><span class="line">//只是防止法线和up平行；只能保证两者在同一平面上，不一定互相垂直</span><br><span class="line">float3 upDir = abs(normalDir.y) &gt; 0.999 ? float3(0, 0, 1) : float3(0, 1, 0);</span><br><span class="line">float3 rightDir = normalize(cross(upDir, normalDir));</span><br><span class="line">upDir = normalize(cross(normalDir, rightDir));</span><br><span class="line"></span><br><span class="line">//3.计算新的顶点位置</span><br><span class="line">//目前只保证了坐标系是正确的；模型的顶点还要更新</span><br><span class="line">//根据原始位置相对于锚点的偏移量，以及3个正交基矢量</span><br><span class="line">float3 centerOffs = v.vertex.xyz - center;</span><br><span class="line">float3 localPos = center + rightDir * centerOffs.x + upDir * centerOffs.y + normalDir * centerOffs.z;</span><br><span class="line"></span><br><span class="line">o.pos = UnityObjectToClipPos(localPos);</span><br><span class="line"></span><br><span class="line">return o;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>🎈取消批处理：会带来一定的性能下降，增加了Draw Call，因此尽量避免使用模型空间下的一些绝对位置和方向来计算。</p>
<p>🎈为顶点动画计算阴影。如果使用的是内置的ShadowCaster Pass，这个Pass<strong>没有相关的定点动画</strong>，因此Unity仍然<strong>按照原来的顶点位置</strong>来计算阴影。</p>
<p>​    👉需要提供<strong>自定义</strong>的ShadowCaster Pass，在这个Pass中进行<strong>同样的顶点变换过程</strong>。</p>
<p>🎏实践（继河流的顶点动画添加阴影）</p>
<p>​    👉【重点】需要按正常的Pass的处理来剔除片元或进行顶点动画，以便阴影可以和物体渲染的结果<strong>相匹配</strong>。</p>
<p>​    👉【Unity提供的内置宏】用来计算阴影投影时需要的各种变量。而我们可以只关注自定义计算的部分。</p>
<p>【设置】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Pass to render object as a shadow caster</span><br><span class="line">Pass &#123;</span><br><span class="line">    Tags &#123; &quot;LightMode&quot; = &quot;ShadowCaster&quot; &#125;		//</span><br><span class="line"></span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    #pragma vertex vert</span><br><span class="line">    #pragma fragment frag</span><br><span class="line"></span><br><span class="line">    #pragma multi_compile_shadowcaster			//</span><br><span class="line"></span><br><span class="line">    #include &quot;UnityCG.cginc&quot;</span><br></pre></td></tr></table></figure>

<p>【v2f / vert】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct v2f &#123; </span><br><span class="line">	//定义阴影投射需要定义的变量</span><br><span class="line">	V2F_SHADOW_CASTER;		</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">v2f vert(appdata_base v) &#123;</span><br><span class="line">    v2f o;</span><br><span class="line"></span><br><span class="line">    float4 offset;</span><br><span class="line">    offset.yzw = float3(0.0, 0.0, 0.0);</span><br><span class="line">    offset.x = sin(_Frequency * _Time.y + v.vertex.x * _InvWaveLength + v.vertex.y * _InvWaveLength + v.vertex.z * _InvWaveLength) * _Magnitude;</span><br><span class="line">    v.vertex = v.vertex + offset;</span><br><span class="line"></span><br><span class="line">	//计算顶点的偏移量——》顶点位置</span><br><span class="line">    TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)</span><br><span class="line"></span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【frag】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fixed4 frag(v2f i) : SV_Target &#123;</span><br><span class="line">	//让Unity自动完成阴影投射部分，把结果输出到深度图和阴影映射纹理中</span><br><span class="line">	SHADOW_CASTER_FRAGMENT(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/dp_pic.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/18/UnityShader-%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E9%AB%98%E7%BA%A7%E7%AF%87-%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/img/319833.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UnityShader 入门精要/高级篇 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/28/Unity%20shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/"><img class="next-cover" src="/img/ta.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">UnityShader 入门精要/基础篇＋初级篇 笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(●ˇ∀ˇ●)</div><div class="author-info__description">someone very lazy</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huangxinhere"><i class="fab fa-github"></i><span>Don't Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E5%85%89%E7%85%A7"><span class="toc-number">1.</span> <span class="toc-text">更复杂的光照</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.</span> <span class="toc-text">Unity的渲染路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">前向渲染路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unity%E4%B8%AD%E7%9A%84%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">Unity中的前向渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%9A%84%E5%85%89%E7%85%A7%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">内置的光照变量和函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%85%A7%E6%98%8E%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">顶点照明渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">延迟渲染路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%93%AA%E7%A7%8D%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">选择哪种路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">Unity的光源类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mul-unity-ObjectToWorld-v-vertex-xyz%E5%92%8CUnityObjectToClipPos-v-vertex-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.1.</span> <span class="toc-text">mul(unity_ObjectToWorld,v.vertex).xyz和UnityObjectToClipPos(v.vertex);的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E4%B8%AD%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84%E5%85%89%E6%BA%90%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">在前向渲染中处理不同的光源类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">Unity的光照衰减</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F%E7%9A%84%E7%BA%B9%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">用于光照衰减的纹理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">1.4.</span> <span class="toc-text">Unity的阴影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">阴影是如何实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">1.4.2.</span> <span class="toc-text">不透明物体的阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%AE%A1%E7%90%86%E5%85%89%E7%85%A7%E8%A1%B0%E5%87%8F%E5%92%8C%E9%98%B4%E5%BD%B1"><span class="toc-number">1.4.3.</span> <span class="toc-text">统一管理光照衰减和阴影</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E7%9A%84%E9%98%B4%E5%BD%B1"><span class="toc-number">1.4.4.</span> <span class="toc-text">透明物体的阴影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86Unity-Shader"><span class="toc-number">1.5.</span> <span class="toc-text">标准Unity Shader</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%BA%B9%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">高级纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E6%96%B9%E4%BD%93%E7%BA%B9%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">立方体纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E7%A9%BA%E7%9B%92%E5%AD%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">天空盒子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E4%BA%8E%E7%8E%AF%E5%A2%83%E6%98%A0%E5%B0%84%E7%9A%84%E7%AB%8B%E6%96%B9%E4%BD%93%E7%BA%B9%E7%90%86"><span class="toc-number">2.1.2.</span> <span class="toc-text">创建用于环境映射的立方体纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">2.1.3.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%B0%84"><span class="toc-number">2.1.4.</span> <span class="toc-text">折射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B2%E6%B6%85%E5%B0%94%E5%8F%8D%E5%B0%84"><span class="toc-number">2.1.5.</span> <span class="toc-text">菲涅尔反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">渲染纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%AD%90%E6%95%88%E6%9E%9C"><span class="toc-number">2.2.1.</span> <span class="toc-text">镜子效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%BB%E7%92%83%E6%95%88%E6%9E%9C"><span class="toc-number">2.2.2.</span> <span class="toc-text">玻璃效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E7%BA%B9%E7%90%86-vs-GrabPass"><span class="toc-number">2.2.3.</span> <span class="toc-text">渲染纹理 vs GrabPass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BA%B9%E7%90%86-Procedural-Texture"><span class="toc-number">2.3.</span> <span class="toc-text">程序纹理 Procedural Texture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8Unity%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BA%B9%E7%90%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">在Unity中实现简单的程序纹理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A9%E7%94%BB%E9%9D%A2%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="toc-number">3.</span> <span class="toc-text">让画面动起来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity-Shader%E4%B8%AD%E7%9A%84%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F%EF%BC%88%E6%97%B6%E9%97%B4%E7%AF%87%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">Unity Shader中的内置变量（时间篇）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%B9%E7%90%86%E5%8A%A8%E7%94%BB"><span class="toc-number">3.2.</span> <span class="toc-text">纹理动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%B8%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">序列帧动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">滚动的背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E5%8A%A8%E7%94%BB"><span class="toc-number">3.2.3.</span> <span class="toc-text">顶点动画</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E5%8A%A8%E7%9A%84%E6%B2%B3%E6%B5%81"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">流动的河流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%91%8A%E7%89%8C%E6%8A%80%E6%9C%AF-Billboarding"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">广告牌技术 Billboarding</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.2.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By (●ˇ∀ˇ●)</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks to watch my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
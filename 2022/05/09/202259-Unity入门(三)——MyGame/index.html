<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Unity入门(三)——MyGame | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="结课作业第一波：第一次尝试想法先行，后操作">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity入门(三)——MyGame">
<meta property="og:url" content="https://huangxinhere.github.io/2022/05/09/202259-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="结课作业第一波：第一次尝试想法先行，后操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huangxinhere.github.io/img/MyGame.png">
<meta property="article:published_time" content="2022-05-08T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-15T10:45:45.686Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huangxinhere.github.io/img/MyGame.png"><link rel="shortcut icon" href="/huangxinhere.github.io/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2022/05/09/202259-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/huangxinhere.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/huangxinhere.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity入门(三)——MyGame',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-15 18:45:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/huangxinhere.github.io/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/huangxinhere.github.io/img/head_pic_3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/huangxinhere.github.io/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/huangxinhere.github.io/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/huangxinhere.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/huangxinhere.github.io/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/huangxinhere.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/huangxinhere.github.io/img/MyGame.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/huangxinhere.github.io/">Hx's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/huangxinhere.github.io/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/huangxinhere.github.io/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/huangxinhere.github.io/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/huangxinhere.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity入门(三)——MyGame</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-08T16:00:00.000Z" title="发表于 2022-05-09 00:00:00">2022-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-15T10:45:45.686Z" title="更新于 2022-06-15 18:45:45">2022-06-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/huangxinhere.github.io/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity入门(三)——MyGame"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h1><h2 id="水平垂直方向的平移"><a href="#水平垂直方向的平移" class="headerlink" title="水平垂直方向的平移"></a>水平垂直方向的平移</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> h = Input.GetAxisRaw(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    <span class="built_in">float</span> v = Input.GetAxisRaw(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*存储角色的移动*/</span></span><br><span class="line">    m_Movement.Set(h, <span class="number">0f</span>, v);</span><br><span class="line">    m_Movement.Normalize();     <span class="comment">//确保对角线移动速度相同【矢量标准化为长度1】</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> hasHorizontalInput = !Mathf.Approximately(h, <span class="number">0f</span>);  <span class="comment">//两者相似，则不在移动</span></span><br><span class="line">    <span class="built_in">bool</span> hasVerticalInput = !Mathf.Approximately(v, <span class="number">0f</span>);</span><br><span class="line">    <span class="built_in">bool</span> isWalking = hasHorizontalInput || hasVerticalInput;<span class="comment">//判断是否在走路</span></span><br><span class="line">    animator.SetBool(<span class="string">&quot;isWalking&quot;</span>, isWalking);               <span class="comment">//通过所有定义的输入来判断是否走路。如果按照按键则限制较大</span></span><br><span class="line">    <span class="comment">//这里为止，只是播放动画但会一直往前走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>控制角色旋转的速度：</p>
<ul>
<li>创建和存储旋转，以便可以在任何需要的地方使用。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"> Quaternion m_Rotation = Quaternion.identity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line">Vector3 desiredForward = Vector3.RotateTowards(transform.forward, m_Movement, rotateSpeed * Time.deltaTime, <span class="number">0f</span>);</span><br><span class="line">        m_Rotation = Quaternion.LookRotation(desiredForward);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四元数是存储旋转的一种方式"><a href="#四元数是存储旋转的一种方式" class="headerlink" title="四元数是存储旋转的一种方式"></a>四元数是存储旋转的一种方式</h3><ul>
<li>可用于解决将旋转存储为 3D 矢量时遇到的一些问题。</li>
<li>通常情况下，创建类的实例时，会将属于类的变量（成员变量）而不是属于特定方法的变量设置为默认值。例如，Vector3 的默认值是将 x、y 和 z 都设置为 0。四元数也是如此。但是，虽然零矢量是合理的（因为没有移动），零四元数却不太合理。这里设置的 Quaternion.identity 值就是为其赋予无旋转的值，这是一个<strong>更合理的默认值</strong>。</li>
</ul>
<h3 id="Vector3-RotateTowards"><a href="#Vector3-RotateTowards" class="headerlink" title="Vector3.RotateTowards"></a>Vector3.RotateTowards</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">RotateTowards</span> (<span class="params">Vector3 current, Vector3 target, <span class="built_in">float</span> maxRadiansDelta, <span class="built_in">float</span> maxMagnitudeDelta</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://s3.bmp.ovh/imgs/2022/05/09/46b181830a7d075b.png" alt="image-20220509155607107"></p>
<ul>
<li>返回<strong>Vector3</strong> RotateTowards 生成的位置。</li>
<li>描述：该函数类似于 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.MoveTowards.html">MoveTowards</a>，但<strong>向量被视为方向而不是位置</strong>。 <code>current</code> 向量将朝 <code>target</code> 方向旋转 <code>maxRadiansDelta</code> 的角度， 但其将准确地落在目标上而不会超过目标。 如果 <code>current</code> 和 <code>target</code> 的大小不同，则在旋转期间对结果大小进行线性插值。 如果为 <code>maxRadiansDelta</code> 使用负值，则向量将朝远离 <code>target</code> 的方向旋转， 直到它指向完全相反的方向，然后停止。</li>
</ul>
<h3 id="每一帧存储旋转方向"><a href="#每一帧存储旋转方向" class="headerlink" title="每一帧存储旋转方向"></a>每一帧存储旋转方向</h3><h2 id="将移动和旋转应用于角色"><a href="#将移动和旋转应用于角色" class="headerlink" title="将移动和旋转应用于角色"></a>将移动和旋转应用于角色</h2><ul>
<li><p>可以通过多种方式来执行此操作，但是由于<strong>角色需要成为物理系统的一部分</strong>，因此需要移动刚体而不是使用任何其他方法。</p>
</li>
<li><p>该角色有一段有趣的 Walk 动画，最好为此使用<strong>根运动</strong>。但是，该动画中没有任何旋转，如果尝试在 Update 方法中旋转刚体 (Rigidbody)，则动画可能会覆盖该刚体（这可能导致角色在应该旋转的时候不旋转）</p>
</li>
<li><p><strong>实际需要的是动画的一部分根运动</strong>（？，但不是全部的根运动；具体来说，需要应用移动而不是旋转。那么如何更改从 Animator 中应用根运动的方式呢？幸运的是，MonoBehaviour 有一种特殊的方法可用于更改从 Animator 中应用根运动的方式</p>
</li>
</ul>
<h3 id="根运动"><a href="#根运动" class="headerlink" title="根运动"></a>根运动</h3><ul>
<li><p>根运动 (Root Motion) 角色根的运动（无论是由动画本身还是由外部控制）。</p>
</li>
<li><p>工作原理：<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/Manual/RootMotion.html">根运动 - 工作原理 - Unity 手册</a></p>
</li>
<li><p>动画用于在特定层级视图中移动和旋转所有游戏对象。这些移动和旋转大多数都是相对于其父项完成的，但是层级视图的父游戏对象没有父项，因此它们的移动不是相对的。此父游戏对象也可以称为根 (Root)，因此其移动称为根运动 (Root Motion)。</p>
<p><strong>重要注意事项！</strong>在 JohnLemon 预制件的层级视图中称为根的游戏对象指的是其骨架的根，而不是实际的根游戏对象。根游戏对象是 Animator 组件所在的任何游戏对象，在本例中，该游戏对象称为 JohnLemon。</p>
<p>在 Animator 组件上启用了 Apply Root Motion，因此根在动画中的任何移动都将应用于每一帧。由于 Animator 正在播放 Idle 动画，没有移动，因此 Animator 不会施加任何动作。那么，为什么 JohnLemon 游戏对象会移动呢？这是因为 Animator 的**更新模式 (Update Mode)**。</p>
</li>
</ul>
<h3 id="OnAnimatorMove（）"><a href="#OnAnimatorMove（）" class="headerlink" title="OnAnimatorMove（）"></a>OnAnimatorMove（）</h3><ul>
<li>MonoBehaviour 有一种特殊的方法可用于更改从 Animator 中应用根运动的方式。</li>
<li>在每个更新帧中为每个 <strong>Animator 组件</strong>调用一次此函数来<strong>修改根运动</strong> (Root Motion)。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    m_Rigidbody.MovePosition(m_Rigidbody.position + m_Movement * animator.deltaPosition.magnitude);</span><br><span class="line">    m_Rigidbody.MoveRotation(m_Rotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Animator 的 <strong>deltaPosition</strong> 是由于可以应用于此帧的根运动而导致的位置变化。将其大小（即长度）乘以我们希望角色移动的实际方向上的移动向量</p>
</blockquote>
<h3 id="Animator通过物理循环适时运行"><a href="#Animator通过物理循环适时运行" class="headerlink" title="Animator通过物理循环适时运行"></a>Animator通过物理循环适时运行</h3><p><a target="_blank" rel="noopener" href="https://learn.unity.com/tutorial/the-player-character-part-1">从而避免物理与动画之间发生冲突。但是，现在您将使用 OnAnimatorMove 来覆盖根运动。这意味着 OnAnimato</a>rMove 实际上将通过物理适时被调用，而不是像 Update 方法那样通过渲染被调用。</p>
<ul>
<li>FixedUpdate：在物理系统处理所有碰撞和其他已发生的交互之前被调用。默认情况下，每秒正好调用 50 次这个方法。</li>
</ul>
<h3 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h3><p>整个流程下来都是很晕。试了一下，如果</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1*/</span></span><br><span class="line">m_Movement.Set(h, <span class="number">0f</span>, v);</span><br><span class="line">m_Movement.Normalize();  </span><br><span class="line"></span><br><span class="line">rg.MovePosition(m_Movement);<span class="comment">//h，v只是方向向量，长度为1，所以不能连续移动（最远也是一个单位）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2:普通做法*/</span></span><br><span class="line">Vector3 move = rg.position;</span><br><span class="line">move.x += move_speed * h * Time.deltaTime;</span><br><span class="line">move.z += move_speed * v * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">rg.MovePosition(move);	<span class="comment">//这样便是自己控制速度来移动（不会旋转）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorMove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    m_Rigidbody.MovePosition(m_Rigidbody.position + m_Movement * animator.deltaPosition.magnitude);</span><br><span class="line">    m_Rigidbody.MoveRotation(m_Rotation);</span><br><span class="line">&#125;						</span><br><span class="line"><span class="comment">//所以比较看出，这个方法并没有设置速度，而是用了animator.deltaPosition.magnitude来作为移动的变化量</span></span><br><span class="line"><span class="comment">//官方解释：应用于此帧的根运动而导致的位置变化；或者说是动画固定的步长？</span></span><br><span class="line"><span class="comment">//那么，模型和动画实质上可以相互影响的？</span></span><br><span class="line"><span class="comment">//之前觉得就是控制模型刚体移动，然后顺便播放动画</span></span><br></pre></td></tr></table></figure>

<h2 id="吃透理解！！"><a href="#吃透理解！！" class="headerlink" title="吃透理解！！"></a>吃透理解！！</h2><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/2bcff3ae37034084.png" alt="image-20220509202135390"></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/06/04/4b31d6cfc4ff781a.png" alt="image-20220513213526442"></p>
<blockquote>
<p>补充PS部分：是重写了OnAnimationMove()方法才会取消复选框</p>
</blockquote>
<h2 id="Root-Motion工作原理"><a href="#Root-Motion工作原理" class="headerlink" title="Root Motion工作原理"></a>Root Motion工作原理</h2><h3 id="Body-Transform"><a href="#Body-Transform" class="headerlink" title="Body Transform"></a>Body Transform</h3><p>是角色的质心（重心）。用于Mecanim系统的<em>重定向引擎</em>中来提供<strong>稳定的模型移动</strong>。身体朝向是角色模型在T姿势下上身和下身朝向的平均值。</p>
<p><strong>Body Transform和朝向</strong>存储在Animation Clip中，这两个是Animation Clip中存储的唯二<strong>世界空间</strong>的曲线，<u>其他的动画曲线</u>都是以相对body transform的形式存储的。</p>
<h3 id="Root-Transform（根变换）"><a href="#Root-Transform（根变换）" class="headerlink" title="Root Transform（根变换）"></a>Root Transform（根变换）</h3><p>是body transform在Y平面上的投影，并且是运行时运算的。每一帧Root Transform的变化实时计算。然后Transform的变化会被应用到GameObject上从而让物体移动。</p>
<h3 id="调整Root-Transform"><a href="#调整Root-Transform" class="headerlink" title="调整Root  Transform"></a>调整Root  Transform</h3><h4 id="Root-Transform-Rotation"><a href="#Root-Transform-Rotation" class="headerlink" title="Root Transform Rotation"></a>Root Transform Rotation</h4><h4 id="Root-Transform-Position-Y"><a href="#Root-Transform-Position-Y" class="headerlink" title="Root Transform Position(Y)"></a>Root Transform Position(Y)</h4><h4 id="Root-Transform-Position-XZ"><a href="#Root-Transform-Position-XZ" class="headerlink" title="Root Transform Position(XZ)"></a>Root Transform Position(XZ)</h4><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/d065079294b6ba57.png" alt="image-20220513213506678"></p>
<p>详情见<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/151387595">Unity动画系统详解6：如何做好角色的移动动画？（Root Motion详解） - 知乎 (zhihu.com)</a></p>
<h1 id="相机跟随（CineMachine）"><a href="#相机跟随（CineMachine）" class="headerlink" title="相机跟随（CineMachine）"></a>相机跟随（CineMachine）</h1><p><a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineUsing.html">使用Cinemachine|电影|2.8.4 (unity.cn)</a></p>
<h2 id="虚拟摄像机"><a href="#虚拟摄像机" class="headerlink" title="虚拟摄像机"></a>虚拟摄像机</h2><p>Cinemachine 是 Unity 针对游戏中与摄像机有关的所有问题的解决方案。</p>
<ul>
<li>在场景中创建一个或多个“虚拟”摄像机。</li>
<li>这些虚拟摄像机由一个名为 Cinemachine Brain 的组件进行管理。</li>
<li>Cinemachine Brain 与 Camera 组件连接到相同的游戏对象，默认情况下，这个游戏对象将是 Main Camera 游戏对象。</li>
<li>Cinemachine Brain 管理所有虚拟摄像机，并确定实际摄像机应跟随哪个虚拟摄像机（或虚拟摄像机的组合）。</li>
</ul>
<p>详细说明：</p>
<ul>
<li><p>Cinemachine不会创建新的摄像机。相反，它会将单个 Unity 摄像机定向到多个镜头。您可以使用<strong>虚拟摄像机</strong>构图这些镜头。虚拟摄像机移动和旋转 Unity 摄像机并控制其设置。</p>
</li>
<li><p>虚拟摄像机是独立于 Unity 摄像机的游戏对象，其行为独立。它们不嵌套在彼此内。例如，场景可能如下所示：</p>
<p><img src="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/images/CinemachineSceneHierarchy.png" alt="A Scene containing a Unity camera with Cinemachine Brain (blue) and multiple Virtual Cameras (red)"></p>
<ul>
<li>虚拟摄像机为您执行的主要任务：<ul>
<li>将 Unity 摄像机放置在场景中。</li>
<li>将 Unity 相机对准某些物体。</li>
<li>将程序噪声添加到 Unity 摄像机。噪音模拟手持效果或车辆晃动等。</li>
</ul>
</li>
<li>Cinemachine鼓励您创建许多虚拟摄像机。虚拟摄像机的设计<strong>消耗很少的处理能力</strong>。如果您的场景对性能敏感，请在任何给定时刻停用除基本虚拟摄像机之外的所有摄像机，以获得最佳性能。</li>
<li>一个虚拟摄像机可以在任何时间点控制 Unity 摄像机。这是<strong>实时</strong>虚拟摄像机。此规则的例外情况是从一个虚拟摄像机到下一个虚拟摄像机的混合。在混合过程中，两个虚拟摄像机都是实时的。</li>
</ul>
</li>
</ul>
<h2 id="Cinemachine-Brain"><a href="#Cinemachine-Brain" class="headerlink" title="Cinemachine Brain"></a>Cinemachine Brain</h2><ul>
<li><p>是Unity Camera本身的一个组件.</p>
</li>
<li><p><strong>监控</strong>场景中所有活动的虚拟摄像机。【选择】要指定下一个实时虚拟摄像机，请<a target="_blank" rel="noopener" href="https://docs.unity.cn/Manual/DeactivatingGameObjects.html">激活或停用</a>所需虚拟摄像机的游戏对象。然后，Cinemachine Brain选择与实时虚拟摄像机具有相同或更高优先级的最新激活的虚拟摄像机。它在以前的虚拟摄像机和新虚拟摄像机之间执行剪切或混合。</p>
</li>
<li><p>使用Cinemachine Brain实时响应动态游戏事件。它允许您的游戏逻辑通过操作优先级来控制摄像机。这对于实时游戏玩法特别有用，因为实时游戏玩法中的动作并不总是可预测的。使用<a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineTimeline.html">时间轴</a>在可预测的情况下（如过场动画）编排摄像机。时间轴覆盖了Cinemachine Brain优先级系统，为您提供精确的帧摄像机控制。</p>
<p>（也就是相对于时间轴来说可以实时控制摄像机）</p>
</li>
</ul>
<h2 id="Moving-and-aiming"><a href="#Moving-and-aiming" class="headerlink" title="Moving and aiming"></a>Moving and aiming</h2><p>这里面有多种算法来控制移动和瞄准。每个算法都解决一个特定问题。（理解为某种特定的相机行为模式,在此分为怎么样跟随，怎么样旋转）</p>
<h3 id="Body-properties-how-to-move-跟随"><a href="#Body-properties-how-to-move-跟随" class="headerlink" title="Body properties: how to move(跟随)"></a>Body properties: how to move(跟随)</h3><ul>
<li>Transposer：以<u>固定关系</u>移动到<strong>“跟随</strong>”目标，并具有可选的阻尼。</li>
<li>Do Nothing: 虚拟相机不移动。</li>
<li>Framing Transposer: 在固定的屏幕空间关系中移动到<strong>“跟随”</strong>目标，并带有可选的阻尼。</li>
<li>Orbital Transposer: 在可变关系中移动到<strong>“跟随”</strong>目标，可以选择接受玩家输入。??</li>
<li>Tracked Dolly: 沿预定义的路径移动。为静态拍摄或直接使用自定义脚本对摄像机位置进行动画处理，选择此算法。</li>
<li>Hard Lock to Target: 在<strong>“跟随</strong>”目标位置使用相同的位置。</li>
<li>3rd Person Follow: 将摄像机保持在相对于跟随目标的恒定位置和距离（受阻尼控制），跟踪目标的移动和旋转。</li>
</ul>
<h3 id="Aim-properties-how-to-rotate（瞄准）"><a href="#Aim-properties-how-to-rotate（瞄准）" class="headerlink" title="Aim properties: how to rotate（瞄准）"></a>Aim properties: how to rotate（瞄准）</h3><ul>
<li>Composer: 将<strong>“查看”</strong>目标保留在相机帧中，并带有合成约束。??</li>
<li>Group Composer: 在相机帧中保留多个<strong>“查看”</strong>目标。</li>
<li>Do Nothing: 不旋转</li>
<li>POV: 根据用户输入旋转虚拟摄像机</li>
<li>Same As Follow Target: 将相机的旋转设置为<strong>跟随</strong>目标的旋转。</li>
<li>Hard Look At: 将<strong>“看向”</strong>目标保持在相机帧的中心。</li>
</ul>
<h3 id="Composing-a-shot-构图"><a href="#Composing-a-shot-构图" class="headerlink" title="Composing a shot 构图"></a>Composing a shot 构图</h3><p>Framing Transposer/Composer/Group Composer算法定义了相机帧中区域，以便构图：</p>
<ul>
<li><p><strong>盲区</strong>：Cinemachine将目标保留在画面中的区域。</p>
</li>
<li><p><strong>柔和区域</strong>：如果目标进入帧的此区域，相机将重新定向以将其放回盲区。它将根据阻尼设置中指定的时间缓慢或快速地执行此操作。</p>
</li>
<li><p><strong>屏幕</strong>：死区中心的屏幕位置。0.5 是屏幕的中心。</p>
</li>
<li><p><strong>阻尼</strong>：模拟真实摄像机操作员在操作重型物理摄像机时引入的滞后。阻尼指定当目标进入<strong>软区</strong>时，当摄像机跟踪目标时，摄像机会快速或缓慢地做出反应。使用小数字来模拟响应更快的相机，快速移动或瞄准相机以将目标保持在<strong>盲区</strong>。模拟更重的摄像机数量越多，值越大，Cinemachine允许目标进入软区的数量就越多。</p>
<p><img src="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/images/CinemachineGameWindowGuides.png" alt="游戏窗口指南提供阻尼、屏幕、软区和死区的视觉指示"></p>
<blockquote>
<p>清晰区域表示<strong>盲区</strong>。蓝色区域表示<strong>柔和区域</strong>。软区和死区的位置表示<strong>屏幕</strong>位置。红色区域表示目标从未进入的<strong>无通过</strong>区域。黄色方块表示目标。</p>
</blockquote>
</li>
</ul>
<p>调整这些区域以获得各种相机行为。为此，请在“游戏”视图中拖动其边缘，或在“检查器”窗口中编辑其属性。</p>
<h2 id="使用噪点模拟相机抖动"><a href="#使用噪点模拟相机抖动" class="headerlink" title="使用噪点模拟相机抖动"></a>使用噪点模拟相机抖动</h2><p>现实世界的物理相机通常很重且笨重。它们由摄像机操作员手持或安装在不稳定的物体上，如移动的车辆。使用<a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraNoise.html">“杂色”属性</a>（Noise properties）来模拟这些真实世界品质，以获得电影效果。例如，您可以在跟随正在奔跑的角色时添加摄像机抖动，以使玩家沉浸在动作中。</p>
<h2 id="虚拟摄像机属性"><a href="#虚拟摄像机属性" class="headerlink" title="虚拟摄像机属性"></a>虚拟摄像机属性</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><ul>
<li><strong>Live</strong>：虚拟摄像机主动控制具有Cinemachine大脑的Unity摄像机。当Cinemachine大脑从一个虚拟摄像机混合到下一个虚拟摄像机时，两个虚拟摄像机都是实时的。混合完成后，只有一个实时虚拟摄像机。</li>
<li><strong>待机</strong>Standby：虚拟摄像机无法控制 Unity 摄像机。但是，它仍然遵循并瞄准其目标，并在每一帧更新。处于此状态的虚拟摄像机将被激活，其优先级与实时虚拟摄像机相同或更低。</li>
<li><strong>已禁用</strong>Disabled：虚拟摄像机无法控制 Unity 摄像机，也不会主动跟踪或瞄准其目标。处于此状态的虚拟摄像机不会消耗处理能力。要禁用虚拟摄像机，请停用其游戏对象。虚拟摄像机存在，但在场景中处于禁用状态。但是，即使游戏对象已停用，如果虚拟摄像机正在参与混合，或者如果时间轴调用了该混合，虚拟摄像机仍然可以控制 Unity 摄像机。</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>Property:</strong></th>
<th align="left"></th>
<th align="left"><strong>Function:</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Solo</strong></td>
<td align="left"></td>
<td align="left">Toggles whether or not the Virtual Camera is temporarily live. Use this property to get immediate visual feedback in the <a target="_blank" rel="noopener" href="https://docs.unity.cn/Manual/GameView.html">Game view</a> to adjust the Virtual Camera.</td>
</tr>
<tr>
<td align="left"><strong>Game Window Guides</strong></td>
<td align="left"></td>
<td align="left">参考线</td>
</tr>
<tr>
<td align="left"><strong>Save During Play</strong></td>
<td align="left"></td>
<td align="left">Check to <a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineSavingDuringPlay.html">apply the changes while in Play mode</a>.</td>
</tr>
<tr>
<td align="left"><strong>Priority</strong></td>
<td align="left"></td>
<td align="left">值越大，表示优先级越高。 将虚拟摄像机与时间轴配合使用时，此属性不起作用。</td>
</tr>
<tr>
<td align="left"><strong>Follow</strong></td>
<td align="left"></td>
<td align="left">The target GameObject that the Virtual Camera moves with. The <a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraBody.html">Body properties</a> use this target to update <strong>the position of the Unity camera</strong>. //？？Keep this property empty to make the Unity camera use the position of the Virtual Camera’ transform. For example, you might choose to animate the Virtual Camera in Timeline.</td>
</tr>
<tr>
<td align="left"><strong>Look At</strong></td>
<td align="left"></td>
<td align="left">The target GameObject to aim the Unity camera at. The <a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraAim.html">Aim properties</a> use this target to update the rotation of the Unity camera. Keep this property empty to make the Unity camera use the orientation of the Virtual Camera.</td>
</tr>
<tr>
<td align="left"><strong>Standby Update</strong></td>
<td align="left"></td>
<td align="left">Controls <u>how often</u> the virtual camera is updated when the virtual camera is not live.</td>
</tr>
<tr>
<td align="left"><strong>Position Blending</strong></td>
<td align="left"></td>
<td align="left">Style for blending positions to and from this Virtual Camera.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Linear</em></td>
<td align="left">Standard linear position blend.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Spherical</em></td>
<td align="left">Spherical blend about the Look At position, if there is a Look At target.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Cylindrical</em>圆柱</td>
<td align="left">Cylindrical blend about the Look At position, if there is a Look At target. Vertical coordinate is linearly interpolated.</td>
</tr>
<tr>
<td align="left"><strong>Lens</strong></td>
<td align="left"></td>
<td align="left">属性镜像<a target="_blank" rel="noopener" href="https://docs.unity.cn/Manual/class-Camera.html">Unity camera</a>.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Field Of View</em></td>
<td align="left">The camera view in vertical degrees. For example, to specify the equivalent of a 50mm lens on a Super 35 sensor, enter a Field of View of 19.6 degrees. This property is available when the Unity camera with the Cinemachine Brain component uses a Projection of Perspective.//太专业了，不懂</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Presets</em></td>
<td align="left">A drop-down menu of settings for commonly-used lenses. Choose <strong>Edit Presets</strong> to add or edit the asset that contains a default list of lenses.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Orthographic Size</em></td>
<td align="left">When using an orthographic camera, defines the half-height of the camera view, in world coordinates. Available when the Unity camera with the Cinemachine Brain component uses a Projection of Orthographic.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Near Clip Plane</em></td>
<td align="left">The closest point relative to the camera where drawing occurs.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Far Clip Plane</em></td>
<td align="left">The furthest point relative to the camera where drawing occurs.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Dutch</em>荷兰语（特有的）</td>
<td align="left">Dutch angle. Tilts the Unity camera on the z-axis, in degrees. This property is unique to the Virtual Camera; there is no counterpart property in the Unity camera.</td>
</tr>
<tr>
<td align="left"><strong>Mode Override</strong></td>
<td align="left"></td>
<td align="left">Allows you to select a different camera mode to apply to the <a target="_blank" rel="noopener" href="https://docs.unity.cn/Manual/class-Camera.html">Unity camera</a> component when Cinemachine activates this Virtual Camera. <strong>Important:</strong> All the changes applied to the Camera component through this setting will remain after the Virtual Camera deactivation. If you set a mode override in any Virtual Camera, you should set one in all Virtual Cameras.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>None</em></td>
<td align="left">Leaves the <strong>Projection</strong> and <strong>Physical Camera</strong> properties unchanged in the Camera.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Orthographic</em></td>
<td align="left">Sets the <strong>Projection</strong> property to <strong>Orthographic</strong>.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Perspective</em></td>
<td align="left">Sets the <strong>Projection</strong> property to <strong>Perspective</strong> and <em>disables</em> the <strong>Physical Camera</strong> feature and properties.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Physical</em></td>
<td align="left">Sets the <strong>Projection</strong> property to <strong>Perspective</strong> and <em>enables</em> the <strong>Physical Camera</strong> feature and properties.</td>
</tr>
<tr>
<td align="left"><strong>Blend Hint</strong></td>
<td align="left"></td>
<td align="left">Provides hints for blending positions to and from the virtual camera.</td>
</tr>
<tr>
<td align="left"><strong>Inherit Position</strong></td>
<td align="left"></td>
<td align="left">When enabled, whenever this virtual camera goes live, forces the initial position to be the same as the current position of the Unity Camera, if possible.</td>
</tr>
<tr>
<td align="left"><strong>Extensions</strong></td>
<td align="left"></td>
<td align="left">Components that add extra behaviors to the Virtual Camera.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><em>Add Extension</em></td>
<td align="left">Choose a new <a target="_blank" rel="noopener" href="https://docs.unity.cn/Packages/com.unity.cinemachine@2.8/manual/CinemachineVirtualCameraExtensions.html">extension</a> to add to the Virtual Camera.</td>
</tr>
</tbody></table>
<h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/2021.3/Documentation/Manual/UIToolkits.html">Unity - 手动：创建用户界面 （UI） (unity3d.com)</a></p>
<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>表示在其中布局和呈现 UI 的抽象空间。所有 UI 元素都必须是附加了画布组件的游戏对象的子级。</p>
<table>
<thead>
<tr>
<th align="left">*<em>Property:*</em></th>
<th align="left">*<em>Function:*</em></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Render Mode</strong></td>
<td align="left">The way the <strong>UI</strong>  is rendered to the screen or as an object in 3D space (see below). The options are <em>Screen Space - Overlay</em>, <em>Screen Space - Camera</em> and <em>World Space</em>.</td>
</tr>
<tr>
<td align="left"><strong>Pixel Perfect (*Screen Space* modes only)</strong></td>
<td align="left">Should the UI be rendered without <strong>antialiasing</strong>  for precision?为了精确度产生抗锯齿</td>
</tr>
<tr>
<td align="left"><strong>Render</strong> Camera__ (<em>Screen Space - Camera</em> mode only)__</td>
<td align="left">The camera to which the UI should be rendered (see below).</td>
</tr>
<tr>
<td align="left"><strong>Plane Distance (*Screen Space - Camera* mode only)</strong></td>
<td align="left">The distance at which the UI plane should be placed in front of the camera.</td>
</tr>
<tr>
<td align="left"><strong>Event Camera (*World Space* mode only)</strong></td>
<td align="left">The camera that will be used to process UI events.</td>
</tr>
<tr>
<td align="left"><strong>Receives Events</strong></td>
<td align="left">UI 事件是否由此画布处理？</td>
</tr>
</tbody></table>
<h3 id="单个或多个canvas"><a href="#单个或多个canvas" class="headerlink" title="单个或多个canvas"></a>单个或多个canvas</h3><p>所有 UI 元素的单个画布就足够了，但scene是可能的。也可以使用嵌套的 Canvas，其中一个 Canvas 被放置为另一个 Canvas 的子级以进行优化。嵌套的画布使用与其父级相同的渲染模式。</p>
<h3 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h3><h4 id="Screen-Space-Overlay-屏幕空间-叠加"><a href="#Screen-Space-Overlay-屏幕空间-叠加" class="headerlink" title="Screen Space - Overlay 屏幕空间 - 叠加"></a>Screen Space - Overlay 屏幕空间 - 叠加</h4><p>在此模式下，将缩放 Canvas 以<strong>适合屏幕</strong>，然后直接渲染，而<strong>不参考场景或摄像机</strong>（即使场景中根本没有摄像机，也会渲染 UI）。如果屏幕的大小或分辨率发生更改，则 UI 将自动重新缩放以适合屏幕大小。UI 将在任何其他图形（如相机视图）上绘制。</p>
<p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasOverlay.png" alt="在场景对象上呈现的叠加 UI"></p>
<blockquote>
<p>在场景对象上呈现的叠加 UI</p>
</blockquote>
<p>注： “屏幕空间 - 叠加”画布需要存储在层次结构的顶层。如果不使用它，则 UI 可能会从视图中消失。这是一个内置限制。将“屏幕空间 - 叠加”画布<strong>保留在层次结构的顶层</strong>，以获得预期的结果。(在游戏对象的排序中最前？)</p>
<h4 id="Screen-Space-Camera-屏幕空间-相机"><a href="#Screen-Space-Camera-屏幕空间-相机" class="headerlink" title="Screen Space - Camera 屏幕空间 - 相机"></a>Screen Space - Camera 屏幕空间 - 相机</h4><p>在此模式下，Canvas 的渲染方式就像是<strong>在给定摄像机前方一定距离的平面对象上绘制</strong>的一样。UI 的屏幕大小不会随距离而变化，因为它始终会重新缩放以完全适合<a target="_blank" rel="noopener" href="https://docs.unity3d.com/2021.3/Documentation/Manual/FrustumSizeAtDistance.html">相机视锥体</a>。如果屏幕的大小或分辨率或相机视锥体发生更改，则 UI 将自动重新缩放以适合。任何<strong>3D 对象</strong>在场景中，比UI平面更靠近UI平面将在UI前面渲染，而平面后面的对象将被遮挡。</p>
<p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasCamera.png" alt="相机模式 UI，前面有场景对象"></p>
<blockquote>
<p>相机模式 UI，前面有场景对象</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/06/04/dcd6a08baf6d9250.png" alt="image-20220516145017102"></p>
<blockquote>
<p>Plane distance: 绘制平面离相机多远</p>
</blockquote>
<h4 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h4><p>此模式将 UI 呈现为<strong>场景中的平面对象</strong>。然而，与<em>屏幕空间 - 相机</em>模式不同，飞机不需要面对相机，并且可以随心所欲地定向。Canvas 的大小可以使用其 Rect Transform 进行设置，但<strong>其屏幕大小将取决于摄像机的视角和距离</strong>。其他场景对象可以穿过画布的后面、穿过或前面。</p>
<p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/CanvasWorldSpace.png" alt="与场景对象相交的世界空间 UI"></p>
<blockquote>
<p>与场景对象相交的世界空间 UI</p>
</blockquote>
<h3 id="适应屏幕分辨率"><a href="#适应屏幕分辨率" class="headerlink" title="适应屏幕分辨率"></a>适应屏幕分辨率</h3><h4 id="使用锚点适应不同的宽高比（相对位置）"><a href="#使用锚点适应不同的宽高比（相对位置）" class="headerlink" title="使用锚点适应不同的宽高比（相对位置）"></a>使用锚点适应不同的宽高比（相对位置）</h4><ul>
<li><p>锚点Anchors</p>
<p>（父布局如Canvas和子布局如Img相对变换的关系）</p>
</li>
<li><p>Pivot控件自身的锚点</p>
<p>在Pivot模式下才能编辑（相当于自身坐标时吧，反之是世界坐标？）</p>
</li>
</ul>
<p>把控件锚定到各自的角落</p>
<p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_MultiResCorners.png" alt="img"></p>
<h4 id="随屏幕尺寸缩放（相对大小）"><a href="#随屏幕尺寸缩放（相对大小）" class="headerlink" title="随屏幕尺寸缩放（相对大小）"></a>随屏幕尺寸缩放（相对大小）</h4><p>The <strong>Canvas Scaler</strong> component can be added to a root <strong>Canvas</strong></p>
<ul>
<li><p>UI缩放模式：随屏幕大小缩放</p>
</li>
<li><p>可以指定要用作参考的分辨率。如果当前屏幕分辨率小于或大于此参考分辨率，则会相应地设置 Canvas 的比例因子，以便所有 UI 元素与屏幕分辨率一起放大或缩小</p>
</li>
<li><p>缩放的方式也会带来效果的不同：</p>
<ul>
<li><p>添加 Canvas Scaler 组件后，检查布局在其他宽高比下的外观也很重要。通过将分辨率设置回 Phone HD 横向，我们可以看到按钮现在看起来比它们应该（和过去）更大。</p>
<p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_MultiResLandscapeWrongScaling.png" alt="img"></p>
<blockquote>
<p>横向宽高比中较大按钮的原因归结为画布缩放器设置的工作方式。默认情况下，它将宽度或当前分辨率与 Canvas 缩放器的宽度进行比较，并将结果用作缩放所有内容的比例因子。由于当前 960 x 640 的横向分辨率的宽度比 640 x 960 的纵向 Canvas 缩放器大 1.5 倍，因此布局放大了 1.5 倍。**[只比较宽度]**</p>
</blockquote>
</li>
<li><p><strong>Match</strong> 的属性，该属性可以是 0（宽度）、1（高度）或介于两者之间的值。默认情况下，它设置为 0，这会将当前屏幕宽度与画布缩放器宽度进行比较，如上所述。</p>
<p>如果 <strong>Match</strong> 属性设置为 0.5，它将当前宽度与参考宽度进行比较，将当前<strong>高度</strong>与参考高度进行比较，并选择介于两者之间的比例因子。由于在这种情况下，横向分辨率宽1.5倍，但也短1.5倍，因此这两个因素平衡并产生最终比例因子1，这意味着按钮保持其原始大小。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Canvas-Group"><a href="#Canvas-Group" class="headerlink" title="Canvas Group"></a>Canvas Group</h3><p>The <strong>Canvas Group</strong> can be used to control certain aspects of a whole group of <strong>UI</strong> elements from one place without needing to handle them each individually. The properties of the Canvas Group affect the <strong>GameObject</strong> it is on as well as all children.</p>
<p><img src="https://docs.unity3d.com/2021.3/Documentation/uploads/Main/UI_CanvasGroupInspector.png" alt="img"></p>
<table>
<thead>
<tr>
<th align="left">*<strong>Property:*</strong></th>
<th align="left">*<strong>Function:*</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Alpha</strong></td>
<td align="left">此组中 UI 元素的不透明度。该值介于 0 和 1 之间，其中 0 表示完全透明，1 表示完全不透明。请注意，元素也保留其自身的透明度，因此 Canvas Group Alpha 和各个 UI 元素的 Alpha 值将相互相乘。</td>
</tr>
<tr>
<td align="left"><strong>Interactable</strong></td>
<td align="left">确定此组件是否接受输入。当它设置为 false 交互时，将禁用该交互。</td>
</tr>
<tr>
<td align="left"><strong>Block Raycasts</strong></td>
<td align="left">此组件是否充当<strong>对撞机</strong><br>对于 Raycasts？您需要在连接到 Canvas 的图形光线投射器上调用 RayCast 函数。这<em>不适用于</em><strong>Physics.Raycast</strong>。</td>
</tr>
<tr>
<td align="left"><strong>Ignore Parent Groups</strong></td>
<td align="left">此组是否也会受到游戏对象层次结构中更上方的 Canvas 组组件中的设置的影响，还是会忽略这些设置并因此覆盖它们？</td>
</tr>
</tbody></table>
<p>Canvas Group 的典型用途包括：</p>
<ul>
<li>通过在窗口的游戏对象上添加画布组来淡入或淡出整个窗口，并控制其 Alpha 属性。</li>
<li>通过将 Canvas 组添加到父游戏对象并将其 Interactable 属性设置为 false，使整组控件不可交互（“灰显”）。</li>
<li>通过将 Canvas Group 组件放在元素或其父元素之一上，并将其 Block Raycasts 属性设置为 false，使一个或多个 UI 元素不阻止鼠标事件。</li>
</ul>
<h2 id="Event-System"><a href="#Event-System" class="headerlink" title="Event System"></a>Event System</h2><p>此子系统负责控制构成事件的所有其他元素。它协调当前处于活动状态的输入模块，哪个<strong>游戏对象</strong>目前被认为是“被选中的”，以及许多其他高级别<strong>事件系统</strong>概念。</p>
<h4 id="Graphic-Raycaster-图形光线投射器"><a href="#Graphic-Raycaster-图形光线投射器" class="headerlink" title="Graphic Raycaster 图形光线投射器"></a>Graphic Raycaster 图形光线投射器</h4><p>图形光线投射器用于<strong>对画布进行光线投射</strong>。Raycaster 会查看画布上的所有图形，并确定其中<strong>是否有任何图形被击中</strong>。</p>
<table>
<thead>
<tr>
<th align="left">*<strong>Property:*</strong></th>
<th align="left">*<strong>Function:*</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Ignore Reversed Graphics</strong></td>
<td align="left">是否应考虑远离光线投射器的图形？</td>
</tr>
<tr>
<td align="left"><strong>Blocked Objects</strong></td>
<td align="left">将阻止图形光线投射的对象类型。</td>
</tr>
<tr>
<td align="left"><strong>Blocking Mask</strong></td>
<td align="left">Type of objects that will block graphic raycasts.</td>
</tr>
</tbody></table>
<h4 id="Physics-Raycaster"><a href="#Physics-Raycaster" class="headerlink" title="Physics Raycaster"></a>Physics Raycaster</h4><p>The Raycaster raycasts against <strong>3D objects</strong> in the <strong>scene</strong>. This allows messages to be sent to 3D physics objects that implement event interfaces.（意思是可以将点击事件反馈到3D物理对象上？）</p>
<table>
<thead>
<tr>
<th align="left">*<strong>Property:*</strong></th>
<th align="left">*<strong>Function:*</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Depth</strong></td>
<td align="left">Get the depth of the configured <strong>camera</strong> .</td>
</tr>
<tr>
<td align="left"><strong>Event Camera</strong></td>
<td align="left">Get the camera that is used for this module.</td>
</tr>
<tr>
<td align="left"><strong>Event Mask</strong></td>
<td align="left">Logical and of Camera mask and eventMask.</td>
</tr>
<tr>
<td align="left"><strong>Final Event Mask</strong></td>
<td align="left">Logical and of Camera mask and eventMask.</td>
</tr>
</tbody></table>
<h1 id="unity中括号"><a href="#unity中括号" class="headerlink" title="unity中括号"></a>unity中括号</h1><h2 id="HideInInspector"><a href="#HideInInspector" class="headerlink" title="[HideInInspector]"></a>[HideInInspector]</h2><p>让public变量在编辑器里不显示</p>
<h2 id="SerializeField"><a href="#SerializeField" class="headerlink" title="[SerializeField]"></a>[SerializeField]</h2><p>让private在编辑器里显示</p>
<h2 id="Range-0-100"><a href="#Range-0-100" class="headerlink" title="[Range(0,100)]"></a>[Range(0,100)]</h2><p>设定某个值的范围</p>
<h2 id="Header-“XXX”"><a href="#Header-“XXX”" class="headerlink" title="[Header(“XXX”)]"></a>[Header(“XXX”)]</h2><p>显示提示</p>
<h2 id="Tooltip-“XXX”"><a href="#Tooltip-“XXX”" class="headerlink" title="[Tooltip(“XXX”)]"></a>[Tooltip(“XXX”)]</h2><p>鼠标移至属性名产生提示</p>
<h2 id="Space-50"><a href="#Space-50" class="headerlink" title="[Space(50)]"></a>[Space(50)]</h2><p>空出几行</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101124913">Unity脚本用中括号引起来的属性 - 知乎 (zhihu.com)</a></p>
<h2 id="RequireComponent-typeof-XX"><a href="#RequireComponent-typeof-XX" class="headerlink" title="[RequireComponent(typeof(XX))]"></a>[RequireComponent(typeof(XX))]</h2><p>当你添加的一个用了RequireComponent组件的脚本，需要的组件将会自动被添加到game object（游戏物体）。这个可以有效的避免组装错误。</p>
<h1 id="昼夜交替"><a href="#昼夜交替" class="headerlink" title="昼夜交替"></a>昼夜交替</h1><p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=H3JpkcGi8DI">DAY &amp; NIGHT CYCLE in Unity using HDRP (2019.3) - YouTube</a></p>
<h2 id="时间的范围和计时机制"><a href="#时间的范围和计时机制" class="headerlink" title="时间的范围和计时机制"></a>时间的范围和计时机制</h2><h2 id="模拟阳光的角度变换"><a href="#模拟阳光的角度变换" class="headerlink" title="模拟阳光的角度变换"></a>模拟阳光的角度变换</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*白天阳光的旋转角度*/</span></span><br><span class="line">[<span class="meta">Header(<span class="meta-string">&quot;Sun Light&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Transform dailyRotation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustSunRotation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">float</span> sunAngle = timeOfDay * <span class="number">360f</span>;</span><br><span class="line">    dailyRotation.transform.localRotation = Quaternion.Euler(<span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, sunAngle));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Transform-localRotation"><a href="#Transform-localRotation" class="headerlink" title="Transform.localRotation"></a>Transform.localRotation</h3><ul>
<li><p>相对于父级变换旋转的变换旋转</p>
</li>
<li><p>Unity 在内部将旋转存储为四元数。要旋转对象，请使用 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Transform.Rotate.html">Transform.Rotate</a>。 要将旋转修改为欧拉角，请使用 <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Transform-localEulerAngles.html">Transform.localEulerAngles</a></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Example</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.localRotation = Quaternion.identity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Quaternion-Euler"><a href="#Quaternion-Euler" class="headerlink" title="Quaternion.Euler"></a>Quaternion.Euler</h3><ul>
<li><p>public static <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Quaternion.html">Quaternion</a> <strong>Euler</strong> (float <strong>x</strong>, float <strong>y</strong>, float <strong>z</strong>);</p>
</li>
<li><p>返回一个旋转，它围绕 z 轴旋转 z 度、围绕 x 轴旋转 x 度、围绕 y 轴旋转 y 度（按该顺序应用）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// A rotation 30 degrees around the y-axis</span></span><br><span class="line">    Quaternion rotation = Quaternion.Euler(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>public static <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Quaternion.html">Quaternion</a> <strong>Euler</strong> (<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.html">Vector3</a> <strong>euler</strong>);</p>
</li>
<li><p>返回一个围绕 Z 轴旋转 z 度、围绕 X 轴旋转 x 度、围绕 Y 轴旋转 y 度的旋转。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// A rotation 30 degrees around the y-axis</span></span><br><span class="line">      Vector3 rotationVector = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">      Quaternion rotation = Quaternion.Euler(rotationVector);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">### Unity中的旋转和方向</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>D 应用程序中的旋转通常以两种方式之一表示：四元数或欧拉角。每种方式都有自己的用途和缺点。Unity 在内部使用四元数表示，但在 Inspector 中显示等效的欧拉角值以便于进行编辑。</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 欧拉角</span></span><br><span class="line"></span><br><span class="line">​	欧拉角由按顺序应用的 X、Y 和 Z 三个角度值来表示。要将欧拉旋转应用于特定游戏对象，则依次应用每个旋转值，作为围绕其对应轴的旋转。</span><br><span class="line"></span><br><span class="line">* 优点：具有直观的“可读”格式，由三个角度组成；可表示通过大于 <span class="number">180</span> 度转向从一个方向到另一个方向的旋转</span><br><span class="line"></span><br><span class="line">* 局限性：欧拉角受到[万向锁 (Gimbal Lock)](https:<span class="comment">//en.wikipedia.org/wiki/Gimbal_lock) 的影响。当依次施加三个旋转时，第一个或第二个旋转可能导致第三个轴的方向与先前两个轴之一相同。这意味着已失去“自由度”，因为不能围绕唯一轴应用第三个旋转值。</span></span><br><span class="line"></span><br><span class="line">  &gt; 先浅浅了解一下万向锁：[“欧拉角旋转”产生“万向锁”的来源，以及如何避免万向锁_哔哩哔哩_bilibili](https:<span class="comment">//www.bilibili.com/video/BV1YJ41127qe?spm_id_from=333.337.search-card.all.click)</span></span><br><span class="line">  &gt;</span><br><span class="line">  &gt; [计算机动画 ：用unity引擎演示万向节死锁（Gimbal Lock）现象 - 知乎 (zhihu.com)](https:<span class="comment">//zhuanlan.zhihu.com/p/376468636)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#### 四元数</span></span><br><span class="line"></span><br><span class="line">​	四元数可用于表示&lt;u&gt;游戏对象的方向或旋转&lt;/u&gt;。此表示方式在内部由四个数字组成（在 Unity 中称为 x、y、z 和 w），但是这些数字&lt;u&gt;不代表角度或轴&lt;/u&gt;，您通常不需要直接访问它们。除非特别想深入研究[四元数的数学原理](https:<span class="comment">//en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)，否则只需要知道四元数&lt;u&gt;代表 3D 空间中的旋转即可&lt;/u&gt;，通常不需要知道或修改 x、y 和 z 属性。</span></span><br><span class="line"></span><br><span class="line">- **优点**：四元数旋转不受万向锁的影响。</span><br><span class="line">- **局限性**：单个四元数不能表示任何方向超过 <span class="number">180</span> 度的旋转。</span><br><span class="line">- **局限性**：四元数的数字表示在直观上难以理解。</span><br><span class="line"></span><br><span class="line">​	Unity 在内部将所有游戏对象旋转存储为四元数，因为这种表示方式的好处超过了局限性。</span><br><span class="line"></span><br><span class="line">​	Transform Inspector 会使用欧拉角显示旋转，因为这种形式更容易理解和编辑。Unity 将 Inspector 中输入的用于旋转游戏对象的新值转换为该游戏对象的新四元数旋转值</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 对动画的影响</span></span><br><span class="line"></span><br><span class="line">​	许多 <span class="number">3</span>D 制作包以及 Unity 自己的内部 [Animation 窗口](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/AnimationEditorGuide.html)均允许使用欧拉角来指定动画期间的旋转。</span></span><br><span class="line"></span><br><span class="line">​	这些旋转值通常可能超过四元数可表示的范围。例如，如果一个游戏对象旋转 <span class="number">720</span> 度，这可以用欧拉角“X：<span class="number">0</span>，Y：<span class="number">720</span>，Z：<span class="number">0</span>”表示。但这不能通过四元数值来表示。</span><br><span class="line"></span><br><span class="line"><span class="meta">#### 四元数扩展</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">重要的类 - Quaternion - Unity 手册</span>](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/class-Quaternion.html)</span></span><br><span class="line"></span><br><span class="line">Unity 使用 Quaternion 类来存储游戏对象的三维方向，也使用它们来描述从一个方向到另一个方向的相对旋转。</span><br><span class="line"></span><br><span class="line">&lt;u&gt;处理脚本中的旋转时，应使用 Quaternion 类及其函数来创建和修改旋转值。&lt;/u&gt;在某些情况下，使用欧拉角也是有效的，但应记住： - 应使用处理欧拉角的 Quaternion 类函数 - 从旋转中检索、修改和重新应用欧拉值可能会导致意外的副作用</span><br><span class="line"></span><br><span class="line"><span class="meta">##### 直接创建和操作四元数</span></span><br><span class="line"></span><br><span class="line">* 创建旋转</span><br><span class="line"></span><br><span class="line">  ```csharp</span><br><span class="line">  <span class="comment">//Quaternion.LookRotaion</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          Vector3 relativePos = target.position - transform.position;</span><br><span class="line">  </span><br><span class="line">          <span class="comment">// the second argument, upwards, defaults to Vector3.up</span></span><br><span class="line">          Quaternion rotation = Quaternion.LookRotation(relativePos, Vector3.up);</span><br><span class="line">          transform.rotation = rotation;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.Angle</span></span><br><span class="line">  <span class="comment">//返回两个旋转 a 和 b 之间的角度（以度为单位）</span></span><br><span class="line">  <span class="built_in">float</span> angle = Quaternion.Angle(transform.rotation, target.rotation);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.AngleAxis</span></span><br><span class="line">  <span class="comment">//创建一个围绕 axis 旋转 angle 度的旋转</span></span><br><span class="line">  transform.rotation = Quaternion.AngleAxis(<span class="number">30</span>, Vector3.up);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//Quaternion.FromToRotation</span></span><br><span class="line">  <span class="comment">//创建一个从 fromDirection 旋转到 toDirection 的旋转</span></span><br><span class="line">  transform.rotation = Quaternion.FromToRotation(Vector3.up, transform.forward);</span><br></pre></td></tr></table></figure></li>
<li><p>操作旋转</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Quaternion.Slerp</span></span><br><span class="line"><span class="comment">//Quaternion 在四元数 a 和 b 之间进行球形插值的四元数,参数 t 限制在范围 [0, 1] 内</span></span><br><span class="line"><span class="comment">//这可用于创建一个旋转，以基于参数的值 a，在第一个四元数 a 到第二个四元数 b 之间平滑进行插值。如果参数的值接近于 0，则输出会接近于 /a/，如果参数的值接近于 1，则输出会接近于 /b/</span></span><br><span class="line"><span class="keyword">public</span> Transform <span class="keyword">from</span>;</span><br><span class="line">    <span class="keyword">public</span> Transform to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> timeCount = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.rotation = Quaternion.Slerp(<span class="keyword">from</span>.rotation, to.rotation, timeCount);</span><br><span class="line">        timeCount = timeCount + Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quaternion.Inverse</span></span><br><span class="line"><span class="comment">//返回 rotation 的反转</span></span><br><span class="line">Transform target;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    transform.rotation = Quaternion.Inverse(target.rotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Quaternion.RotateTowards</span></span><br><span class="line"><span class="comment">//将旋转 from 向 to 旋转。将 from 四元数朝 to 旋转 maxDegreesDelta 的角度步长（但请注意， 该旋转不会过冲）。 如果 maxDegreesDelta 为负值，则向远离 to 的方向旋转，直到旋转 恰好为相反的方向。</span></span><br><span class="line"><span class="comment">// The object whose rotation we want to match.</span></span><br><span class="line">Transform target;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Angular speed in degrees per sec.</span></span><br><span class="line"><span class="built_in">float</span> speed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The step size is equal to speed times frame time.</span></span><br><span class="line">    <span class="keyword">var</span> step = speed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate our transform a step closer to the target&#x27;s.</span></span><br><span class="line">    transform.rotation = Quaternion.RotateTowards(transform.rotation, target.rotation, step);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用欧拉角</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某些情况下，更适合在脚本中使用欧拉角。这时，请务必注意，必须将角度保存在变量中，在使用它们的时候，仅将它们作为欧拉角应用于旋转，最终仍应存储为 Quaternion。虽然可从四元数中获取欧拉角，但在获取、修改和重新应用时，可能会出现问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 旋转脚本错误 #1</span></span><br><span class="line"><span class="comment">// 此处的错误在于我们正在修改四元数的 x 值</span></span><br><span class="line"><span class="comment">// 此值不表示角度，不会产生所需的结果</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> rot = transform.rotation;</span><br><span class="line">    rot.x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = rot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旋转脚本错误 #2</span></span><br><span class="line"><span class="comment">// 从四元数读取、修改并写入欧拉值。</span></span><br><span class="line"><span class="comment">// 因为这些值是从四元数计算的，</span></span><br><span class="line"><span class="comment">// 所以每个新的旋转可能会返回非常不同的欧拉角，而这可能会受到万向锁的影响。</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> angles = transform.rotation.eulerAngles;</span><br><span class="line">    angles.x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = Quaternion.Euler(angles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确使用欧拉角的旋转脚本。</span></span><br><span class="line"><span class="comment">// 将欧拉角存储在一个类变量中，并仅使用</span></span><br><span class="line"><span class="comment">// 该变量作为欧拉角进行应用，但从不依赖于读回欧拉值。</span></span><br><span class="line">        </span><br><span class="line"><span class="built_in">float</span> x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    x += Time.deltaTime * <span class="number">10</span>;</span><br><span class="line">    transform.rotation = Quaternion.Euler(x,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="阳光变换过程中的处理"><a href="#阳光变换过程中的处理" class="headerlink" title="阳光变换过程中的处理"></a>阳光变换过程中的处理</h2><h3 id="阳光的强度"><a href="#阳光的强度" class="headerlink" title="阳光的强度"></a>阳光的强度</h3><p>（待研究</p>
<h3 id="阳光的颜色"><a href="#阳光的颜色" class="headerlink" title="阳光的颜色"></a>阳光的颜色</h3><h2 id="ui和时间的绑定"><a href="#ui和时间的绑定" class="headerlink" title="ui和时间的绑定"></a>ui和时间的绑定</h2><h2 id="Unity实时阴影"><a href="#Unity实时阴影" class="headerlink" title="Unity实时阴影"></a>Unity实时阴影</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35711014/article/details/106746027">(34条消息) Unity角色实时阴影方案_一克拉绿豆的博客-CSDN博客_unity 实时阴影</a></p>
<h1 id="Nav-Mesh-Agent-导航网格代理"><a href="#Nav-Mesh-Agent-导航网格代理" class="headerlink" title="Nav Mesh Agent 导航网格代理"></a>Nav Mesh Agent 导航网格代理</h1><p>NavMeshAgent 组件可帮助您创建在朝目标移动时能够彼此避开的角色。代理 (Agent) 使用导航网格来推断游戏世界，并知道如何避开彼此以及其他移动障碍物。寻路和空间推断是使用导航网格代理的脚本 API 进行处理的。</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><ul>
<li>从一点走到一点</li>
<li>需要考虑：阻挡，路径选择，可行路径，地形特点（沙地草地等）……</li>
</ul>
<h2 id="游戏中常用的导航情况"><a href="#游戏中常用的导航情况" class="headerlink" title="游戏中常用的导航情况"></a>游戏中常用的导航情况</h2><ul>
<li>ai角色：纯导航</li>
<li>主角：ui交互控制下的导航——？</li>
</ul>
<h2 id="导航的常用算法"><a href="#导航的常用算法" class="headerlink" title="导航的常用算法"></a>导航的常用算法</h2><ul>
<li>A*算法（广度优先）<ul>
<li>广泛应用于2D格子型地图</li>
</ul>
</li>
<li>navigation mesh的寻路算法原理<ul>
<li>A*算法的变种</li>
<li>将A*算法的格子变成三角形或多边形网络<ul>
<li>如何构建合理高效的三角形网格，即navigation Mesh</li>
</ul>
</li>
<li>可以方便地从二维扩展到三维</li>
<li>3D游戏的主流寻路算法（基于三角形网格）</li>
</ul>
</li>
</ul>
<h2 id="导航网格制作"><a href="#导航网格制作" class="headerlink" title="导航网格制作"></a>导航网格制作</h2><h3 id="标记哪些物体是属于导航网格的"><a href="#标记哪些物体是属于导航网格的" class="headerlink" title="标记哪些物体是属于导航网格的"></a>标记哪些物体是属于导航网格的</h3><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/b2b81d3d8b6ef4db.png" alt="image-20220527210302934"></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/06/04/a6914beef4d9ff26.png" alt="image-20220527210737542"></p>
<blockquote>
<p>可以在这个视图中查看到物体被纳入</p>
</blockquote>
<p><img src="https://s3.bmp.ovh/imgs/2022/06/04/0294525fcd76abd0.png" alt="image-20220527210825800"></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/06/04/0423c1f54e4e0037.png" alt="image-20220527210839518"></p>
<blockquote>
<p>Bake会出现这些三角形网格。这些物体也是被设为navigation static的</p>
</blockquote>
<ul>
<li>一般会用虚拟物来自定义导航网格的面积，基于模型的话生成的结果可能偏差很大</li>
</ul>
<h2 id="控制物体在导航网格上行走"><a href="#控制物体在导航网格上行走" class="headerlink" title="控制物体在导航网格上行走"></a>控制物体在导航网格上行走</h2><ul>
<li><p>加上Nav Mesh Agent组件</p>
</li>
<li><p>脚本控制方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*首先要声明using UnityEngine.AI*/</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1.自动导航到目标坐标（朝向默认为z轴）</span></span><br><span class="line">  NevMeshAgent agent = Get...</span><br><span class="line">  agent.SetDestination(<span class="keyword">new</span> Vector3(,,));</span><br><span class="line"></span><br><span class="line">​		可以展示导航情况；目标在网格外的话就停在网格内</span><br><span class="line"></span><br><span class="line">&gt; 路线是提前设置好并算死了的而且不会考虑碰撞，如果路上遇到阻碍可能会卡在那儿；</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果物体离网格太远的话会无法生成代理？会发出警告</span><br><span class="line"></span><br><span class="line">* 组件的参数设置：[导航网格代理 (NavMesh Agent) - Unity 手册](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/class-NavMeshAgent.html)</span></span><br><span class="line">* 在实践中角色行走会很卡顿不流畅？</span><br><span class="line"></span><br><span class="line"><span class="meta">## Nav Mesh  Obstacle组件</span></span><br><span class="line"></span><br><span class="line">阻碍物（不可行走类型）可以随着移动而动态变化烘焙的网格。</span><br><span class="line"></span><br><span class="line"><span class="meta"># 鼠标对人物行走的控制</span></span><br><span class="line"></span><br><span class="line"><span class="meta">## 鼠标点击控制人物运动</span></span><br><span class="line"></span><br><span class="line"><span class="meta">### 鼠标点击的位置落在模型上</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">移动设备输入 - Unity 手册</span>](https:<span class="comment">//docs.unity.cn/cn/2020.3/Manual/MobileInput.html)</span></span><br><span class="line"></span><br><span class="line">```<span class="function">csharp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Ray ray = cam.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">            RaycastHit hit;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;We hit&quot;</span> + hit.collider.name);</span><br><span class="line">                Debug.DrawRay(ray.origin, ray.direction * <span class="number">10</span>, Color.yellow,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Camera.ScreenPointToRay()</p>
<p>public <a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Ray.html">Ray</a> <strong>ScreenPointToRay</strong> (<a target="_blank" rel="noopener" href="https://docs.unity.cn/cn/2020.3/ScriptReference/Vector3.html">Vector3</a> <strong>pos</strong>);</p>
<ul>
<li>从摄像机的方向发出的一条到鼠标点方向的射线</li>
<li>易看出摄像机点是固定的，鼠标在屏幕周围映射到四方，呈现点射光的状态</li>
</ul>
<p><img src="https://s3.bmp.ovh/imgs/2022/06/04/938081b90cf4959a.png" alt="image-20220528101846438"></p>
<p><img src="https://s3.bmp.ovh/imgs/2022/06/04/629ff5209bdefd99.png" alt="image-20220528102026215"></p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Physics.Raycast(ray,<span class="keyword">out</span> hit))</span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;We hit&quot;</span> + hit.collider.name);</span><br><span class="line">    Debug.DrawRay(ray.origin, ray.direction * <span class="number">10</span>, Color.yellow,<span class="number">100</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生出光线之后，赋予物理属性，即可发生碰撞，这样就能与场景中的物体产生互动。</p>
</blockquote>
<h2 id="自动导航到目标点"><a href="#自动导航到目标点" class="headerlink" title="自动导航到目标点"></a>自动导航到目标点</h2><h2 id="导航造成动画卡顿和小鸡无法获得主角的动态位置"><a href="#导航造成动画卡顿和小鸡无法获得主角的动态位置" class="headerlink" title="导航造成动画卡顿和小鸡无法获得主角的动态位置"></a>导航造成动画卡顿和小鸡无法获得主角的动态位置</h2><ul>
<li><p>isKinematic:关闭动力学的模拟；覆盖use gravity，不受重力影响</p>
<p>由此position将完全由脚本或者动画控制。</p>
<p><a target="_blank" rel="noopener" href="https://www.kchuhai.com/report/view-4168.html">改变Rigidbody组件中IsKinematic属性的实验 - 快出海 (kchuhai.com)</a></p>
</li>
<li><p>为什么主角加上Nav组件，rigidbody勾选use gravity就卡住不动，把动力学取消了就能艰难移动？</p>
</li>
<li><p>小鸡无法跟踪是因为之前把project的prefab拖进去了，要拖进hierarchy的才行……</p>
</li>
</ul>
<h1 id="自动导航与刚体运动的冲突"><a href="#自动导航与刚体运动的冲突" class="headerlink" title="自动导航与刚体运动的冲突"></a>自动导航与刚体运动的冲突</h1><p><img src="https://s3.bmp.ovh/imgs/2022/06/04/01a2abb988c7094a.png" alt="image-20220530150307740"></p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/huangxinhere.github.io/img/MyGame.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/huangxinhere.github.io/2022/06/04/202264-Unity%E5%85%A5%E9%97%A8(%E4%B8%89)%E2%80%94%E2%80%94MyGame2/"><img class="prev-cover" src="/huangxinhere.github.io/img/myGame03.png" onerror="onerror=null;src='/huangxinhere.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Unity入门(三)——MyGame2</div></div></a></div><div class="next-post pull-right"><a href="/huangxinhere.github.io/2022/04/11/2022411-Unity%E5%85%A5%E9%97%A8(%E4%BA%8C)/"><img class="next-cover" src="/huangxinhere.github.io/img/fruit%20cut.png" onerror="onerror=null;src='/huangxinhere.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity入门(二)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/huangxinhere.github.io/img/head_pic_3.png" onerror="this.onerror=null;this.src='/huangxinhere.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(●ˇ∀ˇ●)</div><div class="author-info__description">someone very lazy</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/huangxinhere.github.io/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/huangxinhere.github.io/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Don't Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">角色移动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E7%9A%84%E5%B9%B3%E7%A7%BB"><span class="toc-number">1.1.</span> <span class="toc-text">水平垂直方向的平移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">1.2.</span> <span class="toc-text">旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%85%83%E6%95%B0%E6%98%AF%E5%AD%98%E5%82%A8%E6%97%8B%E8%BD%AC%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">四元数是存储旋转的一种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector3-RotateTowards"><span class="toc-number">1.2.2.</span> <span class="toc-text">Vector3.RotateTowards</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E4%B8%80%E5%B8%A7%E5%AD%98%E5%82%A8%E6%97%8B%E8%BD%AC%E6%96%B9%E5%90%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">每一帧存储旋转方向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E7%A7%BB%E5%8A%A8%E5%92%8C%E6%97%8B%E8%BD%AC%E5%BA%94%E7%94%A8%E4%BA%8E%E8%A7%92%E8%89%B2"><span class="toc-number">1.3.</span> <span class="toc-text">将移动和旋转应用于角色</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E8%BF%90%E5%8A%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">根运动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OnAnimatorMove%EF%BC%88%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">OnAnimatorMove（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Animator%E9%80%9A%E8%BF%87%E7%89%A9%E7%90%86%E5%BE%AA%E7%8E%AF%E9%80%82%E6%97%B6%E8%BF%90%E8%A1%8C"><span class="toc-number">1.3.3.</span> <span class="toc-text">Animator通过物理循环适时运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%96%91%E6%83%91"><span class="toc-number">1.3.4.</span> <span class="toc-text">疑惑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%83%E9%80%8F%E7%90%86%E8%A7%A3%EF%BC%81%EF%BC%81"><span class="toc-number">1.4.</span> <span class="toc-text">吃透理解！！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Root-Motion%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">Root Motion工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Body-Transform"><span class="toc-number">1.5.1.</span> <span class="toc-text">Body Transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Root-Transform%EF%BC%88%E6%A0%B9%E5%8F%98%E6%8D%A2%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">Root Transform（根变换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4Root-Transform"><span class="toc-number">1.5.3.</span> <span class="toc-text">调整Root  Transform</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Root-Transform-Rotation"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">Root Transform Rotation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Root-Transform-Position-Y"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">Root Transform Position(Y)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Root-Transform-Position-XZ"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">Root Transform Position(XZ)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E6%9C%BA%E8%B7%9F%E9%9A%8F%EF%BC%88CineMachine%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">相机跟随（CineMachine）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%91%84%E5%83%8F%E6%9C%BA"><span class="toc-number">2.1.</span> <span class="toc-text">虚拟摄像机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cinemachine-Brain"><span class="toc-number">2.2.</span> <span class="toc-text">Cinemachine Brain</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Moving-and-aiming"><span class="toc-number">2.3.</span> <span class="toc-text">Moving and aiming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Body-properties-how-to-move-%E8%B7%9F%E9%9A%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">Body properties: how to move(跟随)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Aim-properties-how-to-rotate%EF%BC%88%E7%9E%84%E5%87%86%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">Aim properties: how to rotate（瞄准）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composing-a-shot-%E6%9E%84%E5%9B%BE"><span class="toc-number">2.3.3.</span> <span class="toc-text">Composing a shot 构图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%99%AA%E7%82%B9%E6%A8%A1%E6%8B%9F%E7%9B%B8%E6%9C%BA%E6%8A%96%E5%8A%A8"><span class="toc-number">2.4.</span> <span class="toc-text">使用噪点模拟相机抖动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%91%84%E5%83%8F%E6%9C%BA%E5%B1%9E%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">虚拟摄像机属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">2.5.1.</span> <span class="toc-text">状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UI"><span class="toc-number">3.</span> <span class="toc-text">UI</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Canvas"><span class="toc-number">3.1.</span> <span class="toc-text">Canvas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAcanvas"><span class="toc-number">3.1.1.</span> <span class="toc-text">单个或多个canvas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.2.</span> <span class="toc-text">渲染方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Screen-Space-Overlay-%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4-%E5%8F%A0%E5%8A%A0"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">Screen Space - Overlay 屏幕空间 - 叠加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Screen-Space-Camera-%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4-%E7%9B%B8%E6%9C%BA"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">Screen Space - Camera 屏幕空间 - 相机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%96%E7%95%8C%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">世界空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-number">3.1.3.</span> <span class="toc-text">适应屏幕分辨率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%94%9A%E7%82%B9%E9%80%82%E5%BA%94%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AE%BD%E9%AB%98%E6%AF%94%EF%BC%88%E7%9B%B8%E5%AF%B9%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">使用锚点适应不同的宽高比（相对位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%E7%BC%A9%E6%94%BE%EF%BC%88%E7%9B%B8%E5%AF%B9%E5%A4%A7%E5%B0%8F%EF%BC%89"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">随屏幕尺寸缩放（相对大小）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-Group"><span class="toc-number">3.1.4.</span> <span class="toc-text">Canvas Group</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Event-System"><span class="toc-number">3.2.</span> <span class="toc-text">Event System</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Graphic-Raycaster-%E5%9B%BE%E5%BD%A2%E5%85%89%E7%BA%BF%E6%8A%95%E5%B0%84%E5%99%A8"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">Graphic Raycaster 图形光线投射器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Physics-Raycaster"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">Physics Raycaster</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#unity%E4%B8%AD%E6%8B%AC%E5%8F%B7"><span class="toc-number">4.</span> <span class="toc-text">unity中括号</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HideInInspector"><span class="toc-number">4.1.</span> <span class="toc-text">[HideInInspector]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SerializeField"><span class="toc-number">4.2.</span> <span class="toc-text">[SerializeField]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Range-0-100"><span class="toc-number">4.3.</span> <span class="toc-text">[Range(0,100)]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Header-%E2%80%9CXXX%E2%80%9D"><span class="toc-number">4.4.</span> <span class="toc-text">[Header(“XXX”)]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tooltip-%E2%80%9CXXX%E2%80%9D"><span class="toc-number">4.5.</span> <span class="toc-text">[Tooltip(“XXX”)]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Space-50"><span class="toc-number">4.6.</span> <span class="toc-text">[Space(50)]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequireComponent-typeof-XX"><span class="toc-number">4.7.</span> <span class="toc-text">[RequireComponent(typeof(XX))]</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%98%BC%E5%A4%9C%E4%BA%A4%E6%9B%BF"><span class="toc-number">5.</span> <span class="toc-text">昼夜交替</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C%E8%AE%A1%E6%97%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text">时间的范围和计时机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%98%B3%E5%85%89%E7%9A%84%E8%A7%92%E5%BA%A6%E5%8F%98%E6%8D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">模拟阳光的角度变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Transform-localRotation"><span class="toc-number">5.2.1.</span> <span class="toc-text">Transform.localRotation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quaternion-Euler"><span class="toc-number">5.2.2.</span> <span class="toc-text">Quaternion.Euler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B3%E5%85%89%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">阳光变换过程中的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B3%E5%85%89%E7%9A%84%E5%BC%BA%E5%BA%A6"><span class="toc-number">5.3.1.</span> <span class="toc-text">阳光的强度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B3%E5%85%89%E7%9A%84%E9%A2%9C%E8%89%B2"><span class="toc-number">5.3.2.</span> <span class="toc-text">阳光的颜色</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ui%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E7%BB%91%E5%AE%9A"><span class="toc-number">5.4.</span> <span class="toc-text">ui和时间的绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unity%E5%AE%9E%E6%97%B6%E9%98%B4%E5%BD%B1"><span class="toc-number">5.5.</span> <span class="toc-text">Unity实时阴影</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nav-Mesh-Agent-%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC%E4%BB%A3%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">Nav Mesh Agent 导航网格代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA"><span class="toc-number">6.1.</span> <span class="toc-text">导航</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%AF%BC%E8%88%AA%E6%83%85%E5%86%B5"><span class="toc-number">6.2.</span> <span class="toc-text">游戏中常用的导航情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E7%9A%84%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">导航的常用算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC%E5%88%B6%E4%BD%9C"><span class="toc-number">6.4.</span> <span class="toc-text">导航网格制作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%93%AA%E4%BA%9B%E7%89%A9%E4%BD%93%E6%98%AF%E5%B1%9E%E4%BA%8E%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC%E7%9A%84"><span class="toc-number">6.4.1.</span> <span class="toc-text">标记哪些物体是属于导航网格的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%89%A9%E4%BD%93%E5%9C%A8%E5%AF%BC%E8%88%AA%E7%BD%91%E6%A0%BC%E4%B8%8A%E8%A1%8C%E8%B5%B0"><span class="toc-number">6.5.</span> <span class="toc-text">控制物体在导航网格上行走</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AF%BC%E8%88%AA%E5%88%B0%E7%9B%AE%E6%A0%87%E7%82%B9"><span class="toc-number">6.6.</span> <span class="toc-text">自动导航到目标点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E9%80%A0%E6%88%90%E5%8A%A8%E7%94%BB%E5%8D%A1%E9%A1%BF%E5%92%8C%E5%B0%8F%E9%B8%A1%E6%97%A0%E6%B3%95%E8%8E%B7%E5%BE%97%E4%B8%BB%E8%A7%92%E7%9A%84%E5%8A%A8%E6%80%81%E4%BD%8D%E7%BD%AE"><span class="toc-number">6.7.</span> <span class="toc-text">导航造成动画卡顿和小鸡无法获得主角的动态位置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%AF%BC%E8%88%AA%E4%B8%8E%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">7.</span> <span class="toc-text">自动导航与刚体运动的冲突</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By (●ˇ∀ˇ●)</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks to watch my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/huangxinhere.github.io/js/utils.js"></script><script src="/huangxinhere.github.io/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
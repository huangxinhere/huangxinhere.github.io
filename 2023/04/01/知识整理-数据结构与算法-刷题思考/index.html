<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据结构与算法-刷题思考 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="虽然很笨，但是也想突破自己学得更好">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法-刷题思考">
<meta property="og:url" content="https://huangxinhere.github.io/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="虽然很笨，但是也想突破自己学得更好">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huangxinhere.github.io/img/e82f983fly1hdas2vy0ncj20u00gvae1.jpg">
<meta property="article:published_time" content="2023-03-31T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-21T07:54:25.299Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huangxinhere.github.io/img/e82f983fly1hdas2vy0ncj20u00gvae1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法-刷题思考',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-21 15:54:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_pic_3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/e82f983fly1hdas2vy0ncj20u00gvae1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hx's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法-刷题思考</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-31T16:00:00.000Z" title="发表于 2023-04-01 00:00:00">2023-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-21T07:54:25.299Z" title="更新于 2023-08-21 15:54:25">2023-08-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法-刷题思考"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUxNjY5NTYxNA==&action=getalbum&album_id=1485825793120387074&scene=173&from_msgid=2247486598&from_itemidx=1&count=3&nolastread=1#wechat_redirect">#数据结构与算法 (qq.com)</a></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="JZ57-和为S的两个数字【哈希】【双指针】"><a href="#JZ57-和为S的两个数字【哈希】【双指针】" class="headerlink" title="JZ57 和为S的两个数字【哈希】【双指针】"></a>JZ57 和为S的两个数字【哈希】【双指针】</h2><p>首先想到用哈希表存储，遍历元素的时候记录想要的差，以后遇到这个元素就返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : array) &#123;</span><br><span class="line">        <span class="comment">// 若存在于想要的数字中，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (map[num]) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;&#123;num, sum - num&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不存在，则存储需要的值</span></span><br><span class="line">        map[sum-num] = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目提供的是有序数组，那么肯定可以利用这个有序的特点。[1,2,4,7,11,15],15 比如遍历1，那么需要14，用二分查找？emmm，似乎又想复杂了。可以用双指针。首先指向开头和结尾。1+15&gt;15，数太大了，所以右指针向前一位；1+11&lt;15，又小了，所以左指针向右一位……（妙啊</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumbersWithSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = array.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[l]+array[r] == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt; &#123;array[l], array[r]&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (array[l]+array[r] &gt; sum) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (array[l]+array[r] &lt; sum) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双指针：两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针）。此处是对撞指针。</p>
</blockquote>
<h2 id="JZ58-左旋转字符串【字符串】【反转】"><a href="#JZ58-左旋转字符串【字符串】【反转】" class="headerlink" title="JZ58 左旋转字符串【字符串】【反转】"></a>JZ58 左旋转字符串【字符串】【反转】</h2><p>刚开始想的是队列循环/或者在原基础上拼接。头元素转到尾元素。（代码简单就不贴了）</p>
<p>【题解】呃，直接反转。我只能说玩得很溜，比较开拓思路。</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404101920920.png" alt="image-20230404101920920"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">LeftRotateString</span><span class="params">(string str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//特殊情况</span></span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//取余，因为每次长度为m的旋转相当于没有变化</span></span><br><span class="line">    n = n % m;</span><br><span class="line">    <span class="comment">//第一次逆转全部数组元素</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//第二次只逆转开头m个</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">begin</span>() + m - n);</span><br><span class="line">    <span class="comment">//第三次只逆转结尾m个</span></span><br><span class="line">    <span class="built_in">reverse</span>(str.<span class="built_in">begin</span>() + m - n, str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ007-数组中和为0的三个数"><a href="#OfferⅡ007-数组中和为0的三个数" class="headerlink" title="OfferⅡ007.数组中和为0的三个数"></a>OfferⅡ007.数组中和为0的三个数</h2><p>先想到排序，然后再暴力……只不过排序后遍历的可能少那么一点点。</p>
<p>先确定左指针，再确定右指针（没有限制），最后确定中间指针（如果不够补那么直接不行）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; nums.<span class="built_in">size</span>()<span class="number">-3</span>; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[l])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map[l]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetR = <span class="number">0</span> - nums[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; r &gt; l+<span class="number">1</span>; r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> targetMid = <span class="number">0</span> - nums[l] - nums[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = r<span class="number">-1</span>; mid &gt; l; mid--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然鹅还是可能出现重复情况，而且不好处理。</p>
<p><img src="https://img-blog.csdnimg.cn/d29041f703f74a33a2ffcc2a26299b47.png" alt="image-20230420225303368"></p>
<p>重复情况出现的原因是，设想有-1，-1，0，0，1，1这种多个重复的情况，也就是左、右、中间的指针都可能重复遍历，都要搞个map来存吗？欧摸，这破代码已经不忍瞩目了。</p>
<p>看了题解后，继续完善自己的代码。自己能想到的最近的一步是去重。其实不用哈希表也可，毕竟已经排好序了，可以通过比较前后数字来去重。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());	<span class="comment">// 排序</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; nums.<span class="built_in">size</span>()<span class="number">-2</span>; l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// l的去重操作：排序后，排除第一个而且和前面一个相同的</span></span><br><span class="line">        <span class="keyword">if</span> (l &amp;&amp; nums[l] == nums[l<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> targetR = <span class="number">0</span> - nums[l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = nums.<span class="built_in">size</span>()<span class="number">-1</span>; r &gt; l+<span class="number">1</span>; r--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// r的去重操作：排序后，排除最后一个而且和后面一个不同的</span></span><br><span class="line">            <span class="keyword">if</span> (r &lt;= nums.<span class="built_in">size</span>()<span class="number">-2</span> &amp;&amp; nums[r] == nums[r+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> targetMid = <span class="number">0</span> - nums[l] - nums[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid = r<span class="number">-1</span>; mid &gt; l; mid--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// mid的去重操作:和后面一个不同的，而且排除后一个是r的情况</span></span><br><span class="line">                <span class="keyword">if</span> ((mid != (r<span class="number">-1</span>)) &amp;&amp; nums[mid] == nums[mid+<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nums[mid] == targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[l], nums[mid], nums[r]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; targetMid)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过[0,0,0,0,0]示例就算成功</p>
</blockquote>
<p>由于时间复杂度是n的三次方，所以还是超时了。有没有办法减少循环的时间复杂度呢？再回顾一下我的思路，第一重循环必是从左到右找到第一个元素，第二重循环是从数组右到左，找到第二个元素，第三重循环就决定了结果。第二重循环b往前移的时候必然变小，那么c肯定会增大，b和c可简化成寻找<code>0-a</code>的”滑动窗口“。确定好a的循环范围，接着是b，然后c根据b的变化来进行滑动。</p>
<p>那这样的话其实l和r包抄mid的思路就有点复杂。比较容易理解的是l，mid，r再根据他俩滑动。mid和r是一个收缩的过程。由于mid和r是”对撞指针“，所以时间复杂度是On。【细节注意】要实现对撞指针，r不能每次都从数组末尾开始，这样就失去了意义，应该从头到尾都是往前前进。</p>
<ul>
<li><p>这个解法思路更清晰一点：</p>
<p>确定第一个a，然后用对撞指针；</p>
<p>如果先去重再判断的话，就可能漏掉mid+1=right的情况，比如(0,0,0)；</p>
<p>所以先判断再去重。也就是找到符合条件的元组后，这个元组就不应该再出现，那么就给它去重，跳过接下来和它一样的元素。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 找出a + b + c = 0</span></span><br><span class="line">        <span class="comment">// a = nums[i], b = nums[left], c = nums[right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 错误去重方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">// 正确去重方法</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="comment">// 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right&lt;=left 了，从而漏掉了 0,0,0 这种三元组</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span></span><br><span class="line"><span class="comment">                while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>







<h2 id="OfferⅡ008-和大于等于target的最短子数组"><a href="#OfferⅡ008-和大于等于target的最短子数组" class="headerlink" title="OfferⅡ008. 和大于等于target的最短子数组"></a>OfferⅡ008. 和大于等于target的最短子数组</h2><p>一看到连续子数组就想到了那道动态规划：求连续子数组的最大和。这次终于有机会打破自己的刻板理解：究竟什么是动态规划？其中一个重要理解点是：【没有后继性】。</p>
<p>想象一串数字，取其中的部分子数组，设子数组最后一个元素为I，如果是动态规划的话，那I为结尾，必然知道I所在已知子数组的答案。比如求连续子数组的最大和，I所在子数组是必定有答案的，与后面的元素无关。</p>
<p>而在这道题中，如<code>2、3、1、2、4、3</code>数组，要使子数组大于等于7，比如遍历到3的时候，已知2、3，你不能确定以2开头还是以3开头的子数组可以达到7，因为这还要取决于后面的元素。可见动态规划是根本不沾边的。</p>
<p>题目特点是【连续】，这可以想到滑动窗口：中间大致不变（遍历过的元素得到某种程度上的保留），根据目标值滑动左右边界。这里左右边界的分工也很明确，因为元素都是正整数，左缩一个sum必减少，右增一个sum必增多。</p>
<ul>
<li>确定左【。</li>
<li>根据target确定右】。（凑不够target就增）</li>
<li>符合target则计算r-l长度，更新min。（已经达到target，为了试探更小长度会左缩，所以回到第一步）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>], min = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; len; l++)</span><br><span class="line">    &#123;         </span><br><span class="line">        <span class="keyword">while</span> (sum &lt; target &amp;&amp; r &lt; len<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r++;</span><br><span class="line">            sum += nums[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 符合条件时 进行长度更新</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= target)</span><br><span class="line">        &#123;</span><br><span class="line">            min = !min || ((r-l) &lt; min) ? r+<span class="number">1</span>-l : min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 还未达到target但已经遍历完毕 说明后面已经凑不够了 再减少l也没用</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum -= nums[l];	<span class="comment">// 达到target就左缩</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ009-乘积小于k的子数组【动态规划】"><a href="#OfferⅡ009-乘积小于k的子数组【动态规划】" class="headerlink" title="OfferⅡ009.乘积小于k的子数组【动态规划】"></a>OfferⅡ009.乘积小于k的子数组【动态规划】</h2><blockquote>
<p>给定一个正整数数组 <code>nums</code>和整数 <code>k</code> ，求数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: nums = [10,5,2,6], k = 100</span><br><span class="line">&gt;输出: 8</span><br><span class="line">&gt;解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最开始是暴力遍历，两次循环逐一判断，n！的时间复杂度。优化的地方是算过的可以利用起来，就想到滑动窗口（下图）。</p>
<p><img src="https://img-blog.csdnimg.cn/44e3cc7643eb42a9b8b09350aa36b675.png" alt="image-20230424160024746"></p>
<p>右扩大直到大于等于k，然后左边界缩小直到在k内，保持窗口内的数稳定在k内。问题来了，窗口其中一小部分连续子数组怎么办呢？</p>
<p>【题解】我最多想到右增一个能算一个元素与k比较，没想到右增一个就能把里面的子数组个数都算出来了……以j为结尾，与左边界i的关系如下图，如果窗口在k内的话，那么里面所有的子数组都符合小于k。其中还暗含了一点动态规划的思想，不过在这里左缩一个也要计算对应的个数。……只能说，miao啊。</p>
<p><img src="https://img-blog.csdnimg.cn/f064798499a3420d8ff6ccfe21c16bee.png" alt="image-20230424162111158"></p>
<blockquote>
<p>为什么子数组不会重复呢？子数组取决于窗口的左右边界。观察绿色横线，右增一个和左增一个的区别。意义分别是以l为开头的……以r为结尾的所有子数组，然后每次l和r都必然各自只遍历数组一次，所以不会重复。这么想的话，这道题想法真的很奇妙。</p>
<p>而且由于控制在k内，所以不会整型溢出（暴力遍历如果不加以控制的话就会踩雷）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, product = <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.<span class="built_in">size</span>(); r++)</span><br><span class="line">    &#123;</span><br><span class="line">        product *= nums[r];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r &amp;&amp; product &gt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            product /= nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += r - l + <span class="number">1</span>;	<span class="comment">// 最核心</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ010-和为k的子数组"><a href="#OfferⅡ010-和为k的子数组" class="headerlink" title="OfferⅡ010.和为k的子数组"></a>OfferⅡ010.和为k的子数组</h2><blockquote>
<p>给定一个整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2</span><br><span class="line">解释: 此题 [1,1] 与 [1,1] 为两种不同的情况</span><br></pre></td></tr></table></figure>
</blockquote>
<p>滑动窗口算出来的结果不对了。为什么呢？进一步思考滑动窗口的能发挥特性的条件是什么。</p>
<p>如下图，当元素都是正整数时，左右边界滑动是明确可知能增能减的，所以控制在k范围内有明确的方向。</p>
<p>而正数和负数混合时，窗口将无法知道边界向哪才能维护目标值k（去掉负数为增，去掉正数为减，以此类推）</p>
<p><img src="https://img-blog.csdnimg.cn/c17c9fcd25fb485192a305168fec747a.png" alt="image-20230424170042843"></p>
<p>那还有什么办法呢？和以前思路大差不差，先想到暴力，再想着利用已经计算过的部分，就不用逐个重复计算了。每个元素利用（i-1）计算出i个结果，那空间复杂度就有n！了。</p>
<p>再想想，由于是连续数组，那么第i个元素只要和第i-1个元素的结果分别相加就行了，再之前的结果就不用保留。时间复杂度为【<strong>n</strong>（遍历每一个元素）<strong>×n-1×n-2</strong>（遍历前一个元素的数组）】也是n！……</p>
<p><img src="https://img-blog.csdnimg.cn/7b22b3f3498b4e818a14a63c5586ad24.png" alt="image-20230424170722046"></p>
<p>啊啊啊是思维陷阱啊，这似乎是遍历前面然后用空间存储以至于时间复杂度没有爆炸……好吧好吧！</p>
<p>【题解】</p>
<ol>
<li><p>逐个遍历子数组开头和结尾；双循环。</p>
</li>
<li><p>前缀和＋哈希表【重点】</p>
</li>
</ol>
<p>重新回顾一下这道题的难点，如果想提高效率，难的是确定子数组的起始(l)和结尾(r)。思路怎么也绕不过列举l和r，上一个思路为什么会导致乌龙的结果呢，也是因为l和r的动态变化导致计算的子数组并没有好用的规律……</p>
<p>这个解法妙在，使得和为k的(j,i)连续子数组符合k=sum[i]-sum[j-1]。sum是从0到某个元素的和，这样利用k和结尾反推开头……sum是从0开始相加的，这对于每个连续子数组都可用，提高了利用率；而且只是末尾变化，也更稳定……</p>
<p>大概理解是，按照我需要什么然后来找我遍历过的。已知<code>从0开始到i的所有元素和为sum</code>，那么以i为结尾的子数组要满足和为k，就意味着sum减去<code>子数组前面所有元素和sum[j-1]</code>等于k。那么目前未知数只剩下sum[j-1]。只要它满足<code>sum[j-1] = sum[i]-k</code>，就知道这个k子数组存在。</p>
<p>由于sum[j-1]和sum[i]都是从第0位开始，所以sum[j-1]肯定是sum[i]遍历过的，用哈希表存起来对应出现的次数，随时检查判断便可。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/QTMn0o/solution/he-wei-k-de-zi-shu-zu-by-leetcode-soluti-1169/">和为 k 的子数组 - 和为 k 的子数组 - 力扣（LeetCode）</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x:nums) &#123;</span><br><span class="line">            pre += x;</span><br><span class="line">            <span class="comment">// 判断sum[j-1]是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (mp.<span class="built_in">find</span>(pre - k) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="comment">// 比如k=10, 遍历到当前14-10=4，要找的前缀和4可能有多种情况，而哈希表存储的就是前缀和的n种可能</span></span><br><span class="line">                count += mp[pre - k];</span><br><span class="line">            &#125;</span><br><span class="line">            mp[pre]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ011-0和1个数相同的子数组"><a href="#OfferⅡ011-0和1个数相同的子数组" class="headerlink" title="OfferⅡ011.0和1个数相同的子数组"></a>OfferⅡ011.0和1个数相同的子数组</h2><p>仍然是连续子数组问题，思考如何找数组的开头和结尾。同样地，除了遍历法没有其它方法有效地遍历每一个开头和结尾，然后想到上一题和为k的子数组……这里求的是个数，不像k那样具有唯一性，那怎么办呢？</p>
<p>如果要有唯一性，只要把0变成-1，”0和1个数相同“就转换成连续子数组和为0了。</p>
<p>下一个问题，哈希表存的是和出现次数的时候，怎么知道长度呢？既然是最长长度，那就没必要知道所有的出现次数，由于是从前到后遍历的，所以只需要知道长度第一次出现的索引即可。然后计算更新长度差。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前缀和，最先出现的索引</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 求得0~i的连续和</span></span><br><span class="line">        <span class="keyword">if</span> (!nums[i])</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="comment">// map存有第一个和的索引</span></span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(sum);</span><br><span class="line">        <span class="keyword">if</span> (it != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            count = (i-map[sum]) &gt; count ?  (i-map[sum]) : count;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 连续和存入哈希表</span></span><br><span class="line">        map[sum] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>【注意】判断某个元素是否在哈希表内，不能用<code>map[i] == 0</code>（判断不准确，-1也会判定为true），应该用迭代器。</p>
</blockquote>
<h2 id="OfferⅡ013-二维子矩阵的和"><a href="#OfferⅡ013-二维子矩阵的和" class="headerlink" title="OfferⅡ013.二维子矩阵的和"></a>OfferⅡ013.二维子矩阵的和</h2><p>暴力算法是超时的。如何利用已经算过的子矩阵和？但是可利用的子矩阵可大可小，很难控制和存储。既然无法从动态局部推算，那就定一个有相同点的可控的局部。</p>
<p>【题解】又是前缀和。不得不说这真是将前缀和玩出花来了。</p>
<p>先看灰色、红色、蓝色框。红色框代表要求的子矩阵范围，是由黑色框减去两个蓝色框再加上重叠的部分。那么很明显就求出了上面的式子。</p>
<p>但是从公式中绿色下划线可见，row1和col1可能为负数，所以还要避免那三种情况，并分别进行对应的处理，这将会加大工作量。所以绿色框又添加了一行一列，这样相应的坐标改成绿色字，就避免了特殊情况讨论。（miao！</p>
<p><img src="https://img-blog.csdnimg.cn/366a0fe7b8ca4a549af663f4726632ba.png" alt="image-20230428101011460"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; sums;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (h &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            sums.<span class="built_in">resize</span>(h+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(w+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不从1开始，可能是不想≤h，这样判断就会多判断一次n²</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    sums[i+<span class="number">1</span>][j+<span class="number">1</span>] = sums[i][j+<span class="number">1</span>] + sums[i+<span class="number">1</span>][j] + matrix[i][j] - sums[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2+<span class="number">1</span>][col2+<span class="number">1</span>]-sums[row2+<span class="number">1</span>][col1]-sums[row1][col2+<span class="number">1</span>]+sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="JZ67-把字符串换成整数-atoi"><a href="#JZ67-把字符串换成整数-atoi" class="headerlink" title="JZ67 把字符串换成整数(atoi)"></a>JZ67 把字符串换成整数(atoi)</h2><p>一看这个中等难度和正确率就知道坑多多。字符串题除了坑多没别的特点……首先明确的是如果有一个连续的数字，再加上前面的符号位就已经知道结果了。</p>
<p>符号位这个就挺搞的，有没遍历过/遍历过（+/-）三种状态，假设默认为1，那么就是（+/-）两种状态。这看起来很有道理，但是如果遇到”+++–+-……“这种字符串的，遍历到第二个应该知道已经遍历过，返回无效的0。所以如果设成两种状态的话，并不知道有没有遍历过。所以设成（0/-1/1）三种状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sign = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果符号位已经确认</span></span><br><span class="line">    <span class="keyword">if</span> (!sign) &#123;</span><br><span class="line">        sign = s[i] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure>



<p>那么问题又来了，计算sum的时候，刚遍历完符号位sum还是为0，但是以后的计算要涉及到正数还是负数。我把符号给到判断，结果再处理……反正看起来就是一坨东西。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetDigit</span><span class="params">(string s, <span class="keyword">int</span> &amp;i, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">-1</span> &amp;&amp; -sum &lt; -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>)) &#123;</span><br><span class="line">            isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">            isValid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    isValid = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> sign != <span class="number">0</span> ? sum * sign : sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() &amp;&amp; !isValid; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果符号位已经确认</span></span><br><span class="line">            <span class="keyword">if</span> (!sign) &#123;</span><br><span class="line">                sign = s[i] == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            sum = <span class="built_in">GetDigit</span>(s, i, sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+i);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[i]) || s[i] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【题解】遍历法。思路要清晰一些，去掉前面的空格，然后处理第一个符号，接着都按照是否为数字处理。这点抽象整理的思维还是值得我多多学习的。反正都是从头到尾严格地排（符号位+数字位），也不用考虑太多重复遇到的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//(如果有则)去掉前导空格</span></span><br><span class="line">    <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[index] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            index++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉空格就什么都没有了</span></span><br><span class="line">    <span class="keyword">if</span>(index == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//处理第一个符号是正负号的情况</span></span><br><span class="line">    <span class="keyword">if</span>(s[index] == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">        index++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[index] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">        index++;</span><br><span class="line">        sign = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去掉符号就什么都没有了</span></span><br><span class="line">    <span class="keyword">if</span>(index == n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[index];</span><br><span class="line">        <span class="comment">//后续非法字符，截断</span></span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//处理越界</span></span><br><span class="line">        <span class="comment">// 在乘之前就判断是否越界（由于res=res*10+...，倒回来算就是MAX/10，除号会省略余数取整，所以还要判断个位数是否超过MAX最后一位</span></span><br><span class="line">        <span class="keyword">if</span>(res &gt; INT_MAX / <span class="number">10</span> || (res == INT_MAX / <span class="number">10</span> &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; INT_MAX % <span class="number">10</span>))</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; INT_MIN / <span class="number">10</span> || (res == INT_MIN / <span class="number">10</span> &amp;&amp; (c - <span class="string">&#x27;0&#x27;</span>) &gt; -(INT_MIN % <span class="number">10</span>)))</span><br><span class="line">            <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        res = res * <span class="number">10</span> + sign * (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个状态机的，不明觉厉。<a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/d11471c3bf2d40f38b66bb12785df47f?tpId=265&tqId=39262&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=3&judgeStatus=undefined&tags=&title=">把字符串转换成整数(atoi)_牛客题霸_牛客网 (nowcoder.com)</a></p>
<h2 id="JZ75-字符串中第一个不重复的字符"><a href="#JZ75-字符串中第一个不重复的字符" class="headerlink" title="JZ75 字符串中第一个不重复的字符"></a>JZ75 字符串中第一个不重复的字符</h2><p>记录每个元素出现的次数；一旦超过1次就移出记录数组。这种解法简单又朴素……我觉得至少是得记录每个元素出现的次数；然后知道哪些元素是只出现过一次……想不出什么优化的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">char</span>&gt; array; <span class="comment">// 记录只存在一次的</span></span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; map;   <span class="comment">// 记录所有出现过的元素次数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">    map[ch]++;</span><br><span class="line">    <span class="keyword">if</span> (map[ch] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除array重复的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == ch) &#123;</span><br><span class="line">                array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        array.<span class="built_in">push_back</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(array.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ002-二进制加法"><a href="#OfferⅡ002-二进制加法" class="headerlink" title="OfferⅡ002. 二进制加法"></a>OfferⅡ002. 二进制加法</h2><p>原本想转到十进制又转回去的，long long int都不够，还是老实逐位计算了。</p>
<p>先翻转对齐，然后逐位计算，记录进位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">    string s_str, l_str, res;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        s_str = a;</span><br><span class="line">        l_str = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        l_str = a;</span><br><span class="line">        s_str = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(s_str.<span class="built_in">begin</span>(), s_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(l_str.<span class="built_in">begin</span>(), l_str.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 两者相加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (s_str[i] - <span class="string">&#x27;0&#x27;</span>) + (l_str[i] - <span class="string">&#x27;0&#x27;</span>) + add;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum<span class="number">-2</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum));</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 补长的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s_str.<span class="built_in">size</span>(); i &lt; l_str.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l_str[i] - <span class="string">&#x27;0&#x27;</span>) + add;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">1</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum<span class="number">-2</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(sum));</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一位</span></span><br><span class="line">    <span class="keyword">if</span> (add)</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">append</span>(<span class="built_in">to_string</span>(add));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【题解】代码进一步简洁。直接计算最长的，只不过每次都要判断两次越界再判断是否为1，虽然用了语法糖但其实if判断很多次……而且可读性……呃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()), carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 进位</span></span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有位运算。但首先得把两数换成整型，其实还会溢出，这个问题要靠Python语言高精度来弥补……此处略过。</p>
<h2 id="OfferⅡ005-单词长度的最大乘积【位运算】"><a href="#OfferⅡ005-单词长度的最大乘积【位运算】" class="headerlink" title="OfferⅡ005. 单词长度的最大乘积【位运算】"></a>OfferⅡ005. 单词长度的最大乘积【位运算】</h2><blockquote>
<p>给定一个字符串数组 <code>words</code>，请计算当两个字符串 <code>words[i]</code> 和 <code>words[j]</code> 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: words = [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;fxyz&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;fxyz&quot;。它们不包含相同字符，且长度的乘积最大。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>初步思路是暴力遍历和匹配。肯定超时，有没有更好的方法？想到的是字符串匹配算法，但是忘了。由于每个单词长度不同，内容也没有共同性，所以必须得逐个遍历两两匹配？然后是两个单词的比较，也是要逐位配？能优化的就只有后者了吧。</p>
<p>【题解】位运算。因为只有24个小写字母，所以可以用bit来记录a~z是否出现过。然后将两个单词做与操作，只有结果为0时才能说明没有相同字母。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = words.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = words[i][j] - <span class="string">&#x27;a&#x27;</span>;    <span class="comment">// 易错！</span></span><br><span class="line">            bits[i] |= <span class="number">1</span> &lt;&lt; pos;            <span class="comment">// 记住这个写法，把1移动到相应位置再计算，而不是把bits[i]移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(bits[i] &amp; bits[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = <span class="built_in">max</span>(maxLen, <span class="built_in"><span class="keyword">int</span></span>(words[i].<span class="built_in">size</span>() * words[j].<span class="built_in">size</span>()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(L+n的平方)，L是全部单词长度之和。</p>
<p>空间复杂度：O(n)，n是数组长度。</p>
</blockquote>
<h2 id="OfferⅡ020-回文子字符串的个数"><a href="#OfferⅡ020-回文子字符串的个数" class="headerlink" title="OfferⅡ020.回文子字符串的个数"></a>OfferⅡ020.回文子字符串的个数</h2><blockquote>
<p>给定一个字符串 <code>s</code> ，请计算这个字符串中有多少个回文子字符串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>想到暴力遍历，然后又觉得很像之前数组的前缀和，但是又进行不下去。原因是回文判断是前后对称的，不是连续子串的，每增加遍历一个元素，并不能从已遍历的判断出当前是否为回文数。</p>
<p>【题解】一、枚举所有回文子串</p>
<p>枚举又分为两种方法：</p>
<ul>
<li>枚举所有的子串，判断是否为回文：需要O(n²)枚举所有子串，又要O(ri-li+1)的时间检查回文，整个时间复杂度为O(n³)。</li>
<li>枚举每一个可能的回文中心，用两个指针分别向两边拓展，当两个指针指向相同的元素时继续拓展，否则停止。【利用回文的特点，多考虑一下】第一个方法就是有些中心被重复判断，加大了时间复杂度。</li>
</ul>
<p>用第二个方法的话，需要考虑如何有序地枚举可能的回文中心。如果回文长度是奇数，那么回文中心是一个字符；如果回文长度是偶数，那么中心是两个字符。当然你可以做两次循环来分别枚举奇数长度和偶数长度的回文，但是我们也可以用一个循环搞定。我们不妨写一组出来观察观察，假设 n=4，我们可以把可能的回文中心列出来：</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230517153922540-16843091676041.png" alt="image-20230517153922540"></p>
<blockquote>
<p>上图是罗列的所有中心枚举的可能，可见有些中心相同但枚举范围不同的，可以合并起来一起检查（因为范围小的不符合条件，那么大范围的肯定也不符合条件；最大范围便是超过某个边界为止）。</p>
<p>下图是合并同类项的结果，可见中心点可以为0，0 1，1，1 2，2，2 3，3，共2*len-1组。所以可以枚举中心点，范围是超过边界为止。</p>
</blockquote>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230517150610670.png" alt="image-20230517150610670"></p>
<p>也就是说确定了中心点（包括左右）和的关系，就能找到每次遍历的范围。由上图可看出，l = i / 2, r = l + (i%2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = i / <span class="number">2</span>, r = i / <span class="number">2</span> + i % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt; n &amp;&amp; s[l] == s[r]) &#123;</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>此类解决方法还是很巧妙的，很强的观察和归纳能力。</p>
<h2 id="1156-单字符重复子串的最大长度"><a href="#1156-单字符重复子串的最大长度" class="headerlink" title="1156. 单字符重复子串的最大长度"></a>1156. 单字符重复子串的最大长度</h2><blockquote>
<p>如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。</p>
<p>给你一个字符串 <code>text</code>，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;ababa&quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：text = &quot;aaabaaa&quot;</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
</blockquote>
<p>统计出现最多的字符？没有考虑到连续性，没啥用；那么考虑连续性？从当前字母开始计数为1，如果有连续则继续计数，如果出现不同数字，使用掉一次机会，继续往下遍历——如果还是立刻中断，那么要找是否还存在相同字母；如果还能继续连起来，如果剩余还有相同字母说明可以补，否则就是-1.</p>
<p>继续抽象整理一下，第一次中断，就假设有，继续补；第二次中断，就找是否有余下相同字母，如果有，则计数生效，如果没有，假如第一次中断的位置+1就是第二次中断的位置，比如abc =&gt; aac，说明后面没有连续的字母可以补了，比如abaa =&gt; aaab, abcd =&gt; aacd的区别。</p>
<p>然后每个位置的元素都遍历一次，看看有没有更长的（这块能不能优化？）。复杂度就达到了O(n²)级别（当数组都是重复元素）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxRepOpt1</span><span class="params">(string text)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : text) &#123;</span><br><span class="line">            count[c]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.<span class="built_in">size</span>(); ) &#123;</span><br><span class="line">            <span class="comment">// step1: 找出当前连续的一段 [i, j)</span></span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; text.<span class="built_in">size</span>() &amp;&amp; text[j] == text[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> cur_cnt = j - i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step2: 如果这一段长度小于该字符出现的总数，并且前面或后面有空位，则使用 cur_cnt + 1 更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (cur_cnt &lt; count[text[i]] &amp;&amp; (j &lt; text.<span class="built_in">size</span>() || i &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, cur_cnt + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// step3: 找到这一段后面与之相隔一个不同字符的另一段 [j + 1, k)，如果不存在则 k = j + 1 </span></span><br><span class="line">            <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &lt; text.<span class="built_in">size</span>() &amp;&amp; text[k] == text[i]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(k - i, count[text[i]]));</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="OfferⅡ-035-最小时间差"><a href="#OfferⅡ-035-最小时间差" class="headerlink" title="OfferⅡ 035.最小时间差"></a>OfferⅡ 035.最小时间差</h2><blockquote>
<p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>除了00：00之外都可以排序比较……？如果前或者后有一个00：00，那么前后都应该补上一个；如果前后都有00：00，那结果就是0。呃……但处理起来似乎很麻烦？（被时间间隔跳跃难住了）</p>
<p>【题解】因为要找最小时间差，可以先<strong>排序</strong>，那么间隔最小的不是相邻的，就是数组首和尾（是一种特殊的相邻情况）。</p>
<p>接着是对时间间隔的处理。如果两者超过12h，那么可以反减成间隔小于12h之内。</p>
<p>而且题解对时间间隔的处理也抓到了要点：将首尾换成“相隔一天”的时间，如果两个时间间隔大于12h，比如5：00、23：00，那就是29：00-23：00，会比较接近；如果间隔小于12h，比如16：00、23：00，那就是40-23，反而会拉远。呃呃呃，反正就是很奇妙啊（不会灵活变通看啥都很妙）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinutes</span><span class="params">(string &amp;t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>)) * <span class="number">60</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + <span class="built_in"><span class="keyword">int</span></span>(t[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(vector&lt;string&gt; &amp;timePoints)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(timePoints.<span class="built_in">begin</span>(), timePoints.<span class="built_in">end</span>());	<span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> t0Minutes = <span class="built_in">getMinutes</span>(timePoints[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> preMinutes = t0Minutes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; timePoints.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> minutes = <span class="built_in">getMinutes</span>(timePoints[i]);</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, minutes - preMinutes); <span class="comment">// 相邻时间的时间差</span></span><br><span class="line">            preMinutes = minutes;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, t0Minutes + <span class="number">1440</span> - preMinutes); <span class="comment">// 首尾时间的时间差</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>时间复杂度：O(nlogn)，n是数组长度，排序所需时间；</li>
<li>空间复杂度：O(n)或O(nlogn)，排序需要空间，取决于具体语言的实现。</li>
</ul>
</blockquote>
<p>【鸽巢原理】根据题意，一共有 24×60=1440种不同的时间。由鸽巢原理可知，如果 timePoints 的长度超过1440，那么必然会有两个相同的时间，此时可以直接返回0。</p>
<p>鸽巢原理：如果有n+1个鸽子飞进了n个鸽巢中，那么必定有鸽巢中至少飞进了2只鸽子。</p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="OfferⅡ-030-插入、删除和随机访问都是O-1-的容器"><a href="#OfferⅡ-030-插入、删除和随机访问都是O-1-的容器" class="headerlink" title="OfferⅡ 030. 插入、删除和随机访问都是O(1)的容器"></a>OfferⅡ 030. 插入、删除和随机访问都是O(1)的容器</h2><p>插入删除无疑用哈希表，随机访问还想遍历一下，但是时间复杂度不行，所以引入变长容器vector；</p>
<p>vector可以直接访问索引，所以通过索引访问随机元素。但vector又不好插入删除，也要依赖哈希表动态更新，哈希表插入时vector在尾部添加，删除时获取哈希表对应的索引进行特定位置的删除。</p>
<p>但是这样的话vector某个元素的索引是时时变化的。比如原来是第3个，前面删除了，那么就变成了第2个，暂且不说哈希表也要对应变化，后面的一连串也要跟着变化……时间复杂度又上去了。如果vector不删除，或者不连续，都影响随机数每个数字概率都一样的要求……</p>
<p>总结来说，随机数只和vector有关，插入的话只需要哈希表，但是删除的话vector又依赖哈希表（需要知道哪个被删除了），此时要求哈希表的值和索引值严格对应，但vector的索引由于删除又实时更新……</p>
<p>【针对删除出现的问题，就是把删除的位置idx和最后一个last替换，并把last索引更新，时间复杂度就是1了】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="keyword">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (indices.<span class="built_in">count</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = nums.<span class="built_in">size</span>();</span><br><span class="line">        nums.<span class="built_in">emplace_back</span>(val);</span><br><span class="line">        indices[val] = index;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!indices.<span class="built_in">count</span>(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index = indices[val];</span><br><span class="line">        <span class="keyword">int</span> last = nums.<span class="built_in">back</span>();</span><br><span class="line">        nums[index] = last;</span><br><span class="line">        indices[last] = index;</span><br><span class="line">        nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        indices.<span class="built_in">erase</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = <span class="built_in">rand</span>()%nums.<span class="built_in">size</span>();	<span class="comment">// rand()</span></span><br><span class="line">        <span class="keyword">return</span> nums[randomIndex];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; indices;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>所以这道题的难度是，哈希表的特点是判断是否存在但没有索引访问且不连续，而随机数又给出了这样的要求……那么怎样才能辅助哈希表呢？</p>
<p>【题解】哈希表＋滑动窗口。比我原来的想法高明在，找是否有相同的字母来补，不是遍历，而是哈希表计数确定。如果还有其它一部分没算，那就在前一位或者后一位来补。</p>
<p>再看后面有没有重复的部分……有待斟酌。(????这哪跟哪？)</p>
<h2 id="OfferⅡ-031-最近最少使用缓存"><a href="#OfferⅡ-031-最近最少使用缓存" class="headerlink" title="OfferⅡ 031.最近最少使用缓存"></a>OfferⅡ 031.最近最少使用缓存</h2><blockquote>
<p> <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/LRU">LRU (Least Recently Used，最近最少使用) 缓存机制</a></p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li>
</ul>
</blockquote>
<p>逻辑就是以下这样。put的时候会检查存储是否足够，若不够，则删除最久未用的数据；而get的时候会更新该元素的使用情况。其实就满了删除的时候才需要知道哪些元素要删，map做不到，就只能借助于其它数据结构，记录元素更新情况。</p>
<p>如果用数组：put的时候更新元素位置就很麻烦，因为要移动元素；</p>
<p>如果用队列：读元素只能从队头读，也不好移动元素；</p>
<p>什么数据结构能方便读取和移动元素呢？</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230523152452370.png" alt="image-20230523152452370"></p>
<p>【题解】哈希表＋双向链表。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/OrIXps/solution/zui-jin-zui-shao-shi-yong-huan-cun-by-le-p3c2/">最近最少使用缓存 - 最近最少使用缓存 - 力扣（LeetCode）</a></p>
<ul>
<li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li>
<li>哈希表即为普通的哈希映射（HashMap），键存的是数字，值存的是对应的链表结点。而链表结点又存了value值。利用了双向链表<strong>方便插入删除</strong>的特点；还有可以<strong>头插或者尾插</strong>的特点（插入头部后面或尾部前面）。因为辅助的数据结构既要实现队列的功能，也要知道中间的元素（被更新到尾部），使用数组会打乱顺序，使用队列就访问不到中间的元素，所以双向链表是最优选择。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(): <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity): <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        DLinkedNode* node = cache[key];</span><br><span class="line">        <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache[key] = node;</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                DLinkedNode* removed = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(removed-&gt;key);</span><br><span class="line">                <span class="comment">// 防止内存泄漏</span></span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                --size;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* node = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ033-变位词组"><a href="#OfferⅡ033-变位词组" class="headerlink" title="OfferⅡ033.变位词组"></a>OfferⅡ033.变位词组</h2><blockquote>
<p>给定一个变位词组，组合变位词，可以按照任意顺序返回结果。变位词是指字母相同，但排列不同的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p>首先想到遍历。每个元素依次遍历，遇到变位词就组合在一起，再把它们从数组中移除。最坏的情况是每个元素只有自己为一组，那就达到O(n²)的复杂度。</p>
<p>那怎么把遍历的结果存下来呢？想要记录的结果是，有什么字母，对应多少个出现次数；这个用哈希表怎么记录呢？不用哈希表直接映射的话，逐个遍历比较也很耗时间。</p>
<p>【题解】排序。由于互为字母异位词的两个字符串包含的<strong>字母相同</strong>，因此对两个字符串分别进行<strong>排序之后得到的字符串一定是相同的</strong>，故可以将排序之后的字符串作为哈希表的键。</p>
<p>从键来说，简化了记录字母和对应数字，直接整合成字符串；从对来说，哈希表可以存数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (string&amp; str : strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);  <span class="comment">// 哈希表的second可以放数组？</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>时间复杂度：O(nklogk)，其中 n 是strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要遍历n 个字符串，对于每个字符串，需要 O(klogk) 的时间进行排序以及 O(1) 的时间更新哈希表，因此总时间复杂度是 O(nklogk)。</li>
<li>空间复杂度：O(nk)，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的的最大长度。需要用哈希表存储全部字符串。</li>
</ul>
</blockquote>
<p>【计数】直接使用数组作为哈希表的键？需要自定义了。自定义那个看了比较麻烦，有人用字符串来代替数组。需要注意的是，把字符串当作数组来看的话，字符串的元素是char，也就占一个字节，最多记录-128~127，比int记录的要少很多。（怎么解决？待思考</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; hash_al;<span class="comment">//unordered_map的key不能存储vector.</span></span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123;</span><br><span class="line">            <span class="comment">//将字符串转为字母表</span></span><br><span class="line">            <span class="function">string <span class="title">temp</span><span class="params">(<span class="number">26</span>,<span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> ch : str) &#123;</span><br><span class="line">                --temp[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将变位词放在同一键下面</span></span><br><span class="line">            hash_al[temp].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历哈希表，将变位词组改成输出格式形式</span></span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;string, vector&lt;string&gt;&gt;::iterator it = hash_al.<span class="built_in">begin</span>(); it != hash_al.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ-034-外星语言是否排序"><a href="#OfferⅡ-034-外星语言是否排序" class="headerlink" title="OfferⅡ 034.外星语言是否排序"></a>OfferⅡ 034.外星语言是否排序</h2><blockquote>
<p>只有当给定的单词在这种外星语中按字典序排列时，返回 <code>true</code>；</p>
<p>字典顺序：如果前一个单词的第一个字母比后一个单词的第一个字母靠前，则返回true；如果前者靠后，则返回false；如果相同，就看两者的第二个字母，规则同上；如果都相同的情况下，后一个单词比前一个单词长才返回true。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：在该语言的字母表中，&#x27;h&#x27; 位于 &#x27;l&#x27; 之前，所以单词序列是按字典序排列的。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>想到的思路是，从头开始遍历两两比较，如果前一个大于后一个，则返回false；否则继续。</p>
<p>然后是两个单词的比较，也是从头遍历两两比较，如果前一个大于后一个，返回false。由于要参照被打乱的字母表，所以要遍历字母表查两个字母的前后；但是每次比较都遍历的话就很耗时间，k（最短单词长度）×n（数组长度）×26。那么如何记录比较过的信息呢？我想到的键值对是string-int，string是c1c2……但我写得很冗长……</p>
<p>【题解】突破点在如何快速高效地知道乱序字母表的每个字母对应的位置。这里很巧妙地用<code>index[order[i] - &#39;a&#39;] = i;</code>也就是，默认数组的索引0<del>26对应a</del>z，然后元素记录的是新的索引值……所以比较的时候就能直接检索到所需字母以及对应新索引……实在是妙极了啊啊啊啊。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlienSorted</span><span class="params">(vector&lt;string&gt;&amp; words, string order)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">index</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            index[order[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接当作二维数组来比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> valid = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i - <span class="number">1</span>].<span class="built_in">size</span>() &amp;&amp; j &lt; words[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> prev = index[words[i - <span class="number">1</span>][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">int</span> curr = index[words[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span> (prev &lt; curr) &#123;</span><br><span class="line">                    valid = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prev &gt; curr) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                <span class="comment">/* 比较两个字符串的长度 */</span></span><br><span class="line">                <span class="keyword">if</span> (words[i - <span class="number">1</span>].<span class="built_in">size</span>() &gt; words[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这几题下来有些新的启发，最重要的是记录的思想，并不一定是要哈希表，哈希表只是一种快速定位的键值对形式，数组（字符串）也能有索引快速定位的功能。</p>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="JZ56-数组中只出现一次的两个数字"><a href="#JZ56-数组中只出现一次的两个数字" class="headerlink" title="JZ56 数组中只出现一次的两个数字"></a>JZ56 数组中只出现一次的两个数字</h2><p>想的是直接排序，然后遍历删除重复的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((i<span class="number">-1</span>) &gt;= <span class="number">0</span> &amp;&amp; (array[i] == array[i<span class="number">-1</span>])) &#123;</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+(i<span class="number">-1</span>));</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【题解】用到了位运算。</p>
<p>1.总体思路：有一道和它类似的题,它所指的数组中只有一个出现一次的数,而解法就是从头开始不断地异或下去,由于相同的两个数异或值为0,因此最终的异或结果就是答案；</p>
<p>2.而本题有两个只出现一次的数a和b,我们按异或方法<u>最终只能得到a异或b的值</u>,就需要思考一下这两个数异或的结果有何特点；（利用两数不同且唯一的特点做区分）</p>
<p>3.我们可以发现,首先这两个数一定不同,故异或结果一定不为0,那么<u>a异或b的结果中一定有一位为1</u>,假设是第x位,那么就说明了a和b的二进制的第x位是不同,根据这一特点,我们可以将数组分为两个集合,即<u>第x位为1的数和第x位为0的数</u>,两部分的异或和即为a和b的值；（找到区分的点，确保两者独立，然后再区分阵营…好抽象！）</p>
<p>4.要快速求得最后一位1,可以用lowbit运算,它可以快速得到x的最后一位1；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;	<span class="comment">// 是一种快速运算</span></span><br><span class="line">    </span><br><span class="line">    temp = a ^ b;	<span class="comment">// 常规运算</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">1</span>;		<span class="comment">// 0001</span></span><br><span class="line">    <span class="keyword">while</span>((k &amp; temp) == <span class="number">0</span>)</span><br><span class="line">        k &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> twoNums = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 两数异或的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        twoNums ^= i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个不同的1</span></span><br><span class="line">    <span class="keyword">int</span> difPos = <span class="built_in">lowbit</span>(twoNums);</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">        <span class="comment">// 比如difPos = 0010, 那么只有那位为1的时候，与的结果才【不为0】，否则必然为0</span></span><br><span class="line">        <span class="keyword">if</span> (difPos &amp; i) &#123;</span><br><span class="line">            a ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到a的值，也就知道b的值：b = (a^b)^a</span></span><br><span class="line">    b = twoNums ^ a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? vector&lt;<span class="keyword">int</span>&gt;&#123;a,b&#125; : vector&lt;<span class="keyword">int</span>&gt;&#123;b,a&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230403153532720.png" alt="image-20230403153532720"></p>
<h2 id="OfferⅡ004-只出现一次的数字"><a href="#OfferⅡ004-只出现一次的数字" class="headerlink" title="OfferⅡ004. 只出现一次的数字"></a>OfferⅡ004. 只出现一次的数字</h2><p>除了答案是出现一次，其他元素出现三次。两相同数异或为0，0再异或那个数还是那个数，所以全部异或一遍的话就是所有不重复数异或的结果。</p>
<p>那怎么办呢？感觉要从出现三次的地方入手……怎么和出现一次作出区分呢？</p>
<p>【题解】依次确定每一个二进制位。考虑答案的第 i 个二进制位（i 从0开始编号），它可能为0 或 1。对于数组中非答案的元素，每一个元素都出现了 3 次，对应着第 i 个二进制位的 3 个 0 或3 个 1，无论是哪一种情况，它们的和都是 3 的倍数（即和为0 或3）。</p>
<p>所以把每一个进位对应的所有1/0加起来，就是3的倍数加上0/1。反向取余拼接起来就是答案了……OMG！</p>
<p>进一步细节思考：数据条件是<code>-2的31次方 &lt;= nums[i] &lt;= 2的31次方 - 1</code>所以是一个有符号整数，那负数的话……？由于补码就是为了正常运算而存在的，那么应该没影响？   需要注意的是，如果使用的语言对「有符号整数类型」和「无符号整数类型」没有区分，那么可能会得到错误的答案。这是因为「有符号整数类型」（即int 类型）的第 31 个二进制位（即最高位）是补码意义下的符号位，对应着 −2的31次方，而「无符号整数类型」由于没有符号，第 31 个二进制位对应着 2的31次方。因此在某些语言（例如 Python）中需要对最高位进行特殊判断。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            total += ((num &gt;&gt; i) &amp; <span class="number">1</span>);  <span class="comment">// 取某位要&amp;1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (total % <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans |= (<span class="number">1</span> &lt;&lt; i);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="JZ76-删除链表中重复的结点"><a href="#JZ76-删除链表中重复的结点" class="headerlink" title="JZ76 删除链表中重复的结点"></a>JZ76 删除链表中重复的结点</h2><p>题意很简单，但是仔细思考觉得操作起来蛮复杂。</p>
<p>刚开始想用三个指针。pre，curr，last（和curr重复的最后一个结点，但因为循环，所以重复的话会到最后一个结点的下一个）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHead) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    pre-&gt;next = pHead;</span><br><span class="line">    ListNode* curr = pHead, *last;</span><br><span class="line">    vector&lt;ListNode*&gt; deletes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!curr) &#123;</span><br><span class="line">        last = curr;</span><br><span class="line">        <span class="comment">// 找出重复的范围</span></span><br><span class="line">        <span class="keyword">while</span> (!last-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last-&gt;next-&gt;val == last-&gt;val) &#123;</span><br><span class="line">                last = last-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理重复结点</span></span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;val != last-&gt;val) &#123;</span><br><span class="line">            pre-&gt;next = last-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (!curr) &#123;</span><br><span class="line">                deletes.<span class="built_in">push_back</span>(curr);</span><br><span class="line">                curr = curr-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指针更新</span></span><br><span class="line">        curr = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就写不下去了，因为指针多的时候要考虑指针为空的情况，那将要考虑更多情况和写更多的if和while语句，觉得好闹心……而且还要删除重复的指针，不能简单地越过。</p>
<p>然后就思考，单链表麻烦的地方在于必须维护前后关系，然后要考虑下一个结点可能为空的情况；关系一复杂，就很难搞，要很多变量存储这些关系；那如果使用额外空间/顺序数据结构来帮助维护关系呢？</p>
<p>接着想到队列，可知队头和队尾，重复的部分删除就好，重要的是两边的头尾……</p>
<ul>
<li>确定头：当入队的结点和队首的结点值不同且相邻时，队首出队（必不重复），作为pre</li>
<li>当入队的结点和队首的结点值相同时，继续入队</li>
<li>当入队的结点和队首的结点值不同且不相邻时，队首和队尾必然有重复的，从队首开始逐一删除重复元素</li>
<li>回到第一点，如果出队的时候有pre，那么pre下一个就是队首，出队后接着做pre（头尾相连）</li>
</ul>
<p>另，要把空结点也加进去。因为重复的范围必须由下一个元素确定，比如445，但如果后面只有重复的，比如4455，那么空结点也是判断条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pHead) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue&lt;ListNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(pHead);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* curr = pHead-&gt;next, *head = pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (queue.<span class="built_in">front</span>()) &#123;</span><br><span class="line">        queue.<span class="built_in">push</span>(curr);</span><br><span class="line">        <span class="comment">// 确定不是重复的数</span></span><br><span class="line">        <span class="keyword">if</span> ((!curr || queue.<span class="built_in">front</span>()-&gt;val != curr-&gt;val) &amp;&amp; queue.<span class="built_in">front</span>()-&gt;next == curr) &#123;</span><br><span class="line">            pre-&gt;next = queue.<span class="built_in">front</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定重复的范围</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((!curr || queue.<span class="built_in">front</span>()-&gt;val != curr-&gt;val) &amp;&amp; queue.<span class="built_in">front</span>()-&gt;next != curr) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.<span class="built_in">front</span>() != queue.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                <span class="comment">//ListNode* temp = queue.front();</span></span><br><span class="line">                queue.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//delete temp;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复继续往下遍历</span></span><br><span class="line">        <span class="keyword">if</span> (curr) &#123;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历完链表，必须有个收尾</span></span><br><span class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不过实际上还是没有解决删除问题，只是删除了临时变量。</p>
</blockquote>
<p>【题解】呃，别人还是用指针解决了问题，来学习一下。它只用了一个指针，是判断指针的下一个和下下一个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空链表</span></span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//在链表前加一个表头</span></span><br><span class="line">    res-&gt;next = pHead; </span><br><span class="line">    ListNode* cur = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123; </span><br><span class="line">        <span class="comment">//遇到后两个节点值相同</span></span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123; </span><br><span class="line">            <span class="keyword">int</span> temp = cur-&gt;next-&gt;val;</span><br><span class="line">            <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">            <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;val == temp) </span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回时去掉表头</span></span><br><span class="line">    <span class="keyword">return</span> res-&gt;next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>短路运算确实在这起了很大效果。<code>cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL</code>如果前面为空，那么后面必不会运算，这就不会报错。除此之外，跨数字链接，它不是记录头和尾，而是头的next一直往后指……总之它一个指针就能完成这些事情，值得思考和学习。</p>
<h2 id="OfferⅡ-022-链表中环的入口节点"><a href="#OfferⅡ-022-链表中环的入口节点" class="headerlink" title="OfferⅡ 022. 链表中环的入口节点"></a>OfferⅡ 022. 链表中环的入口节点</h2><p>对这种题还是不知道如何思考才正确……</p>
<p>首先知道有环的话两者必定相遇…为什么要先假设速度就是1，2呢？然后要懂得分析相遇时走过的路径……</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/c32eOV/solution/lian-biao-zhong-huan-de-ru-kou-jie-dian-vvofe/">链表中环的入口节点 - 链表中环的入口节点 - 力扣（LeetCode）</a></p>
<h2 id="OfferⅡ-026-重排链表"><a href="#OfferⅡ-026-重排链表" class="headerlink" title="OfferⅡ 026. 重排链表"></a>OfferⅡ 026. 重排链表</h2><p>原想法是，用快慢指针找到后一半，然后把后一半用栈存起来，再一一遍历插入。</p>
<p>之前从来没有注意到一个问题，仔细想想真的还很drama。存入栈的其实是结点的一份拷贝，但指向还是原链表，所以当把栈的元素插入链表中的时候，链表后半部分还在。要是把栈变量的指向改动的话，结果很难设想。这样用空间存储一部分链表的话似乎要十分谨慎，把链表全存入或者构建新链表还好。</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230519120051323.png" alt="image-20230519120051323"></p>
<p>原错误思路:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head, *fast = head;</span><br><span class="line">    std::stack&lt;ListNode*&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将后半部分存入栈</span></span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (slow)</span><br><span class="line">    &#123;</span><br><span class="line">        stack.<span class="built_in">push</span>(slow);</span><br><span class="line">        <span class="comment">//ListNode* temp = slow;</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="comment">//delete temp;	// 这个好像把slow也删掉了？搞晕了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete slow;</span></span><br><span class="line">    <span class="comment">//delete fast;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新遍历，插入</span></span><br><span class="line">    ListNode* curr = head;</span><br><span class="line">    <span class="keyword">while</span> (!stack.<span class="built_in">empty</span>() <span class="comment">/* &amp;&amp; curr */</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* node = stack.<span class="built_in">top</span>(); stack.<span class="built_in">pop</span>();</span><br><span class="line">        node-&gt;next = curr-&gt;next;    <span class="comment">// leetcode 报heap-use-after-use错</span></span><br><span class="line"></span><br><span class="line">        curr-&gt;next = node;</span><br><span class="line">        curr = curr-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//delete curr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>若例子是1,2,3,4，结果是1,4,2,3,4,,,,</p>
</blockquote>
<p>【题解】一、线性表。存储整个链表。</p>
<p>因为链表不支持下标访问，所以我们无法随机访问链表中任意位置的元素。</p>
<p>因此比较容易想到的一个方法是，我们利用线性表存储该链表，然后利用线性表可以下标访问的特点，直接按顺序访问指定元素，重建该链表即可。</p>
<p>这里题解是用线性表重构整个链表。但是不也拷贝了吗？这个要仔细分析才不会先入为主。</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230519122422519.png" alt="image-20230519122422519"></p>
<blockquote>
<p>拷贝出来的是node，存入vec的是圈出来的部分。当修改node的next时，由于next是指针，其实是访问指向的对象的next，这和head的next是一样的，所以效果一样。</p>
<p>仔细想想坑还是好多，以后多积累多思考多注意。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        std::vector&lt;ListNode*&gt; vec;</span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        <span class="keyword">while</span> (node)</span><br><span class="line">        &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            vec[l]-&gt;next = vec[r];</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">if</span> (l == r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[r]-&gt;next = vec[l];</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[l]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>【方法二】链表中点+链表逆序+合并链表</p>
<p>也就是把存储改为逆序，在原链表基础上改，这样就感觉稳很多了。</p>
<h2 id="OfferⅡ-027-回文链表"><a href="#OfferⅡ-027-回文链表" class="headerlink" title="OfferⅡ 027.回文链表"></a>OfferⅡ 027.回文链表</h2><p>后半部分反转链表，再逐一比较：很慢，就超过百分之十几。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* newHead = <span class="built_in">reverse</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明链表长度是奇数, slow在中间点，不需要反转</span></span><br><span class="line">        <span class="keyword">if</span> (fast)</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后半部分</span></span><br><span class="line">        ListNode* head2 = <span class="built_in">reverse</span>(slow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两两比较</span></span><br><span class="line">        <span class="keyword">while</span> (head2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (head-&gt;val != head2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            head2 = head2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>【题解】递归。可知递归是从链表的尾部逐一往前，而再用一个全局变量来遍历前半部分，这样就能前后同时比较了。递归对于<strong>链表往前遍历</strong>也是一种很好的方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    ListNode* frontPointer;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recursivelyCheck</span><span class="params">(ListNode* currentNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentNode != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       		<span class="comment">// 往后递归，直到空结点，返回true；则if判断为!true</span></span><br><span class="line">            <span class="comment">// 从语义来说，也就是递归过的末尾链表符合条件了才返回true，才能够继续往下执行比较，否则就直接返回false</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">recursivelyCheck</span>(currentNode-&gt;next)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上一个if判断为false，开始判断值是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (currentNode-&gt;val != frontPointer-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            frontPointer = frontPointer-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录头结点</span></span><br><span class="line">        frontPointer = head;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursivelyCheck</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ-028-展平多级双向链表"><a href="#OfferⅡ-028-展平多级双向链表" class="headerlink" title="OfferⅡ 028.展平多级双向链表"></a>OfferⅡ 028.展平多级双向链表</h2><p>尝试理解展平的规则：去掉了child指针信息。首先先顺着child往下走，直到没有child的那一个结点，再往右走访问同一行的结点；访问完后回到上一层有孩子结点的结点的右边……用栈来存储有child结点的next结点，访问完child则从栈取出继续访问…</p>
<p>没有好的抽象思维习惯一下子就绕晕了。</p>
<p>【题解】深度优先搜索。</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230522111207578.png" alt="image-20230522111207578"></p>
<blockquote>
<p>这样就好理解多了。把孩子那层扁平化成一条链表再插入到右边去。那在代码实现层面怎么回溯呢？想象了一下递归代码，把孩子层的头结点传进去，返回last结点，把head 和last与自己当前的结点curr和curr-&gt;next连接起来。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node* curr = node;</span><br><span class="line">        <span class="comment">// ！记录链表最后一个结点（没有child和扁平化child的结果不同）</span></span><br><span class="line">        Node* last = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (curr <span class="comment">/* &amp;&amp; curr-&gt;next */</span>)    <span class="comment">// ！要考虑到最后一个结点也可能有child 这样就不需要和next连接</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node* next = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;child)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 扁平化</span></span><br><span class="line">                Node* child_last = <span class="built_in">dfs</span>(curr-&gt;child);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// curr与child连接</span></span><br><span class="line">                curr-&gt;next = curr-&gt;child;</span><br><span class="line">                curr-&gt;child-&gt;prev = curr;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// last和next连接</span></span><br><span class="line">                    child_last-&gt;next = next;</span><br><span class="line">                    next-&gt;prev = child_last;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ！将child置为空</span></span><br><span class="line">                curr-&gt;child = <span class="literal">nullptr</span>;</span><br><span class="line">                last = child_last;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                last = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ！接着原来的next继续往后</span></span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">flatten</span><span class="params">(Node* head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(head);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>时间复杂度：O(n)，其中 n 是链表中的节点个数。</p>
</li>
<li><p>空间复杂度：O(n)。上述代码中使用的空间为深度优先搜索中的栈空间，如果给定的链表的「深度」为<br>d，那么空间复杂度为 O(d)。在最坏情况下，链表中的每个节点的next 都为空，且除了最后一个节点外，每个节点的child 都不为空，整个链表的深度为n，因此时间复杂度为O(n)。</p>
</li>
</ul>
</blockquote>
<p>顺着题解的思路能写出递归的大概，但一些细节是对照别人的代码才看出来的，以后要自己实践一下。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/Qv1Da2/solution/zhan-ping-duo-ji-shuang-xiang-lian-biao-x5ugr/">展平多级双向链表 - 展平多级双向链表 - 力扣（LeetCode）</a></p>
<p>【题解】迭代。按照原先的想法，就是：如果有child就往下遍历，往下-往右遍历完后，再看栈还有没有存储（上一层）的结点，继续出栈访问，以此类推。整个过程就是依次遍历的过程，可以在一个while中完成。</p>
<p>遇到child则进入child所在层，若走到当前层最后一个结点，则考察上一层是否有后续结点，若有则链回上一层（展平）。为了能够链回上一层，需要在通过当前结点cur进入child层时，先将cur.next保存起来，显然应当借助栈来保存。整体是一个层层深入后再自下而上展平的过程。现在来考虑完成展平（结束while）的条件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.cur为空结点 而且 没有上一层（栈空），则为false</span></span><br><span class="line"><span class="keyword">while</span>(cur != null || !stack.<span class="built_in">isEmpty</span>())</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ-029-排序的循环链表"><a href="#OfferⅡ-029-排序的循环链表" class="headerlink" title="OfferⅡ 029.排序的循环链表"></a>OfferⅡ 029.排序的循环链表</h2><p>刚开始想到，既然是非降序，那么插入一个数字，要么是最大/最小的，要么是中间的，但是一想到这是循环链表，可能不好找，没仔细想就放弃了。然后果断用了数组存……这样就随便遍历了。好理解但是麻烦了些，空间复杂度为n。</p>
<p>【题解】找了一个评论，思路和我很像，但是别人写出来了，值得学习。</p>
<p>有一个核心点我没想到，就是既然是非降序循环，那么肯定有“断点”，最大值和最小值相邻的地方。这样就很快判断插入的值是否为最大最小值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 断点 或 边界跳跃点</span></span><br><span class="line">cur-&gt;val &gt; cur-&gt;next-&gt;val <span class="comment">// 当前值大于下一个值</span></span><br><span class="line">value &gt;= cur-&gt;val		<span class="comment">// 插入的值比当前值还大，那就是新的最大值</span></span><br><span class="line">value &lt;= cur-&gt;next-&gt;val	<span class="comment">// 插入的值比最小值（当前的下一个）还小，就是新的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要满足以上情况，此时cur就是要插入的点的前结点</span></span><br></pre></td></tr></table></figure>

<p>剩下就是中间的情况。只要满足：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur-&gt;val &lt;= cur-&gt;next-&gt;val	<span class="comment">// 升序的情况</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(value &gt;= cur-&gt;val &amp;&amp; value &lt;= cur-&gt;next-&gt;val)	<span class="comment">// 夹在两值中间</span></span><br></pre></td></tr></table></figure>

<p>所以找到符合条件的cur，也就是找到了插入的点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结点为空，要创建一个指向自己的新结点</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal);</span><br><span class="line">            head-&gt;next = head;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="comment">// 只遍历一次不重复的</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=head)&#123;</span><br><span class="line">            <span class="comment">// 边界点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val&lt;cur-&gt;val)&#123;</span><br><span class="line">                <span class="comment">// 最小值</span></span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;next-&gt;val&gt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 最大值</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val&lt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处在中间值</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&lt;=insertVal&amp;&amp;cur-&gt;next-&gt;val&gt;=insertVal) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 都不符合条件，继续遍历</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">Node</span>(insertVal, cur-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路很简洁，还有抓住cur以及next的判断也很巧妙。遇到这题觉得头疼是因为没有找到 <strong>结点间的关系 和 判断条件的关系</strong>，总觉得链表遍历单一，一定要有辅助遍历才行，所以没有分析到位。</p>
</blockquote>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="OfferⅡ-037-小行星碰撞"><a href="#OfferⅡ-037-小行星碰撞" class="headerlink" title="OfferⅡ 037.小行星碰撞"></a>OfferⅡ 037.小行星碰撞</h2><h2 id="OfferⅡ-038-每日温度"><a href="#OfferⅡ-038-每日温度" class="headerlink" title="OfferⅡ 038.每日温度"></a>OfferⅡ 038.每日温度</h2><p>时间复杂度为O(n²)果然还是超时了。一个数要找到后面第一个比它大的数……除了一个个找还能咋办呢？</p>
<p>想着要利用已知信息，从左到右遍历的话，比如知道76，78，77，79，即使78知道下一个比它大的数是79，知道有77的存在，但77除了重新遍历还能怎么知道下一个比它大的数呢？</p>
<p>这里的有逆向思维的方法。最后一个元素对应的答案肯定为0，因为后面没有任何元素了。那倒数第一个呢，已知最后一个，也可以推断答案；倒数第三个……已知后面的所有元素，也能记录索引，那么可以有目的地遍历比它大的，找有没有存在对应索引……（反正细细品</p>
<p>【题解】虽然说是暴力，但比我那个暴力要巧妙得多。这脑子就是转不过弯来啊。从前往后，用过的元素对题目条件其实没多大帮助，要是倒过来的话，知道后面所有存在的元素反而可以利用起来。</p>
<p>这里将后面遍历过的元素，存在[30, 100]的数组next里面，记录这个数字（从左往右）第一次出现的索引。然后当当前元素想要找到比它大的元素时，就往[i+1,100]挨个找，看看有没有最近的索引。</p>
<p>这样看起来每次都要遍历(100-i)次，但是由于肯定不超过100，那么时间复杂度可以算作O(n)，n是温度列表的长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(temperatures.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="number">101</span>, INT_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> warmerIndex = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = temperatures[i] + <span class="number">1</span>; j &lt; <span class="number">101</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                warmerIndex = <span class="built_in">min</span>(warmerIndex, next[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (warmerIndex != INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                res[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            next[temperatures[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="JZ54-二叉搜索树的第k个节点"><a href="#JZ54-二叉搜索树的第k个节点" class="headerlink" title="JZ54 二叉搜索树的第k个节点"></a>JZ54 二叉搜索树的第k个节点</h2><p>二叉搜索一般和中序遍历挂钩，然后遇到k就记录下来……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> target = <span class="number">0</span>, res = <span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!proot) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = k;</span><br><span class="line">    <span class="built_in">dfs</span>(proot);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count == target) &#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过找到目标后递归并不能停止。所以加上几个递归条件就更好。不过话说这真的是中等题吗……</p>
<blockquote>
<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中<em>n</em>为二叉树的节点数，所有节点遍历一遍</li>
<li>空间复杂度：<em>O</em>(<em>n</em>)，栈空间最大深度为二叉树退化为链表，长度为<em>n</em></li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!root || res != <span class="number">-1</span> || count &gt; target) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好久没有用过栈了，copy一下来回顾一下：先遍历左子树，把节点都入栈，然后取出栈顶作为当前根节点，来进行判断，接着访问右节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(proot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//记录遍历了多少个数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    TreeNode* p = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用栈辅助建立中序</span></span><br><span class="line">    stack&lt;TreeNode*&gt; s;  </span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() || proot != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (proot != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(proot);</span><br><span class="line">            <span class="comment">//中序遍历每棵子树从最左开始</span></span><br><span class="line">            proot = proot-&gt;left;  </span><br><span class="line">        &#125;</span><br><span class="line">        p = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//第k个直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(count == k)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        proot = p-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没有找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77 按之字形顺序打印二叉树"></a>JZ77 按之字形顺序打印二叉树</h2><p>从左往右遍历的层，就从左往右入队，然后再从右往左取出每个节点，按照右子树左子树的顺序把子树入队；</p>
<p>同理，从右往左遍历的层，就根据上层是从右往左入队，然后再从左往右出队按照左子树右子树把子树入队。</p>
<p>按照这个规律，都是先进后出，那么为了分清层次，用两个栈交替使用。</p>
<p>再梳理一下，比如该层是应该从右往左遍历，但是为了下一层能够从左往右进栈，会从左往右遍历然后将子树入栈，所以遍历的记录要反转一下。【核心是取出栈的节点，然后存节点的顺序】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CheckLayer</span><span class="params">(stack&lt;TreeNode*&gt; &amp;a, stack&lt;TreeNode*&gt; &amp;b, <span class="keyword">bool</span> isL2R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 遍历每个节点，存入</span></span><br><span class="line">    <span class="keyword">while</span> (!a.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* curr = a.<span class="built_in">top</span>();</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isL2R) &#123;</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">            b.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stack1 从左往右存放，从右往左取出，右左遍历</span></span><br><span class="line">    <span class="comment">// stack2 从右往左存放，从左往右取出，左右遍历</span></span><br><span class="line">    stack&lt;TreeNode*&gt; stack1, stack2;</span><br><span class="line">    stack1.<span class="built_in">push</span>(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>() || !stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">CheckLayer</span>(stack1, stack2, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">CheckLayer</span>(stack2, stack1, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【题解】使用队列。要用size记录当前队列长度——解决每一层的问题。然后用level来记录打印方向……确实要简洁很多，直接翻转数组不是快很多吗（doge</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res; </span><br><span class="line">        <span class="keyword">if</span> (!pRoot)</span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        queue&lt;TreeNode*&gt; q; <span class="comment">// 定义队列</span></span><br><span class="line">        q.<span class="built_in">push</span>(pRoot); <span class="comment">// 根结点入队列</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; arr; <span class="comment">// 定义数组存储每一行结果</span></span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>(); <span class="comment">// 当前队列长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* tmp = q.<span class="built_in">front</span>(); <span class="comment">// 队头元素</span></span><br><span class="line">                q.<span class="built_in">pop</span>(); </span><br><span class="line">                <span class="keyword">if</span> (!tmp) <span class="comment">// 空元素跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;left); <span class="comment">// 左孩子入队列</span></span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;right); <span class="comment">// 右孩子入队列</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (level % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从左至右打印</span></span><br><span class="line">                    arr.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 从右至左打印</span></span><br><span class="line">                    arr.<span class="built_in">insert</span>(arr.<span class="built_in">begin</span>(), tmp-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++; <span class="comment">// 下一层，改变打印方向</span></span><br><span class="line">            <span class="keyword">if</span> (!arr.<span class="built_in">empty</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(arr); <span class="comment">// 放入最终结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="JZ78-把二叉树打印成多行"><a href="#JZ78-把二叉树打印成多行" class="headerlink" title="JZ78 把二叉树打印成多行"></a>JZ78 把二叉树打印成多行</h2><p>甚至比JZ77要简单，记录每一层的个数（也就是上一层遍历完后队列的长度）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pRoot) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(pRoot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = queue.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 存储每一行的结果</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; eachLayer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环每一层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* curr = queue.<span class="built_in">front</span>();</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            eachLayer.<span class="built_in">push_back</span>(curr-&gt;val);</span><br><span class="line">            queue.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            queue.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eachLayer.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(eachLayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JZ84-二叉树中和为某一值的路径（三）"><a href="#JZ84-二叉树中和为某一值的路径（三）" class="headerlink" title="JZ84 二叉树中和为某一值的路径（三）"></a>JZ84 二叉树中和为某一值的路径（三）</h2><p>由于不知道起点和终点，所以感觉有很多种可能，如果从上往下，虽然每个节点都只有一个父节点，但是从父节点来的也可能有很多种（如含父/祖父等），更不用说从下往上的子节点的可能性了（每一个子树多种可能）。之前对树的记忆一般都是递归（子树返回唯一值），从上往下（父给予唯一值）……不知道如何入手。</p>
<p>感觉从上往下的思路似乎明确一点。路径就是从父到子，正常思路就是父不够子来凑吧。</p>
<p>那么接着从某个节点角度来思考，它的任务就是接收父节点传来的要求，然后处理。刚好够的话就凑成一条路径，不够的话继续传给子树，多了的话就返回；</p>
<p>末尾问题解决了，那么起始点的问题呢？不是从父节点来的，就是以自己为起始。</p>
<p>所以递归的思路差不多就出来了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, target;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入子树继续找</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以自己为开始</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, target - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, target - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    target = sum;</span><br><span class="line">    <span class="built_in">dfs</span>(root, target);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题是，以自己为开始的代码会重复执行多次。比如一个底层子节点，它的每一个父辈传下去时都试一下自己为初始节点（多次递归到底层节点），那么它就得每次都重复尝试自己作为初始点的情况。</p>
<p>所以起始点的两种情况应该分开。父节点需求找完，就开始新的根节点。</p>
<p>【题解】脑子有点转不过来了。</p>
<p>既然要找所有路径上节点和等于目标值的路径个数，那肯定先找这样的路径起点，但是我们不知道起点究竟在哪里，而且任意节点都有可能是起点，那我们就前序遍历二叉树的所有节点，每个节点都可以作为一次起点，即子树的根节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以其子结点为新根</span></span><br><span class="line"><span class="built_in">FindPath</span>(root.left, sum); </span><br><span class="line"><span class="built_in">FindPath</span>(root.right, sum);</span><br></pre></td></tr></table></figure>

<p>查找路径的时候呢，也需要往下遍历，因此还可以继续前序遍历该子树，在遍历的过程遇到一个节点，sum相应减少，若是到最后往下的一个节点值正好等于剩下的sum，则找到一种情况。</p>
<p>因为前序递归的次序是根左右，因此一定是往下找的路径，不会往上回溯。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入子节点继续找</span></span><br><span class="line"><span class="built_in">dfs</span>(root.left, sum - root.val);</span><br><span class="line"><span class="built_in">dfs</span>(root.right, sum - root.val);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == root-&gt;val) &#123;</span><br><span class="line">        ret++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入子树继续找</span></span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val);</span><br><span class="line">    <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询以某结点为根的路径数</span></span><br><span class="line">    <span class="built_in">dfs</span>(root, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以其子结点为新根</span></span><br><span class="line">    <span class="built_in">FindPath</span>(root-&gt;left, sum);</span><br><span class="line">    <span class="built_in">FindPath</span>(root-&gt;right, sum);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>时间复杂度：O*(<em>n</em>2)，其中n*为二叉树的结点数，两层dfs嵌套递归</li>
<li>空间复杂度：<em>O</em>(<em>n</em>)，每层dfs最深递归栈都只有n</li>
</ul>
</blockquote>
<p>仔细一想我的想法稍微有点复杂，再抽象一点就是每个节点都可能作为路径起始点，就简化了好多（其实也就是暴力啦！）。然后每个节点为根遍历一次……这样就明白许多了。</p>
<p>这种看似多种解法的题很容易想复杂，怎么样才能抓住关键点呢？这道题而言，可能是起始点和终点的问题。</p>
<p>【题解】前缀和 &amp; DFS &amp; 回溯。</p>
<p>思路类似于<code>和为k的子数组个数</code>，树中某一条从上到下的路径就相当于一个数组，计算前缀和 ；只是树的路径遍历完进行变换 / 回溯的时候，就取消记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, targetSum, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* curr, <span class="keyword">int</span> targetSum, <span class="keyword">long</span> <span class="keyword">long</span> prefixSum)</span> </span>&#123;</span><br><span class="line">        prefixSum += curr-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(prefixSum - targetSum) != hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            count += hash[prefixSum - targetSum];</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefixSum]++;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(curr-&gt;left, targetSum, prefixSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(curr-&gt;right, targetSum, prefixSum);</span><br><span class="line">        &#125;</span><br><span class="line">        hash[prefixSum]--; <span class="comment">// 回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只需要遍历每个节点，时间复杂度为O(n)。哈希表同理。栈空间最多n？</p>
</blockquote>
<h2 id="JZ86-在二叉树找到两个节点的最近公共祖先"><a href="#JZ86-在二叉树找到两个节点的最近公共祖先" class="headerlink" title="JZ86 在二叉树找到两个节点的最近公共祖先"></a>JZ86 在二叉树找到两个节点的最近公共祖先</h2><p>之前做过，印象最深的就是路径法，迅速写出来：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; path1, path2;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; target, vector&lt;<span class="keyword">int</span>&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> left = <span class="built_in">FindPath</span>(root-&gt;left, target, path);</span><br><span class="line">    <span class="keyword">bool</span> right = <span class="built_in">FindPath</span>(root-&gt;right, target, path);</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">FindPath</span>(root, o1, path1);</span><br><span class="line">    <span class="built_in">FindPath</span>(root, o2, path2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = path1.<span class="built_in">size</span>() &gt; path2.<span class="built_in">size</span>() ? path1.<span class="built_in">size</span>() : path2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">            res = path1[i];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>时间复杂度：O*(<em>n</em>)，其中n*为二叉树节点数，递归遍历二叉树每一个节点求路径，后续又遍历路径</li>
<li>空间复杂度：O*(<em>n</em>)，最坏情况二叉树化为链表，深度为<em>n</em>，递归栈深度和路径数组为n*</li>
</ul>
</blockquote>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230412090059518.png" alt="image-20230412090059518"></p>
<p>数据很多的时候不知道哪里出了问题……照着题解试改了一下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int len = path1.size() &gt; path2.size() ? path1.size() : path2.size();</span></span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path1.<span class="built_in">size</span>() &amp;&amp; i &lt; path2.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">        res = path1[i];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就成功了！呃，为什么呢？为啥感觉是一样的意思？</p>
<p>根据逻辑判断。要满足条件，首先某个节点必须为符合条件的左右孩子的父节点；或者其中一个节点作为父节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; o1, <span class="keyword">int</span>&amp; o2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> left = <span class="built_in">dfs</span>(root-&gt;left, o1, o2);</span><br><span class="line">    <span class="keyword">bool</span> right = <span class="built_in">dfs</span>(root-&gt;right, o1, o2);</span><br><span class="line">    <span class="comment">// 找到某个节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == o1 || root-&gt;val == o2) &#123;</span><br><span class="line">        <span class="comment">// 看看子树有没有另外一个节点，有就是结果</span></span><br><span class="line">        <span class="keyword">if</span> (left || right)&#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 子树都没有，自己也不是，那么必然不是</span></span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 刚好左右子树都有</span></span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">        res = root-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 似乎没啥意义……</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root, o1, o2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>空间复杂度On，最坏情况二叉树化为链表，递归栈深度为�<em>n</em></p>
</blockquote>
<p>【题解】</p>
<ul>
<li>step 1：如果o1和o2中的任一个和root匹配，那么root就是最近公共祖先。</li>
<li>step 2：如果都不匹配，则分别递归左、右子树。</li>
<li>step 3：如果有一个节点出现在左子树，并且另一个节点出现在右子树，则root就是最近公共祖先.</li>
<li>step 4：如果两个节点都出现在左子树，则说明最低公共祖先在左子树中，否则在右子树。</li>
<li>step 5：继续递归左、右子树，直到遇到step1或者step3的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该子树没找到，返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//该节点是其中某一个节点</span></span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val == o1 || root-&gt;val == o2) </span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="comment">//左子树寻找公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, o1, o2); </span><br><span class="line">    <span class="comment">//右子树寻找公共祖先</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, o1, o2); </span><br><span class="line">    <span class="comment">//左子树为没找到，则在右子树中</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="comment">//右子树没找到，则在左子树中</span></span><br><span class="line">    <span class="keyword">if</span>(right == <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="comment">//否则是当前节点</span></span><br><span class="line">    <span class="keyword">return</span> root-&gt;val; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1110-删点成林"><a href="#1110-删点成林" class="headerlink" title="1110.删点成林"></a>1110.删点成林</h2><p>把要删的存进哈希表里面，然后该节点被删除的时候，如果有左子树，该左子树就成为新的树；如果有右子树则同理。但是我处理的时候用了delete，感觉不太行，删除该节点的指针后，就好像变成了无意义的内存空间，让上一级指向一个不明所以的内存，似乎很不妙。那就想，指向空行不行？怎么告诉父节点该子节点变为空了呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">midOrderTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(root-&gt;val) != map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> root;    <span class="comment">// 指向空还是delete掉？</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">midOrderTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">midOrderTree</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">midOrderTree</span>(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果被删除，则返回nullptr，作为父节点的子节点，而左右子树则作为根节点；不被删除，返回自己，继续作为父节点的子节点……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode *&gt; res;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">midOrderTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 把左右节点都处理好</span></span><br><span class="line">        root-&gt;left = <span class="built_in">midOrderTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;right = <span class="built_in">midOrderTree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该节点不用删除，返回自己</span></span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(root-&gt;val) == map.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 该节点要删除，返回空。但存在的子树将作为新的根</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;TreeNode*&gt; <span class="title">delNodes</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; to_delete)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">int</span>&amp; i : to_delete)</span><br><span class="line">        &#123;</span><br><span class="line">            map[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">midOrderTree</span>(root))</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ-051-节点之和最大的路径"><a href="#OfferⅡ-051-节点之和最大的路径" class="headerlink" title="OfferⅡ 051.节点之和最大的路径"></a>OfferⅡ 051.节点之和最大的路径</h2><blockquote>
<p>路径 被定义为一条<strong>从树中任意节点出发</strong>，沿<strong>父节点-子节点</strong>连接，<strong>达到任意节点</strong>的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给定一个二叉树的根节点 root ，返回其 最大路径和，即所有路径上节点值之和的最大值。</p>
</blockquote>
<p>刚开始只能想到按照路径逐个遍历节点 来计算路径值。然后就卡在当前节点-父节点-子节点这个遍历顺序上。即使是左右根遍历顺序，当前节点也不知道哪一个节点才是父节点……所以从传统的树遍历顺序来说，很难实现。</p>
<p>【题解】其实有点不够理解题意，如果父节点也可以是自身节点……？也就是从自己出发直接往下走…… 或者从自己出发沿着父节点再往子节点……这样一来每个节点可能是路径中的一个节点 或者路径的开头 或者自己单成一个路径也行……</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230607123600961.png" alt="image-20230607123600961"></p>
<p>假设20是当前节点，要走成一条最大和的路径，首先保证加入的节点是最大和，但是不遍历到叶子节点是不知道最大和子路径是多少。所以要递归到叶子节点，再一步步往上累加，每个节点的“最大贡献值” = 左子树最大贡献值 + 右子树最大贡献值 + 当前value。</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230607124010161.png" alt="image-20230607124010161"></p>
<blockquote>
<p>神乎其神又匪夷所思……解题思路是尽量利用树的结构特点：递归+回溯吗？利用每个节点和子树的关系……？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> maxSum = INT_MIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxGain</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递归计算左右子节点的最大贡献值</span></span><br><span class="line">        <span class="comment">// 【只有在最大贡献值大于 0 时，才会选取对应子节点】</span></span><br><span class="line">        <span class="keyword">int</span> leftGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightGain = <span class="built_in">max</span>(<span class="built_in">maxGain</span>(node-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">int</span> priceNewpath = node-&gt;val + leftGain + rightGain;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新答案</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum, priceNewpath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的最大贡献值</span></span><br><span class="line">        <span class="keyword">return</span> node-&gt;val + <span class="built_in">max</span>(leftGain, rightGain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxGain</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间空间复杂度都是O(n)</p>
</blockquote>
<h2 id="OfferⅡ-503-二叉搜索树的中序后继"><a href="#OfferⅡ-503-二叉搜索树的中序后继" class="headerlink" title="OfferⅡ 503.二叉搜索树的中序后继"></a>OfferⅡ 503.二叉搜索树的中序后继</h2><p>原做法是按照中序遍历，记录前一个节点，然后比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">inorderSuccessor</span>(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">if</span> (left) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;val == p-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        TreeNode* right = <span class="built_in">inorderSuccessor</span>(root-&gt;right, p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (right) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* pre = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>细节：虽然题目要求返回节点，但即使节点包含指向其它节点的指针，也无所谓，也就是直接返回原节点就行；</p>
<p>而且递归的话由于是要往上返回值的，所以找到的话就立马结束递归往上传递值……这样的话还不如迭代。</p>
</blockquote>
<p>【题解】利用二叉搜索树的性质。已知p节点，p的中序后继节点要么是右子树的最左节点，（如果没有右子树）要么是祖先节点。前一种情况可以直接求，第二种情况要从root重新往下找起。</p>
<p>此时如果p的值比cur大，说明p在cur的右子树，往右找；反之往左找。往左找的时候（也就是p比cur小）才更新node，那么一定能记录到p的中序后继。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode *successor = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            successor = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (successor-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                successor = successor-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> successor;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;val &gt; p-&gt;val) &#123;</span><br><span class="line">                successor = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ-057-值和下标之差都在给定的范围内"><a href="#OfferⅡ-057-值和下标之差都在给定的范围内" class="headerlink" title="OfferⅡ 057 值和下标之差都在给定的范围内"></a>OfferⅡ 057 值和下标之差都在给定的范围内</h2><p>除了暴力实在想不到别的了，因为两两数字组合没什么规律，除非给它排序之类。要是把全部元素排序的话，还得额外开一个数组一边排序一边记录原索引。</p>
<p>想的是限定k范围（也就是索引范围）然后逐个遍历，判断元素差的绝对值是否符合要求。</p>
<p>【题解】方法的改进之处是，</p>
<p>①利用滑动窗口，只在当前元素x前面的[x-k, x-1]范围内判断。（后面的元素肯定也能遍历到前面的元素）</p>
<p>②对于窗口内的元素，采用有序的排列数据结构set，因为逐个遍历的话就没有改进，用二分查找就快些；窗口内要找到[x-t, x+t]内的元素，所以先找到第一个≥x-t的元素，再判断是否≤x+t 即可。若没有符合的，就继续往下滑动窗口。</p>
<p>如果窗口内有重复的数字，由于在窗口内已经符合k的条件，那么绝对值为最小值0肯定符合要求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = rec.<span class="built_in">lower_bound</span>(<span class="built_in">max</span>(nums[i], INT_MIN + t) - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != rec.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= <span class="built_in">min</span>(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                rec.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="JZ41-数据流中的中位数"><a href="#JZ41-数据流中的中位数" class="headerlink" title="JZ41 数据流中的中位数"></a>JZ41 数据流中的中位数</h2><p>很明确用直接排序来找到中间的数，根据数组奇数或偶数长度来决定。时间复杂度根据内置sort函数，每插入一个数字都进行排序。</p>
<ul>
<li>如何根据排序目标和数组特点，结合各种排序方法的特点，来进行多个维度的思考呢？</li>
</ul>
<p>快排：有点分治的思想，不稳定排序，确保选中的数左右两边各大于小于那个数；</p>
<p>堆：注重最大值最小值，而中位数的左边和右边各是小顶堆和大顶堆……</p>
<h2 id="JZ45-把数组排成最小的数"><a href="#JZ45-把数组排成最小的数" class="headerlink" title="JZ45 把数组排成最小的数"></a>JZ45 把数组排成最小的数</h2><p>重点是排序规则。字符串比较大小……</p>
<h2 id="JZ51-数组中的逆序对【分治】"><a href="#JZ51-数组中的逆序对【分治】" class="headerlink" title="JZ51 数组中的逆序对【分治】"></a>JZ51 数组中的逆序对【分治】</h2><p>刚开始想的是排序求位移差……忽略了补在数字前面的也可能利用了本来比它大的空缺，比如7312，排序1237，3往后只移动一位，因为本来7在3前面占了一个空位。</p>
<p>接着想，一个数要知道它的所有逆序对，首先可以暴力遍历。进一步优化来想，每遍历一个可以来利用的信息是大概知道这个数的位置（<u>7</u>314=&gt;<u>3</u>14<u>7</u>=&gt;14<u>3</u>7一种趋于有序的情况）。但是即使趋于有序（非完全有序），比如4还是不能很好利用有序情况，还是要逐一遍历。那么怎么做到完全有序呢？思考分治。【待思考……】</p>
<p>如果两个区间为[4, 3] 和[1, 2]，那么逆序数为(4,1),(4,2),(3,1),(3,2)，同样的如果区间变为有序，比如[3,4] 和 [1,2]的结果是一样的，也就是说区间有序和无序结果是一样的。<br>但是如果区间有序会有什么好处吗？当然，如果区间有序，比如[3,4] 和 [1,2]，如果3 &gt; 1, 显然3后面的所有数都是大于1， 这里为 4 &gt; 1, 明白其中的奥秘了吧。所以我们可以在合并的时候利用这个规则。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20211207/78416044_1638883228849/D2B5CA33BD970F64A6301FA75AE2EB22" alt="alt"></p>
<h2 id="2517-【二分查找】礼盒的最大甜蜜度"><a href="#2517-【二分查找】礼盒的最大甜蜜度" class="headerlink" title="2517.【二分查找】礼盒的最大甜蜜度"></a>2517.【二分查找】礼盒的最大甜蜜度</h2><p>刚开始只能想到穷举法。k种组合，然后是两两绝对值差……感觉穷举复杂度直线飙升。但是除了穷举法，这个也没啥规律可言，咋办呢？</p>
<p>【题解】二分查找+贪心。思路有点和常规穷举相反，先确定好大概的甜度值，再看看有没有k种组合的可能。</p>
<p>先把price排序，然后最大甜度值就是左右两边的差值，（逐渐缩小甜度值的范围×错误，二分查找应该遵循从中值开始左右波动），只要【找到第一个符合条件的甜度值】，就是目标甜度值了。前提是题目只要求甜度值，不用列举情况……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumTastiness</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = price.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">int</span> left = price[<span class="number">0</span>], right = price[len - <span class="number">1</span>] - price[<span class="number">0</span>]; <span class="comment">// 这里的left right的含义是甜蜜度（价格差）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;  <span class="comment">// +1?</span></span><br><span class="line">            <span class="comment">// 当前预估甜蜜度 是否有k种组合满足</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(price, k, mid))</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; price, <span class="keyword">int</span> k, <span class="keyword">int</span> tastiness)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = INT_MIN &gt;&gt; <span class="number">1</span>;    <span class="comment">// 为确保数组第一个元素作为prev，整一个很小的值也不至于溢出</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p : price)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p - prev &gt;= tastiness)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                prev = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt;= k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>时间复杂度：O(nlogn + nlogC)，前者是数组price的排序时间，后者是二分查找次数，每次查找的时间是n。</li>
<li>空间复杂度：O(logn)，排序的空间复杂度。</li>
</ul>
</blockquote>
<p>总之又是很奇妙的一题，当有多种可能性的时候，可以选可能性最小的某个切入点，然后二分查找遍历？</p>
<h2 id="【堆】OfferⅡ061-和最小的k个数对"><a href="#【堆】OfferⅡ061-和最小的k个数对" class="headerlink" title="【堆】OfferⅡ061.和最小的k个数对"></a>【堆】OfferⅡ061.和最小的k个数对</h2><p>有意识到k个最小和组合，必定是两个有序数组的最前面部分的组合，但是不知道怎么枚举比较快。</p>
<p>以下解法有图示更加清晰容易理解。</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/qn8gGX/solution/by-licold-ytad/">【时光】图解+详细推导，小顶堆 - 和最小的 k 个数对 - 力扣（LeetCode）</a></p>
<ul>
<li>题解：重构解空间+哈希表</li>
</ul>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230709224955451.png" alt="image-20230709224955451"></p>
<blockquote>
<p>罗列了 按升序排序后的两个数组，各自的索引对应的元素相加之和的必然关系。比如[1,1]的和必然大于[0,1]或[1,0]的和。</p>
<p>所以需要从左往后遍历枚举的可能，直到满足k个为止。</p>
<p>不过不是按照一层层遍历，而是取当前最小和的[i,j]，将[i+1,j]或[i,j+1]插入优先队列，继续排序。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// pair 的比较函数</span></span><br><span class="line">    <span class="keyword">auto</span> greaterthan = </span><br><span class="line">        [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)-&gt;<span class="keyword">bool</span></span><br><span class="line">        &#123; <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second]; &#125;;</span><br><span class="line">    <span class="comment">// pair 的hash函数</span></span><br><span class="line">    <span class="keyword">auto</span> hash = [](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a)-&gt;<span class="keyword">size_t</span> &#123; <span class="keyword">return</span> a.first*<span class="number">31</span> + a.second; &#125;;</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(greaterthan)&gt; <span class="built_in">que</span>(greaterthan);</span><br><span class="line">    <span class="keyword">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// set 防止重复放入节点</span></span><br><span class="line">    unordered_set&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="keyword">decltype</span>(hash)&gt; <span class="built_in">st</span>(<span class="number">8</span>, hash);</span><br><span class="line">    que.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>); </span><br><span class="line">    st.<span class="built_in">emplace</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (k -- &amp;&amp; !que.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [i, j] = que.<span class="built_in">top</span>();</span><br><span class="line">        que.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 最小和放入结果中，并移出优先队列</span></span><br><span class="line">        res.<span class="built_in">emplace_back</span>(initializer_list&lt;<span class="keyword">int</span>&gt;&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">        <span class="comment">// 1. 放入后继节点[i,j+1]</span></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">count</span>(&#123;i, j+<span class="number">1</span>&#125;) &amp;&amp; j+<span class="number">1</span>&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">            st.<span class="built_in">emplace</span>(i, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 放入后继节点[i+1,j]</span></span><br><span class="line">        <span class="keyword">if</span> (!st.<span class="built_in">count</span>(&#123;i+<span class="number">1</span>, j&#125;) &amp;&amp; i+<span class="number">1</span>&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            que.<span class="built_in">emplace</span>(i+<span class="number">1</span>, j);</span><br><span class="line">            st.<span class="built_in">emplace</span>(i+<span class="number">1</span>, j);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先理解基本的，优化方法再看链接。</li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="JZ46-把数字翻译成字符串"><a href="#JZ46-把数字翻译成字符串" class="headerlink" title="JZ46 把数字翻译成字符串"></a>JZ46 把数字翻译成字符串</h2><p>首先思考子问题的对象是谁，然后子问题之间的相互关系是什么。</p>
<p>每增加一个字符，要么算它自己一个(如2=&gt;b)，要么和前面一位组成一个（如26=&gt;z)。</p>
<p>这个和爬楼梯就挺像的，</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230401145219925.png" alt="image-20230401145219925"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(string nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] codesNum=<span class="keyword">new</span> <span class="keyword">int</span>[nums.Length]; <span class="comment">//状态数组，记录f(x)</span></span><br><span class="line">        <span class="comment">//初始条件：</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>].ToString() != <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">            codesNum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从数组第2位枚举到最后一位：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.Length;++i)&#123;</span><br><span class="line">            <span class="comment">//判断nums[i]是否不为0</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i].ToString() != <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">                codesNum[i]+=codesNum[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断nums[i-1]与nums[i]的数字组合是否在[10,26]内</span></span><br><span class="line">            <span class="keyword">int</span> temp=<span class="keyword">int</span>.Parse(nums[i-<span class="number">1</span>].ToString() + nums[i].ToString());</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= <span class="number">10</span> &amp;&amp; temp &lt;= <span class="number">26</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>)&#123; <span class="comment">//即f(2)，因为不存在f(0)，所以需要特殊处理：</span></span><br><span class="line">                    codesNum[i]+=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    codesNum[i]+=codesNum[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> codesNum[nums.Length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JZ47-礼物的最大价值"><a href="#JZ47-礼物的最大价值" class="headerlink" title="JZ47 礼物的最大价值"></a>JZ47 礼物的最大价值</h2><p>最开始想的是回溯算法。遍历所有可能的结果然后记录最大值……结果超时了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i_max, j_max, res, max;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 条件判断</span></span><br><span class="line">    <span class="keyword">if</span> ((i &lt; <span class="number">0</span> || i &gt;= i_max) || (j &lt; <span class="number">0</span> || j &gt;= j_max)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag[i][j]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算当前值</span></span><br><span class="line">    res += grid[i][j];</span><br><span class="line">    flag[i][j] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一个计算 或 递归</span></span><br><span class="line">    <span class="keyword">if</span> (i == i_max<span class="number">-1</span> &amp;&amp; j == j_max<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res &gt; max) &#123;</span><br><span class="line">            max = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(i, j+<span class="number">1</span>, grid, flag);</span><br><span class="line">        <span class="built_in">dfs</span>(i+<span class="number">1</span>, j, grid, flag);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回溯</span></span><br><span class="line">    res -= grid[i][j];</span><br><span class="line">    flag[i][j] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i_max = grid.<span class="built_in">size</span>();</span><br><span class="line">    j_max = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    res = <span class="number">0</span>; max = <span class="number">0</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">flag</span>(i_max, vector&lt;<span class="keyword">bool</span>&gt;(j_max, <span class="literal">false</span>));</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, grid, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>看到提示说可以用动态规划。为什么能用动态规划呢？又要怎么思考公式呢？？</p>
<p>回溯是每个元素都要往右往下进行”试探“，都可能进行n次（？遍历？n的n次方？</p>
<p>由于只能往下或往右走，所以就某个当前元素来说，要到达这个元素，只能从左边来或者从上面来。那么两个方向来的谁最大谁的值就保留相加，存储在当前位置。</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230401212846966.png" alt="image-20230401212846966"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i_max = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> j_max = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(i_max, vector&lt;<span class="keyword">int</span>&gt;(j_max, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; i_max; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; j_max; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个遍历元素，存储最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; i_max; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; j_max; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i_max<span class="number">-1</span>][j_max<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优化的空间是，可以把结果直接存储在grid里面，元素遍历过就没用了。呜呜是为数不多想得明白的动态规划。</p>
</blockquote>
<h2 id="1043-分隔数组以得到最大和"><a href="#1043-分隔数组以得到最大和" class="headerlink" title="1043.分隔数组以得到最大和"></a>1043.分隔数组以得到最大和</h2><p>开始还是靠正常推敲，想到要尽可能将大数旁边的小数同化，大数不连累更大的数等等，得到基础的思路如下：</p>
<ul>
<li>排序依次遍历较大数</li>
<li>找到那个数对应的范围</li>
<li>更改数值，记录遍历过的数字，重复第二步</li>
</ul>
<p>难在第二步找范围。以那个数为中心，可能有1~k个数，而且起始点和终点也不好确定。总之是要遍历好多遍的样子……想想就不想写。</p>
<p>【题解】动态规划。还是难以突破思维的惯性，总是习惯找最大数，然后往它左右边找。 </p>
<p>【dp[i]的含义：以i为结尾的所有可能性之中的，整个数组的最大值】</p>
<p>假设已有数组A，每增添一个i，增加的可能性是什么呢？</p>
<p>对于i来说，由于它是数组的结尾，所以包含它的子数组要往前找。它可能自己成为一个数组；或者i、A[i-1]成为一个子数组；或者i、A[i-1]、A[i-2]；直到i 、……A[i-k]。</p>
<p>成为同一个数组的元素，要全部换成最大元素。那么由上可得，数组的总和的可能性有：</p>
<ul>
<li>i+A的总和；</li>
<li>max(i, A[i-1]) * 2 + A[i-2]…的总和；</li>
<li>max(i, A[i-1], A[i-2]) * 3 + A[i-3]…的总和等等，以此类推。</li>
</ul>
<p>所以i和前面的哪些元素一组，就自成一个独立的子数组，再前面的也是独立的子数组……</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230419223227216.png" alt="image-20230419223227216"></p>
<blockquote>
<p>遍历了1，15，7，9后易得每一个最大值都是和15一组。遍历到2的时候，2组队情况有多种，2和9组队时，前面就是以7为结尾的子数组，以7为结尾的子数组中最大值是1，15，7。</p>
</blockquote>
<p>总结：在[i-k, i]范围中，计算多种可能的结果，然后取最大值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历到的当前元素</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = arr[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和元素组队的范围逐渐扩大，并计算每一种可能的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; j &gt;= i - k; j--) &#123;</span><br><span class="line">            <span class="comment">// d[i]是单独组队，右边是和其它元素组队</span></span><br><span class="line">            d[i] = <span class="built_in">max</span>(d[i], d[j] + maxValue * (i - j));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 范围扩大，更新范围内最大值</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue, arr[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/MPnaiL/solution/by-flix-0h27/">『 一招吃遍七道 』滑动窗口的应用 - 字符串中的变位词 - 力扣（LeetCode）</a></p>
<h2 id="JZ48-最长不含重复字符的子字符串"><a href="#JZ48-最长不含重复字符的子字符串" class="headerlink" title="JZ48 最长不含重复字符的子字符串"></a>JZ48 最长不含重复字符的子字符串</h2><p> 逐个遍历，如果在哈希表里面没有记录，那么就继续遍历记录加一，否则清空记录，从被重复的后一位继续开始。（单指针：只需要维护一个指针；原来的想法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 没有重复</span></span><br><span class="line">        <span class="keyword">if</span> (hash.<span class="built_in">find</span>(s[i]) == hash.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max) &#123;</span><br><span class="line">                max = len;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s[i]] = i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始重复</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        i = hash[s[i]];</span><br><span class="line">        hash.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化的空间：从上图可见，第二次遇到a的时候又从b开始，灰色的部分又重复遍历了一次。为了避免重复遍历，这里可用滑动窗口；保留记录过的部分。</p>
<p>如下图所示，第二次遇到a的时候，窗口左边边界向右滑动一个，确保窗口内没有重复值后，右边界继续滑动……（双指针：维护两个指针，右指针肯定向右，左指针根据右指针是否遍历重复值来进行递增）</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402105626689.png" alt="image-20230402105626689"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.<span class="built_in">length</span>(); right++) &#123;</span><br><span class="line">        hash[s[right]]++;</span><br><span class="line">        <span class="comment">// 有重复，去掉左边的记录，左边界右移</span></span><br><span class="line">        <span class="keyword">while</span> (hash[s[right]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            hash[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JZ74-和为S的连续序列"><a href="#JZ74-和为S的连续序列" class="headerlink" title="JZ74 和为S的连续序列"></a>JZ74 和为S的连续序列</h2><p>想到滑动窗口。处理左/右指针（加/减）-判断-移动指针 步骤要区分清楚。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>; r &lt;= sum;) &#123;</span><br><span class="line">    total += r;</span><br><span class="line">    <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &lt; sum) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>()+l);</span><br><span class="line">        total -= l;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; r &lt;= sum;) &#123;</span><br><span class="line">    <span class="comment">// 右指针移动</span></span><br><span class="line">    <span class="keyword">if</span> (total &lt;= sum) &#123;</span><br><span class="line">        r++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        total += r;</span><br><span class="line">        <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r)&#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左指针移动</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>()+l);</span><br><span class="line">        total -= l;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; r &lt;= sum;) &#123;</span><br><span class="line">    <span class="comment">// 计算当前情况，再进行下一步操作</span></span><br><span class="line">    total += curr;</span><br><span class="line">    <span class="keyword">if</span> (total == sum &amp;&amp; l &lt; r) &#123;</span><br><span class="line">        ret.<span class="built_in">push_back</span>(res);</span><br><span class="line">        curr = ++r;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &lt; sum) &#123;</span><br><span class="line">        curr = ++r;</span><br><span class="line">        res.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (total &gt; sum) &#123;</span><br><span class="line">        <span class="comment">// 删除左值</span></span><br><span class="line">        res.<span class="built_in">erase</span>(res.<span class="built_in">begin</span>());</span><br><span class="line">        curr = -(l++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="OfferⅡ014-字符串中的变位词【固定滑动窗口】"><a href="#OfferⅡ014-字符串中的变位词【固定滑动窗口】" class="headerlink" title="OfferⅡ014.字符串中的变位词【固定滑动窗口】"></a>OfferⅡ014.字符串中的变位词【固定滑动窗口】</h2><blockquote>
<p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的某个变位词。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的 <strong>子串</strong> 。</p>
</blockquote>
<p>刚开始有点懵，排列是什么？想到多种可能性又脑袋疼了。从所需结果来看，只需要判断是否包含。那么换个思路，就是长度为n1的子串，有与s1相同多的字母就符合条件了。</p>
<ul>
<li>s2的子串必须是连续的且长度为n1。</li>
<li>出现的字母数量和s1相同。</li>
</ul>
<p>【遍历法-滑动窗口】之前觉得滑动窗口是根据目标值伸缩边界，这里是固定长度，所以没有左缩右扩的条件。遍历时更新记录字母出现次数的数组，然后比较。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = s1.<span class="built_in">length</span>(), len2 = s2.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">if</span> (len1 &gt; len2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt1</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt2</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt1[s1[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnt2[s2[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt1 == cnt2) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 原来是有==重载的…</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len1; i &lt; len2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt2[s2[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        cnt2[s2[i-len1]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (cnt1 == cnt2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【滑动窗口优化】注意到每次窗口滑动时，只统计了一进一出两个字符，却比较了整个 <em>cnt1</em> 和 <em>cnt2</em> 数组。</p>
<p>然后想到差值，数组1和数组2是否相等，换句话来说就是数组1和数组2每个元素的差是否为0.那先计算数组2-数组1的差值用cnt记录，如果cnt[i]为正数，说明数组2多了，否则差了，每遍历一次都要检查是否全为0（而且26个字母也有s1不存在的字母，无法比较）。这样的话也只是比方法一少遍历了一次数组。如果用一个变量记录字母数量不同的个数呢？</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230504161211284.png" alt="image-20230504161211284"></p>
<p>仔细想明白觉得滑动窗口真的很奥妙，要灵活运用还得多体悟思考。此题中窗口大小固定，因为要比较的s1长度固定，需要求s2子串的字母个数和s1分别相等。第一次把两个数组都一起遍历一次，得知s2和s1还差多少字母个数不同的。然后利用滑动窗口，一进一出遍历，减少重复遍历，比如一进，如果进了之后反而增加了差值，那么diff++；反之进了之后减少差值恰好为0，那么diff–。一出同理。</p>
<p>可能考虑到s2有s1不存在的字母怎么办，也会算进diff里面。这就是连续窗口的奥妙了，如果要确保连续子串，那么存在的话必有diff=0的情况。由于窗口会“吞吐”，即使吃到不存在的字母diff++, 在找到合适之前会一直往前滚动遍历，直到吐出不存在的字母diff–。</p>
<h2 id="OfferⅡ017-含有所有字符的最短字符串【变长滑动窗口】"><a href="#OfferⅡ017-含有所有字符的最短字符串【变长滑动窗口】" class="headerlink" title="OfferⅡ017.含有所有字符的最短字符串【变长滑动窗口】"></a>OfferⅡ017.含有所有字符的最短字符串【变长滑动窗口】</h2><p>这次t对于s来说不是连续，而是“含有”，求最短长度。那必然是滑动窗口了，首先返回的结果子串是连续的，其次有明确的边界要求（含有t的所有字母及个数）。先右扩找到符合条件的，再左缩缩小范围看有没有更短的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p: ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右扩：找到含t的所有字母个数为止 需要知道含什么字母，以及对应个数</span></span><br><span class="line">    <span class="comment">// 左缩：原基础再缩小看看能否再短</span></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 记录t的字母及对应个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = INT_MAX, ansL = <span class="number">-1</span>, ansR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; <span class="built_in"><span class="keyword">int</span></span>(s.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="comment">// 记录有效（t含有的）字母[!!]</span></span><br><span class="line">            <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[++r]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++cnt[s[r]];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否已经符合t 符合t则判断长度、回缩</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">check</span>() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[l]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ansL == <span class="number">-1</span> ? <span class="built_in">string</span>() : s.<span class="built_in">substr</span>(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h1 id="基础数学"><a href="#基础数学" class="headerlink" title="基础数学"></a>基础数学</h1><h2 id="JZ65-不用加减乘除做加法【位运算】"><a href="#JZ65-不用加减乘除做加法【位运算】" class="headerlink" title="JZ65 不用加减乘除做加法【位运算】"></a>JZ65 不用加减乘除做加法【位运算】</h2><p>a+b，结果由进位和非进位相加而成，前提是二进制。因为二进制运算可以方便直接获得进制位，只有1和1才有进位，也就是1&amp;1=1，其余都没有进位，即为0。如果是十进制的话，求进位还要减去10……感觉是做复杂了。关于二进制的运算特点和应用还有待深究。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> add = num2;</span><br><span class="line">    <span class="keyword">int</span> sum = num1;</span><br><span class="line">    <span class="comment">// 每一轮只计算 a 和 b 的进位和非进位！不要弄混了</span></span><br><span class="line">    <span class="comment">// 【反例】sum = sum ^ add; add = (sum &amp; add) &lt;&lt; 1; 后者sum改变了，逻辑容易混乱</span></span><br><span class="line">    <span class="keyword">while</span> (add != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非进位</span></span><br><span class="line">        <span class="keyword">int</span> temp = sum ^ add;</span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">        add = (sum &amp; add) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//更新新的和</span></span><br><span class="line">        sum = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="剑指offerⅡ-001-整数除法【快速乘】"><a href="#剑指offerⅡ-001-整数除法【快速乘】" class="headerlink" title="剑指offerⅡ 001.整数除法【快速乘】"></a>剑指offerⅡ 001.整数除法【快速乘】</h2><p>思来想去，还是想到最朴素的 被除数暴力相加，为了方便相加，把ab做同号处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// ab同号，b不变；ab异号，b变号</span></span><br><span class="line">    <span class="keyword">if</span> ((a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) || (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">        flag = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(sum) &lt;= <span class="built_in">abs</span>(a))</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        sum += b;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) || sum &gt;= <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> count * flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>被除数越小，除数越大，时间也越多，改了一些细节后，还是超时了……</p>
</blockquote>
<p>【题解】</p>
<p>题目要求只能使用加减法，那我们自然想到用减法实现除法，用“被减数”能减去几次“减数”来衡量最后的结果，这时候我们想到求x的幂次的快速解法，将x成倍成倍的求幂，这里【将减数成倍成倍的增大，次数对应也是成倍成倍的增大】，例如：取a=23，b=2，b的变化如下:2-&gt;4-&gt;8-&gt;16,次数count的变化如下1-&gt;2-&gt;4-&gt;8,最后a-b=23-16=7，对7再执行一次上述过程，b:2-&gt;4,count:1-&gt;2,a-b=3, 然后对3再执行一次，b:2,count:1,a-b=1，1已经小于原b=2，可以结束了，最后计数一下每轮的count是多少8+2+1=11，就是我们要的答案啦！</p>
<blockquote>
<p>也想过成倍求，但是一想到可能超过很多，就没再继续考虑了……要在范围内进行快速倍求。</p>
</blockquote>
<ul>
<li>为方便运算，我们需要将a，b都转为同正or同负，由于INT_MIN<code>[−2的31次方, 2的31次方−1]</code>转正就越界了，我们只好都转负，这也是都转负的原因；</li>
<li>有一种特殊情况 INT_MIN/(-1)就overflow了 所以直接特殊处理</li>
<li>最终结果的正负</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//利用减法实现除法 均已保证传入的a，b是负数  </span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(a&lt;=b)&#123;<span class="comment">//a的绝对值大</span></span><br><span class="line">           <span class="keyword">int</span> temp=b;</span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> count=<span class="number">1</span>;<span class="comment">//a的绝对值大于b的 那么肯定a能减一次b</span></span><br><span class="line">           <span class="keyword">while</span>(temp&gt;=<span class="number">0xc0000000</span>&amp;&amp;a&lt;=temp+temp)&#123;<span class="comment">//减数不越界方便控制后一个条件：且a的绝对值比两倍的减数还大</span></span><br><span class="line">           		count+=count;<span class="comment">//可以减的次数翻倍</span></span><br><span class="line">           		temp+=temp;<span class="comment">//减数也翻倍</span></span><br><span class="line">           &#125;</span><br><span class="line">           res+=count;</span><br><span class="line">           a-=temp;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> positive=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positive=!positive;</span><br><span class="line">            a = -a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            positive=!positive;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> res = <span class="built_in">div</span>(a, b);</span><br><span class="line">        <span class="keyword">return</span> positive? res : -res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>越界这个实在是太恶心人了……a,b都有可能达到边界，或者两者的结果。count是必须要unsigned的，因为有可能达到2的31次方……</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == INT_MIN &amp;&amp; b == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> positive = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = -a;</span><br><span class="line">        positive = !positive;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">        positive = !positive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 快速求倍数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// a,b都是负数</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">abs</span>(a) &gt;= <span class="built_in">abs</span>(b)) <span class="comment">// 或者a &lt;= b</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//a的绝对值大于b的 那么肯定a能减一次b</span></span><br><span class="line">        <span class="keyword">int</span> bs = b; </span><br><span class="line">        <span class="keyword">while</span> (bs &gt;= -<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) &amp;&amp; <span class="number">2</span> * bs &gt;= a)</span><br><span class="line">        &#123;</span><br><span class="line">            bs *= <span class="number">2</span>;    <span class="comment">// b的倍数翻倍</span></span><br><span class="line">            count *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a -= bs;</span><br><span class="line">        res += count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a,b异号，结果为负</span></span><br><span class="line">    <span class="keyword">return</span> positive ? res : -res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自己模仿写了一下，为什么老是没过**-2147483648/1**啊呜呜呜。找到了，是<code>while (abs(a) &gt;= abs(b))</code>这个判断出了问题。原来是因为-2147483648一取绝对值又改成正数了，就溢出了……</p>
</blockquote>
<p>【题解2】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑被除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MIN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况</span></span><br><span class="line">        <span class="keyword">if</span> (b == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">return</span> a == INT_MIN ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一般情况，使用二分查找</span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况</span></span><br><span class="line">        <span class="keyword">bool</span> rev = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            a = -a;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            b = -b;</span><br><span class="line">            rev = !rev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快速乘</span></span><br><span class="line">        <span class="comment">// x：被除数</span></span><br><span class="line">        <span class="comment">// y：除数</span></span><br><span class="line">        <span class="comment">// z：x/y</span></span><br><span class="line">        <span class="keyword">auto</span> quickAdd = [](<span class="keyword">int</span> y, <span class="keyword">int</span> z, <span class="keyword">int</span> x) &#123;</span><br><span class="line">            <span class="comment">// x 和 y 是负数，z 是正数</span></span><br><span class="line">            <span class="comment">// 需要判断 z * y &gt;= x 是否成立</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>, add = y;</span><br><span class="line">            <span class="keyword">while</span> (z) &#123;</span><br><span class="line">                <span class="keyword">if</span> (z &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 result + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (result &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (z != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 需要保证 add + add &gt;= x</span></span><br><span class="line">                    <span class="keyword">if</span> (add &lt; x - add) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    add += add;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不能使用除法</span></span><br><span class="line">                z &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = INT_MAX, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="comment">// 注意溢出，并且不能使用除法</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">bool</span> check = <span class="built_in">quickAdd</span>(b, mid, a);</span><br><span class="line">            <span class="keyword">if</span> (check) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                <span class="comment">// 注意溢出</span></span><br><span class="line">                <span class="keyword">if</span> (mid == INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个感觉好难懂……</p>
</blockquote>
<h2 id="JZ64-求1-2-3-…-n【短路运算】"><a href="#JZ64-求1-2-3-…-n【短路运算】" class="headerlink" title="JZ64 求1+2+3+…+n【短路运算】"></a>JZ64 求1+2+3+…+n【短路运算】</h2><p>要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。想到的是递归，<code>n += Sum_Solution(n-1);</code>每次都和<code>1~n-1的和</code>相加。但是递归条件也要判断，那该怎么办呢？或者是有限次计算就能算出？不懂。</p>
<p>【题解】利用短路运算结束递归。<a target="_blank" rel="noopener" href="https://blog.csdn.net/bulebin/article/details/79345875">(49条消息) &amp;&amp; || 与或 逻辑运算符的短路运算_&amp;&amp;的运算规则_bulebin的博客-CSDN博客</a></p>
<p>短路运算：当有多个表达式（值）时，左边的表达式值可以确定结果时，就不再继续运算右边的表达式的值。</p>
<ul>
<li>表达式1 <strong>&amp;&amp;</strong> 表达式2 &amp;&amp; 表达式3…<br>①如果表达式1的值为真，则继续往后执行<br>②如果表达式1的值为假，则返回表达式1</li>
<li>表达式1 <strong>||</strong> 表达式2 || 表达式3…<br>①如果表达式1的值为真，则返回表达式1<br>②如果表达式1的值为假，则继续往后执行</li>
</ul>
<p>所以如果n==0的时候（也就是为false），刚好返回0。果然很妙啊~~</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 前者返回一个确定值（为false的时候，即为0）</span></span><br><span class="line">    <span class="comment">// 后者继续递归</span></span><br><span class="line">    n &amp;&amp; (n += <span class="built_in">Sum_Solution</span>(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JZ49-丑数"><a href="#JZ49-丑数" class="headerlink" title="JZ49 丑数"></a>JZ49 丑数</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b?tpId=265&tqId=39247&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=/exam/oj/ta?tpId=13&difficulty=3&judgeStatus=undefined&tags=&title=">丑数_牛客题霸_牛客网 (nowcoder.com)</a></p>
<p>根据丑数概念可知，</p>
<ul>
<li>丑数：只包含2/3/5质数；</li>
<li>非丑数：不含2/3/5；含2/3/5，但还有其他质数。</li>
</ul>
<p>如果求有没有包含2/3/5，那么就要考虑三种情况，变得很复杂。既然题目求的是第n个丑数，而不是判断是不是丑数，就没必要一一遍历，而是直接构建丑数。</p>
<p>那么哪些是丑数呢，基础的是1/2/3/5，然后由小到大相乘（如果a*b两者都没有其他素数，那么结果肯定也没有其他素数）。那么按照怎么样的顺序相乘呢，可见按照右边这样乘不一定按照从小到大的顺序。</p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402154507020.png" alt="image-20230402154507020"></p>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230402154832984.png" alt="image-20230402154832984"></p>
<p>然后想到既然是每位数字都要乘2/3/5，那么只要取出最小的结果先入数组，就能依次排序了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">0</span>, i3 = <span class="number">0</span>, i5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> next2 = <span class="number">0</span>, next3 = <span class="number">0</span>, next5 = <span class="number">0</span>;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其中一个指针到达index-1</span></span><br><span class="line">    <span class="keyword">while</span> (res.<span class="built_in">size</span>() != index) &#123;</span><br><span class="line">        next2 = res[i2] * <span class="number">2</span>;</span><br><span class="line">        next3 = res[i3] * <span class="number">3</span>;</span><br><span class="line">        next5 = res[i5] * <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">min</span>(next2, <span class="built_in">min</span>(next3, next5));</span><br><span class="line">        <span class="comment">// 确保不重复</span></span><br><span class="line">        <span class="keyword">if</span> (*(res.<span class="built_in">end</span>()<span class="number">-1</span>) != num) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == next2) &#123;</span><br><span class="line">            i2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == next3) &#123;</span><br><span class="line">            i3++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == next5) &#123;</span><br><span class="line">            i5++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[index<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JZ62-圆圈中最后剩下的数"><a href="#JZ62-圆圈中最后剩下的数" class="headerlink" title="JZ62 圆圈中最后剩下的数"></a>JZ62 圆圈中最后剩下的数</h2><p>开始借用了一个数组来循环遍历。（原来叫模拟法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; array;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        array.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (array.<span class="built_in">size</span>() != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 删去元素的时候，后面的数会前移一位，所以i已经代表了下一个数</span></span><br><span class="line">        <span class="comment">// 而且count也是1个数</span></span><br><span class="line">        <span class="keyword">if</span> (count == m) &#123;</span><br><span class="line">            array.<span class="built_in">erase</span>(array.<span class="built_in">begin</span>()+i);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i = (i+<span class="number">1</span>) % array.<span class="built_in">size</span>();</span><br><span class="line">            count = count+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不借用额外空间的话，那么怎么知道中间删除了哪些？</p>
<p>【题解】找规律/公式递推。这种方法怎么想到的呢……太抽象太神奇了……</p>
<p><strong>令f(n,m)表示最后一个人的下标</strong>。</p>
<p>1.假设有n个人，报数m， 从0 开始报数，易知出圈的人下标为 m-1。</p>
<p>2.m-1 出圈后，我们对剩余人重新编号 即 第m个人下标为0，第m+1 下标为1 ……以此编号。 那么重新编号之后，那么最后一个人的下标为f(n-1,m)</p>
<p>问题1： 在重新编号之后的f(n-1,m) 与 重新编号之前的f(n,m)有什么关系？<br>重新编号之前 m, m+1,m+2,….（剩余人的编号）<br>重新编号之后 0 ，1 ，2，….<br>可知 (新编号+m)%n = 旧编号</p>
<blockquote>
<p>f(n,m)表示的不是下一个将要删除的人，而是最后一个；可能是因为最后一个人必定是会留下来的，所以只有他的编号是时刻变化着的？</p>
</blockquote>
<p>\3. f(n,m) = (f(n-1,m)+m) %n;<br>递归写法复杂度分析：<br>时间复杂度： O(N)<br>空间复杂度： O(N)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//约瑟夫</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">LastRemaining_Solution</span>(n<span class="number">-1</span>,m)+m)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404213229515.png" alt="image-20230404213229515"></p>
<blockquote>
<p>绿色是位置，绿三角形是被删除的位置，黑圈是最后的数。</p>
</blockquote>
<p><img src="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/hexo_github_blog\source_posts\知识整理-数据结构与算法-刷题思考.assets\image-20230404213240076.png" alt="image-20230404213240076"></p>
<blockquote>
<p>分析了才知道，一直描述的都是最后那个留下的时刻变动的位置。最后只剩下那个数时，位置必然为0，此时n=1；每删除一个数，假如更新第m个的位置使之为0，那么其它的数字位置也会变化，都遵循相同的变化规律。总之觉得太抽象了！！</p>
</blockquote>
<h2 id="JZ70-矩阵覆盖"><a href="#JZ70-矩阵覆盖" class="headerlink" title="JZ70 矩阵覆盖"></a>JZ70 矩阵覆盖</h2><p>刚开始觉得要硬刚……算图形是什么的，然后想得好复杂，放弃。没想到……竟然是数学归纳法……emmm。</p>
<blockquote>
<p>由规律发现，2∗<em>n</em>的矩形的情况数为*f(n)=f(n−1)+f(n−2)*，即这就是一个斐波那契数列，按照斐波那契数列的解法来即可，需要注意不同点在于n小于等于2时，都只有n种。</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/e82f983fly1hdas2vy0ncj20u00gvae1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/"><img class="prev-cover" src="/img/e82f983fly1hdarthbg8rj20u00gvjvd.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++ 基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统（二）：进程管理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(●ˇ∀ˇ●)</div><div class="author-info__description">someone very lazy</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huangxinhere"><i class="fab fa-github"></i><span>Don't Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ57-%E5%92%8C%E4%B8%BAS%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97%E3%80%90%E5%93%88%E5%B8%8C%E3%80%91%E3%80%90%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%91"><span class="toc-number">1.1.</span> <span class="toc-text">JZ57 和为S的两个数字【哈希】【双指针】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%91%E3%80%90%E5%8F%8D%E8%BD%AC%E3%80%91"><span class="toc-number">1.2.</span> <span class="toc-text">JZ58 左旋转字符串【字符串】【反转】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1007-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%92%8C%E4%B8%BA0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">OfferⅡ007.数组中和为0的三个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1008-%E5%92%8C%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8Etarget%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">OfferⅡ008. 和大于等于target的最短子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1009-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91"><span class="toc-number">1.5.</span> <span class="toc-text">OfferⅡ009.乘积小于k的子数组【动态规划】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1010-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">OfferⅡ010.和为k的子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1011-0%E5%92%8C1%E4%B8%AA%E6%95%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.7.</span> <span class="toc-text">OfferⅡ011.0和1个数相同的子数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1013-%E4%BA%8C%E7%BB%B4%E5%AD%90%E7%9F%A9%E9%98%B5%E7%9A%84%E5%92%8C"><span class="toc-number">1.8.</span> <span class="toc-text">OfferⅡ013.二维子矩阵的和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0-atoi"><span class="toc-number">2.1.</span> <span class="toc-text">JZ67 把字符串换成整数(atoi)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ75-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">JZ75 字符串中第一个不重复的字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1002-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8A%A0%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">OfferⅡ002. 二进制加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1005-%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E3%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91"><span class="toc-number">2.4.</span> <span class="toc-text">OfferⅡ005. 单词长度的最大乘积【位运算】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1020-%E5%9B%9E%E6%96%87%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">OfferⅡ020.回文子字符串的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1156-%E5%8D%95%E5%AD%97%E7%AC%A6%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-number">2.6.</span> <span class="toc-text">1156. 单字符重复子串的最大长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-035-%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE"><span class="toc-number">2.7.</span> <span class="toc-text">OfferⅡ 035.最小时间差</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-030-%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AFO-1-%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">OfferⅡ 030. 插入、删除和随机访问都是O(1)的容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-031-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">OfferⅡ 031.最近最少使用缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1033-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84"><span class="toc-number">3.3.</span> <span class="toc-text">OfferⅡ033.变位词组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-034-%E5%A4%96%E6%98%9F%E8%AF%AD%E8%A8%80%E6%98%AF%E5%90%A6%E6%8E%92%E5%BA%8F"><span class="toc-number">3.4.</span> <span class="toc-text">OfferⅡ 034.外星语言是否排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">4.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">4.1.</span> <span class="toc-text">JZ56 数组中只出现一次的两个数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1004-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">4.2.</span> <span class="toc-text">OfferⅡ004. 只出现一次的数字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">5.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ76-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">JZ76 删除链表中重复的结点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-022-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">OfferⅡ 022. 链表中环的入口节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-026-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">OfferⅡ 026. 重排链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-027-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-number">5.4.</span> <span class="toc-text">OfferⅡ 027.回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-028-%E5%B1%95%E5%B9%B3%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">5.5.</span> <span class="toc-text">OfferⅡ 028.展平多级双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-029-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">5.6.</span> <span class="toc-text">OfferⅡ 029.排序的循环链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">6.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-037-%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E"><span class="toc-number">6.1.</span> <span class="toc-text">OfferⅡ 037.小行星碰撞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-038-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">6.2.</span> <span class="toc-text">OfferⅡ 038.每日温度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">7.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">7.1.</span> <span class="toc-text">JZ54 二叉搜索树的第k个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ77-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">7.2.</span> <span class="toc-text">JZ77 按之字形顺序打印二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ78-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C"><span class="toc-number">7.3.</span> <span class="toc-text">JZ78 把二叉树打印成多行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ84-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%88%E4%B8%89%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">JZ84 二叉树中和为某一值的路径（三）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ86-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">7.5.</span> <span class="toc-text">JZ86 在二叉树找到两个节点的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1110-%E5%88%A0%E7%82%B9%E6%88%90%E6%9E%97"><span class="toc-number">7.6.</span> <span class="toc-text">1110.删点成林</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-051-%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">7.7.</span> <span class="toc-text">OfferⅡ 051.节点之和最大的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-503-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">7.8.</span> <span class="toc-text">OfferⅡ 503.二叉搜索树的中序后继</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1-057-%E5%80%BC%E5%92%8C%E4%B8%8B%E6%A0%87%E4%B9%8B%E5%B7%AE%E9%83%BD%E5%9C%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E8%8C%83%E5%9B%B4%E5%86%85"><span class="toc-number">7.9.</span> <span class="toc-text">OfferⅡ 057 值和下标之差都在给定的范围内</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">8.1.</span> <span class="toc-text">JZ41 数据流中的中位数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">JZ45 把数组排成最小的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%E3%80%90%E5%88%86%E6%B2%BB%E3%80%91"><span class="toc-number">8.3.</span> <span class="toc-text">JZ51 数组中的逆序对【分治】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2517-%E3%80%90%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E3%80%91%E7%A4%BC%E7%9B%92%E7%9A%84%E6%9C%80%E5%A4%A7%E7%94%9C%E8%9C%9C%E5%BA%A6"><span class="toc-number">8.4.</span> <span class="toc-text">2517.【二分查找】礼盒的最大甜蜜度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E5%A0%86%E3%80%91Offer%E2%85%A1061-%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0%E5%AF%B9"><span class="toc-number">8.5.</span> <span class="toc-text">【堆】OfferⅡ061.和最小的k个数对</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">9.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">9.1.</span> <span class="toc-text">JZ46 把数字翻译成字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">9.2.</span> <span class="toc-text">JZ47 礼物的最大价值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1043-%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84%E4%BB%A5%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">9.3.</span> <span class="toc-text">1043.分隔数组以得到最大和</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">10.</span> <span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.1.</span> <span class="toc-text">JZ48 最长不含重复字符的子字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ74-%E5%92%8C%E4%B8%BAS%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">10.2.</span> <span class="toc-text">JZ74 和为S的连续序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1014-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%98%E4%BD%8D%E8%AF%8D%E3%80%90%E5%9B%BA%E5%AE%9A%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%91"><span class="toc-number">10.3.</span> <span class="toc-text">OfferⅡ014.字符串中的变位词【固定滑动窗口】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offer%E2%85%A1017-%E5%90%AB%E6%9C%89%E6%89%80%E6%9C%89%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%90%E5%8F%98%E9%95%BF%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%91"><span class="toc-number">10.4.</span> <span class="toc-text">OfferⅡ017.含有所有字符的最短字符串【变长滑动窗口】</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6"><span class="toc-number">11.</span> <span class="toc-text">基础数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95%E3%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91"><span class="toc-number">11.1.</span> <span class="toc-text">JZ65 不用加减乘除做加法【位运算】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87offer%E2%85%A1-001-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95%E3%80%90%E5%BF%AB%E9%80%9F%E4%B9%98%E3%80%91"><span class="toc-number">11.2.</span> <span class="toc-text">剑指offerⅡ 001.整数除法【快速乘】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ64-%E6%B1%821-2-3-%E2%80%A6-n%E3%80%90%E7%9F%AD%E8%B7%AF%E8%BF%90%E7%AE%97%E3%80%91"><span class="toc-number">11.3.</span> <span class="toc-text">JZ64 求1+2+3+…+n【短路运算】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ49-%E4%B8%91%E6%95%B0"><span class="toc-number">11.4.</span> <span class="toc-text">JZ49 丑数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0"><span class="toc-number">11.5.</span> <span class="toc-text">JZ62 圆圈中最后剩下的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JZ70-%E7%9F%A9%E9%98%B5%E8%A6%86%E7%9B%96"><span class="toc-number">11.6.</span> <span class="toc-text">JZ70 矩阵覆盖</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By (●ˇ∀ˇ●)</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks to watch my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Unity的游戏框架搭建 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Unity的游戏框架搭建">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity的游戏框架搭建">
<meta property="og:url" content="https://huangxinhere.github.io/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="Unity的游戏框架搭建">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://huangxinhere.github.io/img/frame.png">
<meta property="article:published_time" content="2023-01-05T16:00:00.000Z">
<meta property="article:modified_time" content="2023-02-20T03:59:05.285Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://huangxinhere.github.io/img/frame.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity的游戏框架搭建',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-20 11:59:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_pic_3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/frame.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hx's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Unity的游戏框架搭建</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-05T16:00:00.000Z" title="发表于 2023-01-06 00:00:00">2023-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-20T03:59:05.285Z" title="更新于 2023-02-20 11:59:05">2023-02-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Unity的游戏框架搭建"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><ul>
<li><p>树结构</p>
</li>
<li><p>对象之间的交互（低耦合）和模块化（高内聚）是整个框架搭建系列的终极问题</p>
<ul>
<li><p>对象交互三种方法</p>
<p>方法调用；</p>
<p>委托或者回调；</p>
<p>消息或事件。</p>
</li>
<li><p>模块化也有三种：</p>
<p>单例；</p>
<p>IOC；</p>
<p>分层，如MVC，三层架构，领域驱动分层等。</p>
</li>
</ul>
</li>
<li><p>表现和数据的分离</p>
</li>
<li><p>交互逻辑和表现逻辑</p>
</li>
</ul>
<h1 id="父子对象和跨模块初探"><a href="#父子对象和跨模块初探" class="headerlink" title="父子对象和跨模块初探"></a>父子对象和跨模块初探</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110170952423.png" alt="image-20230110170952423"></p>
<ul>
<li>目前有UI和Game两个模块，通信都是用事件。</li>
<li>Panel的父子对象则用委托通信。</li>
</ul>
<h1 id="表现和数据分离"><a href="#表现和数据分离" class="headerlink" title="表现和数据分离"></a>表现和数据分离</h1><h2 id="Event的抽象"><a href="#Event的抽象" class="headerlink" title="Event的抽象"></a>Event的抽象</h2><p>上面的GameStartEvent和GamePassEvent都是单独写的，但重复性很高，可以通过 泛型＋继承 来提取，继承解决扩展问题，泛型解决实现代码一致、类不一致的问题，是一个重构技巧。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Event</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action mOnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent += onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent -= onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameStartEvent</span> : <span class="title">Event</span>&lt;<span class="title">GameStartEvent</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110172045530.png" alt="image-20230110172045530"></p>
<h2 id="数据分离"><a href="#数据分离" class="headerlink" title="数据分离"></a>数据分离</h2><p>使用GameModel来进行分离。静态变量。</p>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110172522022.png" alt="image-20230110172522022"></p>
<h2 id="属于Game而不是个体的总体逻辑判断"><a href="#属于Game而不是个体的总体逻辑判断" class="headerlink" title="属于Game而不是个体的总体逻辑判断"></a>属于Game而不是个体的总体逻辑判断</h2><ul>
<li>杀掉一个敌人，就通知Game来判断；用事件而不用委托，因为委托要有多个子对象的引用。</li>
</ul>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110173221574.png" alt="image-20230110173221574"></p>
<blockquote>
<p>简化了图示；单个Enemy交给Game来判断敌人总数。</p>
</blockquote>
<h1 id="交互逻辑和表现逻辑"><a href="#交互逻辑和表现逻辑" class="headerlink" title="交互逻辑和表现逻辑"></a>交互逻辑和表现逻辑</h1><p>交互逻辑：玩家操作界面使得数据发生变化；</p>
<p>表现逻辑：数据变化反馈到界面上。</p>
<h2 id="两者都在controller导致臃肿"><a href="#两者都在controller导致臃肿" class="headerlink" title="两者都在controller导致臃肿"></a>两者都在controller导致臃肿</h2><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110173618010.png" alt="image-20230110173618010"></p>
<h2 id="实现两者的分离"><a href="#实现两者的分离" class="headerlink" title="实现两者的分离"></a>实现两者的分离</h2><p>交互的逻辑并不关心数据变化的逻辑，反之亦是，所以要想办法把两者分开处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//伪代码</span><br><span class="line"></span><br><span class="line">Btn.onClick.AddListener(&#123;</span><br><span class="line">    //使数据变化</span><br><span class="line">    Count++;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//数据展示</span><br><span class="line">Text.text = Count.ToString();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据（Count）变化的时候可以自动通知text更新，实现分开处理。</p>
</blockquote>
<ul>
<li>委托调用处理：交互逻辑持有表现逻辑的引用，通知其更新。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//数据类</span><br><span class="line">public static class CounterModel</span><br><span class="line">&#123;</span><br><span class="line">    private static int mCount = 1;</span><br><span class="line">    </span><br><span class="line">    public static Action&lt;int&gt; OnCountChanged;</span><br><span class="line">    </span><br><span class="line">    public static int Count</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; mCount;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            if(value != mCount)</span><br><span class="line">            &#123;</span><br><span class="line">                mCount = value;</span><br><span class="line">                OnCountChanged?.Invoke(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//数据一旦发生变动，通知View执行 OnCountChanged</span><br><span class="line">CounterModel.OnCountChanged += UpdateView;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110175208278.png" alt="image-20230110175208278"></p>
<ul>
<li>对数据类的进一步抽象。假如有很多共享数据比如金币、生命值等，如果每个数据都按照上面这么写就会很麻烦，所以抽象一个BindableProperty类。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BindableProperty</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">IEquatable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T mValue = <span class="literal">default</span>(T);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Action&lt;T&gt; OnValueChanged;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T Value</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; mValue;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">value</span>.Equals(mValue))</span><br><span class="line">            &#123;</span><br><span class="line">                mValue = <span class="keyword">value</span>;</span><br><span class="line">                OnValueChanged?.Invoke(mValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//应用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CounterModel.Count.Value++;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CounterModel类里面本来是一个int类型Count的数据，但相当于扩展了Count的内容（类型）。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据一般是项目的底层，而Model和View也相当于一个底层和上层的关系，所以自底向上的逻辑可以用委托或者事件，自顶向下可以用方法调用。</p>
<h2 id="交互逻辑优化-引入Command"><a href="#交互逻辑优化-引入Command" class="headerlink" title="交互逻辑优化-引入Command"></a>交互逻辑优化-引入Command</h2><ul>
<li>交互逻辑有很多各种执行的逻辑（比如请求服务器、通知等），会导致Controller比较臃肿。</li>
<li>很多Unity框架的交互逻辑都是由Command实现的。</li>
<li>Command模式可以让逻辑的调用和执行在空间和时间上分离。<ul>
<li>空间分离：调用和执行实现地方不一样。</li>
<li>时间分离：执行比调用稍微慢一些。</li>
</ul>
</li>
<li>Command分担Controller的交互逻辑。</li>
<li>struct比class由更好的内存管理效率。</li>
<li>CQRS读写分离。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命令执行逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CounterModel.Count.Value++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AbstractCountCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        CounterModel.Count.Value--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用命令</span></span><br><span class="line"><span class="keyword">new</span> AddCountCommand().Execute();</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110232804574.png" alt="image-20230110232804574"></p>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110233554506.png" alt="image-20230110233554506"></p>
<h2 id="表现层和底层的分离"><a href="#表现层和底层的分离" class="headerlink" title="表现层和底层的分离"></a>表现层和底层的分离</h2><ul>
<li>大致理解表现层就是View相关的，其他就是底层，分离也就是底层的逻辑可以直接应用到其他种View层上。</li>
<li>好处：<ul>
<li>一般交互逻辑和表现层没啥关系，所以如果将负责操作数据的交互逻辑剥离出来，可以提高底层系统代码的复用率。</li>
<li>一个Command可以理解成用户的一个操作，独立出来分类可以清晰地展现所有的功能/操作。</li>
<li>项目前期由于更多的是做数值和玩法上的验证，所以可以弄个粗略的视图，测试好后再换视图模型。</li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>表现层到底层系统层用Command</li>
<li>底层系统到表现层用委托或者事件</li>
<li>表现层是可以替换的————-</li>
</ul>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230109210658137.png" alt="image-20230109210658137"></p>
<h2 id="使用Command"><a href="#使用Command" class="headerlink" title="使用Command"></a>使用Command</h2><ul>
<li><strong>表现层只能往系统层发送Command或数据查询</strong>，并没有可以发送事件这一说，而且事件只能由底层系统层向表现层发送……（待论证。这样的话，如上图所示，开始菜单点击开始，则不能使用event，要用命令了。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> StartGameCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameStartEvent.Trigger();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//目前开始菜单的逻辑大概是：</span></span><br><span class="line">transform.Find(<span class="string">&quot;BtnStart&quot;</span>).GetComponent&lt;Button&gt;().OnClick.AddListener(</span><br><span class="line">    () =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        gameObject.SetActive(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> StartGameCommand().Execute();</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>消灭敌人数量统计的逻辑优化。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来是在Game（表现层）里实现</span></span><br><span class="line">...Class Game...</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnemyKilled</span>(<span class="params"><span class="built_in">int</span> killedCount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(killedCount == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> PassGameCommand().Execute();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将判断逻辑放到命令里面（底层）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> KillEnemyCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GameModel.KillCount.Value++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(killedCount == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> PassGameCommand().Execute();</span><br><span class="line">            <span class="comment">//或直接 GamePassEvent.Trigger();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230110131824399.png" alt="image-20230110131824399"></p>
<blockquote>
<ul>
<li>表现层-&gt;底层 用命令；</li>
<li>底层-&gt;表现层 用事件；</li>
<li>命令可以触发事件。</li>
</ul>
<p>命令和事件的区别？命令本质上是逻辑的执行，被包裹在对象的方法里面，通过对象去随时随地调用；事件是发送信号，通知其他地方执行。那么为什么表现层和底层要分开使用两者呢？？（待思考</p>
</blockquote>
<h1 id="模块化优化"><a href="#模块化优化" class="headerlink" title="模块化优化"></a>模块化优化</h1><p>表现层主要是根据语义来分模块，不做详解；重点是底层的模块。</p>
<h2 id="方式一：单例"><a href="#方式一：单例" class="headerlink" title="方式一：单例"></a>方式一：单例</h2><ul>
<li>静态类的问题：<ul>
<li>没有访问限制</li>
<li>使用static去扩展模块，模块的识别度不高</li>
</ul>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Singleton</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mInstance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> T instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//反射</span></span><br><span class="line">                <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">                <span class="keyword">var</span> ctors = type.GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);</span><br><span class="line">                <span class="keyword">var</span> ctor = Array.Find(ctors, c =&gt; c.GetParameters().Length == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ctor == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Non public constructor not found in: &quot;</span> + type.Name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mInstance = ctor.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> T;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameModel</span> : <span class="title">Singleton</span>&lt;<span class="title">GameModel</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">GameModel</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; KillCount</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对单例的理解是，一个类有一个静态实例，而不是整个类都是静态的……究竟是如何体现出两者优劣呢？待深入理解。</p>
<ul>
<li>实现的单例的问题：单例类没有访问限制</li>
</ul>
<h2 id="方式二：引入IOC容器"><a href="#方式二：引入IOC容器" class="headerlink" title="方式二：引入IOC容器"></a>方式二：引入IOC容器</h2><p>相当于字典一样，键是类型，对应一个相应的实例。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IOCContainer</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Dictionary</span>&lt;<span class="title">Type</span>, <span class="title">object</span>&gt; mInstances</span> = <span class="keyword">new</span> Dictionary&lt;Type, <span class="built_in">object</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInstances.ContainsKey(key))</span><br><span class="line">        &#123;</span><br><span class="line">            mInstances[key] = instance;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            mInstances.Add(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> key = <span class="keyword">typeof</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mInstances.TryGetValue(key, <span class="keyword">out</span> <span class="keyword">var</span> retInstance))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> retInstance <span class="keyword">as</span> T;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* if (mInstances.ContainsKey(key))</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                return mInstances[key] as T;</span></span><br><span class="line"><span class="comment">            &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IOC内部操作</p>
</blockquote>
<ul>
<li>应用</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IOCContainer mContainer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论是增加还是获取都先检查IOC是否为空（类似单例）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureContainer</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mContainer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mContainer.Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureContainer();</span><br><span class="line">        <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类似于一个IOC的单例。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> <span class="comment">//: Singleton&lt;CounterModel&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//private CounterModel()&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span>   <span class="comment">//可以直接对字段初始化？？</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>首先数据类不再是单例，为了起单例作用都给了IOC来托管。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CounterModel mCounterModel;</span><br><span class="line">mCounterModel = Countapp.Get&lt;CounterModel&gt;();        </span><br><span class="line">mCounterModel.Count.OnValueChanged += OnCountChanged;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>所以使用的时候，要从IOC容器获取，增加了访问的限制。</p>
</blockquote>
<h2 id="IOC的工具类Architecture"><a href="#IOC的工具类Architecture" class="headerlink" title="IOC的工具类Architecture"></a>IOC的工具类Architecture</h2><p>不同项目可能有好几个IOCContainer，代码重复率比较高，所以抽象出一个工具类。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>和之前不同的是，这个工具类有自己的静态实例，然后直接持有一个IOCContainer实例，所以获取IOC容器又多了一层单例；</p>
<p>那继承的子类如何根据需求来Init IOC呢？子类通过Register方法间接注册IOC容器。所以可见，虽然IOC容器是直接附属于工具类的单例的字段的，但提供了方法来使子类间接操作容器。写子类的时候只需要关注注册什么就行了，其他逻辑不需要展现，因此减轻了工作量。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>IOC容器比单例麻烦很多，而且每次从容器里面查询字典也造成更多的性能消耗。</li>
<li>使用IOC容器的意义：<ul>
<li>增加模块访问的限制。比如访问CounterModel要通过Countapp；</li>
<li>在统一的地方注册模块，有利于让开发人员有宏观的视角，充当一个“架构草图”，省去了维护一个“架构草图”的麻烦。</li>
<li>更符合SOLID原则、可以增加层级等等</li>
</ul>
</li>
</ul>
<h2 id="IOC-的隐藏功能：注册接口模块"><a href="#IOC-的隐藏功能：注册接口模块" class="headerlink" title="IOC 的隐藏功能：注册接口模块"></a>IOC 的隐藏功能：注册接口模块</h2><ul>
<li><p>除了<strong>注册和获取</strong>模块，IOC容器一般还有一个隐藏功能，即：注册<strong>接口</strong>模块</p>
</li>
<li><p><strong>抽象-实现</strong> 这种形式注册和获取对象的方式是符合<strong>依赖倒置原则</strong>的。</p>
</li>
<li><p>依赖倒置原则：程序要依赖于抽象接口，不要依赖于具体实现。</p>
</li>
<li><p>好处：</p>
<ul>
<li>接口设计和实现分成两个步骤，设计时可以专注于设计，减少干扰，实现专注于实现；</li>
<li>实现是可以替换的，比如一个接口是IStorage，实现可以是PlayerPrefsStorage、EasySaveStorage等；</li>
<li>比较容易测试（单元测试等）；</li>
<li>实现细节发生变化时，引用接口不会改变，降低耦合……</li>
</ul>
</li>
<li><p>DICExample.cs（DIP是依赖倒置原则的意思）</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DIPExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.设计模块接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> PlayerPrefs.GetString(key, defaultValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">                <span class="keyword">return</span> EditorPrefs.GetString(key, defaultValue);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//避免打包出错</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">                EditorPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> container = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">        container.Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">        <span class="keyword">var</span> storage = container.Get&lt;IStorage&gt;();</span><br><span class="line">        storage.SaveString(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;运行时存储&quot;</span>);</span><br><span class="line">        Debug.Log(storage.LoadString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用另一个实现类来直接替换 容器里同接口的实例</span></span><br><span class="line">        container.Register&lt;IStorage&gt;(<span class="keyword">new</span> EditorPrefsStorage());</span><br><span class="line">        storage = container.Get&lt;IStorage&gt;();</span><br><span class="line">        Debug.Log(storage.LoadString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>依赖倒置原则是SOLID中的字母D；单一职责原则是SOLID中的字母D。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>CounterModel继承了一个接口。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    BindableProperty&lt;<span class="built_in">int</span>&gt; Count &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span> <span class="comment">//: Singleton&lt;CounterModel&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后注册的时候使用的是接口类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么使用CountModel的时候就是通过接口类型来获取。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddNumCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112165507242.png" alt="image-20230112165507242"></p>
<blockquote>
<p>可见CounterModel改成了ICounterModel。虽然改动很小，但是看这张图的时候不用考虑CountModel的具体实现，减轻了心智负担。</p>
</blockquote>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112171057291.png" alt="image-20230112171057291"></p>
<h1 id="引入数据存储功能"><a href="#引入数据存储功能" class="headerlink" title="引入数据存储功能"></a>引入数据存储功能</h1><p>首先基础实现：数据存储和更改的时候，存储在PlayerPrefs，从PlayerPrefs读取。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterModel</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只是初始化的时候，才从存储读取数据</span></span><br><span class="line">        <span class="comment">//而每一次数据变更都改变存储</span></span><br><span class="line">        Count.Value = PlayerPrefs.GetInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个事件本来就要接受一个int参数，</span></span><br><span class="line">        <span class="comment">//count就是那个参数了？不太懂这个语法糖</span></span><br><span class="line">        Count.OnValueChanged += count =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            PlayerPrefs.SetInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, count);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同的存储"><a href="#不同的存储" class="headerlink" title="不同的存储"></a>不同的存储</h2><p>目前EditorCounterApp和CounterApp都是用同一套存储（同一个CounterModel，而Model都是用PlayerPrefs）。回忆一下，两个项目都是在同一个工程，都是通过CounterModel来操作数据。那么如何实现两者的存储不同呢？上回学到IOC的隐藏功能：注册接口模块，同一个接口有多个类实现，假设用EditorPrefs和PlayerPrefs来分别存储；也已经实现类似的例子。注册想要的实现的类。</p>
<ul>
<li>和上次一样</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.设计模块接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PlayerPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PlayerPrefs.GetString(key, defaultValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditorPrefsStorage</span> : <span class="title">IStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">LoadString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> defaultValue = <span class="string">&quot;&quot;</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            <span class="keyword">return</span> EditorPrefs.GetString(key, defaultValue);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SaveString</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">string</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//避免打包出错</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">            EditorPrefs.SetString(key, <span class="keyword">value</span>);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用。相当于存储也存储在单例容器里。model和存储都有各自的接口。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CounterModel</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> storage = Countapp.Get&lt;IStorage&gt;();</span><br><span class="line"></span><br><span class="line">        Count.Value = storage.LoadInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Count.OnValueChanged += count =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            storage.SaveInt(<span class="string">&quot;COUNTER_COUNT&quot;</span>, count);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BindableProperty</span>&lt;<span class="title">int</span>&gt; Count</span> &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> BindableProperty&lt;<span class="built_in">int</span>&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        Value = <span class="number">0</span> </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见调用了容器里面的storage实例来间接调用它的方法。</p>
</blockquote>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113100133148.png" alt="image-20230113100133148"></p>
<h2 id="单例初始化可能造成的循环递归调用的问题"><a href="#单例初始化可能造成的循环递归调用的问题" class="headerlink" title="单例初始化可能造成的循环递归调用的问题"></a>单例初始化可能造成的循环递归调用的问题</h2><p>首先分析一下代码实现的逻辑。model类和存储类都是在此类中注册的，那么Countapp在什么时候调用Init（）方法呢？回到Architecture类看一下。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Register&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        Register&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;	<span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见Init方法是mArchitecture为空的时候调用的。而Get方法和Register方法都可能调用MakeSureArchitecture方法，当第一次调用的时候。所以不是在某个地方Init，而是第一次注册或者get的时候才会初始化。</p>
<p>所以，整个流程是：</p>
<ul>
<li>某个功能要用到数据类Model的时候，首先执行get方法：<code>mCounterModel = Countapp.Get&lt;ICounterModel&gt;();</code></li>
<li>然后Model才开始初始化，执行<code>mArchitecture.Init();</code> </li>
<li>而Init是由子类来实现的，又回到了<code>Register&lt;ICounterModel&gt;(new CounterModel());</code></li>
<li>回到model的构造方法里面，又有<code>var storage = Countapp.Get&lt;IStorage&gt;();</code></li>
<li>这时候<code>mArchitecture</code>还没有初始化完成，所以又回到了子类的init……依次类推循环。</li>
</ul>
<p>【复盘遇到了一个问题：调用CountModel的时候已经MakeSure了一下，执行到代码<code> mArchitecture.Init();</code>，然后开始注册CountModel，在其构造器中尝试Get工具时，虽然又MakeSure了一次，但是此时的mArchitecture已经实例化过，不会执行Init方法了吧？那这样的话Get返回的就是空值了……因为整个代码就是一个静态变量mArchitecture，MakeSure的是mArchitecture】</p>
<p>究其原因，一个类A要成为容器里的一个实例，必须要构造方法实例化一下；而类B的容器注册又在A的构造方法里面；</p>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230112194556474.png" alt="image-20230112194556474"></p>
<h2 id="Architecture类的分析"><a href="#Architecture类的分析" class="headerlink" title="Architecture类的分析"></a>Architecture类的分析</h2><p>【和上文有点重复了，但不要紧，这个是更详细的复盘】首先回忆一下为什么会有Architecture类。开始是直接用IOC容器的，IOC容器就是用字典把某个类型对应的一个实例存储下来，这样一个IOC容器可以有多种模块类的对象实例，而统一管理模块类的类就只需拥有一个静态IOC容器变量就行。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IOCContainer mContainer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无论是增加还是获取都先检查IOC是否为空（类似单例）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureContainer</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mContainer == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line">            Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mContainer.Register(<span class="keyword">new</span> CounterModel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureContainer();</span><br><span class="line">        <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113165437148.png" alt="image-20230113165437148"></p>
<p>这样的话访问Model1就要经过Countapp来访问，达到了限制访问的目的，而不是用静态类随时随地都可以调用。</p>
<p>那么如果有多种管理模块类的类呢？Countapp1，Countapp2……？这时候就必须得抽象一部分代码出来，抽象的关键是：每一个管理类有一个静态的对象来方便访问（可以是IOC或者管理类本身）；IOC可以注册和获取对应的实例；从IOC获取的前提是已经有静态变量而且已经注册过；</p>
<p>所以，抽象出来的Architecture如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Architecture</span>&lt;<span class="title">T</span>&gt;, <span class="title">new</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T mArchitecture;     <span class="comment">//架构类本身是一个单例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">            mArchitecture.Init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;	<span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOCContainer mContainer = <span class="keyword">new</span> IOCContainer();</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>获取模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">Get</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture.mContainer.Get&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>注册模块</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        MakeSureArchitecture();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mContainer.Register&lt;T&gt;(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113171440638.png" alt="image-20230113171440638"></p>
<blockquote>
<p>可见抽象的部分大同小异，只不过静态变量是mArchitecture，传入的T就是管理类（如Countapp），整个过程就是当某个地方需要访问model的数据时，如<code>Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</code>就会调用Countapp的Get方法，里面首先检查是否有<code>mArchitecture</code>实例，没有的话就创建一个实例，并且执行Init方法（此方法就是给子类调用来注册各种模块），注册完后就可以直接调用了。</p>
<p>！！！一定要分清，<code>mArchitecture = new T();</code>就是已经创建了单例，<code>mArchitecture.Init();</code>就是把各模块实例存进来。</p>
</blockquote>
<p>【此处是解决单例循环调用的思路，空白ing】</p>
<h2 id="Architecture类2-0版的分析"><a href="#Architecture类2-0版的分析" class="headerlink" title="Architecture类2.0版的分析"></a>Architecture类2.0版的分析</h2><p>工具层Utility是要通过Model层来进行访问，而System层也可能要访问Model层。也就是说，Model实例化的时候可能要得到Utility，等等。</p>
<p>再回顾一下逻辑执行流程：某处要调用Model（Get它一下），然后检查是否初始化了Architecture，没有就new一个并且执行子类的Init方法，把要注册的都注册一下。注册的时候要调用构造方法，而构造方法可能包含其它层，那如何确保构造的时候其他层已经存在了呢？（不存在的话还得初始化，这样就会重复初始化容易出问题？）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Countapp</span> : <span class="title">Architecture</span>&lt;<span class="title">Countapp</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RegisterSystem&lt;IAchievementSystem&gt;(<span class="keyword">new</span> AchievementSystem());</span><br><span class="line">        RegisterModel&lt;ICounterModel&gt;(<span class="keyword">new</span> CounterModel());</span><br><span class="line">        RegisterUtility&lt;IStorage&gt;(<span class="keyword">new</span> PlayerPrefsStorage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心就是这块注册，把优先级最高的先注册了，然后再注册次优先的。解决的代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MakeSureArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = <span class="keyword">new</span> T();</span><br><span class="line">        mArchitecture.Init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Model初始化</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> architectureModel <span class="keyword">in</span> mArchitecture.mModels)</span><br><span class="line">        &#123;</span><br><span class="line">            architectureModel.Init();</span><br><span class="line">        &#125;</span><br><span class="line">        mArchitecture.mModels.Clear();</span><br><span class="line">        <span class="comment">//System初始化(在Model之后)</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> architectureSystem <span class="keyword">in</span> mArchitecture.mSystems)</span><br><span class="line">        &#123;</span><br><span class="line">            architectureSystem.Init();</span><br><span class="line">        &#125;</span><br><span class="line">        mArchitecture.mSystems.Clear();</span><br><span class="line"></span><br><span class="line">        mArchitecture.mInited = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见执行完<code>mArchitecture.Init();</code>之后，才进行model和System的初始化（相当于构造方法）。Init的时候把要注册的Model和System都存起来，Init完后再逐一初始化。具体处理如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterModel</span>&lt;<span class="title">T</span>&gt;(<span class="params">T model</span>) <span class="keyword">where</span> T : IModel</span></span><br><span class="line">&#123;</span><br><span class="line">    model.Architecture = <span class="keyword">this</span>;</span><br><span class="line">    mContainer.Register&lt;T&gt;(model);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInited)</span><br><span class="line">    &#123;</span><br><span class="line">        mModels.Add(model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        model.Init();</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterSystem</span>&lt;<span class="title">T</span>&gt;(<span class="params">T system</span>) <span class="keyword">where</span> T : ISystem</span></span><br><span class="line">&#123;</span><br><span class="line">    system.Architecture = <span class="keyword">this</span>;</span><br><span class="line">    mContainer.Register&lt;T&gt;(system);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInited)</span><br><span class="line">    &#123;</span><br><span class="line">        mSystems.Add(system);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        system.Init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params">T utility</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mContainer.Register&lt;T&gt;(utility);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了最底层的工具类直接注册，其他都是先进缓存变量待着。</p>
</blockquote>
<p>总之初始化和注册都是一次性就完成的，并且按照顺序逐一实例化，解决互相引用的冲突，所以不会重复调用Init方法。为做到这点还有一个地方要考虑：如果Model直接从<code>Countapp.Get&lt;IStorage&gt;()</code>获取工具类的话，还会调用MakeSure方法……（可能静态变量还是空的？）</p>
<p>反正又进行了很绕的操作：</p>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113191234392.png" alt="image-20230113191234392"></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>/CounterModel.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> storage = Architecture.GetUtility&lt;IStorage&gt;();  <span class="comment">//保证Architecture是赋值好的</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span><span class="doctag">///</span>Architecture.cs</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mContainer.Get&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>model是通过Architecture来GetUtility……为了绕过初始化？也就是获取有两种方法，一种是层级之间（Model/System/Utility）的调用用GetXXX方法（与Init方法无关），这都是继承<code>IBelongToArchitecture</code>来获得的方法，第二种是其他地方调用层级的话直接用Get方法（与Init方法有关）……反正是很绕，滚去多学习语法了。</p>
<h1 id="接口的显式实现"><a href="#接口的显式实现" class="headerlink" title="接口的显式实现"></a>接口的显式实现</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SayOther</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">InterfaceDesignExample</span> : <span class="title">MonoBehaviour</span>, <span class="title">ICanSayHello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接口的隐式实现</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 接口的显式实现，不能带访问权限（均无法访问）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">void</span> ICanSayHello.SayOther()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.SayHello();   </span><br><span class="line"></span><br><span class="line">        (<span class="keyword">this</span> <span class="keyword">as</span> ICanSayHello).SayOther();  <span class="comment">//转成接口对象才能调用,增加了成本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口-抽象类-实现类"><a href="#接口-抽象类-实现类" class="headerlink" title="接口-抽象类-实现类"></a>接口-抽象类-实现类</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CustomScript</span> : <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Destroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        OnDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyScript</span> : <span class="title">CustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这种情况下，子类可以调用接口的<code>Start()</code>方法，那么就会造成循环调用。所以可以限制抽象类的接口方法的访问权限：</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CustomScript</span> : <span class="title">ICustomScript</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Start()</span><br><span class="line">    &#123;</span><br><span class="line">        OnStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Update()</span><br><span class="line">    &#123;</span><br><span class="line">        OnUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICustomScript.Destroy()</span><br><span class="line">    &#123;</span><br><span class="line">        OnDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnStart</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样子类就无法访问抽象类的接口方法，只能继承抽象方法。</p>
</blockquote>
<h2 id="接口-静态扩展时用于限制方法的访问规则"><a href="#接口-静态扩展时用于限制方法的访问规则" class="headerlink" title="接口+静态扩展时用于限制方法的访问规则"></a>接口+静态扩展时用于限制方法的访问规则</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CanDoEveryThing</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething1</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething2</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoSomething3</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;DoSomething3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 总接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing CanDoEveryThing &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口1</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething1</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口1的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething1Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取接口1继承的总接口持有的基本类，并调用其方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;self&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething1</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething1 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口2</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething2</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口2的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething2Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething2</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething2 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 继承总接口的接口3</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanDoSomething3</span> : <span class="title">IHasEverything</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 扩展接口3的静态类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ICanDoSomething3Extension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoSomething3</span>(<span class="params"><span class="keyword">this</span> ICanDoSomething3 self</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.CanDoEveryThing.DoSomething3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo1</span> : <span class="title">ICanDoSomething1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> CanDoEveryThing CanDoEveryThing &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo1 = <span class="keyword">new</span> OnlyCanDo1();</span><br><span class="line">    onlyCanDo1.CanDoEveryThing.DoSomething2();	<span class="comment"><span class="doctag">///</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可见<code>OnlyCanDo1</code>对象可以通过接口持有的实例来访问其他的方法（做事件2和3）.上一种情况是把接口的方法给显式掉，但这次接口是持有其他类的对象。所以，继承接口的类要把接口持有的对象给显式掉。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo1</span> : <span class="title">ICanDoSomething1</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing IHasEverything.CanDoEveryThing &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> CanDoEveryThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo1 = <span class="keyword">new</span> OnlyCanDo1();</span><br><span class="line">    onlyCanDo1.DoSomething1();	<span class="comment">//只能调用接口的方法了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一个接口相当于一个使用规则</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OnlyCanDo23</span> : <span class="title">ICanDoSomething2</span>, <span class="title">ICanDoSomething3</span></span><br><span class="line">&#123;</span><br><span class="line">    CanDoEveryThing IHasEverything.CanDoEveryThing &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> CanDoEveryThing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> onlyCanDo23 = <span class="keyword">new</span> OnlyCanDo23();</span><br><span class="line">    onlyCanDo23.DoSomething2();</span><br><span class="line">    onlyCanDo23.DoSomething3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li>核心知识是接口的显式实现，用于控制C#成员方法的访问权限</li>
<li>接口-抽象类-实现类 时，不想被乱调用一些方法时可以用</li>
<li>接口+静态扩展 时，想通过实现某个接口来获得具体方法的访问权限</li>
</ul>
<h1 id="方式三：引入系统层"><a href="#方式三：引入系统层" class="headerlink" title="方式三：引入系统层"></a>方式三：引入系统层</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230113100249105.png" alt="image-20230113100249105"></p>
<p>目前项目可以分为三个层级：</p>
<ul>
<li>表现层：即ViewController或者MonoBehaviour脚本等；</li>
<li>Model层：管理数据，提供数据的增删改查</li>
<li>Utility层：工具层，提供一些必要的基础工具，比如数据存储、网络链接、蓝牙、序列化反序列化等等</li>
</ul>
<p>而QFramework系统设计架构最终是有四个层级，第四层级叫System层，系统层。目前Command分担了Controller的交互逻辑的部分逻辑，但其实还有一部分交互逻辑是需要给System层分担的。</p>
<p>首先要理解的是，Command是没有状态的，因为Command相当于一个方法，只要调用一次就可以不用了，所以Command是没有状态的。那什么是有状态的？比如角色控制脚本，在里面创建了一些角色数据，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PlayerController</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span> Walking;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> JumpCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxJumpCount;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断有没有状态，可以理解为这个对象要不要维护数据。比如之前写的<code>AddCountCommand</code>只是更改了ICountModel中的Count的值，没 有状态。但是现实情况下，Command除了要更改Model的值，还有可能是开启了某些服务，而这些服务是有状态的，比如计时服务、蓝牙链接服务等，如果将它们写成对象必是有状态的对象，而这些服务既包含<strong>要维护的数据</strong>，也包含一些<strong>对外提供的方法</strong>，所以放Model层和Utility层都是不合适的。</p>
<p>如果放在表现层，会造成大量的重复代码；Command只是表现层和底层系统层交互方式的一种，且不能有状态；所以这部分代码只能再创建一个层级来负责了，那就是System层。</p>
<p>所以四个层次的梳理如下：</p>
<ul>
<li>表现层：即ViewController或者MonoBehaviour脚本等；</li>
<li>System层：系统层，<strong>有状态</strong>，负责既提供API又有状态的对象，比如网络服务、蓝牙服务、商城系统等</li>
<li>Model层：管理数据，<strong>有状态</strong>，提供数据的增删改查</li>
<li>Utility层：工具层，<strong>无状态</strong>，提供一些必要的基础工具API，比如数据存储、网络链接、蓝牙、序列化反序列化等等</li>
</ul>
<p>其中表现层改变System、Model层的状态用Command；</p>
<p>System层和Model层通知表现层用事件或委托；</p>
<p>表现层查询状态时可以直接获取System和Model层。</p>
<p>一般情况下，表现层根本不用访问Utility层，同样Utility层也不用通知表现层。</p>
<p>模块化的三种方式：</p>
<ul>
<li>单例</li>
<li>IOC容器</li>
<li>分层</li>
</ul>
<h2 id="实现系统层"><a href="#实现系统层" class="headerlink" title="实现系统层"></a>实现系统层</h2><p>和Model层差不多，但是init的时候要放在model的后面，因为可能要引用到model</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Model初始化</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> architectureModel <span class="keyword">in</span> mArchitecture.mModels)</span><br><span class="line">&#123;</span><br><span class="line">    architectureModel.Init();</span><br><span class="line">&#125;</span><br><span class="line">mArchitecture.mModels.Clear();</span><br><span class="line"><span class="comment">//System初始化(在Model之后)</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> architectureSystem <span class="keyword">in</span> mArchitecture.mSystems)</span><br><span class="line">&#123;</span><br><span class="line">    architectureSystem.Init();</span><br><span class="line">&#125;</span><br><span class="line">mArchitecture.mSystems.Clear();</span><br></pre></td></tr></table></figure>

<ul>
<li>实现例子：成就系统</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAchievementSystem</span> : <span class="title">ISystem</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AchievementSystem</span> : <span class="title">IAchievementSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> IArchitecture Architecture &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取model的数据</span></span><br><span class="line">        <span class="keyword">var</span> counterModel = Architecture.GetModel&lt;ICounterModel&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> previousCount = counterModel.Count.Value;</span><br><span class="line"></span><br><span class="line">        counterModel.Count.OnValueChanged += newCount =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (previousCount &lt; <span class="number">10</span> &amp;&amp; newCount &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;解锁点击10次的成就&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (previousCount &lt; <span class="number">20</span> &amp;&amp; newCount &gt;= <span class="number">20</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Debug.Log(<span class="string">&quot;解锁点击20次的成就&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousCount = newCount;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li>ICommand</li>
<li>ISystem</li>
<li>IModel</li>
<li>（IController）</li>
<li>（IUtility）</li>
</ul>
<h2 id="IController"><a href="#IController" class="headerlink" title="IController"></a>IController</h2><p>与MVC的Controller是同一个意思。</p>
<p>在表现层需要向底层系统层发送Command，也需要监听底层系统层发送的事件，还需要通过底层系统层的Model或System来查询一些数据，这些功能最好用一个IController来定义一下。目前能够实现的就是查询数据的功能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IController</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>由于表现层的对象会时常进行创建和销毁，所以表现层的对象注册到Architecture是没有意义的，而这里定义的IController的意义就是标记一下这个表现层的对象是属于表现层的（不能和系统层、数据层相提并论，都存在IOC中）；而在表现层对象中，去访问Architecture中的System或Model就不需要使用单例的形式获取了。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//CounterViewController.cs</span></span><br><span class="line">mCounterModel = Countapp.Get&lt;ICounterModel&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>//改为层之间的调用</span></span><br><span class="line"><span class="comment">//继承IController，并且</span></span><br><span class="line">mCounterModel = Architecture.GetModel&lt;ICounterModel&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> IArchitecture Architecture &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = Countapp.Interface;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span>//Architecture.cs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IArchitecture Interface</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mArchitecture == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            MakeSureArchitecture();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Controller是连接Mono（一直运行的）和层级之间的桥梁，如果直接调用<code>Architecture</code>将为空值，所以要加一个方法来获取初始化好的<code>Architecture</code>.</p>
</blockquote>
<h2 id="解决Controller类不能在Mono执行构造方法"><a href="#解决Controller类不能在Mono执行构造方法" class="headerlink" title="解决Controller类不能在Mono执行构造方法"></a>解决Controller类不能在Mono执行构造方法</h2><p>但是在<code>CounterViewController : MonoBehaviour, IController</code>类中，</p>
<p><code>public IArchitecture Architecture &#123; get; set; &#125; = Countapp.Interface;</code>这个构造方法并没有在Mono的方法里面执行，所以会报错。</p>
<p>修改如下：Architecture 的set和get分离。 </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSetArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetArchitecture</span>(<span class="params">IArchitecture architecture</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于IModel和ISystem都是和Architecture相互持有的，所以IModel和ISysem两者都要实现两个接口。</p>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114113357202.png" alt="image-20230114113357202"></p>
<blockquote>
<p>可见IController是直接从Architecture获取，其他层由于和Architecture相互持有，所以还有抽象类来存储Architecture变量。</p>
</blockquote>
<h2 id="IUtility接口"><a href="#IUtility接口" class="headerlink" title="IUtility接口"></a>IUtility接口</h2><p>IUtility并不持有Architecture对象，只是Architecture单向持有它。此时接口似乎只是一个标识（限制类型）作用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStorage</span>: <span class="title">IUtility</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SaveInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">LoadInt</span>(<span class="params"><span class="built_in">string</span> key, <span class="built_in">int</span> defaultValue = <span class="number">0</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="doctag">///</span>/IArchitecture.cs</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params">T instance</span>) <span class="keyword">where</span> T : IUtility</span></span><br><span class="line"><span class="function">T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">class</span>, IUtility</span>; </span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114155707059.png" alt="image-20230114155707059"></p>
<h2 id="ICommand接口"><a href="#ICommand接口" class="headerlink" title="ICommand接口"></a>ICommand接口</h2><p>目前是通过单例的方式来访问Architecture对象。如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> AddNumCommand : ICommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Countapp.Get&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而其他层比如Model、System都是与Architecture互相持有的，所以ICommand也要保持一致。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICommand</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractCommand</span> : <span class="title">ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IArchitecture mArchitecture;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetArchitecture</span>(<span class="params">IArchitecture architecture</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = architecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICommand.Execute()</span><br><span class="line">    &#123;</span><br><span class="line">        OnExecute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddNumCommand</span> : <span class="title">AbstractCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetArchitecture().GetModel&lt;ICounterModel&gt;().Count.Value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114163358549.png" alt="c"></p>
<blockquote>
<p>重点看ICommand对应的内容。目前ICommand只是实现使用Architecture，接下来更改Command的调用方式。不同于目前已经实现的Model层和System层，它们是提供外界访问和内置触发事件（在Init已经安排好）；而Command需要别人主动来调用它。</p>
</blockquote>
<h3 id="Command-的调用"><a href="#Command-的调用" class="headerlink" title="Command 的调用"></a>Command 的调用</h3><p>解决：将Command发送给Architecture，让Architecture去执行Command。（Command已经和Architecture互相持有了，所以意味着Command必须执行SetArchitecture方法？）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : ICommand, <span class="keyword">new</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : ICommand</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//Architecture.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : ICommand, <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> command = <span class="keyword">new</span> T();</span><br><span class="line">    command.SetArchitecture(<span class="keyword">this</span>);</span><br><span class="line">    command.Execute();</span><br><span class="line">    <span class="comment">//command.SetArchitecture(null);  //执行完去掉双向引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendCommand</span>&lt;<span class="title">T</span>&gt;(<span class="params">T command</span>) <span class="keyword">where</span> T : ICommand</span></span><br><span class="line">&#123;</span><br><span class="line">    command.SetArchitecture(<span class="keyword">this</span>);</span><br><span class="line">    command.Execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里完善了command对<code>Architecture</code>的持有以及方法调用。这样就可以通过Architecture来执行command的了。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Enemy</span> : <span class="title">MonoBehaviour</span>, <span class="title">IController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PointGame.Interface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* new KillEnemyCommand()</span></span><br><span class="line"><span class="comment">                    .Execute(); */</span></span><br><span class="line">        GetArchitecture().SendCommand&lt;KillEnemyCommand&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Controller层的，首先继承<code>IController</code>，然后实现<code>GetArchitecture</code>方法来获取Architecture对象以便调用Command层的命令。</p>
</blockquote>
<h1 id="架构使用规则完善一"><a href="#架构使用规则完善一" class="headerlink" title="架构使用规则完善一"></a>架构使用规则完善一</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114172433239.png" alt="image-20230114172433239"></p>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230114172510398.png" alt="image-20230114172510398"></p>
<h2 id="改进一：限制Model层对IArchitecture方法的使用"><a href="#改进一：限制Model层对IArchitecture方法的使用" class="headerlink" title="改进一：限制Model层对IArchitecture方法的使用"></a>改进一：限制Model层对IArchitecture方法的使用</h2><p>model层由于可以使用GetArchitecture()方法来执行IArchitecture接口内设计的所有方法，所以它可以访问Command层，这是不合理的。因为Command是表现层和底层交互的方式。</p>
<p>而在接口的显式实现章节中提到过”接口+静态扩展用于限制方法的访问“，所以可以对Model访问接口的方法做出一些限制。</p>
<ul>
<li>限制model对Set和Get方法的使用</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span>//AbstractModel.class</span></span><br><span class="line"><span class="keyword">void</span> ICanSetArchitecture.SetArchitecture(IArchitecture architecture)</span><br><span class="line">&#123;</span><br><span class="line">    mArchitecture = architecture;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IArchitecture IBelongToArchitecture.GetArchitecture()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mArchitecture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我对这种方式的理解是，用一个额外的接口来继承”可以做全部事情的“接口，但是用一个静态类来扩展这个额外的接口，”扩展“的过程中限制了这个接口的继承下来的方法，所以继承这个”被阉割的“接口的类就只能访问特定的方法了。</p>
<ul>
<li>被阉割的接口：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanGetUtility</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanGetUtilityExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">GetUtility</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanGetUtility self</span>) <span class="keyword">where</span> T : <span class="keyword">class</span>, IUtility</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self.GetArchitecture().GetUtility&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>继承这个接口：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IModel</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span>, <span class="title">ICanGetUtility</span><span class="comment">///</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractModel</span> : <span class="title">IModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> IArchitecture mArchitecture;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> ICanSetArchitecture.SetArchitecture(IArchitecture architecture)<span class="comment"><span class="doctag">///</span>子类被禁用的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        mArchitecture = architecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IArchitecture IBelongToArchitecture.GetArchitecture()	<span class="comment"><span class="doctag">///</span>子类被禁用的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mArchitecture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> IModel.Init()</span><br><span class="line">    &#123;</span><br><span class="line">        OnInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现接口</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CounterModel</span> : <span class="title">AbstractModel</span>, <span class="title">ICounterModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> storage = <span class="keyword">this</span>.GetUtility&lt;IStorage&gt;();  <span class="comment"><span class="doctag">///</span>//</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>[静态类扩展接口的语法要回头好好看看]</p>
<h2 id="限制System层"><a href="#限制System层" class="headerlink" title="限制System层"></a>限制System层</h2><p>和Model差不多,多继承了一个被阉割掉的ICanGetModel</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ISystem</span> : <span class="title">IBelongToArchitecture</span>, <span class="title">ICanSetArchitecture</span>, <span class="title">ICanGetModel</span>, <span class="title">ICanGetUtility</span>	<span class="comment">////</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限制Command层"><a href="#限制Command层" class="headerlink" title="限制Command层"></a>限制Command层</h2><p>Command只能访问System、Model、Utility；做法同上。</p>
<h2 id="限制Controller"><a href="#限制Controller" class="headerlink" title="限制Controller"></a>限制Controller</h2><p>IController可以获取Model、获取System、发送Command。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>限制的范围可以看接口后者能使用的方法就能明白，可以减少说明性的文档，或者规范项目。</p>
<h1 id="架构使用规则完善二"><a href="#架构使用规则完善二" class="headerlink" title="架构使用规则完善二"></a>架构使用规则完善二</h1><h2 id="基于类型的事件机制"><a href="#基于类型的事件机制" class="headerlink" title="基于类型的事件机制"></a>基于类型的事件机制</h2><p>事件是底层系统层向表现层发送的，但是目前还没有限制其使用。</p>
<p>目前的事件基类是一个静态类，一是不能传递参数，二是事件管理对象无法分组。</p>
<p>基于类型……是根据某种类型来统一注册执行事件？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Event</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="title">Event</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Action mOnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent += onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params">Action onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent -= onEvent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Trigger</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mOnEvent?.Invoke();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>TypeEventSystem.cs</code></strong></p>
<ul>
<li>与事件操作相关的方法的接口：注册、广播、注销</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITypeEventSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span>;				<span class="comment">//执行无传参的事件集</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span>;							<span class="comment">//执行传参为T类型的事件集</span></span><br><span class="line">    <span class="function">IUnRegister <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span>; <span class="comment">//注册传参为T类型的事件，返回IUnRegister接口类型的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegister</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span>;		<span class="comment">//注销传参为T类型的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关于注销，这里用了统一注销的思路，避免逐一手动注销。这样的话，要被注销的事件就得被存储下来，并且可以调用此事件相关的注销方法。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IUnRegister</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> TypeEventSystemUnRegister&lt;T&gt; : IUnRegister</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> ITypeEventSystem TypeEventSystem;</span><br><span class="line">    <span class="keyword">public</span> Action&lt;T&gt; OnEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        TypeEventSystem.UnRegister&lt;T&gt;(OnEvent);</span><br><span class="line"></span><br><span class="line">        TypeEventSystem = <span class="literal">null</span>;</span><br><span class="line">        OnEvent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为事件是以字典的形式存储在对应的TypeEventSystem实例的字典变量中的，所以既要记录事件本身，还得记录对应的TypeEventSystem实例，并且调用TypeEventSystem实例的UnRegister方法，所以用类或者结构体来存储这些信息和方法。当new 一个TypeEventSystemUnRegister时，传入字段，并且在相应地方调用实例方法，就能注销掉了。</p>
<p>所以<code>IUnRegister Register&lt;T&gt;(Action&lt;T&gt; onEvent);</code>可以说是返回了记录待注销事件相关信息的变量，然后存在某个地方，等待被注销。</p>
</blockquote>
<ul>
<li>统一注销的实现。这个类继承了Mono，说明可以与物体挂钩，当对应的游戏对象销毁时，自动逐一注销事件</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnRegisterOnDestoryTrigger</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HashSet</span>&lt;<span class="title">IUnRegister</span>&gt; mUnRegisters</span> = <span class="keyword">new</span> HashSet&lt;IUnRegister&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddUnRegister</span>(<span class="params">IUnRegister unRegister</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mUnRegisters.Add(unRegister);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> unRegister <span class="keyword">in</span> mUnRegisters)</span><br><span class="line">        &#123;</span><br><span class="line">            unRegister.UnRegister();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mUnRegisters.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关键是怎么调用AddUnRegister方法。视频又用了接口扩展的高级方法，，，👇</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UnRegisterExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterWhenGameObjectDestoryed</span>(<span class="params"><span class="keyword">this</span> IUnRegister unRegister, GameObject gameObject</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> trigger = gameObject.GetComponent&lt;UnRegisterOnDestoryTrigger&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!trigger)</span><br><span class="line">        &#123;</span><br><span class="line">            trigger = gameObject.AddComponent&lt;UnRegisterOnDestoryTrigger&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trigger.AddUnRegister(unRegister);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IUnRegister接口以及实现的TypeEventSystemUnRegister类都是为待注销事件服务。一个待注销的事件经历了以下阶段：记录事件以及被管理的方法和实例——存储记录到物体挂载的脚本上——物体销毁事件注销。所以，可以将待注销的事件直接理解成<code>TypeEventSystemUnRegister</code>实例，那么如何进行第二步呢？</p>
<p>而且明明一个结构体就能记录的，为啥还要弄一个<code>IUnRegister</code>接口呢？接口可以使用静态类进行扩展，如以上这个类所体现的，<code>UnRegisterExtension类</code>扩展了<code>IUnRegister接口</code>，为其添加了<code>UnRegisterWhenGameObjectDestoryed方法</code>，这样所有实现接口的类的实例都能直接调用已经被静态类实现好的接口方法。</p>
<p>所以，继承了<code>IUnRegister接口</code>的<code>TypeEventSystemUnRegister类</code>的实例能直接调用此方法，也就是说待注销的事件能调用这个方法把自己存储好。</p>
<p>为什么要设计接口静态类扩展？直接全放在一个类里面不行吗？🤨</p>
</blockquote>
<ul>
<li>实现接口里的事件的相关方法。这里是一个事件系统，也就是说各种类型的事件都是统一管理。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeEventSystem</span> : <span class="title">ITypeEventSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IRegisterations</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Registerations</span>&lt;<span class="title">T</span>&gt; : <span class="title">IRegisterations</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> Action&lt;T&gt; OnEvents = e =&gt; &#123;&#125;;	<span class="comment">//同类型的注册的事件集</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Dictionary&lt;Type, IRegisterations&gt; mEventRegisterations = <span class="keyword">new</span> Dictionary&lt;Type, IRegisterations&gt;();							<span class="comment">//一个类型对应一个相应传参类型的事件集</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> e = <span class="keyword">new</span> T();</span><br><span class="line">        Send&lt;T&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line">            (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents(e);  <span class="comment">//执行了方法？</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IUnRegister <span class="title">Register</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册的时候，先看看有没有传参类型相同的大部队</span></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            registerations = <span class="keyword">new</span> Registerations&lt;T&gt;();</span><br><span class="line">            mEventRegisterations.Add(type, registerations);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//在大部队里面加入自己的个体信息</span></span><br><span class="line">        (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents += onEvent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回待注销的事件信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TypeEventSystemUnRegister&lt;T&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            OnEvent = onEvent,</span><br><span class="line">            TypeEventSystem = <span class="keyword">this</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegister</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> type = <span class="keyword">typeof</span>(T);</span><br><span class="line">        IRegisterations registerations;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mEventRegisterations.TryGetValue(type, <span class="keyword">out</span> registerations))</span><br><span class="line">        &#123;</span><br><span class="line">            (registerations <span class="keyword">as</span> Registerations&lt;T&gt;).OnEvents -= onEvent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用例子。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TypeEventSystemExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventA</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventB</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> ParamB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IEventGroup</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventC : IEventGroup</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> EventD : IEventGroup</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TypeEventSystem mTypeEventSystem = <span class="keyword">new</span> TypeEventSystem();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        mTypeEventSystem.Register&lt;EventA&gt;(OnEventA);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem.Register&lt;EventB&gt;(b =&gt; </span><br><span class="line">                                          &#123;</span><br><span class="line">                                              Debug.Log(<span class="string">&quot;OnEventB: &quot;</span> + b.ParamB);</span><br><span class="line">                                          &#125;).UnRegisterWhenGameObjectDestoryed(gameObject);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem.Register&lt;IEventGroup&gt;(e =&gt;</span><br><span class="line">                                               &#123;</span><br><span class="line">                                                   Debug.Log(e.GetType());</span><br><span class="line">                                               &#125;).UnRegisterWhenGameObjectDestoryed(gameObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;EventA&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;EventB&gt;(<span class="keyword">new</span> EventB()</span><br><span class="line">                                          &#123;</span><br><span class="line">                                              ParamB = <span class="number">123</span></span><br><span class="line">                                          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            mTypeEventSystem.Send&lt;IEventGroup&gt;(<span class="keyword">new</span> EventC());</span><br><span class="line">            mTypeEventSystem.Send&lt;IEventGroup&gt;(<span class="keyword">new</span> EventD());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEventA</span>(<span class="params">EventA obj</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;OnEventA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当没有直接执行扩展方法时，就要手动注销</span></span><br><span class="line">        mTypeEventSystem.UnRegister&lt;EventA&gt;(OnEventA);</span><br><span class="line"></span><br><span class="line">        mTypeEventSystem = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230116123132177.png" alt="image-20230116123132177"></p>
<p>如果一个接口有多个类实现，虽然注册的时候是按照接口类型来存入字典的，但是添加事件却是用实现子类的类型……所以就是IEventGroup的效果？</p>
<h2 id="约束事件的使用"><a href="#约束事件的使用" class="headerlink" title="约束事件的使用"></a>约束事件的使用</h2><p>事件是<strong>自底向上</strong>通知的时候用的，在底层内部事件也可以监听。</p>
<p>所以将规则定义为：</p>
<ul>
<li>IController可以监听事件</li>
<li>ICommand可以发送事件</li>
<li>ISytem可以发送和监听事件</li>
<li>IModel可以发送事件</li>
</ul>
<p>定好规则后，先在<code>Architecture类</code>增加<strong>注册和发送事件的支持</strong>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...在IArchitecture写一下方法然后实现</span></span><br><span class="line"><span class="keyword">private</span> ITypeEventSystem mTypeEventSystem = <span class="keyword">new</span> TypeEventSystem();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.Send&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">T e</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.Send&lt;T&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IUnRegister <span class="title">RegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mTypeEventSystem.Register&lt;T&gt;(onEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params">Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    mTypeEventSystem.UnRegister&lt;T&gt;(onEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后写规则脚本，限制接口的方法（本质是空接口再扩展方法）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanSendEvent</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanSendEventExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self</span>) <span class="keyword">where</span> T : <span class="keyword">new</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().SendEvent&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self, T e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().SendEvent&lt;T&gt;(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICanRegisterEvent</span> : <span class="title">IBelongToArchitecture</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">CanRegisterEventExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IUnRegister <span class="title">RegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanRegisterEvent self, Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> self.GetArchitecture().RegisterEvent&lt;T&gt;(onEvent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterEvent</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">this</span> ICanSendEvent self, Action&lt;T&gt; onEvent</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        self.GetArchitecture().UnRegisterEvent&lt;T&gt;(onEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：注册事件。通过Architecture来间接执行事件的相关方法；一个模块管理类拥有一个事件系统。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UI</span> : <span class="title">MonoBehaviour</span>, <span class="title">IController</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GamePassEvent.Register(OnGamePass);</span></span><br><span class="line">        <span class="keyword">this</span>.RegisterEvent&lt;GamePassEvent&gt;(OnGamePass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGamePass</span>(<span class="params">GamePassEvent e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        transform.Find(<span class="string">&quot;Canvas/EndPanel&quot;</span>).gameObject.SetActive(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//GamePassEvent.UnRegister(OnGamePass);</span></span><br><span class="line">        <span class="keyword">this</span>.RegisterEvent&lt;GamePassEvent&gt;(OnGamePass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IArchitecture <span class="title">GetArchitecture</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> PointGame.Interface;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：触发事件。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">KillEnemyCommand</span> : <span class="title">AbstractCommand</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnExecute</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> gameModel = <span class="keyword">this</span>.GetModel&lt;IGameModel&gt;();</span><br><span class="line">        gameModel.KillCount.Value++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (gameModel.KillCount.Value == <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.SendEvent&lt;GamePassEvent&gt;(); 	<span class="comment"><span class="doctag">///</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="架构演化小结"><a href="#架构演化小结" class="headerlink" title="架构演化小结"></a>架构演化小结</h1><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>问题：对象之间的引用无规则。</p>
<p>先使用树结构整理了场景结构，然后引入对象之间交互的概念。</p>
<p>对象之间的交互方式：</p>
<ul>
<li>方法</li>
<li>委托</li>
<li>事件</li>
</ul>
<p>模块化的三种常规方式：</p>
<ul>
<li>单例</li>
<li>IOC</li>
<li>分层</li>
</ul>
<p>最后总结得出：</p>
<ul>
<li>自底向上用事件或者委托</li>
<li>自顶向下用方法</li>
</ul>
<p>这个过程中积累了一个工具类：Event基类</p>
<p>学习理论：</p>
<ul>
<li>表现和数据要分离</li>
<li>交互逻辑（Command模式）和表现逻辑（数据+事件）</li>
</ul>
<p>然后是模块化：</p>
<p>Model——静态类——单例——</p>
<p>IOC容器（访问模块对象不能是无任何规则和限制）——模块接口（访问模块对象）——</p>
<p>四个层级——接口的阉割技术（为层级接口增加了限制）——</p>
<p>增加了事件的使用规则</p>
<p><strong>层级之间的规则：</strong></p>
<ul>
<li>表现层<ul>
<li>可以获取System、Model</li>
<li>可以发送Command</li>
<li>可以监听Event</li>
</ul>
</li>
<li>系统层<ul>
<li>可以获取System、Model、Utility</li>
<li>可以监听、发送Event</li>
</ul>
</li>
<li>数据层<ul>
<li>可以获取Utility</li>
<li>可以发送Event</li>
</ul>
</li>
<li>工具层<ul>
<li>啥都不用干，可以集成第三方库，或者封装API</li>
</ul>
</li>
<li>Command（四个层级之外的一个重要概念）<ul>
<li>可以获取System、Model、Utility</li>
<li>可以发送Event、Command</li>
</ul>
</li>
</ul>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230116135422837.png" alt="image-20230116135422837"></p>
<p>设计方法：</p>
<ul>
<li>总览图：包含整个项目的所有System、Model、Utility对象，以及大致的表现层流程</li>
<li>功能实现图：针对单个业务或操作，绘制表现层对象 或 界面图、相关的System、Model、Utility对象、Command、Event的流向以及简单的引用关系。</li>
</ul>
<h1 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h1><p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230128171630873.png" alt="image-20230128171630873"></p>
<p><img src="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/hexo_github_blog\source_posts\Unity的游戏框架.assets\image-20230128171745351.png" alt="image-20230128171745351"></p>
<blockquote>
<p>简洁图的表现</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/frame.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/01/03/Unity%E7%9A%84InputSystem/"><img class="next-cover" src="/img/inputSystem.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity的Input System</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(●ˇ∀ˇ●)</div><div class="author-info__description">someone very lazy</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huangxinhere"><i class="fab fa-github"></i><span>Don't Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A6%81%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">要点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%B7%A8%E6%A8%A1%E5%9D%97%E5%88%9D%E6%8E%A2"><span class="toc-number">2.</span> <span class="toc-text">父子对象和跨模块初探</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E5%92%8C%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-number">3.</span> <span class="toc-text">表现和数据分离</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Event%E7%9A%84%E6%8A%BD%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">Event的抽象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-number">3.2.</span> <span class="toc-text">数据分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E4%BA%8EGame%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%AA%E4%BD%93%E7%9A%84%E6%80%BB%E4%BD%93%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD"><span class="toc-number">3.3.</span> <span class="toc-text">属于Game而不是个体的总体逻辑判断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91%E5%92%8C%E8%A1%A8%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">4.</span> <span class="toc-text">交互逻辑和表现逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E9%83%BD%E5%9C%A8controller%E5%AF%BC%E8%87%B4%E8%87%83%E8%82%BF"><span class="toc-number">4.1.</span> <span class="toc-text">两者都在controller导致臃肿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%A4%E8%80%85%E7%9A%84%E5%88%86%E7%A6%BB"><span class="toc-number">4.2.</span> <span class="toc-text">实现两者的分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96-%E5%BC%95%E5%85%A5Command"><span class="toc-number">4.4.</span> <span class="toc-text">交互逻辑优化-引入Command</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E5%B1%82%E5%92%8C%E5%BA%95%E5%B1%82%E7%9A%84%E5%88%86%E7%A6%BB"><span class="toc-number">4.5.</span> <span class="toc-text">表现层和底层的分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Command"><span class="toc-number">4.7.</span> <span class="toc-text">使用Command</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E4%BC%98%E5%8C%96"><span class="toc-number">5.</span> <span class="toc-text">模块化优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%8D%95%E4%BE%8B"><span class="toc-number">5.1.</span> <span class="toc-text">方式一：单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%BC%95%E5%85%A5IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">方式二：引入IOC容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BBArchitecture"><span class="toc-number">5.3.</span> <span class="toc-text">IOC的工具类Architecture</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC-%E7%9A%84%E9%9A%90%E8%97%8F%E5%8A%9F%E8%83%BD%EF%BC%9A%E6%B3%A8%E5%86%8C%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%9D%97"><span class="toc-number">5.5.</span> <span class="toc-text">IOC 的隐藏功能：注册接口模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.5.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">5.5.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">6.</span> <span class="toc-text">引入数据存储功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">6.1.</span> <span class="toc-text">不同的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%AF%E8%83%BD%E9%80%A0%E6%88%90%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">单例初始化可能造成的循环递归调用的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Architecture%E7%B1%BB%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">6.3.</span> <span class="toc-text">Architecture类的分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Architecture%E7%B1%BB2-0%E7%89%88%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">6.4.</span> <span class="toc-text">Architecture类2.0版的分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%98%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.</span> <span class="toc-text">接口的显式实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB-%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">接口-抽象类-实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-%E9%9D%99%E6%80%81%E6%89%A9%E5%B1%95%E6%97%B6%E7%94%A8%E4%BA%8E%E9%99%90%E5%88%B6%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99"><span class="toc-number">7.2.</span> <span class="toc-text">接口+静态扩展时用于限制方法的访问规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">7.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%BC%95%E5%85%A5%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="toc-number">8.</span> <span class="toc-text">方式三：引入系统层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="toc-number">8.1.</span> <span class="toc-text">实现系统层</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IController"><span class="toc-number">9.1.</span> <span class="toc-text">IController</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3Controller%E7%B1%BB%E4%B8%8D%E8%83%BD%E5%9C%A8Mono%E6%89%A7%E8%A1%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">解决Controller类不能在Mono执行构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IUtility%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.</span> <span class="toc-text">IUtility接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICommand%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.4.</span> <span class="toc-text">ICommand接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">9.4.1.</span> <span class="toc-text">Command 的调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%AE%8C%E5%96%84%E4%B8%80"><span class="toc-number">10.</span> <span class="toc-text">架构使用规则完善一</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E4%B8%80%EF%BC%9A%E9%99%90%E5%88%B6Model%E5%B1%82%E5%AF%B9IArchitecture%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.1.</span> <span class="toc-text">改进一：限制Model层对IArchitecture方法的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6System%E5%B1%82"><span class="toc-number">10.2.</span> <span class="toc-text">限制System层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6Command%E5%B1%82"><span class="toc-number">10.3.</span> <span class="toc-text">限制Command层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6Controller"><span class="toc-number">10.4.</span> <span class="toc-text">限制Controller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">10.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E5%AE%8C%E5%96%84%E4%BA%8C"><span class="toc-number">11.</span> <span class="toc-text">架构使用规则完善二</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">11.1.</span> <span class="toc-text">基于类型的事件机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">约束事件的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96%E5%B0%8F%E7%BB%93"><span class="toc-number">12.</span> <span class="toc-text">架构演化小结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%9B%98"><span class="toc-number">12.1.</span> <span class="toc-text">复盘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">13.</span> <span class="toc-text">实例演示</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By (●ˇ∀ˇ●)</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks to watch my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
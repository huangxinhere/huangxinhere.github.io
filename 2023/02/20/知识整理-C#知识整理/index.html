<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C#知识整理 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于C#知识点整理">
<meta property="og:type" content="article">
<meta property="og:title" content="C#知识整理">
<meta property="og:url" content="https://huangxinhere.github.io/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="关于C#知识点整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-02-19T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-14T23:28:31.868Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C#知识整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-15 07:28:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_pic_3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hx's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C#知识整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-19T16:00:00.000Z" title="发表于 2023-02-20 00:00:00">2023-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-14T23:28:31.868Z" title="更新于 2023-08-15 07:28:31">2023-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C#知识整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面向对象（OOP）的三大特征：继承、封装、多态"><a href="#面向对象（OOP）的三大特征：继承、封装、多态" class="headerlink" title="面向对象（OOP）的三大特征：继承、封装、多态"></a>面向对象（OOP）的三大特征：继承、封装、多态</h1><p>面向对象编程（Object-Oriented Programming）与面向过程（Procedure Oriented ）。</p>
<ul>
<li>面向过程：面向过程的思想是把一个项目、一件事情按照一定的顺序，从头到尾一步一步地做下去，先做什么，后做什么，一直到结束。这种思想比较好理解，其实这也是一个人做事的方法。</li>
<li>面向对象：面向对象的思想是把一个项目、一件事情分成更小的项目，或者说分成一个个更小的部分，每一部分负责什么方面的功能，最后再由这些部分组合而成为一个整体。这种思想比较适合多人的分工合作，就像一个大的机关，分成各个部门，每个部门分别负责某样职能，各个部门可以充分发挥自己的特色，只要符合一定前提就行了。</li>
</ul>
<blockquote>
<p>个人理解：OOP是按照“人的逻辑语义”来进行划分的，就产生了类的思想，同类数据或行为就封装成一个类，为了实现不同类之间互不干涉，密切分工合作，就对各自的数据进行保护，产生了封装；</p>
<p>划分成一个统一的类可能还不够，不满足一些个性化的需求，所以产生继承；</p>
<p>继承类有完全个性化的实现，也有对父类方法的“重写”，可以选择实现子类还是父类的相同行为但不同表现形式，就叫多态。（既满足了行为的抽象，又满足了具体表现的个性化……？）</p>
</blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul>
<li>提高代码重用度，增强软件可维护性的重要手段；</li>
<li>符合开闭原则（软件中的对象扩展是开放的，修改是关闭的）；</li>
<li>继承就是把子类的公共属性集合起来（变量，方法等）共同管理，这些公共属性设置为父类，C#的继承是单继承，但继承有传递性：A继承B，B继承C，A可以调用C#中的方法。</li>
</ul>
<h3 id="派生类继承基类"><a href="#派生类继承基类" class="headerlink" title="派生类继承基类"></a>派生类继承基类</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> _age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = name;</span><br><span class="line">        <span class="keyword">this</span>._age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _id;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age, <span class="built_in">int</span> id</span>) : <span class="title">base</span>(<span class="params">name, age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>._id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><ul>
<li><p>override：对基类中<u>同名方法</u>的<strong>新实现</strong>；同时基类中的同名方法必须声明为 virtual 或 abstract 类型</p>
<ul>
<li>默认的 C# 方法并非 virtual ，因此不能重写。</li>
<li>基类方法的可访问级别并不因重写它的方法而改变，他们的访问修饰符相同。</li>
<li>new 、 static 和 virtual 关键字不能与 override 访问修饰符一同使用</li>
</ul>
</li>
<li><p>virtual：用于对一个类中<strong>可修改的方法</strong>的声明，这种方法称为虚拟方法；比如当某个类实现了方法A，并将它声明为virtual，那么A还能被子类方法修改成A‘。编译的时候才会判定要执行的是A还是A’，这体现了多态。而abstract修饰的方法没有方法体，且一定要被继承实现。</p>
<ul>
<li><p>详细过程</p>
<ul>
<li><p>当调用一个对象的函数时，系统会直接去检查这个对象声明定义的类，即声明类，看所调用的函数是否为虚函数。如果不是虚函数，那么它就直接执行该函数。</p>
</li>
<li><p>而如果有virtual关键字，也就是一个虚函数，那么这个时候它就不会立刻执行该函数了，而是转去检查对象的【实例类】。</p>
</li>
<li><p>在这个实例类里，他会检查这个实例类的定义中是否有重新实现该虚函数（通过override关键字），如果有，则马上执行该实例类中的这个重新实现的函数。而如果没有，系统会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载了该虚函数的父类为止，然后执行该父类里重载后的函数。</p>
</li>
</ul>
</li>
<li><p>virtual访问修饰符不能与static和override等访问修饰符一同使用；</p>
</li>
<li><p>实现原理：每个虚函数都会有一个与之对应的虚函数表，该虚函数表的实质是一个指针数组，存放的是每一个对象的虚函数入口地址。对于一个派生类来说，他会继承基类的虚函数表同时增加自己的虚函数入口地址，如果派生类重写了基类的虚函数的话，那么继承过来的虚函数入口地址将被派生类的重写虚函数入口地址替代。那么在程序运行时会发生动态绑定，将父类指针绑定到实例化的对象实现多态。 </p>
</li>
</ul>
<blockquote>
<ul>
<li>如果是声明类 &amp; 实例类的话：先检查声明类这个函数是不是虚函数, 如果不是虚函数就直接执行函数. 如果是虚函数的话再去检查这个对象的实例类, 看看实例类中有没有重写这个虚函数, 如果有的话就直接执行该函数, 否则就去找这个实例类的父类, 看看他的父类中有没有重写这个虚函数,有的话就执行, 没有的话就继续找直到找遍所有父类, 如果没有override关键字, 最后会执行申明类里的虚函数.<br>————————————————<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lx2054807/article/details/102703775">https://blog.csdn.net/lx2054807/article/details/102703775</a></li>
<li>如果是基类的引用访问派生类的话：那么直接访问最高（最年幼的）级别的派生类的方法。书p138</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            PrintFields();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintFields</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">class</span> <span class="title">B</span> : <span class="title">A</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">int</span> y;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">PrintFields</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;x=&#123;0&#125;,y=&#123;1&#125;&quot;</span>, x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> B();             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出的是x=1，y=0。先隐式调用父类A的无参构造函数，执行PrintFields()方法，检查到是虚方法，转去检查实例类B，有重载方法，执行重载方法，输出x=1,y=0</p>
</blockquote>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是将<u>数据和行为相结合</u>，通过行为约束代码修改数据的程度，增强<u>数据的安全性</u>，属性是C#封装实现的最好体现。</p>
<p>将一些复杂的逻辑包装起来，程序员不管内部是如何实现的，只负责使用里面的数据或者逻辑，目的是<u>保护或者防止代码被无意修改</u>。</p>
<h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>【简要介绍】<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-polymorphism.html">C# 多态性 | 菜鸟教程 (runoob.com)</a></p>
<p>【详细分析】<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qixinbo/p/8244583.html">C#面向对象（三）：多态 - SeedQi - 博客园 (cnblogs.com)</a></p>
<ul>
<li><p>在继承关系的前提下，实例化出不同的对象，这些对象调用相同的方法，但是却表现出不同的行为，这就叫做多态。</p>
</li>
<li><p><strong>多态性</strong>意味着有多重形式。在面向对象编程范式中，多态性往往表现为”一个接口，多个功能”。</p>
</li>
<li><p>多态性可以是静态的或动态的。在<strong>静态多态性</strong>中，<u>函数的响应</u>是在编译时发生的。在<strong>动态多态性</strong>中，函数的响应是在运行时发生的。</p>
<ul>
<li><p>静态多态性：在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：函数重载 &amp; 运算符重载。</p>
<ul>
<li><p>函数重载：对相同的函数名有多个定义；不能修改返回类型。</p>
</li>
<li><p>运算符重载：<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-operator-overloading.html">C# 运算符重载 | 菜鸟教程 (runoob.com)</a></p>
</li>
<li><p>C++：重载和模板（传入template T才实例化一个函数）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="comment">// opterator+</span></span><br><span class="line"><span class="comment">// 传参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Box <span class="keyword">operator</span>+ (Box b, Box c)</span><br><span class="line">&#123;</span><br><span class="line">    Box box = <span class="keyword">new</span> Box();</span><br><span class="line">    box.length = b.length + c.length;</span><br><span class="line">    box.breadth = b.breadth + c.breadth;</span><br><span class="line">    box.height = b.height + c.height;</span><br><span class="line">    <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>动态多态性：抽象类 &amp; 虚方法。</p>
</li>
</ul>
</li>
</ul>
<h1 id="引用类型，值类型"><a href="#引用类型，值类型" class="headerlink" title="引用类型，值类型"></a>引用类型，值类型</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>值类型<code>继承自System.ValueType</code>：byte、short、int、long、float、 double、bool、char / struct、 enum…;</li>
<li>引用类型<code>继承自System.Object</code>：string、object、delegate、interface、class、array…</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>存储</p>
<ul>
<li><p>地方：值类型存储在栈中，引用类型存储在堆中；</p>
</li>
<li><p>方式：值类型变量声明后，不管是否已经赋值，编译器为其分配内存；当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时<strong>并没有为其分配堆上的内存空间</strong>。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。值类型的实例通常是在线程栈上分配的（静态分配），但是在某些情形下可以存储在堆中。引用类型的对象总是在进程堆中分配（动态分配）。</p>
</li>
<li><p>速度：值类型存储快，引用类型存储慢</p>
</li>
</ul>
</li>
<li><p>意义：值类型表示实际数据，引用类型表示指向在内存堆中的指针和引用</p>
</li>
<li><p>释放：值类型在栈中可以自动释放，引用类型在堆中需要GC来释放</p>
</li>
<li><p>父类：值类型继承于 System.ValueType，（System.ValueType继承于System.Object)，引用类型继承于System.Object</p>
</li>
</ul>
<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><ul>
<li>引用类型在实例化时，先<u>在栈内开辟空间</u>，用于存储堆中对象的地址，然后<u>在堆内开辟空间</u>，存储引用对象。</li>
<li>而值类型直接在栈中开辟空间存储对象。值类型也有引用地址，但都在栈内的同一空间。</li>
<li>修改：在参数对象进入方法体内，实则是在栈中开辟了<u>新的临时空间</u>。（也就是参数对象的副本）栈内值类型的修改，由于栈中地址不同，所以值类型不会影响到主体。而引用类型的存储数据是一个堆内的地址，所以对于引用类型的修改是直接修改堆内的对象。</li>
<li>值类型对象中的引用类型在堆中（struct中定义的string等）；引用类型对象中的值类型也在堆中（class中的int等。</li>
</ul>
<p>拓展传送门：</p>
<p><a target="_blank" rel="noopener" href="https://dpc520.blog.csdn.net/article/details/119285430?spm=1001.2014.3001.5506">(42条消息) C# “值类型“和“引用类型“在内存的分配_生产队的驴.的博客-CSDN博客_c# 值类型和引用类型的内存分配</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qiaoquan3/article/details/51202926">(42条消息) C#详解值类型和引用类型区别_HawkJony的博客-CSDN博客_值类型 引用类型 区别</a>【超详细，待研究】</p>
<h2 id="赋值、浅赋值、深复制"><a href="#赋值、浅赋值、深复制" class="headerlink" title="赋值、浅赋值、深复制"></a>赋值、浅赋值、深复制</h2><ul>
<li>赋值：值类型成员和引用类型成员共用（都会改变</li>
<li>浅复制：值类型成员不共用</li>
<li>深复制：引用类型成员也不共用</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27825451/article/details/81274668">(50条消息) 一文搞懂C#中的赋值、深复制、浅复制_c# 函数赋值_LoveMIss-Y的博客-CSDN博客</a>【含类的拷贝方法】</p>
<p>【数组的深拷贝方法】<a target="_blank" rel="noopener" href="https://www.cnblogs.com/tang-skillhunter/p/8529570.html">C# 数组深拷贝 - 追问图 - 博客园 (cnblogs.com)</a></p>
<p>【类的深拷贝方法】<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhaoqingqing/p/14800759.html">C#对象属性浅拷贝和深拷贝 - 赵青青 - 博客园 (cnblogs.com)</a></p>
<h1 id="String引用类型的特殊性"><a href="#String引用类型的特殊性" class="headerlink" title="String引用类型的特殊性"></a>String引用类型的特殊性</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><p>字符串每重新赋值，不会覆盖原值，而是开辟新空间存储；</p>
<p>如果内容相同，不同栈地址会指向同一个堆地址；</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>若对字符串频繁修改的时候，利用StringBuilder代替String；</p>
<h2 id="StringBuilder的底层实现"><a href="#StringBuilder的底层实现" class="headerlink" title="StringBuilder的底层实现"></a>StringBuilder的底层实现</h2><p>StringBuilder不在内存中创建新对象，而是动态扩展内存以容纳修改后的字符串。在扩容的期间，会丢弃原数组内的内容，将内容拷贝到新数组。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/556672400">C# StringBuilder 使用 - 知乎 (zhihu.com)</a></p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>StringBuffer是线程安全，一般用于多线程（？？</p>
<p>StringBuilder是非线程安全，所以性能略好，一般用于单线程</p>
<h2 id="用StringBuilder拼接字符串就一定比string要好吗？"><a href="#用StringBuilder拼接字符串就一定比string要好吗？" class="headerlink" title="用StringBuilder拼接字符串就一定比string要好吗？"></a>用StringBuilder拼接字符串就一定比string要好吗？</h2><p>答：不一定，stringbuilder有自身的GC消耗</p>
<p>​    极少拼接（或者短字符串）的情况下 String甚至优于StringBuilder，因为String是公用API，通用性好，用途广泛，读取性能高，占用内存较小，Stringbuilder初始化花费时间更大。</p>
<h2 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h2><p>字符串池有什么用，原理是什么？</p>
<ul>
<li>字符串池是CLR一种针对于反复修改字符串对象的优化措施，作用能够一定程度减少内存消耗。</li>
<li>原理是内部开辟容器通过键值对的形式注册字符串对象，键是字符串对象的内容，值是字符串在托管堆上的引用。这样当新创建的时候，会去检查，如果不存在就在这个容器中开辟空间存放字符串。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq826364410/article/details/87994993">(42条消息) C#–字符串常量池_鹅厂程序小哥的博客-CSDN博客_常量池 c#</a></p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>unity内部有两个内存管理池：堆内存和栈内存。</p>
</li>
<li><p>存储的数据：栈内存(stack)主要用来存储<u>较小的和短暂的</u>数据，堆内存(heap)主要用来存储<u>较大的和存储时间较长的</u>数据。unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在栈内存上，要么处于堆内存上。</p>
</li>
<li><p>标记</p>
<ul>
<li><p>状态：只要变量处于激活状态，则其占用的内存会被标记为使用状态，该部分的内存处于被分配的状态。<br>一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。</p>
</li>
<li><p>处理效率：处于栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。不再使用的内存只会在GC的时候才会被回收。</p>
</li>
</ul>
</li>
<li><p>垃圾回收<u>主要是指<strong>堆上的</strong></u><u>内存分配和回收</u>，unity中会定时对堆内存进行GC操作。</p>
</li>
</ul>
<h2 id="GC算法介绍"><a href="#GC算法介绍" class="headerlink" title="GC算法介绍"></a>GC算法介绍</h2><p>​    C#：分代算法，有内存整理，避免碎片化。有压缩。</p>
<p>​    0代，未被标记回收的新分配对象</p>
<p>​    1代，上次垃圾回收中没有被回收的对象</p>
<p>​    2代，在一次以上的垃圾回收之后仍然没有被回收的对象</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41719595/article/details/121016454">(42条消息) C#——垃圾回收(GC)_面向大象编程的博客-CSDN博客_c# gc</a></p>
<h2 id="简易流程"><a href="#简易流程" class="headerlink" title="简易流程"></a>简易流程</h2><ul>
<li><p>GC会检查堆内存上的每个存储变量;</p>
</li>
<li><p>对每个变量会检测其引用<u>是否处于激活状态</u>;</p>
</li>
<li><p>如果变量的引用不再处于激活状态，则会被标记为可<u>回收</u>;</p>
</li>
<li><p>被标记的变量会<u>被移除</u>，其所占有的内存会被回收到堆内存上。</p>
</li>
</ul>
<h2 id="流程详细介绍"><a href="#流程详细介绍" class="headerlink" title="流程详细介绍"></a>流程详细介绍</h2><ul>
<li><p>当新建立引用类型对象时，检查0代储存空间<u>是否有充足的空间</u>使得新的引用类型对象存储。若没有，将0代对象进行<u>遍历检查</u>，是否有被调用（激活），没有被调用的对象被标记“可回收”。</p>
</li>
<li><p>遍历完成后，将所有被“可回收”的对象进行垃圾<strong>回收</strong>，释放的空间返回给0代储存区，其他的对象的对象<strong>迁移</strong> 到1代储存区，标记为“1代对象”，此时该对象是分散分布的，要进行 压缩 操作，使得1代对象顺序紧密排列。新对象存储于0代储存空间，标记为0代对象。</p>
</li>
<li><p>当1代空间满了时，将1代对象按照上述操作遍历，迁移，压缩到2代储存区，标记为2代对象，同时0代迁移压缩到1代。</p>
</li>
</ul>
<h2 id="GC带来的问题"><a href="#GC带来的问题" class="headerlink" title="GC带来的问题"></a>GC带来的问题</h2><p>GC在unity内存管理中，会带来以下问题：</p>
<ul>
<li><p>游戏性能：GC操作是一个极其耗费事件的操作，<u>堆内存上的变量或者引用越多</u> 则导致<u>遍历检查时的操作变得十分缓慢</u>，使得游戏运行缓慢，例如当CUP处于游戏性能的关键时刻，任何一个操作就会导致游戏帧率下降，造成极大的影响。</p>
</li>
<li><p>游戏内存：（unityGC采用的是<strong>非分代非压缩的标记清除算法</strong>）GC操作会产生“<strong>内存碎片化</strong>”。当一个单元内存从堆中分配出来，其大小取决于存储变量的大小。当内存被回收到堆上时，有可能被堆内存分割成碎片化的单元。（就是说总容量大小时固定的，但是单元内存较小。例如房子很大，房间很小，找不到合适的房间）即下次分配时找不到合适的储存单元，<u>就会触发GC操作，或者堆内存扩容操作</u>，导致GC频发发生和游戏内存越来越大。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/265217138">Unity GC 学习总结 - 知乎 (zhihu.com)</a>（看得不是特别仔细，待进一步深究；有GC的优化，特别技巧等）</p>
<h2 id="何时触发"><a href="#何时触发" class="headerlink" title="何时触发"></a>何时触发</h2><ul>
<li><p>在堆内存上进行内存分配操作，而<u>内存不够的时候</u>都会触发垃圾回收来利用闲置的内存;</p>
</li>
<li><p>GC会<u>自动地触发</u>，不同平台运行频率不—样;</p>
</li>
<li><p>GC可以<u>被强制执行</u>。</p>
</li>
</ul>
<h2 id="如何避免GC？（装箱拆箱介绍-对象池介绍-泛型介绍）"><a href="#如何避免GC？（装箱拆箱介绍-对象池介绍-泛型介绍）" class="headerlink" title="如何避免GC？（装箱拆箱介绍/对象池介绍/泛型介绍）"></a>如何避免GC？（装箱拆箱介绍/对象池介绍/泛型介绍）</h2><ul>
<li><u>减少临时变量的使用</u>，多使用公共对象，多利用缓存机制。（将容器定义到函数外，用到容器的时候进行修改即可）</li>
<li>减少new对象的次数</li>
<li>对于<u>大量字符串拼接</u>时，将StringBuilder代替String。（string不可修改性，修改即创建一个新的string对象，旧的直接抛弃等待GC，但少量字符串拼接用string，性能优于stringbuilder）</li>
<li>使用扩容的容器时，例如：List，StringBuilder等，定义时尽量根据存储变量的内存大小定义储存空间，<u>减少扩容的操作</u>。（扩容后，旧的容器直接抛弃等待GC）</li>
<li><u>代码逻辑优化</u>：例如计时器当大于1s后才进行文本修改，而不是每帧都修改，或者禁止在关键时候GC，影响游戏性能，可以在加载页面或者进度条的时候GC</li>
<li><u>利用对象池</u>：对象池是一种Unity经常用到的内存管理服务，<strong>针对经常消失生成的对象</strong>，例如子弹，怪物等，作用在于<strong>减少创建每个对象的系统开销</strong>。在我们想要对象消除时，不直接Destory，而是隐藏起来SetActive（false），放入池子中，当需要再次显示一个新的对象时，先去池子中看有没有隐藏对象，有就取出来（显示） SetActive（true），没有的话，再实例化。</li>
<li><u>减少装箱拆箱操作</u>。<ul>
<li>装箱拆箱介绍：将值类型转换为 object 类型 或由此值类型实现的任何接口类型的过程</li>
<li>装箱的底层操作：去堆内存<strong>new一个Object类对象</strong>——把值类型的<strong>数据存入</strong>到堆中的Object对象中——将堆上创建的对象的<strong>地址返回</strong>给引用类型变量；拆箱是从 object 类型到值类型或从接口类型 到实现该接口的值类型的显式转换</li>
<li>拆箱的底层操作：获取已装箱的对象的地址检查对象实例，以<strong>确保</strong>它是给定值类型的装箱值——将该值从实例<strong>复制</strong>到值类型变量中</li>
<li>产生GC的原因：</li>
<li>在Unity的装箱操作中，对于值类型会在堆内存上分配一个System.Object类型的引用来封装该值类型变量，其<strong>对应的缓存就会产生内存垃圾</strong>。装箱操作是<u>非常普遍的一种产生内存垃圾的行为</u>，即使代码中没有直接的对变量进行装箱操作，在插件或者其他的函数中也有可能会产生。最好的解决办法是尽可能的避免或者移除造成装箱操作的代码。</li>
<li>泛型介绍：处理多个代码对不同的数据类型执行相同指令的操作。也可以理解为：多个类型共享一组代码。<ul>
<li>泛型类不是实际的类，而是类的模板。</li>
<li>泛型不会进行装箱拆箱，所以性能很高，且规定了变量类型的限制，编译器可以在一定程度上验证类 型的假设，提高了程序类型的安全性，因此在使用容器时多使用 带有泛型的容器例如（ArrayList与List<int>)。</int></li>
</ul>
</li>
</ul>
</li>
<li>协程：yeild return 0 会产生装箱拆箱，可以替换为 yeild return null；</li>
<li>减少不必要的Log；</li>
</ul>
<h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><ul>
<li><p>public:对任何类和成员都公开，无限制访问</p>
</li>
<li><p>private:仅对该类公开</p>
</li>
<li><p>protected:对该类和其派生类公开</p>
</li>
<li><p>internal:只能在包含该类的程序集中访问该类</p>
<p> protected internal: protected + internal</p>
</li>
</ul>
<h1 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h1><p>关键字sealed，类声明时<u>可防止其他类继承此类</u>，在方法中声明则可防止派生类重写此方法。与override一起使用。</p>
<p><img src="https://img-blog.csdnimg.cn/d60d565c7fcc4877aa67f54c4a54e52d.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40323256/article/details/86771078?ops_request_misc=&request_id=&biz_id=102&utm_term=sealed%E7%9A%84%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-86771078.142%5Ev42%5Enew_blog_pos_by_title,185%5Ev2%5Econtrol&spm=1018.2226.3001.4187">(42条消息) C#中sealed的用法_疆~的博客-CSDN博客_c# sealed</a></p>
<h1 id="结构体和类"><a href="#结构体和类" class="headerlink" title="结构体和类"></a>结构体和类</h1><h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><ul>
<li>类型：结构体是值类型，类是引用类型。</li>
<li>存储：结构体存在栈中，类存在堆中。</li>
<li>值传递：结构体变量和类对象进行类型传递时，结构体变量进行的就是值传递，而类对象进行的是引用传递，或者说传递的是指针，这样在函数中改变参数值，结构体对象的值是不变的，而类对象的值是变化了。</li>
<li>成员变量初始化：在C#中<strong>结构体类型定义</strong>时，成员是不能初始化的，这样就导致了，定义结构体变量时，<u>变量的所有成员都要自己赋值初始化</u>。但对于类，在<strong>定义类时</strong>，就可以初始化<u>其中的成员变量</u>，所以在定义对象时，对象本身就已经有了初始值，你可以自己在重新给个别变量赋值。(注意在C++中，类的定义中是不能初始化的，初始化要放在构造函数中)</li>
<li>构造函数和析构函数<ul>
<li>结构体不能申明无参的构造函数，而类可以。</li>
<li>结构体需要在构造函数中初始化<u>所有成员变量</u>，而类随意。</li>
<li>声明了结构类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。</li>
<li>结构体申明有参构造函数后，无参构造不会被顶掉。</li>
<li>结构体不能申明析构函数，而类可以。</li>
</ul>
</li>
<li>继承：结构体不能被继承，而类可以。</li>
<li>静态：结构体不能被静态static修饰(不存在静态结构体)，而类可以。</li>
</ul>
<blockquote>
<p>对于C++来说，类和结构体的唯一区别只是：类的成员默认为private，结构体成员默认为public；因为为了兼容C，所以保留了结构体。在C里面结构体不能有成员函数。C++中类和结构体都可互换使用。</p>
</blockquote>
<h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><ul>
<li><p>结构体</p>
<ul>
<li>结构是值类型在栈中，栈的存取速度比堆快，但是容量小，<u>适合轻量级的对象</u>，比如点、矩形、颜色。</li>
<li>如果对象是<u>数据集合</u>时，优先考虑接结构体（位置，坐标）；</li>
<li>在<u>变量传值</u>的时候，希望传递对象的是拷贝，而不是对象的引用地址，这个时候就可以使用结构体。</li>
<li>结构使用简单,并且很有用,但是要牢记:结构在堆栈中创建，是值类型，而类是引用类型。每当需要一种经常使用的类型，而且大多数情况下该类型只是一些数据时，使用结构能比使用类获得更佳性能。</li>
</ul>
</li>
<li><p>类</p>
<ul>
<li>类是引用类型，存储在堆中，堆的容量大，适合重量级的对象，栈的空间不大，大量的对应当存在于堆中。</li>
<li>如果对象需要继承和多态特征，用类（玩家、怪物）</li>
</ul>
</li>
</ul>
<h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><h2 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h2><ul>
<li>实例化：接口不是类（无构造函数和析构函数），<strong>不能被实例化</strong>，抽象类可以<strong>间接实例化</strong>（可以被继承，有构造函数，可以实例化子类的同时间接实例化抽象类这个父类）。</li>
<li>方法申明和实现：接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现。</li>
<li>抽象的范围：抽象类中可以有实现成员，接口只能包含抽象成员。因此接口是完全抽象，抽象类是部分抽象。</li>
<li>继承和实现<ul>
<li>抽象类要被子类继承，接口要被类实现；</li>
<li>接口可以实现多继承，抽象类只能实现单继承，一个类只能继承一个类但可以实现多个接口；</li>
<li>抽象方法要被实现，所以不能是静态的，也不能是私有的。</li>
</ul>
</li>
<li>成员修饰符：抽象类中所有的成员修饰符都能使用，接口中的成员都是对外的，所以不需要修饰符修饰。</li>
</ul>
<ul>
<li>按照个人理解来说，接口更注重方法的设计，以供其他类扩展，而抽象类就是一个抽象的模板，让子类都按照这个来做。</li>
</ul>
<h2 id="使用环境-1"><a href="#使用环境-1" class="headerlink" title="使用环境"></a>使用环境</h2><ul>
<li><p>使用抽象类是为了<strong>代码的复用</strong>，而使用接口的动机是为了<strong>实现多态性</strong>。</p>
</li>
<li><p>抽象类适合用来定义某个领域的<strong>固有属性</strong>，也就是本质，接口适合用来定义某个领域的<strong>扩展功能</strong>。</p>
</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li>当2个或多个类中有重复部分的时候，我们可以抽象出来一个基类，如果希望这个基类<strong>不能被实例化</strong>，就可以把这个基类设计成抽象类。</li>
<li>当需要为一些类提供公共的实现代码时，应优先考虑抽象类。因为抽象类中的非抽象方法可以被子类继承下来，使实现功能的代码更简单。</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>当注重代码的扩展性跟可维护性时，应当优先采用接口。</p>
<ul>
<li><p>接口与实现它的类之间可以不存在任何层次关系，接口可以实现毫不相关类的相同行为，比抽象类的使用<strong>更加方便灵活</strong>；</p>
</li>
<li><p>接口只关心对象之间的交互的方法，而不关心对象所对应的具体类。接口是程序之间的一个协议，比抽象类的使用更安全、清晰。一般使用接口的情况更多。</p>
</li>
</ul>
<h1 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h1><p>静态构造函数用于初始化任何<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/static">静态</a>数据(动态初始化)，或执行仅需执行一次的特定操作。</p>
<p>将在创建第一个实例或引用任何静态成员之前自动调用静态构造函数。 </p>
<p>静态构造函数最多调用一次。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SimpleClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Static variable that must be initialized at run time.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">long</span> baseline;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Static constructor is called at most one time, before any</span></span><br><span class="line">    <span class="comment">// instance constructor is invoked or member is accessed.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">SimpleClass</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        baseline = DateTime.Now.Ticks;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态构造函数既没有访问修饰符，也没有参数。</li>
<li>在创建第一个类实例或任何静态成员被引用时，.NET将自动调用静态构造函数来初始化类。</li>
<li>一个类只能有一个静态构造函数。</li>
<li>无参数的构造函数可以与静态构造函数共存。</li>
<li>最多只运行一次。</li>
<li>静态构造函数不可以被继承。</li>
<li>如果没有写静态构造函数，而类中包含带有初始值设定的静态成员，那么编译器会<u>自动生成默认的静态构造函数</u>。</li>
<li>如果静态构造函数引发异常，运行时将不会再次调用该构造函数，并且在程序运行所在的应用程序域的生存期内，类型将保持未初始化。</li>
</ul>
<h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>引用传递可以理解为就是对象本身传递，而非一个<strong>副本或者地址</strong>，一般使用 in、out、ref 关键字声明参数是引用传递。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">in</th>
<th align="center">out</th>
<th align="center">ref</th>
</tr>
</thead>
<tbody><tr>
<td align="center">传递类型</td>
<td align="center">引用传递</td>
<td align="center">引用传递</td>
<td align="center">引用传递</td>
</tr>
<tr>
<td align="center">含义</td>
<td align="center">引用传进（只读</td>
<td align="center">引用传出（必写</td>
<td align="center">可读可写</td>
</tr>
<tr>
<td align="center">需要提前初始化</td>
<td align="center">Y</td>
<td align="center">N</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center">调用/传参关键字是否可以省</td>
<td align="center">Y/N</td>
<td align="center">N/N</td>
<td align="center">N/N</td>
</tr>
</tbody></table>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shanfeng1000/p/15043795.html">C#中的值传递与引用传递（in、out、ref） - 没有星星的夏季 - 博客园 (cnblogs.com)</a>（具体可查看里面的例子）</p>
<h2 id="ref引用"><a href="#ref引用" class="headerlink" title="ref引用"></a>ref引用</h2><p>ref关键字表示变量是引用，或是另一个对象的别名。有五种使用的情况：</p>
<p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference">ref 关键字 - C# 参考 | Microsoft Learn</a></p>
<h3 id="按引用传递参数"><a href="#按引用传递参数" class="headerlink" title="按引用传递参数"></a>按引用传递参数</h3><p>在<u>方法签名</u>和<u>方法调用</u>中，按引用将参数传递给方法。</p>
<ul>
<li><p>方法签名：在方法的参数列表中使用 <code>ref</code> 关键字时，它指示参数按引用传递，而非按值传递。 <code>ref</code> 关键字让形参成为实参的别名，这必须是变量。 换而言之，对形参执行的任何操作都是对实参执行的。</p>
</li>
<li><p>方法定义和调用方法：若要使用 <code>ref</code> 参数，方法定义和调用方法均必须显式使用 <code>ref</code> 关键字，如下面的示例所示。 （除了在进行 COM 调用时，调用方法可忽略 <code>ref</code>。）</p>
</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*按引用传递【值类型】*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> refArgument</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    refArgument = refArgument + <span class="number">44</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> number = <span class="number">1</span>;</span><br><span class="line">Method(<span class="keyword">ref</span> number);</span><br><span class="line">Console.WriteLine(number);</span><br><span class="line"><span class="comment">// Output: 45</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 传递到 <code>ref</code> 或 <code>in</code> 形参的实参必须先经过初始化，然后才能传递；</p>
</blockquote>
<ul>
<li>重载方法能生效的情况</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">CS0663_Example</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Compiler error CS0663: &quot;Cannot define overloaded</span></span><br><span class="line">    <span class="comment">// methods that differ only on ref and out&quot;.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">RefOverloadExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="built_in">int</span> i</span>)</span> &#123; &#125;		<span class="comment">//要有值传递与之区别</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SampleMethod</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> i</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>按引用传递【值类型】或【引用类型】<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/liudongdong19/article/details/83758830">(42条消息) c#引用（&amp;）的用法和应用实例_路途…的博客-CSDN博客_c# 引用</a>【有详细图解】</li>
<li>不要混淆通过引用传递的概念与引用类型的概念。 这两种概念是不同的。 无论方法参数是值类型还是引用类型，均可由 <code>ref</code> 修改。 当通过引用传递时，不会对值类型装箱。</li>
<li>总结<ul>
<li>如果传递的参数是基元类型（int，float等）或结构体（struct），那么就是传值调用。</li>
<li>如果传递的参数前有ref或者out关键字，那么就是传引用调用。</li>
<li>如果传递的参数是类（class）并且没有ref或out关键字：<ul>
<li>如果调用的函数中对参数重新进行了地址分配(new操作)，那么执行结果类似传值调用；</li>
<li>如果调用的函数中没有对参数重新进行了地址分配，直接就是使用了传递的参数，那么执行结果类似传引用调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><p>C#在有限的范围内支持指针；</p>
<p>指针只能指向非托管类型，包括所有基本数据类型、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">枚举类型</a>、其他指针类型和只包含非托管类型的结构。</p>
<ul>
<li>能否为空：引用不能为空，即不存在对空对象的引用，指针可以为空，指向空对象。</li>
<li>初始化：引用必须初始化，指定对哪个对象的引用，指针不需要。</li>
<li>值更改：引用初始化后不能改变，指针可以改变所指对象的值。（？</li>
<li>引用访问对象是直接访问，指针访问对象是间接访问。</li>
<li>引用的大小是所引用对象的大小，指针的大小，是指针本身大小，通常是4字节。</li>
<li>引用没有const，指针有const。</li>
<li>引用和指针的+自增运算符意义不同。</li>
<li>引用不需要分配内存空间，指针需要。</li>
</ul>
<h1 id="不安全代码和非托管代码"><a href="#不安全代码和非托管代码" class="headerlink" title="不安全代码和非托管代码"></a>不安全代码和非托管代码</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sibaison/article/details/72675257">(42条消息) C#的三大难点之二：托管与非托管_游子2022的博客-CSDN博客_c#托管</a></p>
<h2 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h2><p>​    源代码首先经过预处理器，对头文件以及宏进行解析，然后经过编译器，生成汇编代码，接着，经过汇编，生成机器指令，最后将所有文件连接起来。</p>
<p>​    这种编译方式的优点在于，最终<strong>直接生成了机器码</strong>，可以直接被计算机识别和运行，<strong>无需任何中间运行环境</strong>，但缺点也在于，由于不同平台能够识别的机器码不同，因此程序的跨平台能力较差。</p>
<h2 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h2><p>​    而在Java语言中，源代码并没有被直接翻译成机器码，而是编译成了一种<strong>中间代码</strong>（字节码Bytecode）。因此，运行Java程序需要一个额外的JRE（Java Runtime Enviromental）运行环境，在JRE中存在着JVM（Java Virtual Mechinal，Java虚拟机），在程序运行的时候，会将中间代码进一步<strong>解释</strong>为机器码，并在机器上运行。</p>
<p>​    使用中间代码的好处在于，程序的跨平台性比较好，一次编译，可以在不同的设备上运行。</p>
<p>​    <strong>托管/非托管</strong>是微软的.net framework中特有的概念，其中，非托管代码也叫本地（native）代码。托管代码与Java中的机制类似，也是先将源代码编译成中间代码（MSIL，Microsoft Intermediate Language），然后再由.net中的<code>CLR</code>将中间代码<strong>编译</strong>成机器代码。</p>
<p>​    而C#与Java的区别在于，Java是先编译后解释，C#是两次编译。<br>​    托管的方式除了拥有跨平台的优点之外，对程序的性能也产生一定的影响。</p>
<h2 id="托管与非托管资源"><a href="#托管与非托管资源" class="headerlink" title="托管与非托管资源"></a>托管与非托管资源</h2><p>在C/C++中，资源都是需要手动释放的，比如，你new了一个指针，用过之后就需要delete掉，否则就会造成内存泄露。</p>
<p>而在Java中，不必考虑资源释放的问题，Java的垃圾回收机制（GC，Garbage Collection）会保证失效的资源被自动释放。</p>
<p>而C#的机制与Java类似，运行于.net平台上的代码，分配的资源一般会<strong>自动由平台的垃圾回收器释放</strong>，这样的资源就是<strong>托管资源</strong>。</p>
<p>但是一些例外的资源，如System.IO.StreamReader等各种流、各种连接所分配的资源，需要显式调用Close()或Dispose()释放，这种资源就叫做<strong>非托管资源</strong>。</p>
<h2 id="不安全代码"><a href="#不安全代码" class="headerlink" title="不安全代码"></a>不安全代码</h2><p>不安全代码可以被认为是介于托管代码和非托管代码之间的。不安全代码<strong>仍然在公共语言运行时(CLR)控制下运行</strong>，但它将允许您直接<strong>通过指针访问内存</strong>。</p>
<h1 id="第14章-委托"><a href="#第14章-委托" class="headerlink" title="第14章 委托"></a>第14章 委托</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>可以把delegate看作一个包含有序方法列表的对象，这些方法具有相同的签名和返回类型。</p>
<ul>
<li>方法的列表叫做调用列表；</li>
<li>委托持有的方法可以来自任何类或结构，只要他们的【委托的返回类型】&amp;【委托的签名（包括ref和out修饰符）】相同；</li>
<li>调用列表中的方法可以是实例方法也可以是静态方法；</li>
<li>调用委托会调用列表中的所有方法。</li>
</ul>
<h3 id="声明委托类型"><a href="#声明委托类型" class="headerlink" title="声明委托类型"></a>声明委托类型</h3><p>看上去和方法的声明很类似，有返回类型和签名（没有方法主体）；指定了委托接受方法的形式。</p>
<p>不需要在类内部声明，因为它是类型声明。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="创建委托对象"><a href="#创建委托对象" class="headerlink" title="创建委托对象"></a>创建委托对象</h3><ul>
<li>new 运算符</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyDel mydel = <span class="keyword">new</span> MyDel(<span class="comment">/*实例方法*/</span>myInsObj.MyM1);</span><br><span class="line">MyDel dVar = <span class="keyword">new</span> dVar(<span class="comment">/*静态方法*/</span>SClass.OtherM2);</span><br></pre></td></tr></table></figure>

<ul>
<li>=（存在隐式转换）</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyDel mydel = myInsObj.MyM1;</span><br><span class="line">MyDel dVar = SClass.OtherM2;</span><br></pre></td></tr></table></figure>

<h3 id="给委托赋值"><a href="#给委托赋值" class="headerlink" title="给委托赋值"></a>给委托赋值</h3><p>委托是引用类型，给它赋值可改变包含在委托变量中的引用；旧的委托对象会被垃圾回收器回收。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel mydel;</span><br><span class="line">mydel = myInsObj.MyM1;<span class="comment">//被回收</span></span><br><span class="line">mydel = SClass.OtherM2;</span><br></pre></td></tr></table></figure>

<h3 id="组合委托"><a href="#组合委托" class="headerlink" title="组合委托"></a>组合委托</h3><p>用运算符组合；</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel delA = myInsObj.MyM1;</span><br><span class="line">MyDel delB = SClass.OtherM2;</span><br><span class="line">MyDel delC = delA + delB;</span><br></pre></td></tr></table></figure>

<p>运算最终会创建一个新的委托，其调用列表连接了两个委托的列表副本。委托对象被创建后就不能被改变。</p>
<p><img src="https://img-blog.csdnimg.cn/ed1d971fa2964e71a31baaef50d8c0be.png" alt="img"></p>
<h3 id="为委托添加-移除方法"><a href="#为委托添加-移除方法" class="headerlink" title="为委托添加/移除方法"></a>为委托添加/移除方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyDel delVar = inst.MyM1;</span><br><span class="line">delVar += SCl.m3;</span><br><span class="line">delVar += SCl.m4;</span><br></pre></td></tr></table></figure>

<p>委托其实是不变的，实际上是创建了新的委托，然后将新的委托赋值给delVar。</p>
<p><img src="https://img-blog.csdnimg.cn/24f5b881a8a846a3ab4e29a54b36059f.png" alt="img"></p>
<p>删除委托的一些注意事项：</p>
<ul>
<li>-=运算符从列表末尾开始搜索，并移除第一个匹配的实例；</li>
</ul>
<h3 id="调用委托"><a href="#调用委托" class="headerlink" title="调用委托"></a>调用委托</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像方法一样调用</span></span><br><span class="line"><span class="keyword">if</span>(delVar != <span class="literal">null</span>) delVar(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用委托的Invoke方法</span></span><br><span class="line">delVar?.Invoke();</span><br></pre></td></tr></table></figure>

<h3 id="调用带有返回值的委托"><a href="#调用带有返回值的委托" class="headerlink" title="调用带有返回值的委托"></a>调用带有返回值的委托</h3><p><img src="https://img-blog.csdnimg.cn/534f66710017454b9ccaee3fa6abcedb.png" alt="img"></p>
<h3 id="调用带有引用参数的委托"><a href="#调用带有引用参数的委托" class="headerlink" title="调用带有引用参数的委托"></a>调用带有引用参数的委托</h3><p><img src="https://img-blog.csdnimg.cn/f00ffde37101478382d8c663237d572a.png" alt="img"></p>
<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">MyDel</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line"></span><br><span class="line">MyDel del = <span class="built_in">delegate</span>(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (<span class="comment">/*参数列表*/</span>) &#123;<span class="comment">/*语句块*/</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p> 不会显式地声明返回值；</p>
</li>
<li><p>匿名方法可以访问外围作用域的局部变量和环境（方法捕获）；</p>
</li>
<li><p>捕获变量的生命周期的扩展：</p>
<p><img src="https://img-blog.csdnimg.cn/36a253bcbd734b38963d6196bf8ffec7.png" alt="img"></p>
</li>
</ul>
<h2 id="通过委托执行方法"><a href="#通过委托执行方法" class="headerlink" title="通过委托执行方法"></a>通过委托执行方法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title">DelegateExample</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DoDelegate</span>(<span class="params"><span class="built_in">string</span> valueStr</span>)</span>;		<span class="comment">//委托声明</span></span><br><span class="line">     <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">DoFunction</span>(<span class="params"></span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">//声明一个委托变量，并把已知方法作为构造函数的参数</span></span><br><span class="line">         DoDelegate doDelegate = <span class="keyword">new</span> DoDelegate(Test);</span><br><span class="line">         <span class="comment">//通过委托的静态方法Invoke触发委托</span></span><br><span class="line">         doDelegate?.Invoke(<span class="string">&quot;传入委托的值！&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">string</span> valueStr</span>)</span></span><br><span class="line">     &#123;</span><br><span class="line">         Console.Write(<span class="string">$&quot;valueStr=<span class="subst">&#123;valueStr&#125;</span>&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">DelegateExample delegateExample = <span class="keyword">new</span> DelegateExample();</span><br><span class="line">delegateExample.DoFunction();</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>在CLR运行时，DoDelegate实际上是一个类，该类的构造函数有一个<u>参数类型</u>，这个参数类型就是Test方法；并且提供了一个<u>实例Invoke方法</u>，用来触发委托执行；</li>
<li>委托DoDelegate定义了方法的参数和返回值类型；</li>
<li>通过委托DoDelegate的构造函数，可以将符合的方法赋值给委托；</li>
<li>调用委托的实例方法Invoke执行方法。</li>
</ul>
</blockquote>
<h2 id="委托执行方法的另外一种方式：委托变量（参数列表）"><a href="#委托执行方法的另外一种方式：委托变量（参数列表）" class="headerlink" title="委托执行方法的另外一种方式：委托变量（参数列表）"></a><strong>委托执行方法的另外一种方式：委托变量（参数列表）</strong></h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DelegateExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DoDelegate</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">DoFunction</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个委托变量，并将已知方法作为构造函数的参数</span></span><br><span class="line">        DoDelegate doDelegate = <span class="keyword">new</span> DoDelegate(Test);</span><br><span class="line">        <span class="built_in">object</span> sender = <span class="number">888</span>;</span><br><span class="line">        EventArgs e = <span class="keyword">new</span> EventArgs();</span><br><span class="line">        doDelegate(sender, e);	<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">$&quot;valueStr=<span class="subst">&#123;sender&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>委托DoDelegate中的参数object sender通常表示动作的发起者，EventArgs e表示动作所带的参数。</p>
<p>实际上，事件就是采用委托变量（参数列表）形式执行方法。</p>
</blockquote>
<h2 id="委托和接口的区别"><a href="#委托和接口的区别" class="headerlink" title="委托和接口的区别"></a>委托和接口的区别</h2><p>接口是约束类应该具备功能的集合，约束了类应该具备哪些功能，使类从复杂的逻辑中解脱出来，方便类的管理和拓展，同时解决类的单继承问题。</p>
<p>接口：无法继承的场所；完全抽象的场所；多人协作的场所；</p>
<p>委托：多用于事件的处理。只是方法集合的管理</p>
<h2 id="委托和事件的区别"><a href="#委托和事件的区别" class="headerlink" title="委托和事件的区别"></a>委托和事件的区别</h2><p>通过事件注册、取消多个<u>委托</u>和<u>方法</u>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DelegateExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DoDelegate</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> DoDelegate DoEvent;	<span class="comment">//类型是DoDelegate</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">void</span> <span class="title">DoFunction</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DoDelegate doDelegate = <span class="keyword">new</span> DoDelegate(Test);</span><br><span class="line">        <span class="built_in">object</span> sender = <span class="number">888</span>;</span><br><span class="line">        EventArgs e = <span class="keyword">new</span> EventArgs();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//事件添加委托</span></span><br><span class="line">        DoEvent += <span class="keyword">new</span> DoDelegate(doDelegate);</span><br><span class="line">        DoEvent(sender, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Test</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">$&quot;valueStr=<span class="subst">&#123;sender&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件可以看做成委托中的一个变量。</p>
<p>事件是基于委托的存在，事件是委托的安全包裹 让委托的使用更具有安全性。</p>
<ol>
<li>委托可以用“=”来赋值，事件不可以。</li>
<li>委托是一个类型，事件是类或结构的成员。</li>
<li>委托可以在声明它的类外部进行调用，而事件只能在类的内部进行调用。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>委托是一个类，可以实例化，通过委托的构造函数把方法赋值给委托实例；</li>
<li>触发委托有两种方式：委托实例.Invoke(参数列表)和委托实例（参数列表）；</li>
<li>事件可看作是一个委托类型的变量；</li>
<li>+=为事件注册多个委托实例或多个方法；</li>
<li>-=为事件减少多个委托实例或多个方法；</li>
</ul>
<h2 id="委托原理"><a href="#委托原理" class="headerlink" title="委托原理"></a>委托原理</h2><h2 id="和Delegate的区别"><a href="#和Delegate的区别" class="headerlink" title="和Delegate的区别"></a>和Delegate的区别</h2><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/delegate-class">System.Delegate 和“delegate”关键字 | Microsoft Learn</a></p>
<p>[<a target="_blank" rel="noopener" href="https://blog.csdn.net/alexander_xfl/article/details/45695657">C#-2] delegate和Delegate的区别_石圣的博客-CSDN博客</a></p>
<p>简单的来说就是：Delegate是个类，基类，抽象类。delegate是一个关键字</p>
<p>更深入一点则可以这样理解：</p>
<p>Delegate 类是委托类型的基类。 然而，只有系统和编译器可以显式地从 Delegate 类或 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/system.multicastdelegate(v=vs.110).aspx">MulticastDelegate</a> 类派生。 此外，还不允许从委托类型派生新类型。 Delegate 类不是委托类型，该类<strong>用于派生委托类型</strong>。</p>
<p>大多数语言实现 <strong>delegate</strong> 关键字，这些语言的编译器能够从 <a target="_blank" rel="noopener" href="https://msdn.microsoft.com/zh-cn/library/system.multicastdelegate(v=vs.110).aspx">MulticastDelegate</a> 类进行派生；所以，用户应当使用语言所提供的 <strong>delegate</strong> 关键字。</p>
<h1 id="C-中基本类型占用的字节数"><a href="#C-中基本类型占用的字节数" class="headerlink" title="C#中基本类型占用的字节数"></a>C#中基本类型占用的字节数</h1><table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>bool -&gt; System.Boolean</td>
<td>布尔型，其值为 true 或者 false</td>
</tr>
<tr>
<td>byte -&gt; System.Byte</td>
<td>字节型，占 1 字节，表示 8 位正整数，范围 0 ~ 255</td>
</tr>
<tr>
<td>sbyte -&gt; System.SByte</td>
<td>带符号字节型，占 1 字节，表示 8 位整数，范围 -128 ~ 127</td>
</tr>
<tr>
<td>char -&gt; System.Char</td>
<td>字符型，占有两个字节，表示 1 个 Unicode 字符</td>
</tr>
<tr>
<td>short -&gt; System.Int16</td>
<td>短整型，占 2 字节，表示 16 位整数，范围 -32,768 ~ 32,767</td>
</tr>
<tr>
<td>ushort -&gt; System.UInt16</td>
<td>无符号短整型，占 2 字节，表示 16 位正整数，范围 0 ~ 65,535</td>
</tr>
<tr>
<td>uint -&gt; System.UInt32</td>
<td>无符号整型，占 4 字节，表示 32 位正整数，范围 0 ~ 4,294,967,295</td>
</tr>
<tr>
<td>int -&gt; System.Int32</td>
<td>整型，占 4 字节，表示 32 位整数，范围 -2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td>float -&gt; System.Single</td>
<td>单精度浮点型，占 4 个字节</td>
</tr>
<tr>
<td>ulong -&gt; System.UInt64</td>
<td>无符号长整型，占 8 字节，表示 64 位正整数，范围 0 ~ 大约 10 的 20 次方</td>
</tr>
<tr>
<td>long -&gt; System.Int64</td>
<td>长整型，占 8 字节，表示 64 位整数，范围大约 -(10 的 19) 次方 到 10 的 19 次方</td>
</tr>
<tr>
<td>double -&gt; System.Double</td>
<td>双精度浮点型，占8 个字节</td>
</tr>
</tbody></table>
<h1 id="协变与逆变"><a href="#协变与逆变" class="headerlink" title="协变与逆变??"></a>协变与逆变??</h1><h2 id="协变-out"><a href="#协变-out" class="headerlink" title="协变(out)"></a>协变(out)</h2><p>和谐、自然的变化。里式替换原则中，父类容器可以装载子类对象，子类可以转换成父类。比如string转object，感受是和谐的。</p>
<h2 id="逆变-in"><a href="#逆变-in" class="headerlink" title="逆变(in)"></a>逆变(in)</h2><p>逆常规、不正常的变化。里式替换原则中，父类容器可以装载子类对象，但是子类对象不能装载父类。所以父类转换为子类，比如object转string，感受是不和谐的。</p>
<p>协变和逆变是用来修饰泛型的，用于泛型中修饰字母，只有泛型接口和泛型委托能使用.</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.返回值与参数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用out修饰的泛型，只能作为返回值</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">Testout</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;(<span class="params"></span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用in修饰的泛型，只能作为参数</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> T <span class="title">TestIn</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br></pre></td></tr></table></figure>

<h1 id="反射-大概需要从书本慢慢看起，先了解前面的概念"><a href="#反射-大概需要从书本慢慢看起，先了解前面的概念" class="headerlink" title="反射(大概需要从书本慢慢看起，先了解前面的概念)"></a>反射(大概需要从书本慢慢看起，先了解前面的概念)</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>反射指程序可以访问、 检测和修改它本身状态或行为的一种能力。</p>
<p>程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。</p>
<p>可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>优点：<ul>
<li>反射提高了程序的灵活性和扩展性；</li>
<li>降低耦合性，提高自适应能力；</li>
<li>它允许程序创建和控制任何类的对象，无需提前硬编码目标类。</li>
</ul>
</li>
<li>缺点：<ul>
<li>性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要<strong>远慢于直接代码</strong>。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。</li>
<li>使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码<strong>比相应的直接代码更复杂</strong>。</li>
</ul>
</li>
</ul>
<h2 id="用途（？"><a href="#用途（？" class="headerlink" title="用途（？"></a>用途（？</h2><ul>
<li>它允许在运行时查看特性（attribute）信息。</li>
<li>它允许审查集合中的各种类型，以及实例化这些类型。</li>
<li>它允许延迟绑定的方法和属性（property）。</li>
<li>它允许在运行时创建新类型，然后使用这些类型执行一些任务。</li>
</ul>
<h2 id="查看元数据"><a href="#查看元数据" class="headerlink" title="查看元数据"></a>查看元数据</h2><p>使用反射（Reflection）可以查看特性（attribute）信息。</p>
<p><strong>System.Reflection</strong> 类的 <strong>MemberInfo</strong> 对象需要被初始化，用于发现与类相关的特性（attribute）。为了做到这点，您可以定义目标类的一个对象，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.Reflection.MemberInfo info = <span class="keyword">typeof</span>(MyClass);</span><br></pre></td></tr></table></figure>



<h1 id="第19章-枚举器和迭代器"><a href="#第19章-枚举器和迭代器" class="headerlink" title="第19章 枚举器和迭代器"></a>第19章 枚举器和迭代器</h1><h2 id="枚举器和可枚举类型"><a href="#枚举器和可枚举类型" class="headerlink" title="枚举器和可枚举类型"></a>枚举器和可枚举类型</h2><p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623171428364.png" alt="image-20230623171428364"></p>
<ul>
<li>①可枚举类型：带有<code>GetEnumerator</code>方法的类，返回用于项的枚举器。</li>
<li>②枚举器：<code>GetEnumerator</code>方法返回的实例。③可以依次返回（可枚举类型对象的）集合中项的类对象。</li>
</ul>
<p>foreach结构的本质就是：</p>
<ul>
<li>调用<code>GetEnumerator</code>方法获取对象的枚举器；</li>
<li>从枚举器中请求每一项并且把它作为迭代变量，代码可以读取但不可改变该变量。</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (Type VarName <span class="keyword">in</span> EnumerableObject)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IEnumerator接口"><a href="#IEnumerator接口" class="headerlink" title="IEnumerator接口"></a>IEnumerator接口</h2><p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623172405819.png" alt="image-20230623172405819"></p>
<blockquote>
<p>枚举器的内容：</p>
<ul>
<li>当前项的位置；</li>
<li>Current：返回序列中当前位置项的（只读）<strong>属性</strong>；返回<u>object类型的引用</u>，所以可以返回任何类型的对象。</li>
<li>MoveNext()：把枚举器位置前进一位的方法。返回布尔值，反映新的位置是否有效。</li>
<li>Reset()：把位置重置为原始状态的方法。</li>
</ul>
</blockquote>
<p>模仿foreach循环遍历：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] arr = &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;;</span><br><span class="line">IEnumerator ie = arr.GetEnumerator();</span><br><span class="line"><span class="keyword">while</span>(ie.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> item = (<span class="built_in">int</span>) ie.Current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IEnumerable接口"><a href="#IEnumerable接口" class="headerlink" title="IEnumerable接口"></a>IEnumerable接口</h2><p> 可枚举类是指实现了IEnumerable接口的类。IEnumerable接口只有一个成员——GetEnumerator方法，返回对象的枚举器。</p>
<ul>
<li>使用IEnumerable和IEnumerator实例：</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ColorEnumerator</span> : <span class="title">IEnumerator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] colors;</span><br><span class="line">    <span class="built_in">int</span> 	 position = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//...分别实现三个方法，详情见书P359</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Spectrum</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] colors = &#123;...&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ColorEnumerator(colors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach迭代</span></span><br><span class="line">Spectrum spectrum = <span class="keyword">new</span> Spectrum();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> color <span class="keyword">in</span> spectrum)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="泛型枚举接口"><a href="#泛型枚举接口" class="headerlink" title="泛型枚举接口"></a>泛型枚举接口</h2><p>最重要区别是非泛型接口的实现不是类型安全的。Current返回的是Object，必须转化为实际类型。</p>
<p>而泛型接口的枚举器是类型安全的，返回实际类型的引用。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>C#2.0版本提供的更简单的 创建枚举器和可枚举类型的 方式，可以把手动编码的可枚举类型和枚举器替换为由迭代器生成的可<del>和枚举</del>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br></pre></td></tr></table></figure>



<p>【<strong>迭代器块</strong>】</p>
<p>迭代器块是有一个或多个yield语句的代码块。</p>
<p>有两个特殊语句：</p>
<ul>
<li>yield return 语句指定了序列中要返回的下一项。</li>
<li>yield break 语句指定了在序列中没有其它项。</li>
</ul>
<p><u>编译器</u>得到有关如何<u>枚举项的描述</u>后，使用它来构建 包含所有需要的方法和属性实现的 <u>枚举器类</u>。</p>
<p>【<strong>使用迭代器来创建枚举器</strong>】</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用的是迭代器的方法，返回枚举器</span></span><br><span class="line">        <span class="comment">// 编译器根据迭代器自动创建了一个枚举器类</span></span><br><span class="line">        <span class="keyword">return</span> BlackAndWhite();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator&lt;<span class="built_in">string</span>&gt; <span class="title">BlackAndWhite</span>(<span class="params"></span>)	<span class="comment">// 迭代器</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;gray&quot;</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="string">&quot;white&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foreach</span></span><br><span class="line">MyClass mc = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>【使用迭代器来创建可枚举类型】</strong></p>
<p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623183650444.png" alt="image-20230623183650444"></p>
<p>左边：迭代器返回类型是IEnumerable<string>;</string></p>
<p>右边：编译器生成的类有一个嵌套类实现了IEnumerable<string>和IEnumerator<string>。</string></string></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的实例，因为实现了GetEnumerator方法。这个方法获取了嵌套类的GetEnumerator...</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> shade <span class="keyword">in</span> mc)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接获取嵌套类（迭代器返回的可枚举类型）</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">string</span> shade <span class="keyword">in</span> mc.BlackAndWhite())</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有点绕啊…</p>
<h2 id="常见迭代器模式"><a href="#常见迭代器模式" class="headerlink" title="常见迭代器模式"></a>常见迭代器模式</h2><ul>
<li>实现返回【枚举器】的迭代器：必须通过实现【GetEnumerator方法（不一定要实现接口）】让类可枚举，返回迭代器的枚举器。</li>
<li>实现返回【可枚举类型】的迭代器：<ul>
<li>让类实现GetEnumerator让类本身可枚举：通过方法获取嵌套类</li>
<li>不实现GetEnumerator让类不可枚举：直接由迭代器返回。</li>
</ul>
</li>
</ul>
<h2 id="产生多个可枚举类型"><a href="#产生多个可枚举类型" class="headerlink" title="产生多个可枚举类型"></a>产生多个可枚举类型</h2><p>让迭代器返回可枚举类型，直接使用嵌套类（书本P367）</p>
<h2 id="迭代器的实质"><a href="#迭代器的实质" class="headerlink" title="迭代器的实质"></a>迭代器的实质</h2><p>重要事项：</p>
<ul>
<li>编译器生成的枚举器中，不支持Reset方法。</li>
</ul>
<p>在后台，由编译器生成的枚举器类是包含4个状态的状态机。</p>
<p><img src="/2023/02/20/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/hexo_github_blog\source_posts\知识整理-C#知识整理.assets\image-20230623185456266.png" alt="image-20230623185456266"></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="-字典"></a>-字典</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/InCerry/p/10325290.html">浅析C# Dictionary实现原理 - InCerry - 博客园 (cnblogs.com)</a>[更清晰]</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/96633352">【C#】浅析C# Dictionary实现原理 - 知乎 (zhihu.com)</a></p>
<p>主要是拉链法。</p>
<p><img src="https://img2018.cnblogs.com/blog/997046/201901/997046-20190126232144436-391161641.png" alt="1548494357566"></p>
<h2 id="Hash桶算法"><a href="#Hash桶算法" class="headerlink" title="Hash桶算法"></a>Hash桶算法</h2><p>说到Hash算法大家就会想到<strong>Hash表</strong>，一个Key通过Hash函数运算后可快速的得到hashCode，通过hashCode的映射可直接Get到Value，但是hashCode一般取值都是非常大的，经常是2^32以上，不可能对每个hashCode都指定一个映射。</p>
<p>因为这样的一个问题，所以人们就将生成的HashCode以分段的形式来映射，把每一段称之为一个<strong>Bucket（桶）</strong>，一般常见的Hash桶就是直接对结果取余。</p>
<blockquote>
<p>假设将生成的hashCode可能取值有2^32个，然后将其切分成一段一段，使用<strong>8</strong>个桶来映射，那么就可以通过<code>bucketIndex = HashFunc(key1) % 8</code>这样一个算法来确定这个hashCode映射到具体的哪个桶中。</p>
</blockquote>
<p>大家可以看出来，通过hash桶这种形式来进行映射，所以会加剧hash的冲突。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法 知识整理</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/06/Unity%E7%9A%84%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/"><img class="next-cover" src="/img/frame.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Unity的游戏框架搭建</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(●ˇ∀ˇ●)</div><div class="author-info__description">someone very lazy</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huangxinhere"><i class="fab fa-github"></i><span>Don't Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A%E7%BB%A7%E6%89%BF%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">面向对象（OOP）的三大特征：继承、封装、多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%BB%A7%E6%89%BF%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">派生类继承基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">1.1.2.</span> <span class="toc-text">方法重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">1.3.</span> <span class="toc-text">多态性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">引用类型，值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">底层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E5%A4%8D%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">赋值、浅赋值、深复制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#String%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%89%B9%E6%AE%8A%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">String引用类型的特殊性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3"><span class="toc-number">3.2.</span> <span class="toc-text">解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">StringBuilder的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">3.4.</span> <span class="toc-text">扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8StringBuilder%E6%8B%BC%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94string%E8%A6%81%E5%A5%BD%E5%90%97%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">用StringBuilder拼接字符串就一定比string要好吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B1%A0"><span class="toc-number">3.6.</span> <span class="toc-text">字符串池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GC"><span class="toc-number">4.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.2.</span> <span class="toc-text">GC算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">简易流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.4.</span> <span class="toc-text">流程详细介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.5.</span> <span class="toc-text">GC带来的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E8%A7%A6%E5%8F%91"><span class="toc-number">4.6.</span> <span class="toc-text">何时触发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DGC%EF%BC%9F%EF%BC%88%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E4%BB%8B%E7%BB%8D-%E5%AF%B9%E8%B1%A1%E6%B1%A0%E4%BB%8B%E7%BB%8D-%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">如何避免GC？（装箱拆箱介绍&#x2F;对象池介绍&#x2F;泛型介绍）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">修饰符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">密封类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">结构体和类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">7.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">7.2.</span> <span class="toc-text">使用环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">接口和抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-2"><span class="toc-number">8.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83-1"><span class="toc-number">8.2.</span> <span class="toc-text">使用环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.3.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.4.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">静态构造函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">10.</span> <span class="toc-text">指针和引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">10.1.</span> <span class="toc-text">引用传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ref%E5%BC%95%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">ref引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">10.2.1.</span> <span class="toc-text">按引用传递参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.3.</span> <span class="toc-text">指针和引用的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81%E5%92%8C%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">11.</span> <span class="toc-text">不安全代码和非托管代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">11.1.</span> <span class="toc-text">非托管代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">11.2.</span> <span class="toc-text">托管代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E4%B8%8E%E9%9D%9E%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90"><span class="toc-number">11.3.</span> <span class="toc-text">托管与非托管资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E4%BB%A3%E7%A0%81"><span class="toc-number">11.4.</span> <span class="toc-text">不安全代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E5%A7%94%E6%89%98"><span class="toc-number">12.</span> <span class="toc-text">第14章 委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">12.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%A7%94%E6%89%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.1.1.</span> <span class="toc-text">声明委托类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A7%94%E6%89%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.1.2.</span> <span class="toc-text">创建委托对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%A7%94%E6%89%98%E8%B5%8B%E5%80%BC"><span class="toc-number">12.1.3.</span> <span class="toc-text">给委托赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E5%A7%94%E6%89%98"><span class="toc-number">12.1.4.</span> <span class="toc-text">组合委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%A7%94%E6%89%98%E6%B7%BB%E5%8A%A0-%E7%A7%BB%E9%99%A4%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.5.</span> <span class="toc-text">为委托添加&#x2F;移除方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%A7%94%E6%89%98"><span class="toc-number">12.1.6.</span> <span class="toc-text">调用委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%B8%A6%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">12.1.7.</span> <span class="toc-text">调用带有返回值的委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%B8%A6%E6%9C%89%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">12.1.8.</span> <span class="toc-text">调用带有引用参数的委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.9.</span> <span class="toc-text">匿名方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">通过委托执行方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%89%A7%E8%A1%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%A7%94%E6%89%98%E5%8F%98%E9%87%8F%EF%BC%88%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">委托执行方法的另外一种方式：委托变量（参数列表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.4.</span> <span class="toc-text">委托和接口的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.5.</span> <span class="toc-text">委托和事件的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%8E%9F%E7%90%86"><span class="toc-number">12.7.</span> <span class="toc-text">委托原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8CDelegate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.8.</span> <span class="toc-text">和Delegate的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E7%9A%84%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">13.</span> <span class="toc-text">C#中基本类型占用的字节数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98"><span class="toc-number">14.</span> <span class="toc-text">协变与逆变??</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98-out"><span class="toc-number">14.1.</span> <span class="toc-text">协变(out)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%86%E5%8F%98-in"><span class="toc-number">14.2.</span> <span class="toc-text">逆变(in)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84-%E5%A4%A7%E6%A6%82%E9%9C%80%E8%A6%81%E4%BB%8E%E4%B9%A6%E6%9C%AC%E6%85%A2%E6%85%A2%E7%9C%8B%E8%B5%B7%EF%BC%8C%E5%85%88%E4%BA%86%E8%A7%A3%E5%89%8D%E9%9D%A2%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">15.</span> <span class="toc-text">反射(大概需要从书本慢慢看起，先了解前面的概念)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">15.2.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%94%EF%BC%88%EF%BC%9F"><span class="toc-number">15.3.</span> <span class="toc-text">用途（？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%85%83%E6%95%B0%E6%8D%AE"><span class="toc-number">15.4.</span> <span class="toc-text">查看元数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC19%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.</span> <span class="toc-text">第19章 枚举器和迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%99%A8%E5%92%8C%E5%8F%AF%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.1.</span> <span class="toc-text">枚举器和可枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IEnumerator%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.2.</span> <span class="toc-text">IEnumerator接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IEnumerable%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.3.</span> <span class="toc-text">IEnumerable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%9E%9A%E4%B8%BE%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.4.</span> <span class="toc-text">泛型枚举接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">16.5.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">16.6.</span> <span class="toc-text">常见迭代器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%A4%9A%E4%B8%AA%E5%8F%AF%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.7.</span> <span class="toc-text">产生多个可枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E8%B4%A8"><span class="toc-number">16.8.</span> <span class="toc-text">迭代器的实质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">17.</span> <span class="toc-text">-字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">17.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">17.2.</span> <span class="toc-text">Hash桶算法</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By (●ˇ∀ˇ●)</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks to watch my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
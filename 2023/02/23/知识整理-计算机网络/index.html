<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>计算机网络 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于计算机网络知识点整理">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="关于计算机网络知识点整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-02-22T16:00:00.000Z">
<meta property="article:modified_time" content="2024-11-28T08:16:40.077Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "计算机网络",
  "url": "https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/",
  "image": "https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg",
  "datePublished": "2023-02-22T16:00:00.000Z",
  "dateModified": "2024-11-28T08:16:40.077Z",
  "author": [
    {
      "@type": "Person",
      "name": "(●ˇ∀ˇ●)",
      "url": "https://huangxinhere.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '计算机网络',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hx's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">计算机网络</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-22T16:00:00.000Z" title="发表于 2023-02-23 00:00:00">2023-02-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-28T08:16:40.077Z" title="更新于 2024-11-28 16:16:40">2024-11-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="网络游戏服务器技术栈"><a href="#网络游戏服务器技术栈" class="headerlink" title="网络游戏服务器技术栈"></a>网络游戏服务器技术栈</h1><p><img src="https://pic1.zhimg.com/80/v2-8d51ea0fc4019514a346facd143b1a44_720w.webp" alt="img"></p>
<h1 id="TCP-IP协议栈各个层次及分别的功能"><a href="#TCP-IP协议栈各个层次及分别的功能" class="headerlink" title="TCP&#x2F;IP协议栈各个层次及分别的功能"></a>TCP&#x2F;IP协议栈各个层次及分别的功能</h1><p><img src="https://img-blog.csdnimg.cn/d1adcd8356f248f1945646dbbb74bb2b.png" alt="img"></p>
<ul>
<li>应用层：用来处理特定的应用，<u>针对不同的应用提供了不同的协议</u>， 例如进行文件传输时用到的FTP协议，发送email用到的 SMTP等。对应协议：FTP、HTTP、SMTP、DNS等。</li>
<li>传输层:  主要功能是提供<u>应用程序之间的通信</u>，这一层主要是TCP&#x2F;UDP协议。</li>
<li>网络层:  处理分组在<u>网络中的活动</u>，例如路由选择和转发等，这一 层主要包括IP协议、ARP、ICMP协议等。</li>
<li>网络接口层：这是协议栈的最低层，对应OSI的物理层和数据链路层，  主要完成<u>数据帧的实际发送和接收</u>。</li>
</ul>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">不连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">不可靠</td>
<td align="center">可靠传输；使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">支持一对一，一对多，多对一，多对多交互通信</td>
<td align="center">仅支持一对一通信</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向报文</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center">数据边界</td>
<td align="center">保存数据边界</td>
<td align="center">不保存数据边界</td>
</tr>
<tr>
<td align="center">速度</td>
<td align="center">快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">发送消耗</td>
<td align="center">轻量级（UDP的传输信息不承担任何间接创造连接</td>
<td align="center">重量级</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">小，仅8个字节</td>
<td align="center">大，最小20字节，最大60字节</td>
</tr>
<tr>
<td align="center">有序性</td>
<td align="center">不保证</td>
<td align="center">TCP 保证了消息的有序性，即使到达客户端顺序不同，TCP 也会排序。</td>
</tr>
<tr>
<td align="center">应用场景</td>
<td align="center">IP电话，视频会议，直播，以及FPS竞技类的使用UDP帧同步</td>
<td align="center">要求可靠传输的应用例如文件传输，以及MMO类的TCP状态同步</td>
</tr>
</tbody></table>
<h2 id="TCP运输连接管理：三握四挥"><a href="#TCP运输连接管理：三握四挥" class="headerlink" title="TCP运输连接管理：三握四挥"></a>TCP运输连接管理：三握四挥</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33426324/article/details/105344168">(42条消息) 为什么TCP需要三次握手，四次挥手？_小菜鸡的日常问题的博客-CSDN博客_计算机网络 三次握手、四次挥手、为啥要四次</a></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul>
<li>概念</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/30c2c4802d0b4622a3ecee2a2e66bd8c.png" alt="img"></p>
<blockquote>
<p>三次握手的关键是要确认对方收到了自己的数据包，这个目标就是通过 “确认号（Ack）”字段实现的。<strong>计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测 “确认号（Ack）字段”，看 Ack &#x3D; Seq + 1 是否成立</strong>，如果成立说明对方 正确收到了自己的数据包。</p>
</blockquote>
<p>-首先Client端<strong>发送连接请求</strong>报文（只是请求，没有建立连接？）；</p>
<blockquote>
<p>客户端的发送能力 和 服务器的接受能力没有问题。</p>
<p>”客户端：我只知道我发送出去了。“</p>
</blockquote>
<p>-Server 段<strong>接收链接后回复</strong>ACK 报文，并为这次连接<strong>分配资源</strong>；</p>
<blockquote>
<p>服务器的发送能力和接收能力没有问题；</p>
<p>客户端的发送和接收能力没有问题；</p>
<p>但此时服务器不能确认客户端的接受能力有没有问题。</p>
<p>”客户端：我发送出去了；而且我收到了回复。“</p>
<p>”服务器：我收到了；我告诉客户端我收到了，还想问他：你是真的想和我连接吗？“</p>
</blockquote>
<p>-Client 端接收到 ACK 报文后也向 Server 段发生 ACK 报文，并<strong>分配资源</strong>，这样 TCP 连接就建立了。</p>
<blockquote>
<p>通过这次接收，服务器确认客户端的接收能力和发送能力没有问题；</p>
<p>本身的发送和接收能力也没有问题。</p>
<p>”服务器&#x2F;客户端：都要确定发送出去，收到并且对方回复“</p>
</blockquote>
<p><strong>因此需要三次握手才能确认客户端和服务器的发送、接收能力是否正常</strong></p>
<ul>
<li><p>为什么要三次握手？</p>
<ul>
<li>如果只有一次握手，Client不能确定与Server的单向连接，更加不能确定Server与Client单向连接；</li>
<li>如果只有两次握手，Client确定与Server的单向连接，但是Sevrer不能确定与Client的单向连接；</li>
<li>只有三次握手，Client与Server才能相互确认双向连接，实现双方的数据传输。</li>
</ul>
</li>
<li><p>两次握手不行吗？</p>
<p>三次握手是为了<strong>防止当已失效的连接请求报文段</strong>突然又传到服务端，造成双方的不一致，导致资源的浪费</p>
<p>“已失效的链接请求报文段”是指：当客户端发送一个SYN报文，由于阻塞或某些原因在网络中滞留，导致客户端认为丢包了(其实没有丢)，于是又重新发送一个新的SYN报文，若这次顺利完成，双方建立的链接。</p>
<p>此时网络中存在隐患那个滞留的SYN文，若这个SYN在连接期间被服务接收到，服务器会无视它，</p>
<p>但若在连接释放之后接收到此SYN报文，服务器会认为客户端又向他发出连接请求，于是并返回一个SYNACK报文回应。若此时不采用三次握手，就建立新的连接。<br>这时服务器认为已完成连接，向客户端发送数据，而客户端处于Closed状态会丢弃这些数据，<br>也不发送数据，则服务端一直等待客户端发送数据，导致浪费资源。</p>
</li>
<li><p>三次握手过程中可以携带数据吗？</p>
<p>第三次握手的时候，可以携带数据，但是第一二次握手不可以携带数据。</p>
<p>第一握手不可以存放数据，其中简单的原因是会让服务器更加容易受到攻击。<br>而对于第三次握手的话，因为此时的客户端ESTABLISHED状态，对于客户端来讲，它已经建立起来了连接，并且也已经知道服务器的接受、发送能力没有问题，所以携带数据也没有问题</p>
</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><ul>
<li><p>关闭连接时，服务端收到客户端的 FIN 报文时，仅表示对方不再发送数据，但仍然能够接收数据。此时，服务端不一定将全部数据都发送给了客户端。</p>
</li>
<li><p>因此服务端关闭有两种方式：</p>
<ul>
<li>立即关闭；</li>
<li><u>继续发送一些数据给客户端</u>后，再发送 FIN 报文给客户端（表示同意关闭连接），是否立刻关闭发送数据通道，需交由上层应用决定;</li>
</ul>
</li>
</ul>
<p>所以，客户端的 ACK 和 FIN 一般都会分开发送，这里就会导致次数增加一</p>
<p>数据传输完毕后，双方均可释放连接。起初，客户端和服务端均处于 ESTABLISHED 状态，然后是客户端主动关闭，服务器被动关闭.<br><img src="https://img-blog.csdnimg.cn/7d3aa066c42843d9b03f0be303cd172c.png" alt="img"></p>
<ul>
<li><p>客户端发送第一次挥手，之后由 ESTABLISHED 状态转为 FIN_WAIT1 状态</p>
</li>
<li><p>服务器收到客户端的第一次挥手之后，发送第二次挥手给服务器，服务器进入 CLOSE_WAIT 状态，等待服务器自身的 SOCKET 关闭等处理</p>
</li>
<li><p>客户端收到服务器的第二次挥手，进入 FIN_WAIT2 状态，等待服务器关闭</p>
</li>
<li><p>服务器发送第三次挥手，然后进入 LAST_ACK 状态</p>
</li>
<li><p>客户端收到第三次挥手，发送第四次挥手，客户端进入 TIME_WAIT 状态；</p>
</li>
<li><p>服务器收到第四次挥手，进入 CLOSED 状态，客户端等待 2MSL 后，进入 CLOSED 状态</p>
</li>
<li><p><strong>为什么要四次挥手（常问）</strong></p>
</li>
</ul>
<p>服务端在收到客户端的释放报文时，可能自己的数据报还没有发完，所以不会直接返回FIN+ACK，而只先返回一个ACK，表示自己收到了客户端的释放请求（第二次挥手）。等到服务端报文发完以后，在返回FIN（第三次挥手）。</p>
<ul>
<li><strong>那么，我们是否可以在服务器端数据传送完成后，再返回FIN+ACK呢？中间就可以省略一次ACK了？（省略第二次挥手）</strong></li>
</ul>
<p>​    试想一下，如果服务端还有很多数据需要传送，耗时长，客户端在发送释放报文后，一直没有收到反馈，那么他会认为服务端没有收到我的FIN，因此就会不停的重发FIN。（第一次挥手）</p>
<p>​    所以最好的办法就是，客户端发送FIN，服务端回复ACK，表示我已经收到了，但是我在忙，你等等，我处理完成后联系你。服务端数据传送完成后，发送FIN给客户端，客户端再回复ACK。</p>
<ul>
<li><strong>为什么不能直接CLOSE状态，必须要先设置TIME_WAIT(2个MSL）状态</strong></li>
</ul>
<p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能客户端发送给服务的的最后一个ACK丢失。一段时间后，服务端收不到最后的ACK，认为客户端没有收到FIN请求（第三次挥手），进行超时重发，但是客户端已经关闭了，不会给响应。（理论上来说 服务器超时重发5次后，就会主动断开连接，这样数据既不会丢失也不会错乱，是可以的，但是这样不符合可靠连接。）</p>
<p>此时若旧的客户端直接CLOSE没有TIME_WAIT状态，新的客户端建立与服务端之间的连接，如果新连接和老连接的端口是一样的。假设老连接还有一些数据，因为网络或者其他原因，一直滞留没有发送成功，新连接建立后，就直接发送到新连接里面去了，造成数据的紊乱，因此，我们需要2*MSL的TIMEWAIT状态，让滞留在网络中的报文失效，再去建立新的连接。</p>
<p>所以简单来说TIME_WAIT状态中的2个MSL(TIME_WAIT状态作用)</p>
<ol>
<li>用来重发可能丢失（第四次挥手）的ACK报文</li>
<li>避免服务器有了新的数据需要发送给客户端。</li>
</ol>
<h2 id="TCP-为什么稳定"><a href="#TCP-为什么稳定" class="headerlink" title="TCP 为什么稳定"></a>TCP 为什么稳定</h2><p>与 乱序重排、应答确认、报文重传 和 流量控制 四种机制有关。</p>
<h3 id="乱序重排"><a href="#乱序重排" class="headerlink" title="乱序重排"></a>乱序重排</h3><p>由于网络或“多线程”等因素，接收方收到的数据段很可能是乱序的，不过因为每个 TCP 封装都有序号，接收方重组起来非常容易。</p>
<h3 id="应答确认"><a href="#应答确认" class="headerlink" title="应答确认"></a>应答确认</h3><p>计算机会记录下自己发送的数据包序号 Seq，待收到对方的数据包后，检测 “确认号（Ack）字段”，看 Ack &#x3D; Seq + 1 是否成立，如果成立说明对方正确收到了自己的数据包。</p>
<p>不过为了提高效率，客户端一次有可能发送上千条数据，根据服务端返回客户端的确认号，判断是否为这上千条中最后一条的序列号+1，即发送5000条数据包，判断服务器发送给客户端的Ack是否为5001，等式成立即为接受完整。</p>
<h3 id="报文重传"><a href="#报文重传" class="headerlink" title="报文重传"></a>报文重传</h3><p>TCP 的报文重传有两种独立的办法。一种是超时重传，一种是快速重传。</p>
<p><strong>【超时重传】</strong></p>
<p>因为网速 并不是稳定的，传输时的每个报文的延时也不一样。TCP 会根据报文的往返时间（RTT）自动调整超时重传时间（RTO）。发送方每发一个报文段都会开始计时，如果时间超过 RTO 还没收到这个报文段的确认，就重传该报文段。</p>
<p><strong>【快速重传】</strong></p>
<p>接收方收到序号X 后，回复X+1的确认号，希望收到X+1序号报文，但没有收到，却收到了比X+1还要大的报文，就连续发出确认号X+1的报文，如果发送方连续三次收到重复的确认号，立即重发该报文段，而不管是否超时。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>首先要明白一点，应用程序不论发送还是接收数据，都会先把数据放入缓冲区，再从缓冲区中发出或读取数据。</p>
<p>这个缓冲区大小，反映了应用程序一次能处理数据的能力。如果接收方应用程序处理速度比发送方的发送速度慢，就会造成接收方缓冲区“溢出”。实际上，发送方发送速度和接收方处理速度很难一致。 这就需要 window 来调整了。 TCP 在三次握手建立连接时，会协商双方缓冲区 window 大小。如果因为接收方处理速度较慢，接收方会通过 window 告知发送方，实现动态调整，避免“溢出”。</p>
<p>所谓流量控制就是<u>让发送方发送速率不要过快，让接收方来得及接收</u>。利用滑动窗口机制就可以实施流量控制。原理这就是运用 TCP 报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。解决这个问题，TCP 为每一个连接设置一个持续计时（persistence timer）。只要 TCP 的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小。</p>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p>拥塞的发生是因为路由器缓存溢出，拥塞会导致丢包，但丢包不一定触发拥塞。<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6&spm=1001.2101.3001.7020">拥塞控制</a>是快速传输的基础。一个拥塞控制算法一般包括慢启动算法、拥塞避免算法、快速重传算法、快速恢复算法四部分。</p>
<h2 id="粘包和分包"><a href="#粘包和分包" class="headerlink" title="粘包和分包"></a>粘包和分包</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YYL_Debug/article/details/79414095">(53条消息) Unity3D笔记——Socket粘包分包的理解和最简单的处理方式_YYL_Debug的博客-CSDN博客</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>该现象主要发生在TCP协议中：如果发送的数据很小，那么会自动把一些小的数据合并在一起发送出去；但是接收端就没办法自己分开了，这就是粘包现象(接收方不知道接收的数据间的界限，不知道接收多长的数据。)；而当一次发送的数据又过长的时候，TCP就会把该数据分成几部分发送出去，每次接收方就只会接受部分的数据，这就是分包现象；</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 粘包现象：</span></span><br><span class="line">客户端发送：hello</span><br><span class="line">客户端发送：aaaaa</span><br><span class="line">服务器收到：helloaaaaa</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分包现象：</span></span><br><span class="line">客户端发送：helloxiaoming</span><br><span class="line">服务器收到：hell</span><br><span class="line">服务器收到：oxiaoming</span><br></pre></td></tr></table></figure>

<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p> 1.发送端需要等缓冲区满才发送出去，造成粘包(发送端出现粘包)</p>
<p> 2.接收端没有及时接收缓冲区包数据，造成一次性接收多个包，出现粘包(接收端出现粘包)</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>1.缓冲区过大造成了粘包，所以在发送&#x2F;接收消息时<strong>先将消息的长度作为消息的一部分发出去</strong>，这样接收方就可以根据接收到的消息长度来<u>动态定义缓冲区的大小</u>。(这种方法就是所谓的自定义协议，这种方法是最常用的)</p>
<p>2.对发送的数据进行处理，每条消息的首尾加上特殊字符，然后再把要发送的所有消息放入一个字符串中，最后将这个字符串发送出去，接收方接收到这个字符串之后，再通过特殊标记操作字符串，把每条消息截出来。(这种方法只适合数据量较小的情况)</p>
<h2 id="Socket的封包、拆包"><a href="#Socket的封包、拆包" class="headerlink" title="Socket的封包、拆包"></a>Socket的封包、拆包</h2><p><strong>基于TCP的通信程序需要封包、拆包的原因</strong></p>
<p>TCP是流协议，所谓流，就是没有界限的一串数据。但是程序中却有多种不同的数据包，那就很可能会出现如上所说的粘包问题，所以就需要在发送端封包，在接收端拆包。</p>
<p><strong>那么如何封包、拆包</strong></p>
<p>封包就是给一段数据加上包头或者包尾。比如说我们上面为解决粘包所使用的两种方法，其实就是封包与拆包的具体实现。</p>
<h2 id="断线重连（缺详细"><a href="#断线重连（缺详细" class="headerlink" title="断线重连（缺详细"></a>断线重连（缺详细</h2><p>当检测到客户端断线时，断开当前客户端 Socket；重新根据IP和端口号重建新的 Socket。当连接上服务器网关后，携带 token，向服务器发送断线重连协议。</p>
<h1 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/556920018">帧同步：原理与实现 - 知乎 (zhihu.com)</a></p>
<h2 id="什么游戏适合帧同步？"><a href="#什么游戏适合帧同步？" class="headerlink" title="什么游戏适合帧同步？"></a>什么游戏适合帧同步？</h2><ul>
<li>网络波动比较大（比如手机网络，可能在任何地方如公交高铁等）；</li>
<li>追求即时反馈（FPS、MOBA、SPT）；而且因为状态同步固有的这种技术特性，是以<u>一定的频率来进行数据同步的</u>，所以不管怎样优化它<u>都是会产生延迟的</u>。</li>
<li>控制大量游戏单位（RTS-即时战略类游戏）；因为如果采用状态同步控制大量游戏单位，为了对每一个游戏单位进行位置朝向，以及其他信息的同步，会产生<u>非常大的数据同步量</u></li>
</ul>
<h2 id="状态同步与帧同步从技术上来说有什么区别？"><a href="#状态同步与帧同步从技术上来说有什么区别？" class="headerlink" title="状态同步与帧同步从技术上来说有什么区别？"></a>状态同步与帧同步从技术上来说有什么区别？</h2><ol>
<li><p>帧同步</p>
<ul>
<li>可以总结为六个字：<strong>发操作、收操作</strong>，也就是说客户端发送的是操作，接收的也是操作，服务器在接收到客户端发送的操作后，不会做任何运算，而是以广播的形式将这个操作发送给同一房间里的所有玩家。</li>
<li>其他玩家<u>在接收到的操作后就会产生相应的画面表示</u>，比如玩家1发射了一颗子弹，那么在玩家2的客户端上就应该实例化一颗子弹出来，然后让颗子弹以一定的速度朝某一个方向发射，这就是帧同步的一个特点。</li>
<li>帧同步将所有运算都放在客户端去做其实有一个非常大的好处，就是它的<u>运算非常简洁</u>。因为就像在开发一个客户端游戏一样，服务器不需要做什么太多的工作，如果你是一个优秀的客户端开发者，就可以比较轻松的实现一个相对比较完善的帧同步框架。</li>
</ul>
</li>
<li><p>状态同步</p>
<ul>
<li><p>状态同步是<u>大型网游</u>普遍会采用的一种同步技术，它特点是客户端会向服务器发送一些指令；</p>
<p>比如在角色扮演类中从游戏的NPC那里买一些物品时，客户端会向服务器发送一个指令，指令中包括玩家ID、购买商品的ID号、商贩NPC的ID号，将这些信息传到服务器后，服务器会计算玩家的金钱是否足够，当前所处位置是否在NPC身边、NPC是否有这个物品等等</p>
<p>服务器会<u>做很多校验</u>，校验完以后才能确定玩家是否能购买物品，如果不能买，服务器就会给客户端下发一个交易失败的指令；可以购买，服务器则会下发：玩家在购买完商品以后，背包里面增加了哪些东西，或者减少了哪些东西的消息</p>
</li>
<li><p>状态同步的特点就是状态同步<strong>发送的是一些操作，接收的是一些状态</strong>，这些<u>状态数据可能会很大</u>，所以在同步时所要同步的数据量也会比较大；</p>
</li>
<li><p>状态同步的的好处就是<u>安全性比较好，反作弊能力比较强</u></p>
</li>
</ul>
</li>
</ol>
<h2 id="同样是控制100个游戏单位移动，帧同步与状态同步有什么区别"><a href="#同样是控制100个游戏单位移动，帧同步与状态同步有什么区别" class="headerlink" title="同样是控制100个游戏单位移动，帧同步与状态同步有什么区别"></a>同样是控制100个游戏单位移动，帧同步与状态同步有什么区别</h2><p><img src="https://pic3.zhimg.com/80/v2-38edbfa86c7898a4cedfc2b7d7301e46_720w.webp" alt="img"></p>
<blockquote>
<p>由于服务器发送的状态数据比较大，而且要定时发送，所以总共数据量很大；</p>
<p>而帧同步只发送操作+帧号，而且是一次性发送的，所以数据量小一些。</p>
</blockquote>
<h2 id="帧同步和状态同步比较"><a href="#帧同步和状态同步比较" class="headerlink" title="帧同步和状态同步比较"></a>帧同步和状态同步比较</h2><p><img src="https://pic1.zhimg.com/80/v2-62bdd816dd5f678652b0440a3832a670_720w.webp" alt="img"></p>
<ol>
<li><strong>服务器代码编写复杂程度</strong></li>
</ol>
<ul>
<li><p>帧同步</p>
<ul>
<li>帧同步的服务器代码编写相对来说比较简单，因为帧同步只是转发数据。</li>
</ul>
</li>
<li><p>状态同步</p>
<ul>
<li>因为状态同步的大量逻辑运算都是在服务器上进行的，所以如果你不是一个熟练的服务器开发者，你所要面对的第一个问题就是无法在服务器中调用Unity里的那些方便的API，比如计算坐标、计算朝向等等，这些都需要服务器程序员自己实现。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>客户端代码的编写复杂程度</strong></li>
</ol>
<ul>
<li><p>帧同步</p>
<ul>
<li>帧同步的客户端代码编写复杂程度比状态同步要复杂的多，帧同步必须要<strong>保证每个客户端的计算结果是完全一致</strong>的，比如游戏中常用的一些<u>随机数</u>，帧同步必须要保证所有玩家生成的随机数序列是相同的，所以在帧同步中字典是不能用的，因为字典是一个无序列表。</li>
<li>因为<u>数学和物理运算</u>都会牵涉到一些浮点数，而浮点数是具有不稳定性、不精确性的，所以在帧同步中不能用传统的Unity里提供的那些数学和物理库了，必须自己实现一套。</li>
</ul>
</li>
<li><p>状态同步</p>
<ul>
<li>状态同步的逻辑都是在服务器上进行运算，所以就算服务器上有一些浮点数误差也没有关系，只要发给所有客户端的结果是一样的就行了</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>中途加入游戏</strong></li>
</ol>
<ul>
<li>帧同步<ul>
<li>帧同步要中途加入游戏需要<strong>追帧</strong>，所以一些采用帧同步的网络游戏大多都要一个很明显的特点，就是中途加入一局游戏时都需要等一会儿。</li>
</ul>
</li>
</ul>
<ul>
<li><p>状态同步</p>
<ul>
<li>因为状态同步是直接下发当前的角色状态，所以它不需要等待</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>服务器带宽要求</strong></li>
</ol>
<ul>
<li><p>帧同步对服务器带宽要求比较小，因为帧同步只需要传递操作</p>
</li>
<li><p>状态同步因为同步数据量比较大，所以对服务器带宽要求比较高</p>
</li>
</ul>
<ol start="5">
<li><strong>客户端体验</strong></li>
</ol>
<ul>
<li><p>帧同步的逻辑运算是在本地进行的，所以它的反应更加灵敏，打击感更强</p>
</li>
<li><p>状态同步的<strong>延迟相对要高一些</strong></p>
</li>
</ul>
<ol start="6">
<li><strong>反作弊</strong></li>
</ol>
<ul>
<li><p>帧同步在反作弊上是有点问题的，帧同步<strong>需要所有的客户端进行协作判定</strong>玩家作弊，所以比较容易出现一些很变态的外挂</p>
</li>
<li><p>状态同步就算有外挂，也大多是辅助性的外挂，危害性要稍微弱一些</p>
</li>
</ul>
<ol start="7">
<li><strong>离线战斗</strong></li>
</ol>
<ul>
<li>所谓的离线战斗就是不连服务器，也能进行战斗，帧同步很容易就能实现，因为帧同步本身的框架就是基于每一帧数据的，帧同步在进行离线战斗时会在客户端做一个虚拟的服务器，这个服务器会把客户端发送的数据发回给自己</li>
<li>状态同步要做离线战斗就不太容易</li>
</ul>
<ol start="8">
<li><strong>回放&amp;观战</strong></li>
</ol>
<p>帧同步的<strong>回放&amp;观战</strong>比状态同步好做得多，因为只需要保存每局所有人的操作就好了，</p>
<p>而状态同步的回放&amp;观战，需要有一个回放&amp;观战服务器，当一局战斗打响，战斗服务器在给客户端发送消息的同时，还需要把这些消息发给放&amp;观战服务器，回放&amp;观战服务器做储存，如果有其他客户端请求回放或者观战，则回放&amp;观战服务器把储存起来的消息按时间发给客户端。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>帧同步（LockStep）</th>
<th>状态同步</th>
</tr>
</thead>
<tbody><tr>
<td>确定性</td>
<td>严格确定</td>
<td>允许小误差，定时纠正误差数据</td>
</tr>
<tr>
<td>表现与响应速度</td>
<td>传统严格帧锁定要等其他客户端消息全部到达，响应比较慢；乐观帧锁定可以做到本地立刻响应，但是需要回滚的时候，体验就没那么好了</td>
<td>一般会做预测，可以做到立刻响应。不做预测的话，响应时间是一个往返时间（RTT）</td>
</tr>
<tr>
<td>带宽与流量</td>
<td>带宽随人数增加而增加，不适合MMO</td>
<td>需要发送各种状态数据，带宽占用比较高。可以通过压缩、裁剪、增量等方式优化。人数较少时候不如帧同步省流量</td>
</tr>
<tr>
<td>网络延迟适应性</td>
<td>要求较低的延迟。如果延迟较高，所有玩家体验都不好。即使采用乐观帧锁定优化，高延迟下也容易产生卡顿</td>
<td>适应性较高，方便做各种插值优化。当然高延迟下，也容易产生位置突变</td>
</tr>
<tr>
<td>开发难度</td>
<td>初期开发减法，框架容易实现，但是后期解决bug和完善系统很困难。比如浮点数、随机数、执行顺序导致计算结果不一致，问题很难排查</td>
<td>框架比较复杂，客户端服务端一套代码，每个功能都需要客户端服务端联调。问题定位比较容易。也会出现时序问题</td>
</tr>
<tr>
<td>玩家数量</td>
<td>适合少量的玩家，比如ACT、MOBA</td>
<td>可多可少</td>
</tr>
<tr>
<td>跨平台</td>
<td>不适合跨平台，会有浮点数问题，可以用定点数来将误差控制在一个可接受范围，同时可以定时纠正结果</td>
<td>适合。有权威服务器</td>
</tr>
<tr>
<td>反外挂</td>
<td>P2P架构不适合反外挂，如果引入战斗服务器来校验各个客户端结果，可以解决常见外挂，但是透视和全图视野防不了</td>
<td>与服务器加入校验机制，可以起到比较好的反外挂效果。但是一样防不了透视外挂</td>
</tr>
<tr>
<td>中途加入和断线重连</td>
<td>比较复杂。可以在断线的时候，通过快捷播放服务器同步的帧数据来快速跟上游戏</td>
<td>容易。由于实时记录了各个对象的状态信息，所以重连的时候，直接创建这些对象，并同步信息即可</td>
</tr>
<tr>
<td>性能（客户端）</td>
<td>客户端要跑完整逻辑，还要执行渲染逻辑，开销比较大</td>
<td>可以灵活优化，客户端跑较少逻辑</td>
</tr>
<tr>
<td>回放（离线）</td>
<td>本身收集了所有玩家的输入信息进行逻辑推进，天然支持回放，且回放文件比较小</td>
<td>可以支持回放，但是逻辑比较复杂，需要不断记录状态信息，同时回放时候需要读取合适的时间。回放文件大</td>
</tr>
<tr>
<td>回放（实时）</td>
<td>比较复杂，客户端需要本地对全场状态进行序列化，才能回到目标时间。播完回放后还需要加速追上实时游戏状态</td>
<td>相对容易，可以方便的记录快照信息，并按照录制内容随时播放</td>
</tr>
</tbody></table>
<h2 id="帧同步基本原理"><a href="#帧同步基本原理" class="headerlink" title="帧同步基本原理"></a>帧同步基本原理</h2><p><img src="/2023/02/23/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/hexo_github_blog\source_posts\知识梳理-计算机网络.assets\image-20230906232135570.png" alt="image-20230906232135570"></p>
<ul>
<li><p>假设在帧同步游戏中，两个玩家匹配到一个房间里，客户端与服务器约定的<strong>数据同步频率为每五帧同步一次</strong>，这时服务器需要<strong>发送初始帧</strong>给客户端A和客户端B，告诉它们游戏可以开始了，初始帧在上图中用UPDATE0表示，服务器给客户包发的都是UPDATE，序号表示它是第几帧的数据。</p>
</li>
<li><p>初始帧的同步数据发给两个客户端后就要开始准备了，让它们都<strong>处于相同的准备状态</strong>，客户端收到服务器发送的初始帧消息还要<strong>以每五帧同步一次的频率给服务器发送消息</strong>，上图中的CTRL0就是客户端发给服务器的第0帧操作</p>
</li>
<li><p>客户端A和客户端B在第5帧开始之前，已经把它们的操作发送到服务器去了，也就是说服务器<strong>在5帧延迟以内收到了A和B的操作</strong>，这时服务器就会将A和B的操作进行<strong>打包，再发回给所有的客户端</strong>，客户端A会同时收到A和B的操作，客户端B也一样，它们会根据服务器发送的数据来进行运算</p>
</li>
<li><p>比如客户端A发了移动消息而客户端B没有任何的操作，客户端B也要发送这一帧没有操作的消息到服务器，服务器收到后，会把这些消息再转发给所有客户端，客户端收到服务器发出的消息后就要表现客户端A的玩家和客户端B的玩家在这些操作下的动作，如果没有操作就不动</p>
</li>
<li><p>以上就是第一帧画面的同步过程，同步完以后咱们就开始同步第2帧画面，在同步第2帧画面时由于客户端B的网络比较好，它立刻就把操作发到了服务器，而客户端A的网络不太好，发生了延迟，延迟到第十帧画面以后了</p>
<p>也就是说服务器在第10帧的位置上只收到了一个玩家的数据，这样它就不能够把数据发送给客户端，<u>必须要等到玩家A发过来的数据后，才把这些数据发给玩家A和玩家B</u>，这就是为什么帧同步会产生等待的原因</p>
</li>
</ul>
<h2 id="一套完整的帧同步游戏框架要实现什么？"><a href="#一套完整的帧同步游戏框架要实现什么？" class="headerlink" title="一套完整的帧同步游戏框架要实现什么？"></a>一套完整的帧同步游戏框架要实现什么？</h2><h3 id="可靠UDP"><a href="#可靠UDP" class="headerlink" title="可靠UDP"></a>可靠UDP</h3><ul>
<li><p><strong>TCP协议</strong>为了保证数据的时序性、重传机制、应答机制、粘包机制，<strong>会有50毫秒的默认数据延迟</strong>，比如有一些只有一个字节的数据包，这时TCP协议如果一个字节，一个字节的发，那么它本身的数据包裹大小就比这个一个字节的数据包要大得多，所以TCP协议有一个粘包机制；</p>
<p><strong>粘包机制</strong>不是一个缺点，而是一个特性，它会等待50毫秒，然后将这50毫米以内的小数据包合并成一个包发送；</p>
</li>
<li><p>这就是TCP协议的问题，要解决这个问题需要有可靠UDP协议，可靠UDP协议可以说是UDP协议的升级版，因为UDP协议本身不能保证时序性，不能进行数据校验和重传，也没有应答机制，不能确定数据的顺序，但是UDP的一个好处就是<strong>没有最小延迟</strong></p>
</li>
<li><p>可靠UDP就是在UDP协议上增加一些东西，来实现时序性、重传机制、以及应答机制</p>
</li>
</ul>
<h3 id="确定性的数学和物理运算"><a href="#确定性的数学和物理运算" class="headerlink" title="确定性的数学和物理运算"></a>确定性的数学和物理运算</h3><ul>
<li>十进制浮点数无法精确转换为二进制；0.1转化为二进制是：0.0001 1001 1001…（无限循环）</li>
<li>浮点数运算对位；0.1 + 0.2 &#x3D; 0.30…..04；</li>
<li>因为Unity所有的物理、导航、动画、碰撞全部<u>基于浮点数运算</u>的，所以我们必须要自己实现一套能够精确运算浮点数的运算库，另外如果仅仅只是实现浮点数的优化并不能达到多个客户端完全同步的目的，还必须要<u>保证随机数一致</u>，你使用的<u>容器在存储数据时的顺序必须一致</u></li>
</ul>
<p>解决方法：</p>
<ol>
<li>取整计算法</li>
</ol>
<ul>
<li>这个问题可以通过取整计算法来解决，但这种方法也有一点小问题</li>
<li>取整计算法把浮点数取整后的精确性是有误差的</li>
</ul>
<ol start="2">
<li>容许小概率的误差</li>
</ol>
<p>在初始开发时可以允许小概率的误差，出现问题时只要在服务器上给点补偿就行了</p>
<ol start="3">
<li>逻辑表现分离</li>
</ol>
<p>可以允许表现层使用浮点数有误差，只需要保证逻辑层没有误差</p>
<h3 id="断线重连"><a href="#断线重连" class="headerlink" title="断线重连"></a>断线重连</h3><p><img src="https://pic2.zhimg.com/v2-bd6ea6117ebca7b2dd7be972d9950415_b.webp" alt="动图"></p>
<ul>
<li>上图是两个玩家的游戏画面，左边是玩家1，右边是玩家2</li>
<li>可以看到玩家1在进行断线重连后通过追帧重新演算到了当前帧的游戏状态，追到当前帧后，玩家1与玩家2又可以进行同步移动了</li>
</ul>
<h3 id="比赛回放"><a href="#比赛回放" class="headerlink" title="比赛回放"></a>比赛回放</h3><ul>
<li>服务器记录关键帧</li>
<li>下发客户端回放</li>
</ul>
<h3 id="反作弊"><a href="#反作弊" class="headerlink" title="反作弊"></a>反作弊</h3><h3 id="避免等待"><a href="#避免等待" class="headerlink" title="避免等待"></a>避免等待</h3><ul>
<li>乐观帧锁定</li>
</ul>
<p>针对传统严格<u>帧锁定</u>算法中，<u>网速慢会卡到网速快</u>的问题，实践中线上动作游戏通常用“<strong>定时不等待</strong>”的乐观方式在每次固定Interval时钟发生时就广播操作给所有用户，不依赖具体每个玩家是否有操作更新：</p>
<ol>
<li>单个用户当前键盘上下左右攻击跳跃是否按下用一个32位整数描述，服务端描述一局游戏中最多8玩家的键盘操作为：int player_keyboards[8];</li>
<li>服务端每秒钟20-50次向所有客户端发送更新消息（包含所有客户端的操作和递增的帧号）：</li>
<li>update&#x3D;（FrameID，player_keyboards）</li>
<li><strong>客户端就像播放游戏录像一样不停的播放这些包含每帧所有玩家操作的 update消息</strong>。</li>
<li>客户端如果<u>没有update数据了，就必须等待，直到有新的数据到来。</u></li>
<li>客户端如果<u>一下子收到很多连续的update，则快进播放</u>。</li>
<li><strong>客户端只要按键按下或者放开，就会发送消息给服务端</strong>（而不是到每帧开始才采集键盘），消息只包含一个整数。服务端收到以后，改写player_keyboards</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20190419153328311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW5nZ3VpbG9uZzIwMDA=,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>虽然网速慢的玩家网络一卡，可能就被网速快的玩家给秒了（其他游戏也差不多）。但是网速慢的玩家不会卡到快的玩家，只会感觉自己操作延迟而已。</p>
<ul>
<li><strong>同步的实现</strong><ol>
<li>同步随机种子</li>
<li>客户端上传<u>当前逻辑帧</u>的<u>操作</u>(帧索引+游戏操作)</li>
<li>服务器广播客户端操作</li>
</ol>
</li>
</ul>
<p>帧同步可以说同步的是操作(输入)，服务器收到每个客户端当前的输入，将数据广播到所有客户端，客户端针对其他客户端的操作，做出逻辑处理，使得所有客户端在每一时刻的数据都是一致的。</p>
<ul>
<li><p>优点</p>
<ol>
<li>单次同步数据很小，传输速率快，因为数据的逻辑处理主要是在客户端，服务器只起到分发同步的作用。<br>服务端压力小。</li>
<li>更容易实现录像功能，因为是帧同步，每一个时刻的帧序列都有记录，可以很好的还原游戏过程。</li>
<li>开发效率高，可以部分当作单机游戏来开发。</li>
<li>游戏精准度更高，能呈现更好的打击感、音效、特效等反馈、以及动作的反馈、动作的频率也可以更高。</li>
<li>流量消耗小，因为传输的数据量更少。大部分逻辑处理都在客户端处理好了。</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li><p>反外挂能力弱。因为主要的数据处理是在客户端。</p>
</li>
<li><p>网络要求更高，因为是实时同步，一旦客户端网络延迟过高，很容易影响用户体验，产生网络抖动。</p>
</li>
<li><p>断线重连难度很大，因为一旦掉线，本地数据丢失了，需要从服务器逐帧来读取游戏进度，直到与当前游戏进度一致。如果直接从当前游戏进度开始进行同步，是很容易出现数据错误的。</p>
</li>
</ol>
</li>
</ul>
<h1 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/357973435">【网络同步】浅析帧同步和状态同步 - 知乎 (zhihu.com)</a></p>
<p>概念以及优缺点在帧同步有提到，这里主要记录状态同步的优化技术。</p>
<p>首先问个问题：网络同步优化到底在优化什么？</p>
<ul>
<li>在单机游戏，我们从按下按键到画面响应，中间经历了：<strong>采样延迟、渲染流水线、刷新延迟、显示延迟</strong>等</li>
<li>在网络游戏，我们从按下按键到另一个机器收到指令，则会经历一个极为耗时的<strong>网络延迟</strong></li>
<li>网络延迟其实包括<strong>处理延迟、传输延迟（主要延迟）、排队延迟、传播延迟</strong>等</li>
</ul>
<p>我们进行网络同步优化，主要是想将网络延迟进行优化。</p>
<h2 id="表现优化"><a href="#表现优化" class="headerlink" title="表现优化"></a>表现优化</h2><p>表现优化主要是想弱化玩家对延迟的感受。</p>
<h3 id="插值优化"><a href="#插值优化" class="headerlink" title="插值优化"></a>插值优化</h3><p>在状态同步中，由于客户端每次收到的是其他角色的位置信息，为了避免位置突变，客户端会采用插值技术，让表现更平滑，而不是跳帧。</p>
<ul>
<li>内插值的目的是解决客户端离散信息更新导致的突变问题。（？？</li>
<li>外插值的目的是解决网络延迟过大或者抖动导致间歇性收不到数据的卡顿问题。（？？</li>
<li>两种方案不冲突，可以同时采用</li>
</ul>
<p>具体应用的时候，可以用使<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MjM5OTc2ODUxMw==&mid=2649723567&idx=2&sn=ec946eef347c5768f05a67160f1dfe97&scene=21%23wechat_redirect">逻辑帧和渲染帧分离</a></p>
<h3 id="客户端预测-回滚"><a href="#客户端预测-回滚" class="headerlink" title="客户端预测+回滚"></a>客户端预测+回滚</h3><p>MMORPG服务器承载了整个场景服所有对象的大量逻辑运算，所以服务器的tick时间往往是100ms级别，精度有限，</p>
<p>而客户端frameTick&lt;&#x3D;逻辑tick&lt;&#x3D;50ms，在动画表现时更需要20ms以下的精度，再考虑到50-100ms的网络延迟，主角的操作如果等待服务器返回是会有明显延迟感的。</p>
<ul>
<li>预测的目的是让玩家输入后，本地立刻收到反馈，提高游戏体验</li>
<li>回滚是为了保证服务器的权威性</li>
</ul>
<p>关于预测，就是本地先执行。</p>
<p>把玩家本地预执行的指令都记录好时间戳并存放到一个Move_Buffer列表里（类似滑动窗口）。在添加了时间戳条件下，收到了一条过时的服务器位置数据。</p>
<ul>
<li>如果玩家本地预测结果与服务器几乎一致，服务器回复一个ACKMOVE。客户端把Move_Buffer列表中对应数据清除</li>
<li>如果预测结果与服务器不一致：需要本地回滚到服务器指定位置，把错误时刻后面的Move_Buffer列表指令执行一遍</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-78eebb397049bfe060f2c12477f6e1a1_720w.webp" alt="img"></p>
<h2 id="延迟对抗"><a href="#延迟对抗" class="headerlink" title="延迟对抗"></a>延迟对抗</h2><h3 id="延迟补偿（？"><a href="#延迟补偿（？" class="headerlink" title="延迟补偿（？"></a>延迟补偿（？</h3><p>延迟补偿就是弥补客户端到服务器同步延迟的一项技术，核心就是<strong>服务器</strong>在指定时刻对玩家角色进行位置回滚与计算处理。</p>
<p>实现方式：服务端会定时记录所有玩家位置。假设客户端到服务端的延迟为Xms，当服务端收到客户端操作后，服务端使用记录的Xms前所有玩家位置来计算是否命中，从而抵消延迟带来的问题</p>
<p>延迟补偿缺陷：使用延迟补偿要考虑游戏类型。不适合ACT网游</p>
<h3 id="命令缓冲区"><a href="#命令缓冲区" class="headerlink" title="命令缓冲区"></a>命令缓冲区</h3><p>把远端数据缓存在一个buffer里面，然后按照固定频率从buffer里面取，可以解决客户端卡顿以及网络抖动问题。</p>
<p>不过缓冲区和延迟是有冲突的，缓冲区越大，证明我们缓存远端数据越多，延迟越大！</p>
<h3 id="假表现"><a href="#假表现" class="headerlink" title="假表现"></a>假表现</h3><p>真实开发环境下，我们可以根据游戏的具体情况，加一些前摇动画来掩盖延迟。比如在无敌状态前播一个前摇动画等。</p>
<h2 id="丢包对抗"><a href="#丢包对抗" class="headerlink" title="丢包对抗"></a>丢包对抗</h2><h3 id="使用TCP"><a href="#使用TCP" class="headerlink" title="使用TCP"></a>使用TCP</h3><p>TCP不会丢包，对于延迟不敏感的游戏，优先采用TCP</p>
<h3 id="冗余UDP数据包"><a href="#冗余UDP数据包" class="headerlink" title="冗余UDP数据包"></a>冗余UDP数据包</h3><p>一次性发送多个帧的数据来对抗丢包。</p>
<p>对于数据量比较小的游戏，可以采用冗余UDP的方案，即后续的UDP包会冗余一定量前面已发送的UDP包。</p>
<h2 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h2><p>带宽优化的目的是减小客户端及服务器的同步压力。</p>
<h3 id="同步对象裁剪"><a href="#同步对象裁剪" class="headerlink" title="同步对象裁剪"></a>同步对象裁剪</h3><p>剔除不需要同步的对象。比如一个玩家离我很远，远到他的任何行为都不会影响到我，那我们就可以把他剔除，不进行同步给我，我不关心他的任何数据。</p>
<p>常见的裁剪方式有很多：SOI（Spheres Of Influence）、静态区域（把场景划分成多个区域，不在一个区域不同步）、视椎裁剪、八叉树裁剪、<a href="https://link.zhihu.com/?target=https://blog.codingnow.com/2012/03/dev_note_13.html">AOI（Area Of Interest）</a></p>
<p>着重讲一下AOI（Area Of Interest）：根据玩家位置，维护一个动态的视野列表，视野外的对象会被完全忽略。实现方式有很多，常见的是基于格子的空间划分算法。<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/56922476">虚幻引擎的大世界同步框架ReplicationGraph</a>核心思想也是这个</p>
<h3 id="分区分房间"><a href="#分区分房间" class="headerlink" title="分区分房间"></a>分区分房间</h3><p>对于大型MMO来说，这是常见手段。将不同玩家分散到不同场景（不同服务器），这样可以减小服务器压力，降低延迟。但是也带来了跨服数据同步的问题</p>
<h3 id="数据压缩和裁剪"><a href="#数据压缩和裁剪" class="headerlink" title="数据压缩和裁剪"></a>数据压缩和裁剪</h3><p>坐标和旋转是我们场景的同步内容，但很多数据是不需要同步的。比如旋转的话，如果只需要一个Y轴旋转，我们可以传个float，而不是vector。比如我们可以压缩浮点数的精度。</p>
<p>然后对于状态同步，可以采用<u>增量发送？</u>的方式来减少数据量</p>
<h3 id="减少遍历和更细粒度的优化"><a href="#减少遍历和更细粒度的优化" class="headerlink" title="减少遍历和更细粒度的优化"></a>减少遍历和更细粒度的优化</h3><p>对同步对象做优先级划分，发送频率调整等。</p>
<h2 id="帧率优化"><a href="#帧率优化" class="headerlink" title="帧率优化"></a>帧率优化</h2><h3 id="提升帧率"><a href="#提升帧率" class="headerlink" title="提升帧率"></a>提升帧率</h3><p>不同游戏的性能瓶颈不同，需要具体分析，包括：内存问题（GC、频繁申请与释放）、IO（资源加载、频繁读写文件，网络包发送频率过大，频繁读取数据库）、逻辑问题（大量遍历循环、无意义的Tick、过多的锁、高频率Log）、AI（寻路耗时）、物理问题（复杂模拟、碰撞检测）、语言特性等，客户端还有各种复杂的渲染问题（Draw Call太多，半透明，动态阴影），不断地优化，才能把帧率提高和稳定</p>
<h3 id="保持帧率稳定和匹配"><a href="#保持帧率稳定和匹配" class="headerlink" title="保持帧率稳定和匹配"></a>保持帧率稳定和匹配</h3><p>保持服务器帧率稳定</p>
<h3 id="分摊计算压力"><a href="#分摊计算压力" class="headerlink" title="分摊计算压力"></a>分摊计算压力</h3><p>对于MMO这种服务器压力比较大的游戏，可以把一些复杂计算转交给客户端进行计算（甚至计算后返还给服务端），比如物理、寻路、AI等。</p>
<h1 id="如何考虑状态同步还是帧同步"><a href="#如何考虑状态同步还是帧同步" class="headerlink" title="如何考虑状态同步还是帧同步"></a>如何考虑状态同步还是帧同步</h1><ul>
<li><p><strong>服务器难度</strong>：帧同步与状态同步相比，服务器要简单很多，而且服务器的项目可以高度重用，因为写好一个游戏的服务端帧同步，下一个游戏的服务器基本不用改，所以腾讯推出一些服务端的集成方案就有帧同步的服务器，每个游戏项目都可以用, 做到服务端高度重用。</p>
</li>
<li><p><strong>操作手感</strong>：帧同步与状态同步相比，帧同步更平滑,不会有一些峰值，这样导致玩家的手感一直很好，什么叫做峰值，状态同步，突然某个时刻状态变化比较多，同步的数据量大，网络和处理可能会有瞬间的卡顿，而这种可能就影响关键时候的手感,帧同步在这块就更平滑。每次只要同步玩家的操作，数据包更小。所以一些强调操作手感的游戏是可以用帧同步来做的。</p>
</li>
<li><p><strong>客户端计算量</strong>：帧同步每一个玩家对应的角色都要在客户端计算迭代,而不像状态同步只迭代视野范围内的，所以帧同步对客户端的运算量会变大，同时帧同步不能适用在同时3000人一起玩的游戏，因为3000个角色都要在客户端，每帧都同时迭代计算，客户端性能达不到。所有MMORPG, 这种游戏基本都不采用帧同步，采用帧同步的都是固定一起对战的人数的，如王者荣耀5v5, 守望先锋等。</p>
</li>
<li><p><strong>单局游戏时长</strong>：帧同步每次同步都是当前帧依赖前一帧,每次断线重连，只能从第1帧开始迭代计算，快速的跳到最新的帧，所以采用帧同步的游戏一局的时间不能太长。</p>
</li>
</ul>
<h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>序列化 ：将对象状态转化为<strong>可保持</strong>或者<strong>可传输</strong>的格式的过程。</p>
<p>反序列化 ：将已经序列化过后的数据恢复成原先对象的过程。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p> 指可扩展标记语言（eXtensible Markup Language）。是一种通用和重量级的数据交换格式。以文本结构存储。</p>
<ul>
<li><p>优点：</p>
<ol>
<li>格式更为标准和统一</li>
<li>更容易和其它系统进行远程交互</li>
<li>数据共享比较方便</li>
</ol>
</li>
<li><p>缺点：</p>
<p>相比于JSON，由于需要成对的数据标签，数据更加的冗余。 而JSON使用键值对，压缩了数据空间并且更加可读。</p>
</li>
</ul>
<h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>是一种通用和轻量级的数据交换格式。以文本结构存储。</p>
<ul>
<li>优点： <ol>
<li>简单易用开发成本低</li>
<li>跨语言</li>
<li>轻量级数据交换</li>
<li>非冗长性（对比xml标签简单括号闭环）</li>
</ol>
</li>
<li>缺点：<ol>
<li>体积大，影响高并发</li>
<li>无版本检查，自己做兼容</li>
<li>片段的创建和验证过程比一般的XML复杂</li>
<li>缺乏命名空间导致信息混合</li>
<li>没有XML格式这么推广的深入人心和使用广泛,没有XML那么通用性</li>
</ol>
</li>
</ul>
<p>总结：最简单最通用的应用协议，使用广泛，开发效率高，性能相对较低，维护成本较高。</p>
<h3 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h3><p>protocol buffer是Google的一种独立和轻量级的数据交换格式。以<strong>二进制结构</strong>进行存储。</p>
<p>Protobuf是一种以有效并可扩展的格式编码结构化数据的方式。</p>
<p>三者比较：</p>
<ul>
<li>json：一般的web项目中，最流行的主要还是json。因为浏览器对于json数据支持非常好,有很多内建的函数支持。</li>
<li>xml：在webservice中应用最为广泛，但是相比于json，它的数据更加冗余，因为需要成对的闭合标签。json使用了键值对的方式，不仅压缩了一定的数据空间，同时也具有可读性。</li>
<li>protobuf：是后起之秀，是谷歌开源的一种数据格式，适合高性能，对响应速度有要求的数据传输场景。因为profobuf是二进制数据格式，需要编码和解码。数据本身不具有可读性。因此只能反序列化之后得到真正可读的数据。</li>
</ul>
<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>进程：一个应用程序相当于一个进程，是操作系统资源分配的基本单位。 一个进程拥有多个线程。更安全。</p>
<p>线程：是程序的实际执行者。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，一个线程只有一个进程。效率高。</p>
<p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<h2 id="什么是线程争用"><a href="#什么是线程争用" class="headerlink" title="什么是线程争用"></a>什么是线程争用</h2><p>因为进程中可存在多个线程，线程间均可访问主线程资源。所以若线程间争抢资源，可能导致数据混乱。 </p>
<h2 id="如何解决线程争用-？"><a href="#如何解决线程争用-？" class="headerlink" title="如何解决线程争用(？ )"></a>如何解决线程争用(？ )</h2><p>  只要避免同一时间只有一个线程来访问共享数据就OK了。</p>
<p>​    1.Monitor（监控器）</p>
<p>​    2.Lock，是对Monitor的封装，简单易用。</p>
<h2 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h2><p><img src="https://img-blog.csdnimg.cn/a420b296934a4d389c1bce542fba3929.png" alt="img"></p>
<h2 id="前台线程和后台线程"><a href="#前台线程和后台线程" class="headerlink" title="前台线程和后台线程"></a>前台线程和后台线程</h2><ul>
<li><p>线程有两种：前台线程和后台线程。</p>
<p>区别是：应用程序必须运行完所有的前台线程才可以退出；而对于后台线程，应用程序则可以不考虑其是否已经运行完毕而直接退出，所有的后台线程在应用程序退出时都会自动结束。</p>
</li>
<li><p>.net环境使用Thread 建立的线程默认情况下是前台线程，即线程属性IsBackground&#x3D;false。</p>
<p><u>在进程中</u>，只要有一个前台线程未退出，进程就不会终止。<strong>主线程</strong>就是一个<strong>前台线程</strong>。</p>
<p> 而后台线程不管线程是否结束，只要所有的前台线程都退出（包括正常退出和异常退出）后，进程就会自动终止。</p>
</li>
<li><p>使用方法</p>
<p>一般后台线程用于处理时间较短的任务，如在一个Web服务器中可以利用后台线程来处理客户端发过来的请求信息。</p>
<p>而前台线程一般用于处理需要长时间等待的任务，如在Web服务器中的监听客户端请求的程序，或是定时对某些系统资源进行扫描的程序。</p>
</li>
<li><p>注意</p>
<p>在调用Start方法之前设置线程的类型，否则一但线程运行，将无法改变其类型。（还没在unity弄过线程？）</p>
</li>
</ul>
<h2 id="针对于效率与安全方面，两者区别"><a href="#针对于效率与安全方面，两者区别" class="headerlink" title="针对于效率与安全方面，两者区别"></a><strong>针对于效率与安全方面，两者区别</strong></h2><p>线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。</p>
<p>进程执行开销大，但是能够很好的进行资源管理和保护。进程 可以跨机器前移。</p>
<p><strong>使用场景</strong>：</p>
<p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程；</p>
<p>对算力要求高的使用多进程，因为<u>操作系统分配的算力是按进程分配的</u>，一个进程内即使有再多的线程，也只能得到一个CPU核心的算力；</p>
<p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p>
<h1 id="并发-并行-异步-同步"><a href="#并发-并行-异步-同步" class="headerlink" title="并发&#x2F;并行&#x2F;异步&#x2F;同步"></a><strong>并发&#x2F;并行&#x2F;异步&#x2F;同步</strong></h1><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p><strong>一个处理器“同时”处理多个任务</strong>，CPU通过时间片切换轮流执行不同的任务。</p>
<p>进程的调度实际上就是实现了并发，相当于吃饭吃一半，停下来去接电话，接完再吃饭，只是过程很快，做到了像同时运行。</p>
<h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p><strong>“多个”处理器或者多核处理器同时处理多个任务</strong>，两个线程<strong>互不抢占CPU资源</strong>，可以同时执行任务。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>比如我上手机店买手机，服务员去仓库拿手机，要花一分钟，我趁这一分钟才去买水喝，然后回来刚好拿到手机。</p>
<p>这个过程就是当程序遇到阻塞，需要等待的时候，程序会先执行其他任务，完成任务后回来，刚好上个任务也已经完成，可以提高效率。</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>比如我上手机店买手机，服务员去仓库拿手机，要花一分钟，我等了一分钟后拿到手机才去买水喝。这个过程就是当程序遇到阻塞，需要等待的时候，程序会一直等待阻塞解除或者运行完后才进行下一步执行。</p>
<h1 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h1><h2 id="什么是网络抖动"><a href="#什么是网络抖动" class="headerlink" title="什么是网络抖动"></a>什么是网络抖动</h2><p>如果网络发生拥塞，排队延迟将影响端到端的延迟，并导致通过同一连接传输的分组延迟各不相同，而抖动，就是用来描述这样一延迟变化的程度。</p>
<p>他是网络延时变化，最大延迟与最小延迟的时间差；</p>
<p>如最大延迟是20毫秒，最小延迟为5毫秒，那么网络抖动就是15毫秒，它主要标识一个网络的稳定性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huangxinhere.github.io">(●ˇ∀ˇ●)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://huangxinhere.github.io/2023/02/23/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huangxinhere.github.io" target="_blank">Hx's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/02/28/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">操作系统</div></div><div class="info-2"><div class="info-item-1">什么是操作系统操作系统：操作系统概述 - 知乎 (zhihu.com) 定义定义一： 操作系统（Operating System, OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。（之前只是一个裸机） 定义二： 操纵系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的合集。 目标和功能 目标 其主要目标是：方便性（方便用户使用）、有效性(提高系统资源利用率&amp;提高系统的吞吐量)、可扩充性（适应硬件的发展）和开放性（更多的兼容）。 有效性的两层含义：① 提高系统资源的利用率（因为以前各种设备都经常处于空闲状态）② 提高系统的吞吐量（合理组织计算机的工作流程，加速程序运行）  功能（为了实现目标） （1） 作为用户与计算机硬件系统之间的接口 ​            【程序接口（应用程序）&#x2F; 命令接口（用户直接操作，底层命令） &#x2F;  GUI图形用户（命令可视化 ）】 （2） 作为计算机系统资源的管理者 ​           【处理机管理 &#x2F; 存储器管理 &#x2F; I&#x2F;O...</div></div></div></a><a class="pagination-related" href="/2023/02/22/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" title="数据结构与算法"><img class="cover" src="/img/%7D7Y%5B5BZE_KJVDX6TI%5D$9CY1.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">数据结构与算法</div></div><div class="info-2"><div class="info-item-1">数组栈和队列 求最大k值：小根堆优先队列；快排  链表 前驱和后继：前驱就是指逻辑上前一个结点，后继就是逻辑上后一个结点，如果用位号的观点看，前驱就是当前结点的位号-1，后继就是当前结点的位号+1。  树二叉树的概念和性质遍历先序遍历：左根右； 中序遍历：根左右； 后序遍历：左右根；  哪两种遍历方式可以确定一棵树？  先序遍历 + 中序遍历 后序遍历 + 中序遍历 先序遍历 + 后序遍历（不可行）  先序遍历和后序遍历对于我们组建一个二叉树所能提供的信息都只是根节点，我们依次拿着根节点去中序遍历分割左子树和右子树，在通过递归组成整颗树。  如果两两组合的序列相同 二叉树：前序与后序、前序与中序以及中序与后序相同、相反的特征_前序和中序_乐行僧丶的博客-CSDN博客   基本运算 创建 查找 寻找左右孩子 求高度 输出二叉树  二叉树的构造 序列还原二叉树  二叉树表达式  线索二叉树  哈夫曼树 数据结构——哈夫曼树（Huffman Tree） - 知乎 (zhihu.com)  最小带权路径长度的二叉树（路径×结点值），较大的结点离根较近；  结点的带权路径长度为：从根结点到...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">(●ˇ∀ˇ●)</div><div class="author-info-description">该博客暂时停止维护，新博客传送门：https://juejin.cn/user/3598037753539256</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.</span> <span class="toc-text">网络游戏服务器技术栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-IP%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%90%84%E4%B8%AA%E5%B1%82%E6%AC%A1%E5%8F%8A%E5%88%86%E5%88%AB%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP协议栈各个层次及分别的功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">运输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%EF%BC%9A%E4%B8%89%E6%8F%A1%E5%9B%9B%E6%8C%A5"><span class="toc-number">3.2.</span> <span class="toc-text">TCP运输连接管理：三握四挥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">四次挥手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A8%B3%E5%AE%9A"><span class="toc-number">3.3.</span> <span class="toc-text">TCP 为什么稳定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B1%E5%BA%8F%E9%87%8D%E6%8E%92"><span class="toc-number">3.3.1.</span> <span class="toc-text">乱序重排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%AD%94%E7%A1%AE%E8%AE%A4"><span class="toc-number">3.3.2.</span> <span class="toc-text">应答确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E9%87%8D%E4%BC%A0"><span class="toc-number">3.3.3.</span> <span class="toc-text">报文重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.3.4.</span> <span class="toc-text">流量控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text">TCP拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E5%92%8C%E5%88%86%E5%8C%85"><span class="toc-number">3.5.</span> <span class="toc-text">粘包和分包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.5.2.</span> <span class="toc-text">产生原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">3.5.3.</span> <span class="toc-text">如何解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket%E7%9A%84%E5%B0%81%E5%8C%85%E3%80%81%E6%8B%86%E5%8C%85"><span class="toc-number">3.6.</span> <span class="toc-text">Socket的封包、拆包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%EF%BC%88%E7%BC%BA%E8%AF%A6%E7%BB%86"><span class="toc-number">3.7.</span> <span class="toc-text">断线重连（缺详细</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%A7%E5%90%8C%E6%AD%A5"><span class="toc-number">4.</span> <span class="toc-text">帧同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%B8%B8%E6%88%8F%E9%80%82%E5%90%88%E5%B8%A7%E5%90%8C%E6%AD%A5%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">什么游戏适合帧同步？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E4%BB%8E%E6%8A%80%E6%9C%AF%E4%B8%8A%E6%9D%A5%E8%AF%B4%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">状态同步与帧同步从技术上来说有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%A0%B7%E6%98%AF%E6%8E%A7%E5%88%B6100%E4%B8%AA%E6%B8%B8%E6%88%8F%E5%8D%95%E4%BD%8D%E7%A7%BB%E5%8A%A8%EF%BC%8C%E5%B8%A7%E5%90%8C%E6%AD%A5%E4%B8%8E%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">同样是控制100个游戏单位移动，帧同步与状态同步有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E6%AF%94%E8%BE%83"><span class="toc-number">4.4.</span> <span class="toc-text">帧同步和状态同步比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">帧同步基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%A5%97%E5%AE%8C%E6%95%B4%E7%9A%84%E5%B8%A7%E5%90%8C%E6%AD%A5%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">一套完整的帧同步游戏框架要实现什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%9D%A0UDP"><span class="toc-number">4.6.1.</span> <span class="toc-text">可靠UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E6%95%B0%E5%AD%A6%E5%92%8C%E7%89%A9%E7%90%86%E8%BF%90%E7%AE%97"><span class="toc-number">4.6.2.</span> <span class="toc-text">确定性的数学和物理运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E"><span class="toc-number">4.6.3.</span> <span class="toc-text">断线重连</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B%E5%9B%9E%E6%94%BE"><span class="toc-number">4.6.4.</span> <span class="toc-text">比赛回放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E4%BD%9C%E5%BC%8A"><span class="toc-number">4.6.5.</span> <span class="toc-text">反作弊</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%AD%89%E5%BE%85"><span class="toc-number">4.6.6.</span> <span class="toc-text">避免等待</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5"><span class="toc-number">5.</span> <span class="toc-text">状态同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">表现优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.1.</span> <span class="toc-text">插值优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A2%84%E6%B5%8B-%E5%9B%9E%E6%BB%9A"><span class="toc-number">5.1.2.</span> <span class="toc-text">客户端预测+回滚</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E5%AF%B9%E6%8A%97"><span class="toc-number">5.2.</span> <span class="toc-text">延迟对抗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E8%A1%A5%E5%81%BF%EF%BC%88%EF%BC%9F"><span class="toc-number">5.2.1.</span> <span class="toc-text">延迟补偿（？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.2.2.</span> <span class="toc-text">命令缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%A1%A8%E7%8E%B0"><span class="toc-number">5.2.3.</span> <span class="toc-text">假表现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85%E5%AF%B9%E6%8A%97"><span class="toc-number">5.3.</span> <span class="toc-text">丢包对抗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8TCP"><span class="toc-number">5.3.1.</span> <span class="toc-text">使用TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%97%E4%BD%99UDP%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">5.3.2.</span> <span class="toc-text">冗余UDP数据包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%AE%BD%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.</span> <span class="toc-text">带宽优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AF%B9%E8%B1%A1%E8%A3%81%E5%89%AA"><span class="toc-number">5.4.1.</span> <span class="toc-text">同步对象裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E5%88%86%E6%88%BF%E9%97%B4"><span class="toc-number">5.4.2.</span> <span class="toc-text">分区分房间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E5%92%8C%E8%A3%81%E5%89%AA"><span class="toc-number">5.4.3.</span> <span class="toc-text">数据压缩和裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%81%8D%E5%8E%86%E5%92%8C%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">5.4.4.</span> <span class="toc-text">减少遍历和更细粒度的优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A7%E7%8E%87%E4%BC%98%E5%8C%96"><span class="toc-number">5.5.</span> <span class="toc-text">帧率优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8D%87%E5%B8%A7%E7%8E%87"><span class="toc-number">5.5.1.</span> <span class="toc-text">提升帧率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E5%B8%A7%E7%8E%87%E7%A8%B3%E5%AE%9A%E5%92%8C%E5%8C%B9%E9%85%8D"><span class="toc-number">5.5.2.</span> <span class="toc-text">保持帧率稳定和匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%91%8A%E8%AE%A1%E7%AE%97%E5%8E%8B%E5%8A%9B"><span class="toc-number">5.5.3.</span> <span class="toc-text">分摊计算压力</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%B8%A7%E5%90%8C%E6%AD%A5"><span class="toc-number">6.</span> <span class="toc-text">如何考虑状态同步还是帧同步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">7.1.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%88"><span class="toc-number">7.2.</span> <span class="toc-text">方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XML"><span class="toc-number">7.2.1.</span> <span class="toc-text">XML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON"><span class="toc-number">7.2.2.</span> <span class="toc-text">JSON</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Protobuf"><span class="toc-number">7.2.3.</span> <span class="toc-text">Protobuf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%BA%89%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">什么是线程争用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E4%BA%89%E7%94%A8-%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">如何解决线程争用(？ )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.</span> <span class="toc-text">线程和协程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">前台线程和后台线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E6%95%88%E7%8E%87%E4%B8%8E%E5%AE%89%E5%85%A8%E6%96%B9%E9%9D%A2%EF%BC%8C%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">8.5.</span> <span class="toc-text">针对于效率与安全方面，两者区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C-%E5%BC%82%E6%AD%A5-%E5%90%8C%E6%AD%A5"><span class="toc-number">9.</span> <span class="toc-text">并发&#x2F;并行&#x2F;异步&#x2F;同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">9.1.</span> <span class="toc-text">并发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C"><span class="toc-number">9.2.</span> <span class="toc-text">并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5"><span class="toc-number">9.3.</span> <span class="toc-text">异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-number">9.4.</span> <span class="toc-text">同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%8A%96%E5%8A%A8"><span class="toc-number">10.</span> <span class="toc-text">网络抖动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E6%8A%96%E5%8A%A8"><span class="toc-number">10.1.</span> <span class="toc-text">什么是网络抖动</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A520250826-%E7%BD%91%E7%BB%9C%E7%A7%BB%E5%8A%A8%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="技术周报-网络移动能力的最佳实践"><img src="https://cdn.jsdelivr.net/gh/huangxinhere/hexo_img/img/20250816163511_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="技术周报-网络移动能力的最佳实践"/></a><div class="content"><a class="title" href="/2025/08/26/%E6%8A%80%E6%9C%AF%E5%91%A8%E6%8A%A520250826-%E7%BD%91%E7%BB%9C%E7%A7%BB%E5%8A%A8%E8%83%BD%E5%8A%9B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="技术周报-网络移动能力的最佳实践">技术周报-网络移动能力的最佳实践</a><time datetime="2025-08-25T16:00:00.000Z" title="发表于 2025-08-26 00:00:00">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/22/UE%E5%A4%9A%E4%BA%BA%E5%B0%84%E5%87%BBC++%EF%BC%881%EF%BC%89%E4%BA%92%E8%81%94%E7%BD%91%E8%81%94%E6%9C%BA%E8%AE%BE%E7%BD%AE/" title="UE与OnlineSubsystemSteam（OSS Steam）"><img src="https://cdn.jsdelivr.net/gh/huangxinhere/hexo_img/img/20250822000958_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE与OnlineSubsystemSteam（OSS Steam）"/></a><div class="content"><a class="title" href="/2025/08/22/UE%E5%A4%9A%E4%BA%BA%E5%B0%84%E5%87%BBC++%EF%BC%881%EF%BC%89%E4%BA%92%E8%81%94%E7%BD%91%E8%81%94%E6%9C%BA%E8%AE%BE%E7%BD%AE/" title="UE与OnlineSubsystemSteam（OSS Steam）">UE与OnlineSubsystemSteam（OSS Steam）</a><time datetime="2025-08-21T16:00:00.000Z" title="发表于 2025-08-22 00:00:00">2025-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/13/2024313-Unity-UI%EF%BC%882%EF%BC%89/" title="Unity-UI（2）"><img src="/img/unity.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-UI（2）"/></a><div class="content"><a class="title" href="/2024/03/13/2024313-Unity-UI%EF%BC%882%EF%BC%89/" title="Unity-UI（2）">Unity-UI（2）</a><time datetime="2024-03-12T16:00:00.000Z" title="发表于 2024-03-13 00:00:00">2024-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="Unity-性能优化"><img src="/img/unity.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-性能优化"/></a><div class="content"><a class="title" href="/2023/09/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="Unity-性能优化">Unity-性能优化</a><time datetime="2023-09-13T16:00:00.000Z" title="发表于 2023-09-14 00:00:00">2023-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E5%9B%BE%E5%BD%A2/" title="Unity-图形"><img src="/img/unity.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-图形"/></a><div class="content"><a class="title" href="/2023/09/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E5%9B%BE%E5%BD%A2/" title="Unity-图形">Unity-图形</a><time datetime="2023-09-12T16:00:00.000Z" title="发表于 2023-09-13 00:00:00">2023-09-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By (●ˇ∀ˇ●)</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统（二）：进程管理 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于操作系统的知识点整理">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统（二）：进程管理">
<meta property="og:url" content="https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="关于操作系统的知识点整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-03-26T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-26T08:01:19.887Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统（二）：进程管理",
  "url": "https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/",
  "image": "https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg",
  "datePublished": "2023-03-26T16:00:00.000Z",
  "dateModified": "2023-11-26T08:01:19.887Z",
  "author": [
    {
      "@type": "Person",
      "name": "(●ˇ∀ˇ●)",
      "url": "https://huangxinhere.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统（二）：进程管理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Hx's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">操作系统（二）：进程管理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">操作系统（二）：进程管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-26T16:00:00.000Z" title="发表于 2023-03-27 00:00:00">2023-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-26T08:01:19.887Z" title="更新于 2023-11-26 16:01:19">2023-11-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="前驱图、顺序执行与并发执行的特征"><a href="#前驱图、顺序执行与并发执行的特征" class="headerlink" title="前驱图、顺序执行与并发执行的特征"></a>前驱图、顺序执行与并发执行的特征</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43722079/article/details/108033191">(42条消息) 【OS笔记 5】前驱图、顺序执行与并发执行的特征_os 顺序执行 前驱图_Crayon小鱼干的博客-CSDN博客</a></p>
<p>顺序执行</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统.assets\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center.jpeg" alt="在这里插入图片描述"></p>
<p>并发执行</p>
<p><img src="https://img-blog.csdnimg.cn/20200816124803336.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>程序并发执行时的特征</li>
</ul>
<p>① 间断性<br>也就是一个程序的整个执行过程是“走走停停”的，由于共享资源，这些并发的程序相互制约，有时需要进行等待，造成了 “执行——暂停——执行” 的间断性活动规律。</p>
<p>② 失去封闭性<br>由于并发的程序之间共享系统资源，导致其中任一程序在运行时，其环境都必然会收到其它程序的影响，所以就失去了运行环境的封闭性。</p>
<p>③ 不可再现性<br>程序在并发执行时，由于失去了封闭性，从而也失去了不可再现性。换句话说，程序在多次执行后，虽然它们执行的环境和初始条件是相同的，但得到的结果却各不相同。<br>比如 A 和 B 两个程序共享变量N，A 中会让 N+1 ，B 中会让 N&#x3D;0 。那么 N 最后的数值肯定跟 A 和 B 执行的情况（比如执行顺序什么的）有关系。</p>
<p>此时还未引入进程的概念。如果每次执行的结果都不同，岂不是失去了程序的意义，因此，人们引入了“进程”的概念，并且设计了相应的进程同步机制，<u>使得程序在并发同时也能独立地运行</u>。【两个进程同时跑，但又可能得占用同样的资源，就会发生冲突】</p>
<h1 id="——进程是什么？——"><a href="#——进程是什么？——" class="headerlink" title="——进程是什么？——"></a>——进程是什么？——</h1><h1 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h1><ul>
<li>进程是程序的一次执行。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是 &#x2F; 具有独立功能的程序 &#x2F; 在一个数据集合上 &#x2F; 的运行过程，它是<u>系统进行资源分配和调度的一个独立单位</u>。</li>
<li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立过程。</li>
</ul>
<h1 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h1><p><strong>进程实体 &#x3D; 程序 + 数据 + PCB</strong></p>
<p>为了使参与并发执行的每个程序（含数据）都能独立运行，在操作系统中必须为之<u>配置一个专门的数据结构</u>，称为<strong>进程控制块</strong>（Process Control Block，<strong>PCB</strong>）。</p>
<p><strong>PCB 的作用：</strong> 描述进程的基本情况和活动过程，方便系统控制和管理进程。所谓创建进程，实质上是创建进程实体中的 PCB；而撤销进程，实质上是撤销进程的 PCB。</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230328122220686.png" alt="image-20230328122220686"></p>
<blockquote>
<p>程序段可被多个进程共享：一个应用开启多个线程时，数据不一样，但是程序相同，所以没必要再开辟新的内存来存放程序。</p>
</blockquote>
<h2 id="进程控制块PCB详解"><a href="#进程控制块PCB详解" class="headerlink" title="进程控制块PCB详解"></a>进程控制块PCB详解</h2><p>【PCB是什么】</p>
<p>PCB是用以记录与进程相关信息的<u>主存区</u>，是进程存在的唯一标志。</p>
<p><img src="https://img-blog.csdnimg.cn/20200816155207727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>【PCB中的信息】</p>
<ul>
<li><p><strong>进程标识符</strong>：唯一地标识一个进程；</p>
<p>进程本身：外标识、内部标识；？<br>家族信息：父进程、子进程信息；？</p>
</li>
<li><p><strong>处理机状态</strong></p>
<p>处理机状态信息也称为处理机的上下文（Context），主要是由处理机的各种<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AF%84%E5%AD%98%E5%99%A8&spm=1001.2101.3001.7020">寄存器</a>中的内容组成的。<br>也就是中断现场的保留区，当进程被切换时，处理机状态信息必须都保存在相应的PCB中，以便该进程在重新执行时能再从断点继续执行。</p>
</li>
<li><p><strong>进程调度信息</strong></p>
<p>在OS进行调度时，必须了解<u>进程的状态</u>以及<u>有关进程调度的信息</u>。这些信息包括：</p>
<p>① 进程状态<br>就绪、执行、阻塞等，是进程调度和对换的依据</p>
<p>② 进程优先级<br>是分配CPU的重要依据</p>
<p>③ 其它信息<br>比如进程已等待CPU的时间总和、已执行的时间总和等</p>
<p>④ 事件<br>指的是阻塞原因（即程序由执行状态变为阻塞状态的原因）</p>
</li>
<li><p><strong>进程控制信息</strong></p>
<p>① 程序和数据的首地址<br>调度到该进程的时候，可以找到其程序和数据</p>
<p>② 进程同步和通信机制<br>如消息队列指针、信号量等，以后的进程同步中会学到</p>
<p>③ 资源清单<br>列出了该进程在运行期间所需的全部资源（CPU除外），另外还有一张该进程已分配的资源清单</p>
<p>④ 链接指针<br>给出了该进程（PCB）所在队列中下一个进程的PCB首地址，跟链表一样</p>
</li>
</ul>
<p>【PCB的三种组织方式】</p>
<ul>
<li><strong>线性方式</strong></li>
</ul>
<p>系统中所有PCB都组织在一张线性表中，表的首地址存放在内存专用区</p>
<p><strong>优点：</strong> 实现简单、开销小</p>
<p><strong>缺点：</strong> 每次查找时都要扫描一整张表，因此适合进程数目不多的系统</p>
<p><img src="https://img-blog.csdnimg.cn/20200816202839640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><strong>链接方式</strong></li>
</ul>
<p>具有相同状态进程的PCB分别通过PCB中的链接字链接成一个队列。</p>
<p><img src="https://img-blog.csdnimg.cn/20200816203026357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>内存存储方式还是线性的，然后通过类似于链表的链接组成一个逻辑上的队列？</p>
</blockquote>
<ul>
<li><strong>索引方式</strong></li>
</ul>
<p>系统根据所有进程状态的不同，建立几张索引表，并把索引表的首地址记录在内存的专用单元中。在每个索引表的表目中，记录具有相应状态的PCB在PCB表中的首地址</p>
<p>（其实就是改进版的线性方式，分类之后，变成了很多子表，不需要把整个PCB表都扫描一遍，只需要先根据进程状态找到对应的子表，然后再扫描子表就行了）</p>
<p><img src="https://img-blog.csdnimg.cn/20200816203851862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h1><ul>
<li>动态性。进程的实质是进程实体的执行过程，“它由创建而产生，由撤销而死亡。” 有一定的生命周期，动态性是进程最基本的特征。</li>
<li>并发性。引入进程后，只有建立了PCB的程序，也就是进程才能并发执行。并发性是进程的另一重要特征。</li>
<li>独立性。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。 凡未建立PCB的程序都不能作为一个独立的单位参与运行。</li>
<li>异步性。指进程是按各自独立的、不可预知的速度向前推进的。（是不是想到了操作系统的基本特征也有异步性？二者是一个意思）所以才要配备相应的进程同步机制，让各进程之间独立地运行，使得<u>程序每次运行的结果都是一样的</u>。</li>
<li>制约性。进程之间由于对资源的征用而相互制约。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43722079/article/details/104874035">(42条消息) 试比较程序和进程的异同（区别与联系）_试比较进程和程序的区别_Crayon小鱼干的博客-CSDN博客</a></p>
<h1 id="进程、线程、协程"><a href="#进程、线程、协程" class="headerlink" title="进程、线程、协程"></a>进程、线程、协程</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_49199646/article/details/109210547">(43条消息) 进程、线程及协程的区别_协程与线程的区别_clw_18的博客-CSDN博客</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>进程：一个具有一定独立功能的程序 &#x2F; 关于某个数据集合上的 &#x2F; 一次运行活动，是<strong>系统资源分配和独立运行</strong>的最小单位；为了使多个程序并发执行，提高资源利用率和系统效率，OS引入了进程。</li>
<li>线程：是进程的 &#x2F; 一个执行单元，是<strong>任务调度和系统执行</strong>的最小单位；为了减少程序并发执行时所付出的时空开销，使得并发粒度更细、并发性更好，OS引入了线程。</li>
<li>协程：协程是一种<strong>用户态的轻量级线程</strong>，协程的调度<strong>完全由用户控制</strong>。</li>
</ul>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><strong>根本区别</strong>：进程是操作系统资源分配和独立运行的最小单位；线程是任务调度和系统执行的最小单位。</li>
<li><strong>地址空间区别</strong>： 每个进程都有独立的地址空间，一个进程崩溃不影响其它进程；一个进程中的多个线程共享该进程的地址空间，一个线程的非法操作会使整个进程崩溃。</li>
<li><strong>上下文切换开销区别：</strong> 每个进程有独立的代码和数据空间，进程之间上下文切换开销较大；线程组共享代码和数据空间，线程之间切换的开销较小。</li>
<li><strong>支持多处理机系统方面</strong>：不管有几个处理机，一个进程只能分配到一个CPU上执行，但同一进程内的多个线程可分配到多个CPU上并行执行。</li>
<li>为什么要引用线程：提高OS的并发性（如同一个应用程序同时执行多个功能），减少资源的分配；</li>
</ul>
<h2 id="进程和线程的联系"><a href="#进程和线程的联系" class="headerlink" title="进程和线程的联系"></a>进程和线程的联系</h2><p>一个进程由<u>共享空间</u>（包括堆、代码区、数据区、进程空间和打开的文件描述符）和<u>一个或多个线程</u>组成，<u>各个线程之间共享进程的内存空间</u>，而<strong>一个标准的线程由线程ID、程序计数器PC、寄存器和栈组成</strong>。</p>
<blockquote>
<p>为了实现并发性，线程需要独享某些资源。例如CPU寄存器的值。 当从一个线程切换到另一个线程上时，必须将原有线程的CPU寄存器集合状态保存，以便该线程在被重新切换到运行状态时能得以恢复。</p>
</blockquote>
<p>进程和线程之间的联系如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20201021221100545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20201021221114554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>多线程的优点：</p>
<ul>
<li>响应度高：只需要阻塞部分线程，提高了对用户的响应；</li>
<li>资源共享：线程默认共享所属进程的内存和资源；</li>
<li>经济：创建和切换线程的代价更小；</li>
<li>多处理器体系结构的利用：在多CPU上提高了并行性。</li>
</ul>
</blockquote>
<p>线程的实现方式：</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230329161419124.png" alt="image-20230329161419124"></p>
<ul>
<li>用户级线程ULT【User Level Thread】（控制块在用户空间）：多个线程通过一个<strong>进程</strong>来系统调用；对内核不可见有多少个线程；进程内切换，都与内核无关，所以减少切换开销。</li>
<li>内核级线程KLT【Kernel Level Thread】（控制块在内核空间）：多个处理机处理多个线程-并行。由于控制块在内核，程序在用户空间，所以切换时首先到内核空间进行切换，再切换回用户空间执行程序，线程调度开销较大；</li>
<li>组合方式：内核的一般比用户少。</li>
</ul>
<h2 id="进程与线程的选择"><a href="#进程与线程的选择" class="headerlink" title="进程与线程的选择"></a>进程与线程的选择</h2><p>1、线程的<u>创建或销毁的代价</u>比进程小，需要频繁创建和销毁时应优先选用线程；</p>
<p>2、线程<u>上下文切换的速度</u>比进程快，需要大量计算时优先选用线程；</p>
<p>3、线程<u>在CPU上的使用效率</u>更高，需要多核分布时优先选用线程，需要多机分布时优先选用进程；</p>
<p>4、线程的<u>安全性、稳定性</u>没有进程好，需要更稳定安全时优先使用进程。</p>
<p>综上，线程创建和销毁的代价低、上下文切换速度快、对系统资源占用小、对CPU的使用效率高，<u>因此一般情况下优先选择线程进行高并发编程</u>；但线程组的所有线程共用一个进程的内存空间，安全稳定性相对较差，若其中一个线程发生崩溃，可能会使整个进程，因此<u>对安全稳定性要求较高时，需要优先选择进程进行高并发编程</u>。</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zheng199172/article/details/88800275">(43条消息) 什么是协程_笑是神的伪装的博客-CSDN博客</a></p>
<p>协程拥有自己的<strong>寄存器上下文和栈</strong>。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态。这个过程<u>完全由程序控制，不需要内核进行调度</u>。<br><img src="https://img-blog.csdnimg.cn/a550c0974c584398a71c29f783d9b4d9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80OTE5OTY0Ng==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><p>1、根本区别： 协程是用户态的轻量级线程，不受内核调度；线程是任务调度和系统执行的最小单位，需要内核调度。<br>2、运行机制区别： 线程和进程是同步机制，而协程是异步机制。<br>3、上下文切换开销区别： 线程运行状态切换及上下文切换需要内核调度，会消耗系统资源；而协程完全由程序控制，状态切换及上下文切换不需要内核参与。</p>
<h1 id="——-进程是怎么运行的？——"><a href="#——-进程是怎么运行的？——" class="headerlink" title="——-进程是怎么运行的？——-"></a>——-进程是怎么运行的？——-</h1><h1 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h1><p>由于多个进程在并发执行时共享系统资源，致使它们在运行过程中呈现<strong>间断性的运行规律</strong>，所以进程在其<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>内可能具有多种状态。</p>
<h2 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h2><ul>
<li><strong>就绪状态</strong></li>
</ul>
<p>进程已分配到<u>除CPU之外的所有必要资源</u>，只要再获得CPU，便可立即执行。（可运行但未运行）</p>
<ul>
<li><strong>执行状态</strong></li>
</ul>
<p>进程<u>已获得CPU</u>，正在执行。（多处理机系统中，则有多个进程处于执行状态）</p>
<ul>
<li><strong>阻塞状态</strong></li>
</ul>
<p>正在执行的进程由于发生某时间（如I&#x2F;O请求、申请缓冲区失败等）<u>暂时无法继续执行</u>的状态，即进程的执行受到阻塞。</p>
<p>引起进程阻塞的事件：</p>
<p>​	① 向系统请求共享资源失败<br>​	② 等待某种操作的完成<br>​	③ 新数据尚未到达<br>​	④ 等待新任务的到达</p>
<p>在执行过程中，如果发生了上述事件，进程便通过阻塞原语 block 将自己阻塞。可见，<strong>阻塞是进程自身的一种主动行为</strong>。 </p>
<h2 id="三种基本状态的转换"><a href="#三种基本状态的转换" class="headerlink" title="三种基本状态的转换"></a>三种基本状态的转换</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330223850527.png" alt="image-20230330223850527"></p>
<blockquote>
<p>I&#x2F;O请求是广义的资源调度吗？</p>
</blockquote>
<h2 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h2><ul>
<li><p><strong>创建状态（New）</strong>：进程正在创建的状态。创建工作尚未完成（即未进入就绪状态），进程不能被调度运行。</p>
<ul>
<li><p>引起进程创建的事件：</p>
<p><u>（由系统内核创建的三种情况）</u></p>
<p>① 用户登录<br>在分时系统中，用户登录成功后，系统将为该用户建立一个进程。<br>② 作业调度<br>在多道批处理系统中，从后备队列中选择进程调度时，便为它（们）创建进程，并插入就绪队列中。<br>③ 提供服务<br>比如用户程序要求文件进行打印，操作系统将为它创建一个打印进程。</p>
<p><u>（用户进程自己创建）</u></p>
<p>④ 应用请求</p>
</li>
<li><p>创建的步骤：</p>
<p>① 申请<u>空白 PCB</u><br>② 为新进程分配其运行<u>所需的资源</u><br>③ <u>初始化</u>进程控制块 PCB<br>④ 将新进程插入就绪队列</p>
</li>
<li><p>进程的层次结构</p>
<p>在OS中，允许一个进程创建另一个进程，也就是父进程创建子进程，由此便形成了一个进程的层次结构。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200818104211935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>终止状态</p>
<p>进程正常或异常结束，<u>移出就绪队列</u>，但<u>尚未被撤销</u>时的状态。</p>
<ul>
<li><p>引起进程终止的事件</p>
<p>① 正常结束<br>表示进程的任务已经完成，准备退出运行。<br>② 异常结束<br>指进程在运行时发生了某种异常事件，使程序无法继续运行。比如越界错、保护错、非法指令、运行超时等等。<br>③ 外界干预<br>进程应外界的请求而终止运行。比如操作员或操作系统干预、父进程请求、父进程终止时随着父进程而终止。</p>
</li>
<li><p>终止需要经过两个步骤：</p>
<p>① 等待操作系统进行善后处理（标记？）<br>② 将进程的<u>PCB清零</u>，并将PCB空间返还系统</p>
</li>
</ul>
</li>
</ul>
<h2 id="五种状态的转换"><a href="#五种状态的转换" class="headerlink" title="五种状态的转换"></a>五种状态的转换</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330224650329.png" alt="image-20230330224650329"></p>
<h2 id="引入挂起原语"><a href="#引入挂起原语" class="headerlink" title="引入挂起原语"></a>引入挂起原语</h2><p>在许多系统中，为了<u>系统和用户观察分析进程的需要</u>，还引入了挂起操作。</p>
<p>程序被挂起，意味着进入静止状态。</p>
<p>如果程序正处于执行状态，它将暂停执行。</p>
<p>如果程序正处于就绪状态，它将暂不接受调度。</p>
<ul>
<li>引入原因<ul>
<li>终端用户的需要：用户发现自己的程序有可疑问题，希望暂停时，可以使用挂起使之停止。</li>
<li>父进程请求：有时父进程希望挂起自己的某个子进程，以便考察和修改。</li>
<li>负荷调节的需要：实时系统中的工作负荷较重时，可以将一些不重要的进程挂起。</li>
<li>操作系统的需要：操作系统有时需要挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li>
</ul>
</li>
<li>引入挂起操作后的状态转换图</li>
</ul>
<p>在 就绪-执行-阻塞 的状态基础上添加以下状态：</p>
<p>就绪有两种：活动就绪Readya（Ready + active）&#x2F; 静止就绪Readys（Ready + suspend）；一旦被挂起就从活动就绪转换到静止就绪；要被激活成活动就绪才能被执行。</p>
<p>阻塞也有两种：活动阻塞 Blockeda（Blocked + active）&#x2F; 静止阻塞 Blockeds（Blocked + suspend）；一旦被挂起就从活动阻塞转换到静止阻塞；要被激活成活动阻塞才能进入活动就绪。</p>
<p><img src="https://img-blog.csdnimg.cn/20200817200724452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzIyMDc5,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h1><p>即OS对进程实现有效的管理，包括创建新进程、撤销已有进程、挂起、阻塞和唤醒、进程切换等多种操作。OS通过**原语（Primitive）**操作实现进程控制。</p>
<h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><ul>
<li>概念：计算机控制器的机器指令是微操作构成的，原语是机器指令的延伸，是由<u>若干条机器指令构成</u>用以完成特定功能的<u>一段程序</u>。为保证操作的正确性，它们应当是<strong>原子操作</strong>(AtomicOperation)。所谓原子操作是指：一个操作中的所有动作，要么全做，要么全不做。原子操作是一个不可分割的操作。</li>
<li>特点<ul>
<li>原子操作，要么全做，要么全不做，执行过程不会被中断；</li>
<li>在管态、系统态、内核态下执行，常驻内存；</li>
<li>是内核三大支撑功能之一（中断处理、时钟管理、原语操作）。</li>
</ul>
</li>
</ul>
<h2 id="创建-终止-阻塞-唤醒"><a href="#创建-终止-阻塞-唤醒" class="headerlink" title="创建&#x2F;终止&#x2F;阻塞&#x2F;唤醒"></a>创建&#x2F;终止&#x2F;阻塞&#x2F;唤醒</h2><ul>
<li>创建原语：create</li>
<li>阻塞原语：block</li>
<li>唤醒原语：wakeup</li>
<li>撤销原语：destroy</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230330230746574.png" alt="image-20230330230746574"></p>
<h2 id="挂起和激活"><a href="#挂起和激活" class="headerlink" title="挂起和激活"></a>挂起和激活</h2><p>为了系统和用户观察和分析进程。</p>
<ul>
<li>挂起是放在外存，不在内存中。</li>
<li>创建&#x3D;&gt;挂起：创建的时候资源还够，执行的时候要挂起？</li>
<li>活动阻塞&#x3D;&gt;挂起：可能因为等待时间过久。</li>
<li>严格来说”挂起“不算状态。</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230402115106696.png" alt="image-20230402115106696"></p>
<h1 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h1><h2 id="处理机调度和调度层次"><a href="#处理机调度和调度层次" class="headerlink" title="处理机调度和调度层次"></a>处理机调度和调度层次</h2><p>也叫做处理机调度。根据一定的算法和原则 &#x2F; 将处理机资源 &#x2F; 进行重新分配的过程。（上面进程的控制中，控制的对象是进程，对其活动进行干涉；而调度则是面对多个进程）</p>
<ul>
<li>前提：作业&#x2F;进程数 远远大于 处理机数。</li>
<li>目的：提高资源利用率，减少处理机空闲时间。</li>
<li>调度程序：一方面要满足特定系统用户的需求（快速响应），另一方面要考虑系统整体效率（系统平均周转时间）和调度算法本身的开销。</li>
</ul>
<p>【<strong>调度的层次</strong>】</p>
<p>多道批处理系统：三级调度模型。</p>
<p>在多道批处理系统中，一个作业从提交到获得CPU执行，直到作业运行完毕，可能需要经历多级处理机调度。</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230402121120477.png" alt="image-20230402121120477"></p>
<ul>
<li><p>高级调度（作业调度&#x2F;长期调度）</p>
<ul>
<li>把后备<strong>作业</strong><u>调入内存</u>；</li>
<li>只调入一次，调出一次（进程的创建和销毁）；</li>
</ul>
</li>
<li><p>中级调度（内存调度&#x2F;中程调度）</p>
<ul>
<li>将<u><strong>进程</strong>调至外存</u>，条件合适再调入内存；</li>
<li>在内、外存对换区进行进程对换。</li>
</ul>
</li>
<li><p>低级调度（进程调度&#x2F;短程调度）</p>
<ul>
<li>从就绪队列选取<strong>进程</strong>分配给处理机；</li>
<li>最基本的调度，频率非常高（相当于一个时间片完成）；</li>
</ul>
</li>
</ul>
<h2 id="进程调度方式（策略）"><a href="#进程调度方式（策略）" class="headerlink" title="进程调度方式（策略）"></a>进程调度方式（策略）</h2><ul>
<li><p>剥夺式 &#x2F; 抢占式调度</p>
<ul>
<li>立即暂停当前进程；</li>
<li>分配处理机给另一个进程；</li>
<li>原则：优先权 &#x2F; 短进程优先 &#x2F; 时间片原则。</li>
</ul>
</li>
<li><p>非剥夺式 &#x2F; 非抢占式调度</p>
<ul>
<li>若有进程请求执行；</li>
<li>等待直到当前进程完成或阻塞；</li>
<li>缺点：适用于批处理系统，不适用分时&#x2F;实时系统。</li>
</ul>
</li>
</ul>
<h2 id="调度的时机、切换与过程（执行）"><a href="#调度的时机、切换与过程（执行）" class="headerlink" title="调度的时机、切换与过程（执行）"></a>调度的时机、切换与过程（执行）</h2><ul>
<li>调度时机<ul>
<li>进程运行完毕；</li>
<li>进程时间片用完；</li>
<li>进程要求I&#x2F;O操作；</li>
<li>执行某种原语操作；</li>
<li>高优先级进程申请运行（剥夺式调度）。</li>
</ul>
</li>
<li>调度过程（调度策略&#x2F;保存进程&#x2F;切换）<ul>
<li>保存镜像：记录进程现场信息；</li>
<li>调度算法：确定分配处理机的原则；</li>
<li>进程切换：分配处理机给其他进程；</li>
<li>处理机回收：从进程收回处理机。</li>
</ul>
</li>
</ul>
<h2 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h2><p>调度算法指标：<u>CPU利用率</u>（忙碌时间&#x2F;总时间）；<u>系统吞吐量</u>（完成作业数&#x2F;总时间）；周转时间（作业完成时间-提交时间）；等待时间（作业等待处理机调度时间-关注平均值）；响应时间（提交请求到首次响应间隔）……</p>
<h2 id="典型的调度算法"><a href="#典型的调度算法" class="headerlink" title="典型的调度算法"></a>典型的调度算法</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230403193116458.png" alt="image-20230403193116458"></p>
<h3 id="先来先服务（FCFS-First-Come-First-Served）"><a href="#先来先服务（FCFS-First-Come-First-Served）" class="headerlink" title="先来先服务（FCFS, First Come First Served）"></a>先来先服务（FCFS, First Come First Served）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230403193607734.png" alt="image-20230403193607734"></p>
<ul>
<li>算法内容：调度作业&#x2F;就绪队列中最先入队者，等待操作完成或阻塞；</li>
<li>算法原则：按作业&#x2F;进程到达顺序 服务；</li>
<li>调度方式：非抢占式调度；</li>
<li>适用场景：作业&#x2F;进程调度；</li>
<li>优缺点：有利于CPU繁忙型作业，充分利用CPU资源；不利于I&#x2F;O繁忙型作业，操作耗时，其他饥饿。</li>
</ul>
<h3 id="短作业优先（SJF，Shortest-Job-First）"><a href="#短作业优先（SJF，Shortest-Job-First）" class="headerlink" title="短作业优先（SJF，Shortest Job First）"></a>短作业优先（SJF，Shortest Job First）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230413165325539.png" alt="image-20230413165325539"></p>
<ul>
<li>算法内容：<strong>所需服务时间最短</strong>的作业 &#x2F; 进程优先服务；</li>
<li>算法原则：追求最少的平均（带权）周转时间；</li>
<li>调度方式：SJF &#x2F; SPF 非抢占式（？还没进CPU？；</li>
<li>适用场景：作业 &#x2F; 进程调度；</li>
<li>优缺点<ul>
<li>平均等待&#x2F;周转时间最少；</li>
<li>长作业周转时间会增加或饥饿；</li>
<li>估计时间不准确，不能保证紧迫任务及时处理。</li>
</ul>
</li>
</ul>
<h3 id="高响应比优先（HRRN，Highest-Response-Ratio-Next"><a href="#高响应比优先（HRRN，Highest-Response-Ratio-Next" class="headerlink" title="高响应比优先（HRRN，Highest Response Ratio Next)"></a>高响应比优先（HRRN，Highest Response Ratio Next)</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424194517483.png" alt="image-20230424194517483"></p>
<ul>
<li>算法内容：总和FCFS和SJF，综合考虑等待时间和服务时间响应比，高的优先调度；</li>
<li>算法原则：综合考虑作业 &#x2F; 进程的等待时间和服务时间；</li>
<li>调度方式：非抢占式；</li>
<li>适用场景：作业 &#x2F; 进程调度；</li>
<li>响应比计算：<ul>
<li>响应比 &#x3D; <strong>（等待时间+服务时间）&#x2F;服务时间</strong> &#x3D; 等待时间&#x2F;服务时间 + 1， ≥1；</li>
<li>只有当前进程放弃执行权（完成 &#x2F; 阻塞）时，重新计算所有进程响应比；</li>
<li><u>长作业</u>等待<u>越久</u>响应比越高，更容易获得处理机。</li>
</ul>
</li>
</ul>
<h3 id="优先级调度（PSA，Priority-Scheduling-Algorithm）"><a href="#优先级调度（PSA，Priority-Scheduling-Algorithm）" class="headerlink" title="优先级调度（PSA，Priority-Scheduling Algorithm）"></a>优先级调度（PSA，Priority-Scheduling Algorithm）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424195233727.png" alt="image-20230424195233727"></p>
<ul>
<li>算法内容：又叫优先权调度，按作业 &#x2F; 进程 的优先级（紧迫程度）进行调度；</li>
<li>算法原则：优先级最高（最紧迫）的作业 &#x2F; 进程先调度；</li>
<li>调度方式：抢占 &#x2F; 非抢占式（并不能获得及时执行）</li>
<li>优先级设置原则：<ul>
<li>静态（进程创建就确定了） &#x2F; 动态优先级；</li>
<li>系统 ＞用户；交互型 ＞ 非交互型；I&#x2F;O型 ＞计算型；</li>
<li>低优先级进程可能会产生”饥饿“。</li>
</ul>
</li>
</ul>
<h3 id="【时间片轮转调度算法】（RR，Round-Robin"><a href="#【时间片轮转调度算法】（RR，Round-Robin" class="headerlink" title="【时间片轮转调度算法】（RR，Round-Robin)"></a>【时间片轮转调度算法】（RR，Round-Robin)</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230424195725057.png" alt="image-20230424195725057"></p>
<blockquote>
<p>后面的进程必须要等到前面的进程完成时间片，所以严格来说不是实时的，有一定等待时间。</p>
</blockquote>
<ul>
<li>算法内容：按进程到达就绪队列的顺序，轮流分配一个时间片去执行，时间用完则剥夺；</li>
<li>算法原则：<strong>公平、轮流</strong>为每个进程服务，进程在一定时间内都能得到响应；</li>
<li>调度方式：抢占式，由<strong>时钟中断</strong>确定时间到；</li>
<li>适用场景：进程调度；（作业调度是一次性的）</li>
<li>优缺点：<ul>
<li>公平，响应快，适用于分时系统；</li>
<li>时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力；</li>
<li>时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大。</li>
</ul>
</li>
</ul>
<h3 id="【多级反馈队列调度】（MFQ，Multileveled-Feedback-Queue）"><a href="#【多级反馈队列调度】（MFQ，Multileveled-Feedback-Queue）" class="headerlink" title="【多级反馈队列调度】（MFQ，Multileveled Feedback Queue）"></a>【多级反馈队列调度】（MFQ，Multileveled Feedback Queue）</h3><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230426123415014.png" alt="image-20230426123415014"></p>
<ul>
<li>算法内容<ul>
<li>设置<strong>多个按优先级排序的</strong>就绪队列；</li>
<li>优先级由高到低，时间片从小到大；</li>
<li>新进程采用队列降级法（进入第一级队列，按FCFS分时间片）（没有执行完，移到第二级，第三级……）</li>
<li>前面队列不为空，不执行后续队列进程。</li>
</ul>
</li>
</ul>
<blockquote>
<p>无论优先级多少 或者是长短作业，首先都会进入第一个优先级队列，没执行完就进入下一个队列……至少都会执行一下，不至于完全饥饿的状态。</p>
<p>越往下，优先级越低，但是执行时间越长……</p>
</blockquote>
<ul>
<li>算法原则：集前几种算法优点，相当于PSA+RR</li>
<li>调度方式：抢占式</li>
<li>适用场景：进程调度</li>
<li>优缺点<ul>
<li>对各类型相对公平；快速响应；</li>
<li>终端型作业用户：短作业优先；</li>
<li>批处理作业用户：周转时间短；</li>
<li>长批处理作业用户：在前几个队列部分执行。</li>
</ul>
</li>
</ul>
<h1 id="——进程之间是怎么协作的——"><a href="#——进程之间是怎么协作的——" class="headerlink" title="——进程之间是怎么协作的——-"></a>——进程之间是怎么协作的——-</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1803377">看完了进程同步与互斥机制，我终于彻底理解了 PV 操作-腾讯云开发者社区-腾讯云 (tencent.com)</a>[比较通俗易懂的。]</p>
<ul>
<li><p>进程调度是为了最大程度的利用 CPU 资源，选用合适的算法调度就绪队列中的进程。</p>
</li>
<li><p>进程同步是为了<strong>协调一些进程以完成某个任务</strong>，比如读和写，你肯定先写后读，不能先读后写吧，这就是进程同步做的事情了，指定这些进程的先后执行次序使得某个任务能够顺利完成。</p>
</li>
<li><p>进程同步：进程 A 应在进程 B 之前执行</p>
</li>
<li><p>进程互斥：进程 A 和进程 B 不能在同一时刻执行。</p>
</li>
</ul>
<p>从上不难看出，<strong>「进程互斥是一种特殊的进程同步」</strong>，即逐次使用临界资源，也是对进程使用资源的先后执行次序的一种协调。</p>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427160912451.png" alt="image-20230427160912451"></p>
<ul>
<li>概念：进程通信即<strong>进程间的信息交换</strong>。<ul>
<li>进程是资源分配的基本单位，各进程内存空间彼此独立；</li>
<li>一个进程不能随意地访问其它进程的地址空间。</li>
</ul>
</li>
<li>特点<ul>
<li>共享存储（Shared-Memory)</li>
<li>消息传递（Message-Passing）</li>
<li>管道通信（Pipe）</li>
</ul>
</li>
</ul>
<h2 id="共享存储（Shared-Memory"><a href="#共享存储（Shared-Memory" class="headerlink" title="共享存储（Shared-Memory)"></a>共享存储（Shared-Memory)</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427161116063.png" alt="image-20230427161116063"></p>
<ul>
<li><p>基于<strong>共享数据结构</strong>（只是存储量小）的通信方式</p>
<ul>
<li>多个进程共用某个数据结构（OS提供并控制）；</li>
<li>由<u>用户（程序员）负责</u>同步处理（读写操作的先后等）；</li>
<li>低级通信：可以传递少量数据，效率低。（低级：直接操控物理硬件&#x2F;如内存等</li>
</ul>
</li>
<li><p>基于<strong>共享存储区</strong>的通信方式</p>
<ul>
<li>多个进程共用内存中的一块存储区域；</li>
<li>由<u>进程控制</u>数据的形式和方式（进程自己动态申请）；</li>
<li>高级通信：可以传递<u>大量数据</u>，效率高（不是调用数据结构的底层操作……？</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据收发过程双方不可见，存在安全隐患。</p>
</blockquote>
<h2 id="消息传递（Message-Passing）"><a href="#消息传递（Message-Passing）" class="headerlink" title="消息传递（Message-Passing）"></a>消息传递（Message-Passing）</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427161951629.png" alt="image-20230427161951629"></p>
<ul>
<li><p>直接通信：点到点发送</p>
<ul>
<li>发送和接收时指明<u>双方进程的ID</u>；</li>
<li>每个进程维护一个<u>消息缓冲</u>队列；</li>
<li>格式化消息：遵循一定格式，如消息头、进程ID等。</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230427162351207.png" alt="image-20230427162351207"></p>
<ul>
<li><p>间接通信：广播信箱</p>
<ul>
<li>以信箱为媒介，作为中间实体；</li>
<li>发进程将消息发送到信箱，收进程从信箱读取；</li>
<li>可以广播，容易建立双向通信链。</li>
</ul>
<blockquote>
<p>和共享内存什么区别？操作方式。消息传递是通过send &#x2F; receive原语……</p>
</blockquote>
</li>
</ul>
<h2 id="管道通信（Pipe）"><a href="#管道通信（Pipe）" class="headerlink" title="管道通信（Pipe）"></a>管道通信（Pipe）</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230428115510038.png" alt="image-20230428115510038"></p>
<ul>
<li>管道<ul>
<li>用于连接读 &#x2F; 写进程的共享<strong>文件</strong>，pipe文件；把从一个进程连接到另一个进程的一个数据流称为一个“管道”。</li>
<li>本质上是<strong>内存中</strong><u>固定大小</u>的缓冲区。</li>
<li>写满（或者通过结束符标志）才能读(一次性读完)，读完才能写；空的时候不读，空的时候才写；读写两操作互斥</li>
</ul>
</li>
<li><strong>半双工</strong>通信<ul>
<li>同一时段只能单向通信，双工通信需要两个管道；</li>
<li>以先进先出（FIFO）方式组织数据传输；</li>
<li>通过系统调用read()&#x2F;write()函数进行读写操作。</li>
</ul>
</li>
<li>优点：可传输数据量大，而且安全（对共享存储进行了改进）</li>
</ul>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>协调</strong>进程间的<strong>相互制约关系</strong>，使它们按照预期的方式执行的过程。（让这些进程按照我们想要的规则&#x2F;顺序去执行）</p>
<ul>
<li>前提<ul>
<li>进程是并发执行的，进程间存在相互制约关系；</li>
<li>并发的进程对系统共享资源进行竞争；</li>
<li>进程通信，过程中相互发送的信号称为消息或事件。</li>
</ul>
</li>
<li>两种相互制约形式<ul>
<li>间接相互制约关系（<strong>互斥</strong>）：进程<u>排他性</u>地访问共享资源；</li>
<li>直接相互制约关系（<strong>同步</strong>）：进程间的<u>合作</u>，比如管道通信；</li>
</ul>
</li>
</ul>
<blockquote>
<p>理解广义和狭义的同步概念是什么</p>
</blockquote>
<h2 id="实现临界区互斥的基本方法"><a href="#实现临界区互斥的基本方法" class="headerlink" title="实现临界区互斥的基本方法"></a>实现临界区互斥的基本方法</h2><p>进程同步：互斥地访问临界资源（也就是共享资源）。</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230501094800100.png" alt="image-20230501094800100"></p>
<ul>
<li><p>访问过程</p>
<ol>
<li>进入区：尝试进入临界区，成功则【<strong>加锁（lock）</strong>】</li>
<li>临界区：访问共享资源</li>
<li>退出区：【<strong>解锁（unlock）</strong>】，唤醒其它阻塞进程</li>
<li>剩余区：其它代码</li>
</ol>
</li>
<li><p>访问原则</p>
<ol>
<li>空闲让进：临界区空闲，允许一个进程进入；</li>
<li>忙则等待：临界区已有进程，其它进程等待（阻塞状态）；</li>
<li>有限等待：处于等待的进程，等待时间有限；</li>
<li>让权等待：等待时应让出CPU执行权，防止“忙等待”（例如死循环</li>
</ol>
</li>
<li><p>软件实现方法</p>
<ul>
<li>单标志法：</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230503165357299.png" alt="image-20230503165357299"></p>
<blockquote>
<p>对于P0来说：turn≠0的时候（也就是该进入临界区访问共享资源的进程不是它），就一直在进入区（也就是while循环）里面等待；直到别的进程把turn设置为0的时候才会跳出循环，进入下一步临界区进行访问……其它进程以此类推。</p>
<p>在这里，两个进程是交替访问。</p>
<p>【问题】当P0在剩余区执行不再返回到进入区的时候（只设置一次turn&#x3D;1），P1如果想反复进入临界区的话 将一直在进入区等待。临界区没人使用，但是P1却用不了。这违背了【空闲让进】原则。</p>
</blockquote>
<ul>
<li><p>双标志法先检查：</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230503171625478.png" alt="image-20230503171625478"></p>
<blockquote>
<p>在临界区的进程对应的元素位就设置成true。就P0来说，如果P1在临界区，就在进入区等待；直到P1退出并唤醒P0。如果P0想反复进入临界区，只要p1不在临界区就能执行。</p>
<p>【问题】虚线框的代码。如果P0刚刚好执行完<code>while(flag[1]);</code>此时还没执行<code>flag[0]=true</code>也就是仍然是false，若此时p1刚好执行了<code>while(flag[0])</code>，那就误判P0还未进入临界区，此时两线程将一起访问临界区，违背了【忙则等待】原则。</p>
</blockquote>
</li>
<li><p>双标志法后检查：</p>
</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230504164520333.png" alt="image-20230504164520333"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 可能执行的顺序</span><br><span class="line">flag[0] = true;</span><br><span class="line">flag[1] = true;</span><br><span class="line">while(flag[1]);</span><br><span class="line">while(flag[0]);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双方都以为对方在临界区，所以都在进入区等待，违背了【空闲让进】【有限等待】原则。</p>
</blockquote>
<ul>
<li>皮特森算法（在双标志法的基础上加上单标志）</li>
</ul>
<p> <img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230504170107437.png" alt="image-20230504170107437"></p>
</li>
<li><p>硬件实现方法</p>
<ul>
<li><p>中断屏蔽方法：关中断&#x2F;开中断</p>
<p><strong>禁止一切中断，CPU执行完临界区之前不会切换</strong>；</p>
<p>关中断可能会被滥用；</p>
<p>关中断时间长影响效率；</p>
<p>不适用于多处理机，无法防止其它处理机调度其它进程访问临界区；（不能锁其它处理机，没有实现效果）</p>
<p>只适用于内核进程（中断等操作是低级指令，运行在内核态）</p>
</li>
<li><p>Test-And-Set（TS指令&#x2F;TSL指令）</p>
<p>下图是简要理解。</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230517184530800.png" alt="image-20230517184530800"></p>
<blockquote>
<p>先看第二个框，当TestAndSet函数一直返回true的时候，while将在进入临界区之前一直执行循环，也叫自旋、忙等；即该线程还不能进入临界区。</p>
<p>为什么还不能进入呢，看第一框，old &#x3D; *lock，也就是lock为true的时候，即其它线程正在锁，该线程只能等待；当lock为false，则跳出循环，进入临界区，直到执行完毕，把lock赋值为false解锁，给其它线程用。</p>
</blockquote>
<p>读出标志并设置为true，返回旧值，<strong>原子操作</strong>。 （函数内执行的话不会被打断）；</p>
<p>也被称为TSL指令（Test-And-Set-Lock)；</p>
<p>违背“让权等待”，会发生忙等。</p>
</li>
<li><p>Swap指令</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230522224425218.png" alt="image-20230522224425218"></p>
<blockquote>
<p>只有lock为false的时候，交换后old为false，才会跳出进入临界区之前的循环。</p>
</blockquote>
<ul>
<li>交换两个变量的值，<strong>原子操作</strong>；</li>
<li>违背“让权等待”（忙等</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><ul>
<li>信号量（Semaphore）机制<ul>
<li>PV操作：P操作——<strong>wait原语</strong>，进程等待；V操作——<strong>signal原语</strong>，唤醒等待进程；</li>
<li>整型信号量：表示可用资源数；</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523193837115.png" alt="image-20230523193837115"></p>
<blockquote>
<p>违背“让权等待”，会发生忙等</p>
</blockquote>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523194347162.png" alt="image-20230523194347162"></p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230523195423701.png" alt="image-20230523195423701"></p>
<blockquote>
<ul>
<li><p>改成用block原语阻塞进程，就不会发生忙等（死循环且在执行）。</p>
</li>
<li><p>整个流程：假设有三个进程，一个资源，进程1执行wait的时候，S.value&#x3D;0，可以进入临界区访问资源；进程2执行wait的时候，S.value&#x3D;-1, 小于0，进行阻塞；进程3也进来了，S.value&#x3D;-2，也在阻塞。</p>
<p>等到进程1访问完到退出区了，执行signal方法，S.value&#x3D;-1,但还是小于等于0，此时用wakeup原语（重复执行signal方法，直到S.value&gt;0）唤醒等待队列（L）的所有进程。</p>
</li>
</ul>
</blockquote>
<p>这个是<strong>记录型信号量</strong>：进程进入<strong>阻塞状态</strong>，不会忙等。</p>
<ul>
<li>分析进程同步和互斥问题的方法步骤<ul>
<li>分析关系：进程的数量、进程间的同步或互斥关系、前驱关系；</li>
<li>整理思路：根据进程的操作流程，确定等待（P）、唤醒（V）的大致顺序；</li>
<li>设置信号量：根据前两步分析和整理，设置信号量初始值。</li>
</ul>
</li>
</ul>
<h2 id="管程（Monitor，监视器）"><a href="#管程（Monitor，监视器）" class="headerlink" title="管程（Monitor，监视器）"></a>管程（Monitor，监视器）</h2><ul>
<li><p>定义</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230525192806235.png" alt="image-20230525192806235"></p>
<p>“管理进程”，<strong>即用于实现进程同步的工具</strong>。是由代表<u>共享资源的数据结构</u>和<u>一组过程（进行PV操作的函数）组成的管理程序</u>（封装）。</p>
<p>把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理，管程的局部变量只能由该管程的过程存取，进程只能互斥地调用管程中的过程。</p>
<p>【比信号量封装性更高，工作原理和信号量一致；面向对象思想：数据和函数的封装；是被进程调用的程序，本身不是进程】</p>
</li>
<li><p>管程的组成</p>
<ul>
<li>管程名称；</li>
<li>局部于管程内部的共享数据结构；【数据私有】</li>
<li>对该数据结构操作的一组过程（函数）；</li>
<li>管程内共享数据的初始化语句；</li>
</ul>
</li>
<li><p>管程的基本特性</p>
<ul>
<li>是一个模块化的基本程序单位，可以单独编译；（可以对应一个对象实例，有多个管程）；</li>
<li>是一种抽象数据类型，包含数据和操作；（也就是一个类型；</li>
<li>信息掩蔽，共享数据只能被管程内的过程访问；</li>
</ul>
</li>
<li><p>条件变量 &#x2F; 条件对象</p>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230526200939155.png" alt="image-20230526200939155"></p>
<ul>
<li>进入管程的进程可能由于条件不满足而阻塞（Wait操作）；</li>
<li>此时进程应释放管程以便其它进程调用管程；</li>
<li>进程被阻塞的条件（原因）有多个，移入不同的条件队列；</li>
<li>进程被移入条件队列后，应释放管程。</li>
</ul>
</li>
</ul>
<h2 id="经典同步问题（缺）"><a href="#经典同步问题（缺）" class="headerlink" title="经典同步问题（缺）"></a>经典同步问题（缺）</h2><h1 id="——-如何处理死锁问题？——–"><a href="#——-如何处理死锁问题？——–" class="headerlink" title="——-如何处理死锁问题？——–"></a>——-如何处理死锁问题？——–</h1><h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>多个进程由于<strong>竞争资源</strong>而造成的<strong>阻塞现象</strong>，若无外力作用，这些进程将无法继续推进。</p>
<ul>
<li>相似概念：饥饿。<strong>等待时间过长</strong>以至于给进程推进和响应带来明显影响，“饿而<strong>不死</strong>”。（能得到执行但效率很低，不至于完全阻塞）</li>
</ul>
<h2 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a>死锁产生的原因</h2><ul>
<li>系统资源的竞争；</li>
<li>进程推进顺序非法。</li>
</ul>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>必要条件：条件缺一不可。（?</p>
<p>【狭义的死锁】</p>
<ul>
<li>互斥条件：共享资源的非他性访问 &#x2F; 独占性访问；（有且只有一个进程访问）</li>
<li>不剥夺条件：访问时该共享资源不会被剥夺；（只有进程主动释放）</li>
<li>请求并保持条件：<strong>保持</strong>当前资源时<strong>请求</strong>另一个资源；（某个进程持有某个进程的时候，还想访问另一个资源，但这个资源正在被持有；占有资源一直不出来的一个原因，否则迟早都会出来……？）</li>
<li>循环等待条件：存在共享资源的<strong>循环等待链</strong>。（你等我，我等你……）</li>
</ul>
<h1 id="死锁处理策略"><a href="#死锁处理策略" class="headerlink" title="死锁处理策略"></a>死锁处理策略</h1><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230528144335190.png" alt="image-20230528144335190"></p>
<ul>
<li><p>破坏互斥条件</p>
<ul>
<li>将只能互斥访问的资源改为<strong>同时共享访问</strong>；</li>
<li>将独占锁改为共享锁；（信号量＞1）</li>
<li>不是所有资源都能改成可共享的；</li>
</ul>
</li>
<li><p>破坏不剥夺 &#x2F; 不可抢占条件</p>
<ul>
<li>请求<strong>新资源无法满足</strong>时必须释放已有资源；</li>
<li>由OS协助<strong>强制剥夺</strong>某进程持有的资源；</li>
<li>实现复杂，代价高；</li>
<li>此操作过多导致原进程任务无法推进。</li>
</ul>
</li>
<li><p>破坏请求并保持条件</p>
<ul>
<li>进程开始运行时一次性申请所需资源——资源浪费（资源用没用上都被占着）、进程饥饿（其它进程拿不到资源）；【P0】（理解是，进程一直占有很多资源，暂时用不到的资源但其它进程想要请求，就造成了等待；所以阶段性请求和释放就增大资源的利用率，减少等待）</li>
<li>阶段性请求和释放资源；【P1】</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529084721110.png" alt="image-20230529084721110"></p>
</li>
<li><p>破坏循环等待条件</p>
<ul>
<li>对所有资源现行排序，按序号请求资源；（之前执行的都是乱序的）<ul>
<li>请求时先低再高；</li>
<li>释放时先高再低；</li>
</ul>
</li>
<li>对资源的编号应相对稳定，限制了新设备的增加；（预先知道并安排资源）</li>
<li>进程使用资源的顺序可能与系统编号顺序不同；</li>
<li>限制了用户编程；（内定好顺序了）</li>
</ul>
</li>
</ul>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>死锁避免：安全性算法。</p>
<ul>
<li><p>系统安全状态</p>
<ul>
<li>安全状态一定不会出现死锁；</li>
<li>不安全状态可能出现死锁；</li>
</ul>
</li>
<li><p>银行家算法</p>
<ul>
<li>系统预判进程请求是否导致不安全状态；</li>
<li>是则拒绝请求，否则答应请求；</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529085923176.png" alt="image-20230529085923176"></p>
<blockquote>
<p>进程先让操作系统知道，最大需求是多少；系统判断：申请的数量是否大于所需最大数量、可用数量够不够。</p>
<p>（如果分配给进程的资源数量 ＋ 进程已分配的资源 ≤ 最大需求，进程未得到满足就继续占有已有资源并等待请求更多的资源——请求并保持，所以要确保满足进程最大需求，好让它用完并释放）</p>
</blockquote>
</li>
</ul>
<h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><ul>
<li>死锁检测（判断 死锁产生的条件 是否出现）<ul>
<li>需要一种数据结构，保存有关资源的请求和分配信息；</li>
<li>提供一种算法，利用这些信息检测是否形成了死锁。</li>
</ul>
</li>
</ul>
<p><img src="/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统（二）.assets\image-20230529091141333.png" alt="image-20230529091141333"></p>
<blockquote>
<p>【资源分配图】两种资源、两种节点。请求边：进程向资源请求；反之。</p>
</blockquote>
<ul>
<li><p>死锁定理（死锁状态的充分条件；而死锁的四个产生条件是必要条件）：</p>
<ul>
<li>当且仅当此状态下资源分配图是不可完全简化的；</li>
<li>简化过程<strong>类似于</strong>“拓扑排序”算法（先找到没有入边的节点，然后循环找没有入边的节点进行排序）</li>
</ul>
<blockquote>
<p>先看是否为孤点（无两种边）。是否阻塞主要看请求边。请求的是否能得到满足；</p>
<p>上面示意图中，先取出P0（资源充足，执行完可以释放掉，再轮到P1），再取出P1，简化完成，所以不会阻塞。</p>
</blockquote>
</li>
<li><p>死锁解除</p>
<ul>
<li>资源剥夺；（解决资源不够的问题）<ul>
<li>挂起死锁进程；</li>
<li>剥夺其资源；</li>
<li>将资源分配给其它（死锁）进程。</li>
</ul>
</li>
<li>撤销进程；（Destroy）</li>
<li>进程回退。<ul>
<li>回退到足以避免死锁的地步；</li>
<li>需要记录进程历史信息，设置还原点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://huangxinhere.github.io">(●ˇ∀ˇ●)</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">https://huangxinhere.github.io/2023/03/27/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BA%8C%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://huangxinhere.github.io" target="_blank">Hx's blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/04/01/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83/" title="数据结构与算法-刷题思考"><img class="cover" src="/img/e82f983fly1hdas2vy0ncj20u00gvae1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">数据结构与算法-刷题思考</div></div><div class="info-2"><div class="info-item-1">#数据结构与算法 (qq.com) 数组JZ57 和为S的两个数字【哈希】【双指针】首先想到用哈希表存储，遍历元素的时候记录想要的差，以后遇到这个元素就返回。 12345678910111213141516vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;    if (array.empty()) &#123;        return &#123;&#125;;    &#125;    unordered_map&lt;int, int&gt; map;    for (int num : array) &#123;        // 若存在于想要的数字中，则返回        if (map[num]) &#123;            return vector&lt;int&gt;&#123;num, sum - num&#125;;        &#125;        // 不存在，则存储需要的值        map[sum-num] = num;  ...</div></div></div></a><a class="pagination-related" href="/2023/03/18/Unity%E5%BC%80%E5%8F%91-%E9%80%83%E5%87%BA%E5%9C%B0%E7%90%83/" title=""><img class="cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">  TilemapTilemap - Unity 手册 (47条消息) Unity Tilemap动态生成2d地图_tilemap 动态地形_crushKB的博客-CSDN博客 unity2018使用tileMap生成地图 类似泰拉瑞亚创建和销毁地图块 - 三页菌 - 博客园 (cnblogs.com) 开始的想法是用Tilemap，因为可以方便地选择格子来填充或删除。 但是看了好多资料，却越来越清晰地意识到：Tilemap还是为了地图而存在的，也就是静态的，单元格集成的。所以，几乎不可能移动单个Tile？都是跟随Tilemap一起的刚体属性。 纯物理2D 关节 - Unity 手册 【例子不全面，好坑】[(47条消息) Unity] Unity2D 中的物理关节_Rickshao1993的博客-CSDN博客 网格系统Unity中的网格系统 Grid System in Unity (How to make it and where to use it)_哔哩哔哩_bilibili 用UI直接代替逻辑网格系统统一 - 手动：画布  先排好Grid按钮，整理好画布  接着将点击的U...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">(●ˇ∀ˇ●)</div><div class="author-info-description">该博客暂时停止维护，新博客传送门：https://juejin.cn/user/3598037753539256</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E9%A9%B1%E5%9B%BE%E3%80%81%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.</span> <span class="toc-text">前驱图、顺序执行与并发执行的特征</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%80%94%E2%80%94"><span class="toc-number">2.</span> <span class="toc-text">——进程是什么？——</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.</span> <span class="toc-text">进程的定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">进程的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97PCB%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.1.</span> <span class="toc-text">进程控制块PCB详解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">5.</span> <span class="toc-text">进程的特征</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">进程、线程、协程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.2.</span> <span class="toc-text">进程和线程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">6.3.</span> <span class="toc-text">进程和线程的联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">6.4.</span> <span class="toc-text">进程与线程的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">6.5.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">协程和线程的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F%E2%80%94%E2%80%94"><span class="toc-number">7.</span> <span class="toc-text">——-进程是怎么运行的？——-</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">8.</span> <span class="toc-text">进程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="toc-number">8.1.</span> <span class="toc-text">进程的三种基本状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.2.</span> <span class="toc-text">三种基本状态的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="toc-number">8.3.</span> <span class="toc-text">创建状态和终止状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.4.</span> <span class="toc-text">五种状态的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E6%8C%82%E8%B5%B7%E5%8E%9F%E8%AF%AD"><span class="toc-number">8.5.</span> <span class="toc-text">引入挂起原语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">进程的控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD"><span class="toc-number">9.1.</span> <span class="toc-text">原语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-%E7%BB%88%E6%AD%A2-%E9%98%BB%E5%A1%9E-%E5%94%A4%E9%86%92"><span class="toc-number">9.2.</span> <span class="toc-text">创建&#x2F;终止&#x2F;阻塞&#x2F;唤醒</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%92%8C%E6%BF%80%E6%B4%BB"><span class="toc-number">9.3.</span> <span class="toc-text">挂起和激活</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">10.</span> <span class="toc-text">进程的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E5%92%8C%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1"><span class="toc-number">10.1.</span> <span class="toc-text">处理机调度和调度层次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F%EF%BC%88%E7%AD%96%E7%95%A5%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">进程调度方式（策略）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA%E3%80%81%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B%EF%BC%88%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">调度的时机、切换与过程（执行）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%87%86%E5%88%99"><span class="toc-number">10.4.</span> <span class="toc-text">调度的基本准则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">10.5.</span> <span class="toc-text">典型的调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS-First-Come-First-Served%EF%BC%89"><span class="toc-number">10.5.1.</span> <span class="toc-text">先来先服务（FCFS, First Come First Served）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%EF%BC%88SJF%EF%BC%8CShortest-Job-First%EF%BC%89"><span class="toc-number">10.5.2.</span> <span class="toc-text">短作业优先（SJF，Shortest Job First）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%EF%BC%88HRRN%EF%BC%8CHighest-Response-Ratio-Next"><span class="toc-number">10.5.3.</span> <span class="toc-text">高响应比优先（HRRN，Highest Response Ratio Next)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%88PSA%EF%BC%8CPriority-Scheduling-Algorithm%EF%BC%89"><span class="toc-number">10.5.4.</span> <span class="toc-text">优先级调度（PSA，Priority-Scheduling Algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E3%80%91%EF%BC%88RR%EF%BC%8CRound-Robin"><span class="toc-number">10.5.5.</span> <span class="toc-text">【时间片轮转调度算法】（RR，Round-Robin)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E3%80%91%EF%BC%88MFQ%EF%BC%8CMultileveled-Feedback-Queue%EF%BC%89"><span class="toc-number">10.5.6.</span> <span class="toc-text">【多级反馈队列调度】（MFQ，Multileveled Feedback Queue）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%98%AF%E6%80%8E%E4%B9%88%E5%8D%8F%E4%BD%9C%E7%9A%84%E2%80%94%E2%80%94"><span class="toc-number">11.</span> <span class="toc-text">——进程之间是怎么协作的——-</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">12.</span> <span class="toc-text">进程通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%EF%BC%88Shared-Memory"><span class="toc-number">12.1.</span> <span class="toc-text">共享存储（Shared-Memory)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%EF%BC%88Message-Passing%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">消息传递（Message-Passing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%EF%BC%88Pipe%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">管道通信（Pipe）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">13.</span> <span class="toc-text">进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">13.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E5%8C%BA%E4%BA%92%E6%96%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">实现临界区互斥的基本方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">13.3.</span> <span class="toc-text">信号量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%EF%BC%88Monitor%EF%BC%8C%E7%9B%91%E8%A7%86%E5%99%A8%EF%BC%89"><span class="toc-number">13.4.</span> <span class="toc-text">管程（Monitor，监视器）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%EF%BC%88%E7%BC%BA%EF%BC%89"><span class="toc-number">13.5.</span> <span class="toc-text">经典同步问题（缺）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%80%94%E2%80%94-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%EF%BC%9F%E2%80%94%E2%80%94%E2%80%93"><span class="toc-number">14.</span> <span class="toc-text">——-如何处理死锁问题？——–</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">15.</span> <span class="toc-text">死锁的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">15.1.</span> <span class="toc-text">死锁的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">15.2.</span> <span class="toc-text">死锁产生的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">15.3.</span> <span class="toc-text">死锁产生的必要条件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">16.</span> <span class="toc-text">死锁处理策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81"><span class="toc-number">16.1.</span> <span class="toc-text">预防死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">16.2.</span> <span class="toc-text">避免死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E8%A7%A3%E9%99%A4"><span class="toc-number">16.3.</span> <span class="toc-text">死锁的检测与解除</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/22/UE%E5%A4%9A%E4%BA%BA%E5%B0%84%E5%87%BBC++%EF%BC%881%EF%BC%89%E4%BA%92%E8%81%94%E7%BD%91%E8%81%94%E6%9C%BA%E8%AE%BE%E7%BD%AE/" title="UE与OnlineSubsystemSteam（OSS Steam）"><img src="https://cdn.jsdelivr.net/gh/huangxinhere/hexo_img/img/20250822000958_1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UE与OnlineSubsystemSteam（OSS Steam）"/></a><div class="content"><a class="title" href="/2025/08/22/UE%E5%A4%9A%E4%BA%BA%E5%B0%84%E5%87%BBC++%EF%BC%881%EF%BC%89%E4%BA%92%E8%81%94%E7%BD%91%E8%81%94%E6%9C%BA%E8%AE%BE%E7%BD%AE/" title="UE与OnlineSubsystemSteam（OSS Steam）">UE与OnlineSubsystemSteam（OSS Steam）</a><time datetime="2025-08-21T16:00:00.000Z" title="发表于 2025-08-22 00:00:00">2025-08-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/13/2024313-Unity-UI%EF%BC%882%EF%BC%89/" title="Unity-UI（2）"><img src="/img/unity.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-UI（2）"/></a><div class="content"><a class="title" href="/2024/03/13/2024313-Unity-UI%EF%BC%882%EF%BC%89/" title="Unity-UI（2）">Unity-UI（2）</a><time datetime="2024-03-12T16:00:00.000Z" title="发表于 2024-03-13 00:00:00">2024-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="Unity-性能优化"><img src="/img/unity.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-性能优化"/></a><div class="content"><a class="title" href="/2023/09/14/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="Unity-性能优化">Unity-性能优化</a><time datetime="2023-09-13T16:00:00.000Z" title="发表于 2023-09-14 00:00:00">2023-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E5%9B%BE%E5%BD%A2/" title="Unity-图形"><img src="/img/unity.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-图形"/></a><div class="content"><a class="title" href="/2023/09/13/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E5%9B%BE%E5%BD%A2/" title="Unity-图形">Unity-图形</a><time datetime="2023-09-12T16:00:00.000Z" title="发表于 2023-09-13 00:00:00">2023-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%83%AD%E6%9B%B4%E6%96%B0/" title="Unity-热更新"><img src="/2023/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%83%AD%E6%9B%B4%E6%96%B0/message_pic.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity-热更新"/></a><div class="content"><a class="title" href="/2023/09/10/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-Unity-%E7%83%AD%E6%9B%B4%E6%96%B0/" title="Unity-热更新">Unity-热更新</a><time datetime="2023-09-09T16:00:00.000Z" title="发表于 2023-09-10 00:00:00">2023-09-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By (●ˇ∀ˇ●)</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
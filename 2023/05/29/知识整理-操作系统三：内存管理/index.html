<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统三：内存管理 | Hx's blog</title><meta name="author" content="(●ˇ∀ˇ●),1159390360@qq.com"><meta name="copyright" content="(●ˇ∀ˇ●)"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于操作系统的知识点整理">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统三：内存管理">
<meta property="og:url" content="https://huangxinhere.github.io/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Hx&#39;s blog">
<meta property="og:description" content="关于操作系统的知识点整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2023-05-28T16:00:00.000Z">
<meta property="article:modified_time" content="2023-06-20T15:00:26.521Z">
<meta property="article:author" content="(●ˇ∀ˇ●)">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://huangxinhere.github.io/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统三：内存管理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-20 23:00:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Hx's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head_pic_3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hx's blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> Pic</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统三：内存管理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-28T16:00:00.000Z" title="发表于 2023-05-29 00:00:00">2023-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-20T15:00:26.521Z" title="更新于 2023-06-20 23:00:26">2023-06-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86/">知识点梳理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统三：内存管理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><h2 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h2><h3 id="0-存储器结构"><a href="#0-存储器结构" class="headerlink" title="0.存储器结构"></a>0.存储器结构</h3><ul>
<li><p>多层结构</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529194909107.png" alt="image-20230529194909107"></p>
<blockquote>
<p>可移动存储介质：U盘；</p>
<p>主存储器：内存；</p>
<p>缓存：连接内存和辅存、寄存器之间的缓存；</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529195154467.png" alt="image-20230529195154467"></p>
<p>外存也就是硬盘缓存。</p>
</blockquote>
</li>
</ul>
<h3 id="0-进程运行的基本原理"><a href="#0-进程运行的基本原理" class="headerlink" title="0.进程运行的基本原理"></a>0.进程运行的基本原理</h3><p>用户程序 =&gt; 进程：编译、链接、装入</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230529195631972.png" alt="image-20230529195631972"></p>
<ul>
<li>编译：属于用户，不属于OS</li>
</ul>
<h3 id="1-程序的装入和链接"><a href="#1-程序的装入和链接" class="headerlink" title="1.程序的装入和链接"></a>1.程序的装入和链接</h3><ul>
<li><p>链接（源码和底层函数等）：</p>
<p>静态链接（在程序运行前 或 装入程序前就已经完成 / 适合体量小的程序）；</p>
<p>装入时动态链接：一边装入一边链接；</p>
<p>运行时动态链接：程序在内存工作的时候按需获取。</p>
</li>
<li><p>装入：（将装入模块装入内存中，但不知道装在内存哪里）</p>
<p>绝对装入：直接在程序定义好放在哪个位置，在以前有可能做到；只适合单道程序</p>
<p>可重定位装入：若运行多道程序，动态寻找内存空闲位置（也是早期）</p>
<p>动态运行时装入：同一个程序被分配的内存不连续；如果程序有2G，内存只有1G，那么如何运行呢——内存扩充。</p>
</li>
</ul>
<h3 id="2-逻辑地址空间与物理地址空间"><a href="#2-逻辑地址空间与物理地址空间" class="headerlink" title="2.逻辑地址空间与物理地址空间"></a>2.逻辑地址空间与物理地址空间</h3><p>逻辑地址（默认从0开始）与物理地址（实际装入的地址可能有偏移）</p>
<h3 id="3-内存保护"><a href="#3-内存保护" class="headerlink" title="3.内存保护"></a>3.内存保护</h3><p>内存保护：寄存器（？记录物理地址的范围，保护已分配的内存防止被访问</p>
<h2 id="内存扩充"><a href="#内存扩充" class="headerlink" title="内存扩充"></a>内存扩充</h2><p>内存扩充的两种方式：覆盖、交换（把不活跃的进程交换到硬盘缓存）。</p>
<h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>单一用户，单一操作系统。从用户区最低的地址开始连续分配；只有一个用户在单一作业，没用的空闲空间比较多。</p>
<p>优点：实现简单；无外部碎片；不一定需要内存保护（虽然用户区没有多个访问，但有可能用户访问系统区）；</p>
<p>缺点：只能用于单用户、单任务OS；有内部碎片（整个用户区没有利用好）；存储器利用率低。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230530104612728.png" alt="image-20230530104612728"></p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>有分区说明表来记录分区信息，比如有多少个分区、分区大小、起始地址、使用状态等；</p>
<p>优点：实现简单，无外部碎片（用户区已经被提前分好了，被分完全了）；</p>
<p>缺点：较大用户程序时，需要采用覆盖技术，降低了性能；会产生内部碎片（比如分了8M的固定内存给4M的进程，剩余4M的空间无法被利用），利用率低。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531101509403.png" alt="image-20230531101509403"></p>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>根据进程需要来动态分配。</p>
<p>缺点：可能产生外部碎片（被各种需求的进程分配后的剩余空间大小不一）；无内部碎片（要多少给多少，对于进程来说刚刚好）。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531102105335.png" alt="image-20230531102105335"></p>
<ul>
<li><p>怎么记录内存的使用情况？</p>
<p>空闲分区表：只记录空闲状态的内存分区。</p>
<p>数据结构：可以是双向链表。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531102428842.png" alt="image-20230531102428842"></p>
</li>
<li><p>选择哪个分区给新进程？</p>
<p>首次适应算法：从<strong>低地址</strong>查找合适空间；（地址低的空间可能大也可能小）</p>
<p>最佳适应算法：优先使用<strong>最小空闲</strong>空间；</p>
<p><strong>最坏</strong>适应算法：优先使用<strong>最大</strong>连续空间；（尽量第一次就找到，减少搜索时间）</p>
<p>临近适应算法：从上次查找处向后查找。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531103937389.png" alt="image-20230531103937389"></p>
<blockquote>
<p>补充说明：</p>
<p>最坏适应的小碎片少：比如有10M分区，被4M进程用了，剩下的碎片是6M，碎片比较大</p>
</blockquote>
</li>
<li><p>已使用的分区怎么回收？</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531104615621.png" alt="image-20230531104615621"></p>
<blockquote>
<p>要回收P4的时候，可以和前后（相邻）空闲区域合并。</p>
</blockquote>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531104804412.png" alt="image-20230531104804412"></p>
</li>
</ul>
<h2 id="非连续分配与管理方式"><a href="#非连续分配与管理方式" class="headerlink" title="非连续分配与管理方式"></a>非连续分配与管理方式</h2><p>连续分配管理方式中，固定分区分配虽然没有外部碎片但有内部碎片，动态则有外部碎片没有内部碎片，总之两者对内存的使用效率都不高。</p>
<p>此分配方法就是尽量最大化地利用内存空间：一个进程占用的内存空间不连续。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531110118490.png" alt="image-20230531110118490"></p>
<blockquote>
<p>数据可能记录在不同的内存块上，需要数据结构来管理。数据结构本身就存在一定消耗。</p>
</blockquote>
<h3 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h3><p>就是<strong>比较小</strong>的固定分区。一般分为4k大小。</p>
<p>内部碎片的产生情况：一般不会超过单位的一半，碎片比较小（页内碎片）；</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230531110329662.png" alt="image-20230531110329662"></p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601162309742.png" alt="image-20230601162309742"></p>
<blockquote>
<p>用页表这个数据结构来记录进程分了多少页，存在PCB中。分页较多的话，数据结构记录的就多。</p>
<p>页号：对应进程分的页；块号：对应分配的不连续的物理地址。</p>
</blockquote>
<ul>
<li><p>基本地址变换机构：逻辑地址对照页表来计算物理地址。（下面的计算也就是，计算在第几个，然后算在那个区域的偏移量；其中物理地址和逻辑地址的偏移量）</p>
<ul>
<li>物理地址 =（页号=&gt;块号）+偏移量。</li>
<li>页号P = 逻辑地址A / 页面长度（大小）L；</li>
<li>偏移量W = 逻辑地址A % 页面长度L；</li>
<li>（位运算没搞懂……）</li>
</ul>
</li>
<li><p>（接）基本地址变换机构：</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601164307632.png" alt="image-20230601164307632"></p>
</li>
</ul>
<blockquote>
<p>目的：虚线框内是内存，左边是CPU，现在要进行的操作是，为1024的逻辑地址+1。</p>
<p>做法：先从页表中查找，找到对应块号，再通过计算找到目的物理地址。</p>
<p>分析：读页表取块号（一次内存访问）、计算最终物理地址并访问（一次内存访问），一共两次；</p>
<p>​            CPU的工作速度比内存要快；</p>
<p>现存的问题：页式管理中地址空间是一维的（页号默认是索引，块号成数组）；每次访存都需要地址转换，必须足够快；页表不能太大，会降低内存利用率；</p>
</blockquote>
<p>解决：具有快表的地址变换机构。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230601165044304.png" alt="image-20230601165044304"></p>
<blockquote>
<p>访问物理地址肯定要访问内存，但是页表能不能放在其它地方呢？放在CPU和寄存器肯定不行，因为两者空间太小；放在寄存器和内存之间的空间——高速缓存里面。</p>
<p>这样就有快表与慢表之分。但快表是慢表的一部分，因为空间有限，只能存一部分。访问过的就从慢表中找并添加到快表。慢表是一位数据，而快表由于不一定连续，要记录页号和块号，所以是二维数据。</p>
</blockquote>
<ul>
<li>直接将页号与快表页号比较；（优先访问快表）</li>
<li>匹配成功，取块号+偏移量形成地址；</li>
<li>匹配失败，访问主存页表，并同步到快表。（局部性原理：使用过的可能会被重新使用）</li>
</ul>
<p>慢表的“慢”除了体现在放在内存中，还有所占空间较大的问题。</p>
<p>假设逻辑地址（由页号和页内地址组成）占32位，页号占20位，页内地址占12位。那么页号最多可能有2的20次幂，也就是1,048,576，差不多一百万多一点，而</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = <span class="number">8</span> bit	 </span><br><span class="line"><span class="number">1</span> KB= <span class="number">1024</span> B	 </span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB	 </span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB	 </span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br></pre></td></tr></table></figure>

<p>则假设每个页号3个字节左右，那么1048576种页号有（×2）…个字节（Byte），大概2M……？【教程是当作1个字节来算】</p>
<p>即使是一维数组，达到这样百万数量效率也会低；</p>
<p>页内地址12位占4个字节，那么整个页表有 1,048,576 × 4个字节，差不多四兆的空间，这样内存开销比较大。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602125221421.png" alt="image-20230602125221421"></p>
<blockquote>
<p>页表占用内存空间：2^20 * 4Bit；</p>
<p>页框数：</p>
</blockquote>
<ul>
<li>页表连续存放，占用大量连续空间；【可以动态装入，部分加载👇 也就是离散】</li>
<li>一段时间内只需要访问部分特定页面；</li>
<li>页表项分组 / 分页离散存储；</li>
<li>建页目录表管理<strong>离散</strong>页表。</li>
</ul>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602125904172.png" alt="image-20230602125904172"></p>
<blockquote>
<p>每一个子列表最多有1024项，所需存储空间1024 × 4Bit = 4K，也就是一个页框的大小，不至于浪费内存空间。</p>
</blockquote>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230602130400618.png" alt="image-20230602130400618"></p>
<blockquote>
<p>刚刚好都可以用位数来分区。</p>
</blockquote>
<p><strong>两级页表</strong>（索引思想）：</p>
<ul>
<li>将逻辑地址拆分成三部分；</li>
<li>从PCB中读取页目录表始址；</li>
<li>根据一级页号（&gt;&gt;22），查出二级页表位置；</li>
<li>根据二级页号查内存块号（&lt;&lt;10 去高位 再 &gt;&gt;22 去低位），加偏移量计算物理地址。</li>
</ul>
<h3 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h3><p>分页是把物理地址划分成 固定大小 连续 的不同区域，进程也划分成很多连续的小块。</p>
<ul>
<li>分段</li>
</ul>
<p>但实际上进程是由多个模块组成的，所以有把进程分段的需求，比如主程序、子程序、公共区域等。根据需求分段，所以每段的大小不确定。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603153243396.png" alt="image-20230603153243396"></p>
<ul>
<li><p>段表</p>
<p>段内是连续的，段与段之间是没有联系的；每段都是从0开始。</p>
<p>段表记录每段在物理地址的起始信息，还有对应的大小。这样段表就是二维的了。</p>
</li>
<li><p>地址变换机构</p>
</li>
</ul>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603153809775.png" alt="image-20230603153809775"></p>
<blockquote>
<p>比如取一号段的逻辑地址，取前16位获得段号，根据基址找到物理地址，再使用后16位地址找到物理地址对应的位置。</p>
</blockquote>
<ul>
<li><p>段的共享与保护</p>
<p>共享：比如进程有某块区域共享，有多个子进程 / 进程访问，子程序也会在自己的段表里面添加对应条目，……？</p>
<p>保护：越界保护。</p>
</li>
</ul>
<ul>
<li><p>分页与分段方式对比（都是非连续分配）</p>
<ul>
<li>页：物理单位按照固定大小划分；</li>
<li>段：逻辑单位 按照逻辑来划分；不过始终要在物理地址上分配（和分页结合）一个段可能占用多个页；</li>
<li>分页：一维地址空间，只需要记录起始地址；</li>
<li>分段：二维地址空间，由于分段大小不固定，还要记录段长；段表一般放在寄存器中，相比于页表一般要小，因为进程不会分很多段。</li>
<li>分段更容易信息共享和保护。分页的颗粒度太小，共享一块区域可能要很多个页，而分段颗粒度比较大。</li>
</ul>
</li>
</ul>
<h3 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h3><p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603155050139.png" alt="image-20230603155050139"></p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603155300794.png" alt="image-20230603155300794"></p>
<ul>
<li>先分段，再分页</li>
</ul>
<p>1个进程对应一个段表；</p>
<p>一个段表项对应一个页表；由于一个段可能占用多个页，比如0号段（7kb），需要占用两个页：0号页（4kb）、1号页（3kb），此时【段页表】的【页表长度】为2，【页表存放块号】为1号块（也就是物理地址编号为1的块），而块上存储了页表信息（k0、k7）……？</p>
<p>一个页表对应多个物理块。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603160115172.png" alt="image-20230603160115172"></p>
<p>前16位：一个进程可能分的段数 / 段号；</p>
<p>页号：一个段可能分的页数 / 页号；最多为16个页。</p>
<p>后14位：对应的就是4k的页的地址。</p>
<ul>
<li>逻辑地址如何映射到物理地址上呢？</li>
</ul>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230603160458909.png" alt="image-20230603160458909"></p>
<blockquote>
<p>黄色虚线区域是内存，左侧是CPU管理区域（包括寄存器）。</p>
<p>段表寄存器：指向那张段页表？</p>
</blockquote>
<p>比如要找到逻辑地址1024（段号+页号+页内地址）</p>
<ul>
<li>【段号】 + 【段表始址】 找到 【段表项】：段表寄存器通过段表始址找到段表放在内存的地方，找到了段表后根据段号找到对应的段表项。</li>
<li>根据 【页表长度】检查页号越界情况；</li>
<li>【页表存放块号】+【页号】找到【页表项】：根据页表存放块号找到对应的物理块，然后物理块里面存有页表的信息，取出页表，根据逻辑地址给的页号来检索对应的页表项。</li>
<li>【内存块号】+【页内地址】得到物理地址。上一步找到页表项就是为了取具体的存放块号的信息，那么知道块号以后，就找到了某块物理地址，再结合逻辑地址的页内地址，就定位到了那块物理地址里面的具体位置（内存物理地址空间）。</li>
</ul>
<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><p>（逻辑上的概念）具有请求调入和置换功能，从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605122423462.png" alt="image-20230605122423462"></p>
<blockquote>
<p>金字塔形状表示离CPU的远近。寄存器的执行效率和cpu一致。主存储器就是内存条。硬盘缓存物理上属于固定磁盘，看起来就是扩充了内存的容量，外存就是硬盘缓存。</p>
<p>一般内存指的是主存（三部分），更狭义就是内存条；而虚拟内存=内存+外存。</p>
</blockquote>
<ul>
<li><p>局部性原理</p>
<ul>
<li>时间局部性：操作过的短时间内可能会再次操作；</li>
<li>空间局部性：同一个位置……</li>
<li>催生了缓存技术。重复利用的放入缓存，缓存效率比内存要高。</li>
</ul>
</li>
<li><p>虚拟内存的特征</p>
<ul>
<li>多次性：动态请求；</li>
<li>对换性：不用的时候换出，要用的时候换入；</li>
<li>虚拟性：逻辑上扩充。</li>
</ul>
</li>
<li><p>虚拟内存的实现</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理（三种和上面提到的差不多</li>
</ul>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605123411819.png" alt="image-20230605123411819"></p>
</li>
</ul>
<h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><p>上节内存管理提到基本分页存储管理，那是一次性把所有进程加载进去。</p>
<p>而请求分页是动态加载：有需要才请求装入。</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605123553415.png" alt="image-20230605123553415"></p>
<ul>
<li><p>页表机制</p>
<ul>
<li>状态位P：0说明在外存中，1反之；</li>
<li>访问字段A：记录被访问的次数；</li>
<li>修改位M：是否被修改过；</li>
<li>外存地址：也是物理地址，调出到的地址</li>
</ul>
</li>
<li><p>缺页中断机构</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124615166.png" alt="image-20230605124615166"></p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124635902.png" alt="image-20230605124635902"></p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124117141.png" alt="image-20230605124117141"></p>
<p>程序运行当中要访问的页不存在，就要从外存中调入。这个过程首先要产生中断。</p>
<blockquote>
<p>举例子，【调入】a号块要从外存x号块加载东西，加载完后要更新页表（内存块号、状态位）。</p>
</blockquote>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230605124435301.png" alt="image-20230605124435301"></p>
<blockquote>
<p>把c号块的东西调出到z号块，也会产生中断。</p>
</blockquote>
</li>
<li><p>地址变换机构</p>
</li>
</ul>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606123009538.png" alt="image-20230606123009538"></p>
<blockquote>
<p>橙色虚线框内就是内存，外面是CPU和寄存器。</p>
</blockquote>
<ul>
<li>请求调页，判断是否在内存。比如程序运行的时候发现缺少页，就要请求从磁盘中加载页。（请求过程也就是先查找快表，找到自己的逻辑地址的页号，对应的快表项，再找到外存地址；如果快表没找到，就通过页表寄存器查找慢表。）</li>
<li>可能需要页面置换。如果调入的时候内存不够，可能要把不太需要的页调出到外存。</li>
<li>新增（换出？） / 修改页表项。</li>
<li>热点表项（经常访问）同步到快表。</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>哪些页面要调入调出的问题。</p>
<h3 id="最佳置换算法OPT：保障最低缺页率"><a href="#最佳置换算法OPT：保障最低缺页率" class="headerlink" title="最佳置换算法OPT：保障最低缺页率"></a>最佳置换算法OPT：保障最低缺页率</h3><p>每次选择淘汰最不可能再次被使用的页面（这样要用的页面就很少被换出）；</p>
<p>不好实现</p>
<h3 id="最近最久置换算法LRU：保障时间和距离上的公平"><a href="#最近最久置换算法LRU：保障时间和距离上的公平" class="headerlink" title="最近最久置换算法LRU：保障时间和距离上的公平"></a>最近最久置换算法LRU：保障时间和距离上的公平</h3><p>每次淘汰最久（时间）最近（距离）未使用的页面；</p>
<p>需要硬件支持，开销大（改页表？</p>
<h3 id="先进先出置换算法FIFO：保障顺序上的公平"><a href="#先进先出置换算法FIFO：保障顺序上的公平" class="headerlink" title="先进先出置换算法FIFO：保障顺序上的公平"></a>先进先出置换算法FIFO：保障顺序上的公平</h3><p>每次选择淘汰最早进入内存的页面；</p>
<p>Belady异常（淘汰的是要用的页），性能差（程序和加载的顺序无关，主要和使用频率有关）</p>
<h3 id="时钟置换算法NRU：保障性能和开销均衡"><a href="#时钟置换算法NRU：保障性能和开销均衡" class="headerlink" title="时钟置换算法NRU：保障性能和开销均衡"></a>时钟置换算法NRU：保障性能和开销均衡</h3><p>为页面设置访问位（0/1），并链接成循环队列，进程访问页面后置为1.</p>
<p>淘汰时为1置为0并跳过，为0时淘汰。(用完之后置为0)</p>
<p>最多需要两轮扫描</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606124914754.png" alt="image-20230606124914754"></p>
<h3 id="改进型时钟置换算法【？？？但-这个是最重要的算法"><a href="#改进型时钟置换算法【？？？但-这个是最重要的算法" class="headerlink" title="改进型时钟置换算法【？？？但 这个是最重要的算法"></a>改进型时钟置换算法【？？？但 这个是最重要的算法</h3><ul>
<li>额外考虑是否修改，保障最少I / O操作；</li>
<li>访问位和修改位主要看哪个？原则：尽可能保留访问位。</li>
</ul>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230606125501363.png" alt="image-20230606125501363"></p>
<p>增加修改位(0 / 1)，第一轮找（0，0），第二轮找（0，1）并修改访问位0，第三轮找（0，0）……</p>
<h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><p>解决到底要给进程分配多大的空间，怎么分配，什么时候分之类的问题。</p>
<ul>
<li>驻留集（驻留在主存中页面数）大小 （进程在内存中占用的空间是多少，按照页面的数量来算）<ul>
<li>（给进程）分配空间小，进程数量多，<strong>CPU时间利用效率</strong>就高；</li>
<li>进程在主存中页数少，<strong>错页率</strong>就高；（要频繁加载外存）</li>
<li>进程在主存页数多，错页率并无明显改善；（无需频繁加载外存，因为本身错页率不高……？</li>
</ul>
</li>
</ul>
<ul>
<li><p>页面分配策略</p>
<ul>
<li>固定分配局部置换</li>
<li>可变分配全局置换</li>
<li>可变分配局部置换</li>
</ul>
<p>固定也就是给进程划分好固定区域，如果内存还是不够，就自己解决，换入换出；</p>
<p>可变也就是划分的内存空间可变，要么换入换出，要么请求操作系统继续扩充内存，这也是局部全局的概念。</p>
<p>那么固定分配的话，如果分配少了，就一直缺，或者频繁换入换出，这时候错页率就高；分配多了，就浪费？</p>
</li>
</ul>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607191652415.png" alt="image-20230607191652415"></p>
<h3 id><a href="#" class="headerlink" title></a></h3><ul>
<li><p>调入页面的时机</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607192638119.png" alt="image-20230607192638119"></p>
<ul>
<li><p>预调页策略（进程被创建之后，就要被调入了）</p>
<p>一次性调入<strong>若干相邻页面</strong>（根据空间局部性原理，一个页面被调用后，相邻的页面也很可能被调用）</p>
<p>多用于进程<strong>首次调入</strong>；</p>
</li>
<li><p>请求调页策略</p>
<p>运行时发现缺页时调入；</p>
<p>I / O开销较大。（调页要访问磁盘，相当于IO操作，要慢很多……？）</p>
</li>
</ul>
</li>
<li><p>从何处调页</p>
<p><img src="/2023/05/29/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%89%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/hexo_github_blog\source_posts\知识整理-操作系统三：内存管理.assets\image-20230607192816172.png" alt="image-20230607192816172"></p>
</li>
<li><p>系统拥有足够的对换区空间的时候：</p>
<p>主程序加载到内存的时候，把其它程序加载在对换区，因为对换区的速度比文件区快。</p>
</li>
<li><p>系统缺少足够的对换区空间的时候：</p>
<p>不会被修改（数据）的文件（函数等）直接调入到文件区，因为没有要改的东西，所以能减少换出，还能减少IO操作。</p>
</li>
<li><p>Unix方式</p>
<p>读主要从文件区，换入换出在对换区。</p>
</li>
</ul>
<h1 id="内存-地址-对齐"><a href="#内存-地址-对齐" class="headerlink" title="内存/地址 对齐"></a>内存/地址 对齐</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解 - 知乎 (zhihu.com)</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 现代计算机中内存空间都是按照字节(byte)划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定变量的时候经常在特定的内存地址访问，<strong>这就需要各类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排列</strong>，这就是对齐。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> y;</span><br><span class="line">&#125;s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(s);  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>理论上，32位系统下，int占4byte，char占一个byte，那么将它们放到一个结构体中应该占4+1=5byte；但是实际上，通过运行程序得到的结果是8 byte，这就是内存对齐所导致的。</p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p>
<p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p>
<p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p>
<p><img src="https://pic3.zhimg.com/80/v2-3f40af513a94901b36ceb5387982277e_1440w.webp" alt="img"></p>
<p>现在有了内存对齐的，int类型数据只能存放在按照对齐规则的内存中，比如说0地址开始的内存。那么现在该处理器在取数据时一次性就能将数据读出来了，而且不需要做额外的操作，提高了效率。</p>
<p><img src="https://pic1.zhimg.com/80/v2-361e2d16876ce8383c9e6ea2dca34474_1440w.webp" alt="img"></p>
<p>1.有些 CPU 可以访问任意地址上的任意数据，而有些 CPU 只能在特定地址访问数据，因此<u>不同硬件平台具有差异性</u>，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有<u>平台可以移植性</u>了。</p>
<p>2.CPU 每次寻址都是要消费时间的，并且 CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐的内存，处理器需要做两次内存访问，而对齐的内存访问仅需要一次访问，内存对齐后可以提升性能。</p>
<p>​    比如有些平台每次读都是从偶数地址开始，如果一个 int 型（假设是 32 位）如果存放在偶数地址开始的地方，那么一个时钟周期就可以读出。而如果是存放在一个奇数地址开始的地方，就可能会需要 2 个时钟周期，并对两次读出的结果的高低字节进行拼凑才能得到该 int 型数据。显然在读取效率上下降很多。这也是空间和时间的博弈。</p>
<h2 id="内存对齐规则"><a href="#内存对齐规则" class="headerlink" title="内存对齐规则"></a>内存对齐规则</h2><p>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。</p>
<p>有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫<strong>对齐单位</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30007037">C/C++内存对齐详解 - 知乎 (zhihu.com)</a></p>
<p>(1) 结构体第一个成员的<strong>偏移量（offset）</strong>为0，以后每个成员相对于结构体首地址的 偏移 都是<strong>该成员大小与有效对齐值中较小那个</strong>的<u>整数倍</u>，如有需要编译器会在成员之间加上填充字节。</p>
<p>(2) <strong>结构体的总大小</strong>为 有效对齐值 的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<p><img src="https://pic2.zhimg.com/80/v2-86c644ce29b1e2d3858380aaa631cc1d_1440w.webp" alt="img"></p>
<blockquote>
<p>第二幅图，char占用一个字节，占用第0单元；到了int，由于≥4，相对于结构体首地址的偏移 要为4的倍数，占用第4，5，6，7单元；第二个char &lt;= 4(有效对齐位)，相对于结构体首地址的偏移要为1的倍数，占用第8单元</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/07/202367-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%88%B7%E9%A2%98%E6%80%9D%E8%80%83-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构与算法-刷题思考-算法思想</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86-C++%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ 知识整理-基础部分</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head_pic_3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(●ˇ∀ˇ●)</div><div class="author-info__description">someone very lazy</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/huangxinhere"><i class="fab fa-github"></i><span>Don't Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">内存管理概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">内存管理的基本原理和要求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">0.存储器结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">0.进程运行的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.程序的装入和链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.1.4.</span> <span class="toc-text">2.逻辑地址空间与物理地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.1.5.</span> <span class="toc-text">3.内存保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%89%A9%E5%85%85"><span class="toc-number">1.2.</span> <span class="toc-text">内存扩充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">1.3.3.</span> <span class="toc-text">动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E4%B8%8E%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">非连续分配与管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本分页存储管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">基本分段存储管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">段页式管理方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">虚拟内存的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">请求分页管理方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">页面置换算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95OPT%EF%BC%9A%E4%BF%9D%E9%9A%9C%E6%9C%80%E4%BD%8E%E7%BC%BA%E9%A1%B5%E7%8E%87"><span class="toc-number">2.3.1.</span> <span class="toc-text">最佳置换算法OPT：保障最低缺页率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95LRU%EF%BC%9A%E4%BF%9D%E9%9A%9C%E6%97%B6%E9%97%B4%E5%92%8C%E8%B7%9D%E7%A6%BB%E4%B8%8A%E7%9A%84%E5%85%AC%E5%B9%B3"><span class="toc-number">2.3.2.</span> <span class="toc-text">最近最久置换算法LRU：保障时间和距离上的公平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95FIFO%EF%BC%9A%E4%BF%9D%E9%9A%9C%E9%A1%BA%E5%BA%8F%E4%B8%8A%E7%9A%84%E5%85%AC%E5%B9%B3"><span class="toc-number">2.3.3.</span> <span class="toc-text">先进先出置换算法FIFO：保障顺序上的公平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95NRU%EF%BC%9A%E4%BF%9D%E9%9A%9C%E6%80%A7%E8%83%BD%E5%92%8C%E5%BC%80%E9%94%80%E5%9D%87%E8%A1%A1"><span class="toc-number">2.3.4.</span> <span class="toc-text">时钟置换算法NRU：保障性能和开销均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%9E%8B%E6%97%B6%E9%92%9F%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E3%80%90%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%BD%86-%E8%BF%99%E4%B8%AA%E6%98%AF%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.5.</span> <span class="toc-text">改进型时钟置换算法【？？？但 这个是最重要的算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.</span> <span class="toc-text">页面分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">2.4.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98-%E5%9C%B0%E5%9D%80-%E5%AF%B9%E9%BD%90"><span class="toc-number">3.</span> <span class="toc-text">内存&#x2F;地址 对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.2.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">内存对齐规则</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By (●ˇ∀ˇ●)</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Thanks to watch my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>